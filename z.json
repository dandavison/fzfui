[{"url":"https://api.github.com/repos/temporalio/temporal/pulls/comments/2518779377","pull_request_review_id":3454066296,"id":2518779377,"node_id":"PRRC_kwDODNqesM6WIYXx","diff_hunk":"@@ -42,8 +42,7 @@ type Engine interface {\n \tPollComponent(\n \t\tcontext.Context,\n \t\tComponentRef,\n-\t\tfunc(Context, Component) (any, bool, error),\n-\t\tfunc(MutableContext, Component, any) error,\n+\t\tfunc(Context, Component) (bool, error),","path":"chasm/engine.go","commit_id":"1d59e66d0ce5d91819f92c428ef5ab4c4efca1fb","original_commit_id":"e38f646f2a658deac110ca4c0e25da54378b685f","user":{"login":"dandavison","id":52205,"node_id":"MDQ6VXNlcjUyMjA1","avatar_url":"https://avatars.githubusercontent.com/u/52205?v=4","gravatar_id":"","url":"https://api.github.com/users/dandavison","html_url":"https://github.com/dandavison","followers_url":"https://api.github.com/users/dandavison/followers","following_url":"https://api.github.com/users/dandavison/following{/other_user}","gists_url":"https://api.github.com/users/dandavison/gists{/gist_id}","starred_url":"https://api.github.com/users/dandavison/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/dandavison/subscriptions","organizations_url":"https://api.github.com/users/dandavison/orgs","repos_url":"https://api.github.com/users/dandavison/repos","events_url":"https://api.github.com/users/dandavison/events{/privacy}","received_events_url":"https://api.github.com/users/dandavison/received_events","type":"User","user_view_type":"public","site_admin":false},"body":"I've removed `operationFn` from `PollComponent` since we don't need poll-with-mutation yet.","created_at":"2025-11-12T15:30:59Z","updated_at":"2025-11-12T21:52:35Z","html_url":"https://github.com/temporalio/temporal/pull/8563#discussion_r2518779377","pull_request_url":"https://api.github.com/repos/temporalio/temporal/pulls/8563","_links":{"self":{"href":"https://api.github.com/repos/temporalio/temporal/pulls/comments/2518779377"},"html":{"href":"https://github.com/temporalio/temporal/pull/8563#discussion_r2518779377"},"pull_request":{"href":"https://api.github.com/repos/temporalio/temporal/pulls/8563"}},"reactions":{"url":"https://api.github.com/repos/temporalio/temporal/pulls/comments/2518779377/reactions","total_count":0,"+1":0,"-1":0,"laugh":0,"hooray":0,"confused":0,"heart":0,"rocket":0,"eyes":0},"start_line":null,"original_start_line":null,"start_side":null,"line":45,"original_line":45,"side":"RIGHT","author_association":"MEMBER","original_position":6,"position":6,"subject_type":"line"},{"url":"https://api.github.com/repos/temporalio/temporal/pulls/comments/2519344176","pull_request_review_id":3454066296,"id":2519344176,"node_id":"PRRC_kwDODNqesM6WKiQw","diff_hunk":"@@ -204,9 +235,17 @@ func (e *ChasmEngine) UpdateComponent(\n \t\treturn nil, serviceerror.NewInternalf(\"componentRef: %+v: %s\", ref, err)\n \t}\n \n+\te.notifier.Notify(&ChasmComponentNotification{\n+\t\tKey: ref.EntityKey,\n+\t\tRef: newSerializedRef,\n+\t})","path":"service/history/chasm_engine.go","commit_id":"da6009564e796063faf853352077eecdc1473612","original_commit_id":"eb1ded5ef804505544b0ab631d660b43072ee6f6","user":{"login":"dandavison","id":52205,"node_id":"MDQ6VXNlcjUyMjA1","avatar_url":"https://avatars.githubusercontent.com/u/52205?v=4","gravatar_id":"","url":"https://api.github.com/users/dandavison","html_url":"https://github.com/dandavison","followers_url":"https://api.github.com/users/dandavison/followers","following_url":"https://api.github.com/users/dandavison/following{/other_user}","gists_url":"https://api.github.com/users/dandavison/gists{/gist_id}","starred_url":"https://api.github.com/users/dandavison/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/dandavison/subscriptions","organizations_url":"https://api.github.com/users/dandavison/orgs","repos_url":"https://api.github.com/users/dandavison/repos","events_url":"https://api.github.com/users/dandavison/events{/privacy}","received_events_url":"https://api.github.com/users/dandavison/received_events","type":"User","user_view_type":"public","site_admin":false},"body":"This is a key line in the PR: every component update emits a notification that a long-poll request may subscribe to.\r\n\r\nThe PR does not yet emit notifications at any other component lifecycle transition.","created_at":"2025-11-12T18:20:35Z","updated_at":"2025-11-12T21:52:35Z","html_url":"https://github.com/temporalio/temporal/pull/8563#discussion_r2519344176","pull_request_url":"https://api.github.com/repos/temporalio/temporal/pulls/8563","_links":{"self":{"href":"https://api.github.com/repos/temporalio/temporal/pulls/comments/2519344176"},"html":{"href":"https://github.com/temporalio/temporal/pull/8563#discussion_r2519344176"},"pull_request":{"href":"https://api.github.com/repos/temporalio/temporal/pulls/8563"}},"reactions":{"url":"https://api.github.com/repos/temporalio/temporal/pulls/comments/2519344176/reactions","total_count":0,"+1":0,"-1":0,"laugh":0,"hooray":0,"confused":0,"heart":0,"rocket":0,"eyes":0},"start_line":null,"original_start_line":null,"start_side":null,"line":null,"original_line":241,"side":"RIGHT","author_association":"MEMBER","original_position":96,"position":1,"subject_type":"line"},{"url":"https://api.github.com/repos/temporalio/temporal/pulls/comments/2519465405","pull_request_review_id":3455005258,"id":2519465405,"node_id":"PRRC_kwDODNqesM6WK_29","diff_hunk":"@@ -241,14 +280,159 @@ func (e *ChasmEngine) ReadComponent(\n \treturn readFn(chasmContext, component)\n }\n \n+// PollComponent waits until the supplied predicate is satisfied when evaluated against the\n+// component identified by the supplied component reference. It returns a component reference\n+// identifying the state at which the predicate was satisfied. An error is returned if entity\n+// transition history is (after reloading from persistence) behind the requested ref, or if the ref\n+// is not interpretable as part of the entity transition history. Thus when the predicate function\n+// is evaluated, it is guaranteed that the entity VT >= requestRef VT.\n func (e *ChasmEngine) PollComponent(\n \tctx context.Context,\n-\tentityRef chasm.ComponentRef,\n-\tpredicateFn func(chasm.Context, chasm.Component) (any, bool, error),\n-\toperationFn func(chasm.MutableContext, chasm.Component, any) error,\n+\trequestRef chasm.ComponentRef,\n+\tpredicateFn func(chasm.Context, chasm.Component) (bool, error),\n \topts ...chasm.TransitionOption,\n-) (newEntityRef []byte, retError error) {\n-\treturn nil, serviceerror.NewUnimplemented(\"PollComponent is not yet supported\")\n+) ([]byte, error) {\n+\t// 1. Acquire lock\n+\t// 2. Error if shard entity VT < requestRef VT ('stale state')\n+\t// 3. If predicate satisfied, release lock and return\n+\t// 4. Subscribe to notifications for this entity\n+\t// 5. Release lock\n+\t// 6. On notification repeat (1) and (2)\n+\n+\tshardContext, executionLease, err := e.getExecutionLease(ctx, requestRef)\n+\tif err != nil {\n+\t\t// E.g. requestRef VT inconsistent with shard VT ('stale reference')\n+\t\treturn nil, err\n+\t}\n+\n+\t// hold lock until return or subscription established\n+\treleased := false\n+\tdefer func() {\n+\t\tif !released {\n+\t\t\t// read-only operation; don't pass error\n+\t\t\texecutionLease.GetReleaseFn()(nil)\n+\t\t}\n+\t}()\n+\n+\t// At this point it's possible that shard VT < requestRef VT (getExecutionLease does not\n+\t// guarantee that returned shard state is non-stale w.r.t. requestRef).\n+\tcurrentRef, err := e.checkPredicate(ctx, requestRef, executionLease, predicateFn)\n+\tif err != nil {\n+\t\treturn nil, err\n+\t}\n+\t// shard VT >= requestRef VT (enforced by checkPredicate)\n+\n+\tif currentRef != nil {\n+\t\t// wait condition was satisfied\n+\t\treturn currentRef, nil\n+\t}\n+\n+\t// Wait condition not satisfied; long-poll\n+\n+\tchannel, subscriberID, err := e.notifier.Subscribe(requestRef.EntityKey)\n+\tif err != nil {\n+\t\treturn nil, err\n+\t}\n+\tdefer func() {\n+\t\t_ = e.notifier.Unsubscribe(requestRef.EntityKey, subscriberID)\n+\t}()\n+\n+\t// Release the lock, now that we are subscribed\n+\texecutionLease.GetReleaseFn()(nil)\n+\treleased = true\n+\n+\tnamespaceRegistry, err := shardContext.GetNamespaceRegistry().GetNamespaceByID(\n+\t\tnamespace.ID(requestRef.EntityKey.NamespaceID),\n+\t)\n+\tif err != nil {\n+\t\treturn nil, err\n+\t}\n+\n+\t// TODO(dan): check desired timeout logic here\n+\tlongPollCtx, cancel := contextutil.WithDeadlineBuffer(\n+\t\tctx,\n+\t\tshardContext.GetConfig().LongPollExpirationInterval(namespaceRegistry.Name().String()),\n+\t\ttime.Second,\n+\t)\n+\tdefer cancel()\n+\n+\tfor {\n+\t\tselect {\n+\t\tcase notification := <-channel:\n+\t\t\tif notification == nil {\n+\t\t\t\treturn nil, serviceerror.NewInternal(\"nil component notification\")\n+\t\t\t}\n+\t\t\t// Received a notification. Re-acquire the lock and check the predicate.\n+\t\t\t_, executionLease, err := e.getExecutionLease(ctx, requestRef)\n+\t\t\tif err != nil {\n+\t\t\t\treturn nil, err\n+\t\t\t}\n+\n+\t\t\tnewRef, err := e.checkPredicate(ctx, requestRef, executionLease, predicateFn)\n+\t\t\texecutionLease.GetReleaseFn()(nil)\n+\t\t\tif err != nil {\n+\t\t\t\treturn nil, err\n+\t\t\t}\n+\t\t\tif newRef != nil {\n+\t\t\t\t// wait condition was satisfied\n+\t\t\t\treturn newRef, nil\n+\t\t\t}\n+\t\tcase <-longPollCtx.Done():\n+\t\t\t// TODO(dan): return empty response?\n+\t\t\treturn nil, serviceerror.NewDeadlineExceeded(\"long-poll timed out\")\n+\t\t}","path":"service/history/chasm_engine.go","commit_id":"1d59e66d0ce5d91819f92c428ef5ab4c4efca1fb","original_commit_id":"33e981eb58e178d489aacb3557dbabef6252e4aa","user":{"login":"cursor[bot]","id":206951365,"node_id":"BOT_kgDODFXTxQ","avatar_url":"https://avatars.githubusercontent.com/in/1210556?v=4","gravatar_id":"","url":"https://api.github.com/users/cursor%5Bbot%5D","html_url":"https://github.com/apps/cursor","followers_url":"https://api.github.com/users/cursor%5Bbot%5D/followers","following_url":"https://api.github.com/users/cursor%5Bbot%5D/following{/other_user}","gists_url":"https://api.github.com/users/cursor%5Bbot%5D/gists{/gist_id}","starred_url":"https://api.github.com/users/cursor%5Bbot%5D/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/cursor%5Bbot%5D/subscriptions","organizations_url":"https://api.github.com/users/cursor%5Bbot%5D/orgs","repos_url":"https://api.github.com/users/cursor%5Bbot%5D/repos","events_url":"https://api.github.com/users/cursor%5Bbot%5D/events{/privacy}","received_events_url":"https://api.github.com/users/cursor%5Bbot%5D/received_events","type":"Bot","user_view_type":"public","site_admin":false},"body":"### Bug: Polling Race Condition: Stale State Causes Timeouts\n\n<!-- **Medium Severity** -->\n\n<!-- DESCRIPTION START -->\nRace condition in `PollComponent` between releasing the lock and entering the select loop. After subscribing to notifications at line 329-331 and releasing the lock at line 337-338, but before entering the select loop at line 359, multiple component updates could occur. If notifications arrive faster than they can be consumed from the buffered channel (buffer size 1), subsequent notifications will be silently dropped by the `broadcast` function's default case. This means the predicate might never be satisfied even though the component state has changed, causing the long-poll to timeout incorrectly.\n<!-- DESCRIPTION END -->\n\n<!-- LOCATIONS START\nservice/history/chasm_engine.go#L328-L383\nLOCATIONS END -->\n<a href=\"https://cursor.com/open?data=eyJhbGciOiJSUzI1NiIsInR5cCI6IkpXVCIsImtpZCI6ImJ1Z2JvdC12MSJ9.eyJ2ZXJzaW9uIjoxLCJ0eXBlIjoiQlVHQk9UX0ZJWF9JTl9DVVJTT1IiLCJkYXRhIjp7InJlZGlzS2V5IjoiYnVnYm90OmMwYzI5ODU4LWE4ZWUtNGZhNS05ZDBjLTU0NzAzOWQzMjFlNCIsImVuY3J5cHRpb25LZXkiOiJ0cTdUUnpKOEFmOE1NdEdtRkVCczU3aXVuQTFFaXViSm5NQy1obVFhQ29VIiwiYnJhbmNoIjoicG9sbC1jb21wb25lbnQifSwiaWF0IjoxNzYyOTc0MjQ1LCJleHAiOjE3NjM1NzkwNDV9.V8JDiOXzMYyLTDEG3e0HBpzCzEOv_i1LOQmMr3420Gk2-sD3tCes_G4kNp3BWfIrocsIn-w_d1FDgEHFPHYQ7ev0XrmEEbirNu2uHGjEA6z19FDDnHhPqDCDemhDwnn7mUSjqmTSXQr5I0gQUvVrSKp4q8l41NNxJQnRgTVMKzVqowzSolsF19u5_W5Rg2pgjnE8wOiskFkgggaZiO9kH6S5WYaJHbwfrfBtxV7gizacnkHrNQO0EriI7SeYxj7D9gVkgX8wZhyKFzoORAeR5318-VpvLG_kdgDRYf1r_Ht-LjbPYxvTx0IiDtvvIF18fAlKwcjKA_Sv8-0BZ_V6TA\"><picture><source media=\"(prefers-color-scheme: dark)\" srcset=\"https://cursor.com/fix-in-cursor-dark.svg\"><source media=\"(prefers-color-scheme: light)\" srcset=\"https://cursor.com/fix-in-cursor-light.svg\"><img alt=\"Fix in Cursor\" src=\"https://cursor.com/fix-in-cursor.svg\"></picture></a>&nbsp;<a href=\"https://cursor.com/agents?data=eyJhbGciOiJSUzI1NiIsInR5cCI6IkpXVCIsImtpZCI6ImJ1Z2JvdC12MSJ9.eyJ2ZXJzaW9uIjoxLCJ0eXBlIjoiQlVHQk9UX0ZJWF9JTl9XRUIiLCJkYXRhIjp7InJlZGlzS2V5IjoiYnVnYm90OmMwYzI5ODU4LWE4ZWUtNGZhNS05ZDBjLTU0NzAzOWQzMjFlNCIsImVuY3J5cHRpb25LZXkiOiJ0cTdUUnpKOEFmOE1NdEdtRkVCczU3aXVuQTFFaXViSm5NQy1obVFhQ29VIiwiYnJhbmNoIjoicG9sbC1jb21wb25lbnQiLCJyZXBvT3duZXIiOiJ0ZW1wb3JhbGlvIiwicmVwb05hbWUiOiJ0ZW1wb3JhbCIsInByTnVtYmVyIjo4NTYzLCJjb21taXRTaGEiOiIzM2U5ODFlYjU4ZTE3OGQ0ODlhYWNiMzU1N2RiYWJlZjYyNTJlNGFhIn0sImlhdCI6MTc2Mjk3NDI0NSwiZXhwIjoxNzYzNTc5MDQ1fQ.Hq0e0phnNkvmgzPxWVYXQQGm8rFIHg2BKXznuyVmF0gT42U_cAgFAOHeNvU0J3GTjYvoxYVi-pn-HjxPfuGBLkA5SCLP_9P8FUiKJ5NIz1lD1t9fzOa22MR7zaHemwDGX7P7ULmy4UqNpvPd05HLK0Q74o48riwZv4_IMvMIUo_K6A5FPUZg853siEpQaa98UIMpkJ0DnbXrdU1xBWiKCUKKGih1Hb7LijP3BWIh0JZeubt2D1GVsD5MWNFz2haUObxrrxOLPbkwSJtz-WGJrfWygOR3inhPVDL580lVjJSGQbkCzHpxpoL22BQDxsX6PtN339iYCacCKgDLR_SLHw\"><picture><source media=\"(prefers-color-scheme: dark)\" srcset=\"https://cursor.com/fix-in-web-dark.svg\"><source media=\"(prefers-color-scheme: light)\" srcset=\"https://cursor.com/fix-in-web-light.svg\"><img alt=\"Fix in Web\" src=\"https://cursor.com/fix-in-web.svg\"></picture></a>\n\n","created_at":"2025-11-12T19:04:06Z","updated_at":"2025-11-12T19:04:06Z","html_url":"https://github.com/temporalio/temporal/pull/8563#discussion_r2519465405","pull_request_url":"https://api.github.com/repos/temporalio/temporal/pulls/8563","_links":{"self":{"href":"https://api.github.com/repos/temporalio/temporal/pulls/comments/2519465405"},"html":{"href":"https://github.com/temporalio/temporal/pull/8563#discussion_r2519465405"},"pull_request":{"href":"https://api.github.com/repos/temporalio/temporal/pulls/8563"}},"reactions":{"url":"https://api.github.com/repos/temporalio/temporal/pulls/comments/2519465405/reactions","total_count":0,"+1":0,"-1":0,"laugh":0,"hooray":0,"confused":0,"heart":0,"rocket":0,"eyes":0},"start_line":null,"original_start_line":null,"start_side":null,"line":326,"original_line":383,"side":"RIGHT","author_association":"NONE","original_position":216,"position":138,"subject_type":"line"},{"url":"https://api.github.com/repos/temporalio/temporal/pulls/comments/2519567383","pull_request_review_id":3454066296,"id":2519567383,"node_id":"PRRC_kwDODNqesM6WLYwX","diff_hunk":"@@ -241,14 +280,159 @@ func (e *ChasmEngine) ReadComponent(\n \treturn readFn(chasmContext, component)\n }\n \n+// PollComponent waits until the supplied predicate is satisfied when evaluated against the\n+// component identified by the supplied component reference. It returns a component reference\n+// identifying the state at which the predicate was satisfied. An error is returned if entity\n+// transition history is (after reloading from persistence) behind the requested ref, or if the ref\n+// is not interpretable as part of the entity transition history. Thus when the predicate function\n+// is evaluated, it is guaranteed that the entity VT >= requestRef VT.\n func (e *ChasmEngine) PollComponent(\n \tctx context.Context,\n-\tentityRef chasm.ComponentRef,\n-\tpredicateFn func(chasm.Context, chasm.Component) (any, bool, error),\n-\toperationFn func(chasm.MutableContext, chasm.Component, any) error,\n+\trequestRef chasm.ComponentRef,\n+\tpredicateFn func(chasm.Context, chasm.Component) (bool, error),\n \topts ...chasm.TransitionOption,\n-) (newEntityRef []byte, retError error) {\n-\treturn nil, serviceerror.NewUnimplemented(\"PollComponent is not yet supported\")\n+) ([]byte, error) {\n+\t// 1. Acquire lock\n+\t// 2. Error if shard entity VT < requestRef VT ('stale state')\n+\t// 3. If predicate satisfied, release lock and return\n+\t// 4. Subscribe to notifications for this entity\n+\t// 5. Release lock\n+\t// 6. On notification repeat (1) and (2)\n+\n+\tshardContext, executionLease, err := e.getExecutionLease(ctx, requestRef)\n+\tif err != nil {\n+\t\t// E.g. requestRef VT inconsistent with shard VT ('stale reference')\n+\t\treturn nil, err\n+\t}\n+\n+\t// hold lock until return or subscription established\n+\treleased := false\n+\tdefer func() {\n+\t\tif !released {\n+\t\t\t// read-only operation; don't pass error\n+\t\t\texecutionLease.GetReleaseFn()(nil)\n+\t\t}\n+\t}()\n+\n+\t// At this point it's possible that shard VT < requestRef VT (getExecutionLease does not\n+\t// guarantee that returned shard state is non-stale w.r.t. requestRef).\n+\tcurrentRef, err := e.checkPredicate(ctx, requestRef, executionLease, predicateFn)\n+\tif err != nil {\n+\t\treturn nil, err\n+\t}\n+\t// shard VT >= requestRef VT (enforced by checkPredicate)\n+\n+\tif currentRef != nil {\n+\t\t// wait condition was satisfied\n+\t\treturn currentRef, nil\n+\t}\n+\n+\t// Wait condition not satisfied; long-poll\n+\n+\tchannel, subscriberID, err := e.notifier.Subscribe(requestRef.EntityKey)\n+\tif err != nil {\n+\t\treturn nil, err\n+\t}\n+\tdefer func() {\n+\t\t_ = e.notifier.Unsubscribe(requestRef.EntityKey, subscriberID)\n+\t}()\n+\n+\t// Release the lock, now that we are subscribed\n+\texecutionLease.GetReleaseFn()(nil)\n+\treleased = true\n+\n+\tnamespaceRegistry, err := shardContext.GetNamespaceRegistry().GetNamespaceByID(\n+\t\tnamespace.ID(requestRef.EntityKey.NamespaceID),\n+\t)\n+\tif err != nil {\n+\t\treturn nil, err\n+\t}\n+\n+\t// TODO(dan): check desired timeout logic here\n+\tlongPollCtx, cancel := contextutil.WithDeadlineBuffer(\n+\t\tctx,\n+\t\tshardContext.GetConfig().LongPollExpirationInterval(namespaceRegistry.Name().String()),\n+\t\ttime.Second,\n+\t)\n+\tdefer cancel()\n+\n+\tfor {\n+\t\tselect {\n+\t\tcase notification := <-channel:\n+\t\t\tif notification == nil {\n+\t\t\t\treturn nil, serviceerror.NewInternal(\"nil component notification\")\n+\t\t\t}\n+\t\t\t// Received a notification. Re-acquire the lock and check the predicate.\n+\t\t\t_, executionLease, err := e.getExecutionLease(ctx, requestRef)\n+\t\t\tif err != nil {\n+\t\t\t\treturn nil, err\n+\t\t\t}\n+\n+\t\t\tnewRef, err := e.checkPredicate(ctx, requestRef, executionLease, predicateFn)\n+\t\t\texecutionLease.GetReleaseFn()(nil)\n+\t\t\tif err != nil {\n+\t\t\t\treturn nil, err\n+\t\t\t}\n+\t\t\tif newRef != nil {\n+\t\t\t\t// wait condition was satisfied\n+\t\t\t\treturn newRef, nil\n+\t\t\t}\n+\t\tcase <-longPollCtx.Done():\n+\t\t\t// TODO(dan): return empty response?\n+\t\t\treturn nil, serviceerror.NewDeadlineExceeded(\"long-poll timed out\")\n+\t\t}","path":"service/history/chasm_engine.go","commit_id":"1d59e66d0ce5d91819f92c428ef5ab4c4efca1fb","original_commit_id":"33e981eb58e178d489aacb3557dbabef6252e4aa","user":{"login":"dandavison","id":52205,"node_id":"MDQ6VXNlcjUyMjA1","avatar_url":"https://avatars.githubusercontent.com/u/52205?v=4","gravatar_id":"","url":"https://api.github.com/users/dandavison","html_url":"https://github.com/dandavison","followers_url":"https://api.github.com/users/dandavison/followers","following_url":"https://api.github.com/users/dandavison/following{/other_user}","gists_url":"https://api.github.com/users/dandavison/gists{/gist_id}","starred_url":"https://api.github.com/users/dandavison/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/dandavison/subscriptions","organizations_url":"https://api.github.com/users/dandavison/orgs","repos_url":"https://api.github.com/users/dandavison/repos","events_url":"https://api.github.com/users/dandavison/events{/privacy}","received_events_url":"https://api.github.com/users/dandavison/received_events","type":"User","user_view_type":"public","site_admin":false},"body":"That is a contract we accept in the original `events.Notifier`: subscribers must keep up. The implication is that the notifications must not be critical for correctness: in the long-poll use case, the caller will get a time-out and on retry should eventually get a consistent non-timeout response.","created_at":"2025-11-12T19:42:10Z","updated_at":"2025-11-12T21:52:35Z","html_url":"https://github.com/temporalio/temporal/pull/8563#discussion_r2519567383","pull_request_url":"https://api.github.com/repos/temporalio/temporal/pulls/8563","_links":{"self":{"href":"https://api.github.com/repos/temporalio/temporal/pulls/comments/2519567383"},"html":{"href":"https://github.com/temporalio/temporal/pull/8563#discussion_r2519567383"},"pull_request":{"href":"https://api.github.com/repos/temporalio/temporal/pulls/8563"}},"reactions":{"url":"https://api.github.com/repos/temporalio/temporal/pulls/comments/2519567383/reactions","total_count":0,"+1":0,"-1":0,"laugh":0,"hooray":0,"confused":0,"heart":0,"rocket":0,"eyes":0},"start_line":null,"original_start_line":null,"start_side":null,"line":326,"original_line":383,"side":"RIGHT","in_reply_to_id":2519465405,"author_association":"MEMBER","original_position":216,"position":138,"subject_type":"line"},{"url":"https://api.github.com/repos/temporalio/temporal/pulls/comments/2519658327","pull_request_review_id":3455277117,"id":2519658327,"node_id":"PRRC_kwDODNqesM6WLu9X","diff_hunk":"@@ -241,14 +280,159 @@ func (e *ChasmEngine) ReadComponent(\n \treturn readFn(chasmContext, component)\n }\n \n+// PollComponent waits until the supplied predicate is satisfied when evaluated against the\n+// component identified by the supplied component reference. It returns a component reference\n+// identifying the state at which the predicate was satisfied. An error is returned if entity\n+// transition history is (after reloading from persistence) behind the requested ref, or if the ref\n+// is not interpretable as part of the entity transition history. Thus when the predicate function\n+// is evaluated, it is guaranteed that the entity VT >= requestRef VT.\n func (e *ChasmEngine) PollComponent(\n \tctx context.Context,\n-\tentityRef chasm.ComponentRef,\n-\tpredicateFn func(chasm.Context, chasm.Component) (any, bool, error),\n-\toperationFn func(chasm.MutableContext, chasm.Component, any) error,\n+\trequestRef chasm.ComponentRef,\n+\tpredicateFn func(chasm.Context, chasm.Component) (bool, error),\n \topts ...chasm.TransitionOption,\n-) (newEntityRef []byte, retError error) {\n-\treturn nil, serviceerror.NewUnimplemented(\"PollComponent is not yet supported\")\n+) ([]byte, error) {\n+\t// 1. Acquire lock\n+\t// 2. Error if shard entity VT < requestRef VT ('stale state')\n+\t// 3. If predicate satisfied, release lock and return\n+\t// 4. Subscribe to notifications for this entity\n+\t// 5. Release lock\n+\t// 6. On notification repeat (1) and (2)\n+\n+\tshardContext, executionLease, err := e.getExecutionLease(ctx, requestRef)\n+\tif err != nil {\n+\t\t// E.g. requestRef VT inconsistent with shard VT ('stale reference')\n+\t\treturn nil, err\n+\t}\n+\n+\t// hold lock until return or subscription established\n+\treleased := false\n+\tdefer func() {\n+\t\tif !released {\n+\t\t\t// read-only operation; don't pass error\n+\t\t\texecutionLease.GetReleaseFn()(nil)\n+\t\t}\n+\t}()\n+\n+\t// At this point it's possible that shard VT < requestRef VT (getExecutionLease does not\n+\t// guarantee that returned shard state is non-stale w.r.t. requestRef).\n+\tcurrentRef, err := e.checkPredicate(ctx, requestRef, executionLease, predicateFn)\n+\tif err != nil {\n+\t\treturn nil, err\n+\t}\n+\t// shard VT >= requestRef VT (enforced by checkPredicate)\n+\n+\tif currentRef != nil {\n+\t\t// wait condition was satisfied\n+\t\treturn currentRef, nil\n+\t}\n+\n+\t// Wait condition not satisfied; long-poll\n+\n+\tchannel, subscriberID, err := e.notifier.Subscribe(requestRef.EntityKey)\n+\tif err != nil {\n+\t\treturn nil, err\n+\t}\n+\tdefer func() {\n+\t\t_ = e.notifier.Unsubscribe(requestRef.EntityKey, subscriberID)\n+\t}()\n+\n+\t// Release the lock, now that we are subscribed\n+\texecutionLease.GetReleaseFn()(nil)\n+\treleased = true\n+\n+\tnamespaceRegistry, err := shardContext.GetNamespaceRegistry().GetNamespaceByID(\n+\t\tnamespace.ID(requestRef.EntityKey.NamespaceID),\n+\t)\n+\tif err != nil {\n+\t\treturn nil, err\n+\t}\n+\n+\t// TODO(dan): check desired timeout logic here\n+\tctx, cancel := contextutil.WithDeadlineBuffer(\n+\t\tctx,\n+\t\tshardContext.GetConfig().LongPollExpirationInterval(namespaceRegistry.Name().String()),\n+\t\ttime.Second,\n+\t)\n+\tdefer cancel()\n+\n+\tfor {\n+\t\tselect {\n+\t\tcase notification := <-channel:\n+\t\t\tif notification == nil {\n+\t\t\t\treturn nil, serviceerror.NewInternal(\"nil component notification\")\n+\t\t\t}\n+\t\t\t// Received a notification. Re-acquire the lock and check the predicate.\n+\t\t\t_, executionLease, err := e.getExecutionLease(ctx, requestRef)\n+\t\t\tif err != nil {\n+\t\t\t\treturn nil, err\n+\t\t\t}\n+\n+\t\t\tnewRef, err := e.checkPredicate(ctx, requestRef, executionLease, predicateFn)\n+\t\t\texecutionLease.GetReleaseFn()(nil)\n+\t\t\tif err != nil {\n+\t\t\t\treturn nil, err\n+\t\t\t}\n+\t\t\tif newRef != nil {\n+\t\t\t\t// wait condition was satisfied\n+\t\t\t\treturn newRef, nil\n+\t\t\t}","path":"service/history/chasm_engine.go","commit_id":"da6009564e796063faf853352077eecdc1473612","original_commit_id":"28665bbdf70db031950bf4cf81f5c4f30f518b42","user":{"login":"cursor[bot]","id":206951365,"node_id":"BOT_kgDODFXTxQ","avatar_url":"https://avatars.githubusercontent.com/in/1210556?v=4","gravatar_id":"","url":"https://api.github.com/users/cursor%5Bbot%5D","html_url":"https://github.com/apps/cursor","followers_url":"https://api.github.com/users/cursor%5Bbot%5D/followers","following_url":"https://api.github.com/users/cursor%5Bbot%5D/following{/other_user}","gists_url":"https://api.github.com/users/cursor%5Bbot%5D/gists{/gist_id}","starred_url":"https://api.github.com/users/cursor%5Bbot%5D/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/cursor%5Bbot%5D/subscriptions","organizations_url":"https://api.github.com/users/cursor%5Bbot%5D/orgs","repos_url":"https://api.github.com/users/cursor%5Bbot%5D/repos","events_url":"https://api.github.com/users/cursor%5Bbot%5D/events{/privacy}","received_events_url":"https://api.github.com/users/cursor%5Bbot%5D/received_events","type":"Bot","user_view_type":"public","site_admin":false},"body":"### Bug: Subscription Loss and System Overload\n\n<!-- **Medium Severity** -->\n\n<!-- DESCRIPTION START -->\nAfter receiving a notification and re-acquiring the lock at line 366, if `checkPredicate` returns an error at line 371, the lock is immediately released at line 372 before returning the error at line 373. However, the defer at line 337 will attempt to unsubscribe after the function returns. If the error from `checkPredicate` is transient (like a temporary lock failure during `getExecutionLease`), the caller loses their subscription but may retry the entire `PollComponent` call, creating a new subscription. This means notifications between the error and retry are lost. The same issue exists at line 377 where `checkPredicate` succeeds but the predicate isn't satisfied - the loop continues without any backoff, potentially hammering the system if notifications are being generated rapidly.\n<!-- DESCRIPTION END -->\n\n<!-- LOCATIONS START\nservice/history/chasm_engine.go#L365-L379\nLOCATIONS END -->\n<a href=\"https://cursor.com/open?data=eyJhbGciOiJSUzI1NiIsInR5cCI6IkpXVCIsImtpZCI6ImJ1Z2JvdC12MSJ9.eyJ2ZXJzaW9uIjoxLCJ0eXBlIjoiQlVHQk9UX0ZJWF9JTl9DVVJTT1IiLCJkYXRhIjp7InJlZGlzS2V5IjoiYnVnYm90OjFjNzZmMWU5LTRkNGUtNDM4Ni05MGQ4LWM5ZDAzMjM4YjYwZSIsImVuY3J5cHRpb25LZXkiOiJzbkRheVJBZjdjeXdhRzEybTg1aFZVbWtFR2lJYy1JUXpZVl9mcEtaWDJ3IiwiYnJhbmNoIjoicG9sbC1jb21wb25lbnQifSwiaWF0IjoxNzYyOTc4MDY3LCJleHAiOjE3NjM1ODI4Njd9.BPktaZCosKHe1K82F0ncobc9DZ8ly94Ok411E7SFHCABxo6KWHP6z8EHcu2pT9ku3nT8wucXN8b7uMrnhmx7iOfxtqp1VlKpwedgPmK-DhX3uXBPqqkxFI3dI6UiW2gLdQ9uAYmaDrdVL8VkyWC_ZoCrTBVh14WHO-M0lI_4jQ2pNGosGniyg34XS3dy9Nmn1r1Fk6T4rcmoJSaEr_T_hakPAS7Ei-LamMLAIP-lpo8CLJmDo5iTYhqJjvq7WEHyjLrzncxfTTIGkKvkdE1UCc1JG4O0mBJsE9BHqIjusz1X35Xuc7d7HhYJHi1L7d7HxT_s9LkJJNxqOY45s3QhMQ\"><picture><source media=\"(prefers-color-scheme: dark)\" srcset=\"https://cursor.com/fix-in-cursor-dark.svg\"><source media=\"(prefers-color-scheme: light)\" srcset=\"https://cursor.com/fix-in-cursor-light.svg\"><img alt=\"Fix in Cursor\" src=\"https://cursor.com/fix-in-cursor.svg\"></picture></a>&nbsp;<a href=\"https://cursor.com/agents?data=eyJhbGciOiJSUzI1NiIsInR5cCI6IkpXVCIsImtpZCI6ImJ1Z2JvdC12MSJ9.eyJ2ZXJzaW9uIjoxLCJ0eXBlIjoiQlVHQk9UX0ZJWF9JTl9XRUIiLCJkYXRhIjp7InJlZGlzS2V5IjoiYnVnYm90OjFjNzZmMWU5LTRkNGUtNDM4Ni05MGQ4LWM5ZDAzMjM4YjYwZSIsImVuY3J5cHRpb25LZXkiOiJzbkRheVJBZjdjeXdhRzEybTg1aFZVbWtFR2lJYy1JUXpZVl9mcEtaWDJ3IiwiYnJhbmNoIjoicG9sbC1jb21wb25lbnQiLCJyZXBvT3duZXIiOiJ0ZW1wb3JhbGlvIiwicmVwb05hbWUiOiJ0ZW1wb3JhbCIsInByTnVtYmVyIjo4NTYzLCJjb21taXRTaGEiOiIyODY2NWJiZGY3MGRiMDMxOTUwYmY0Y2Y4MWY1YzRmMzBmNTE4YjQyIn0sImlhdCI6MTc2Mjk3ODA2NywiZXhwIjoxNzYzNTgyODY3fQ.Z8pdmG-1CxrbJeit8gzh5sO_g2mXd1LXy0dyBsdw0Y8fBokFXZylfxVNzGX4iv2eEdkzyrmRZuCGQyX2cfhyedIyk5sTq5zzCjmFz58g0fh3iiG6XVbnIEvURl1GTnIcwZe8gYV4hm3IAiecxnM0zO5Q-gZBT_pzfxnDNFyXW5_viDF-z6aa2AvB0fHMiGFLtAKscqp-8gX2EZroXTDyFcYYEfSHNAqOSfKkuweavw_xdXLgxEnpu2b0dBcR9DZ-xA9rae-Ge56ZL6XQuMlJvTR5V8F3alMWO718JyWjuA3PuSXAmUzMXNSDzmfM4F-8fMiZr4JqSGRgudD9NRE5nA\"><picture><source media=\"(prefers-color-scheme: dark)\" srcset=\"https://cursor.com/fix-in-web-dark.svg\"><source media=\"(prefers-color-scheme: light)\" srcset=\"https://cursor.com/fix-in-web-light.svg\"><img alt=\"Fix in Web\" src=\"https://cursor.com/fix-in-web.svg\"></picture></a>\n\n","created_at":"2025-11-12T20:07:47Z","updated_at":"2025-11-12T20:07:47Z","html_url":"https://github.com/temporalio/temporal/pull/8563#discussion_r2519658327","pull_request_url":"https://api.github.com/repos/temporalio/temporal/pulls/8563","_links":{"self":{"href":"https://api.github.com/repos/temporalio/temporal/pulls/comments/2519658327"},"html":{"href":"https://github.com/temporalio/temporal/pull/8563#discussion_r2519658327"},"pull_request":{"href":"https://api.github.com/repos/temporalio/temporal/pulls/8563"}},"reactions":{"url":"https://api.github.com/repos/temporalio/temporal/pulls/comments/2519658327/reactions","total_count":1,"+1":0,"-1":1,"laugh":0,"hooray":0,"confused":0,"heart":0,"rocket":0,"eyes":0},"start_line":null,"original_start_line":null,"start_side":null,"line":323,"original_line":379,"side":"RIGHT","author_association":"NONE","original_position":212,"position":1,"subject_type":"line"},{"url":"https://api.github.com/repos/temporalio/temporal/pulls/comments/2519662770","pull_request_review_id":3454066296,"id":2519662770,"node_id":"PRRC_kwDODNqesM6WLwCy","diff_hunk":"@@ -241,14 +280,159 @@ func (e *ChasmEngine) ReadComponent(\n \treturn readFn(chasmContext, component)\n }\n \n+// PollComponent waits until the supplied predicate is satisfied when evaluated against the\n+// component identified by the supplied component reference. It returns a component reference\n+// identifying the state at which the predicate was satisfied. An error is returned if entity\n+// transition history is (after reloading from persistence) behind the requested ref, or if the ref\n+// is not interpretable as part of the entity transition history. Thus when the predicate function\n+// is evaluated, it is guaranteed that the entity VT >= requestRef VT.\n func (e *ChasmEngine) PollComponent(\n \tctx context.Context,\n-\tentityRef chasm.ComponentRef,\n-\tpredicateFn func(chasm.Context, chasm.Component) (any, bool, error),\n-\toperationFn func(chasm.MutableContext, chasm.Component, any) error,\n+\trequestRef chasm.ComponentRef,\n+\tpredicateFn func(chasm.Context, chasm.Component) (bool, error),\n \topts ...chasm.TransitionOption,\n-) (newEntityRef []byte, retError error) {\n-\treturn nil, serviceerror.NewUnimplemented(\"PollComponent is not yet supported\")\n+) ([]byte, error) {\n+\t// 1. Acquire lock\n+\t// 2. Error if shard entity VT < requestRef VT ('stale state')\n+\t// 3. If predicate satisfied, release lock and return\n+\t// 4. Subscribe to notifications for this entity\n+\t// 5. Release lock\n+\t// 6. On notification repeat (1) and (2)\n+\n+\tshardContext, executionLease, err := e.getExecutionLease(ctx, requestRef)\n+\tif err != nil {\n+\t\t// E.g. requestRef VT inconsistent with shard VT ('stale reference')\n+\t\treturn nil, err\n+\t}\n+\n+\t// hold lock until return or subscription established\n+\treleased := false\n+\tdefer func() {\n+\t\tif !released {\n+\t\t\t// read-only operation; don't pass error\n+\t\t\texecutionLease.GetReleaseFn()(nil)\n+\t\t}\n+\t}()\n+\n+\t// At this point it's possible that shard VT < requestRef VT (getExecutionLease does not\n+\t// guarantee that returned shard state is non-stale w.r.t. requestRef).\n+\tcurrentRef, err := e.checkPredicate(ctx, requestRef, executionLease, predicateFn)\n+\tif err != nil {\n+\t\treturn nil, err\n+\t}\n+\t// shard VT >= requestRef VT (enforced by checkPredicate)\n+\n+\tif currentRef != nil {\n+\t\t// wait condition was satisfied\n+\t\treturn currentRef, nil\n+\t}\n+\n+\t// Wait condition not satisfied; long-poll\n+\n+\tchannel, subscriberID, err := e.notifier.Subscribe(requestRef.EntityKey)\n+\tif err != nil {\n+\t\treturn nil, err\n+\t}\n+\tdefer func() {\n+\t\t_ = e.notifier.Unsubscribe(requestRef.EntityKey, subscriberID)\n+\t}()\n+\n+\t// Release the lock, now that we are subscribed\n+\texecutionLease.GetReleaseFn()(nil)\n+\treleased = true\n+\n+\tnamespaceRegistry, err := shardContext.GetNamespaceRegistry().GetNamespaceByID(\n+\t\tnamespace.ID(requestRef.EntityKey.NamespaceID),\n+\t)\n+\tif err != nil {\n+\t\treturn nil, err\n+\t}\n+\n+\t// TODO(dan): check desired timeout logic here\n+\tlongPollCtx, cancel := contextutil.WithDeadlineBuffer(\n+\t\tctx,\n+\t\tshardContext.GetConfig().LongPollExpirationInterval(namespaceRegistry.Name().String()),\n+\t\ttime.Second,\n+\t)\n+\tdefer cancel()\n+\n+\tfor {\n+\t\tselect {\n+\t\tcase notification := <-channel:\n+\t\t\tif notification == nil {\n+\t\t\t\treturn nil, serviceerror.NewInternal(\"nil component notification\")\n+\t\t\t}\n+\t\t\t// Received a notification. Re-acquire the lock and check the predicate.\n+\t\t\t_, executionLease, err := e.getExecutionLease(ctx, requestRef)\n+\t\t\tif err != nil {\n+\t\t\t\treturn nil, err\n+\t\t\t}\n+\n+\t\t\tnewRef, err := e.checkPredicate(ctx, requestRef, executionLease, predicateFn)\n+\t\t\texecutionLease.GetReleaseFn()(nil)\n+\t\t\tif err != nil {\n+\t\t\t\treturn nil, err\n+\t\t\t}\n+\t\t\tif newRef != nil {\n+\t\t\t\t// wait condition was satisfied\n+\t\t\t\treturn newRef, nil\n+\t\t\t}\n+\t\tcase <-longPollCtx.Done():\n+\t\t\t// TODO(dan): return empty response?\n+\t\t\treturn nil, serviceerror.NewDeadlineExceeded(\"long-poll timed out\")\n+\t\t}","path":"service/history/chasm_engine.go","commit_id":"1d59e66d0ce5d91819f92c428ef5ab4c4efca1fb","original_commit_id":"33e981eb58e178d489aacb3557dbabef6252e4aa","user":{"login":"dandavison","id":52205,"node_id":"MDQ6VXNlcjUyMjA1","avatar_url":"https://avatars.githubusercontent.com/u/52205?v=4","gravatar_id":"","url":"https://api.github.com/users/dandavison","html_url":"https://github.com/dandavison","followers_url":"https://api.github.com/users/dandavison/followers","following_url":"https://api.github.com/users/dandavison/following{/other_user}","gists_url":"https://api.github.com/users/dandavison/gists{/gist_id}","starred_url":"https://api.github.com/users/dandavison/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/dandavison/subscriptions","organizations_url":"https://api.github.com/users/dandavison/orgs","repos_url":"https://api.github.com/users/dandavison/repos","events_url":"https://api.github.com/users/dandavison/events{/privacy}","received_events_url":"https://api.github.com/users/dandavison/received_events","type":"User","user_view_type":"public","site_admin":false},"body":"This is the contract: subscribers must keep up. The implication is that dropped notifications must not be correctness bugs. In the long-poll use case a subscriber dropping a notification may lead to a timeout and, on retry, they should get a consistent non-timeout response.","created_at":"2025-11-12T20:08:51Z","updated_at":"2025-11-12T21:52:35Z","html_url":"https://github.com/temporalio/temporal/pull/8563#discussion_r2519662770","pull_request_url":"https://api.github.com/repos/temporalio/temporal/pulls/8563","_links":{"self":{"href":"https://api.github.com/repos/temporalio/temporal/pulls/comments/2519662770"},"html":{"href":"https://github.com/temporalio/temporal/pull/8563#discussion_r2519662770"},"pull_request":{"href":"https://api.github.com/repos/temporalio/temporal/pulls/8563"}},"reactions":{"url":"https://api.github.com/repos/temporalio/temporal/pulls/comments/2519662770/reactions","total_count":0,"+1":0,"-1":0,"laugh":0,"hooray":0,"confused":0,"heart":0,"rocket":0,"eyes":0},"start_line":null,"original_start_line":null,"start_side":null,"line":326,"original_line":383,"side":"RIGHT","in_reply_to_id":2519465405,"author_association":"MEMBER","original_position":216,"position":138,"subject_type":"line"},{"url":"https://api.github.com/repos/temporalio/temporal/pulls/comments/2519839302","pull_request_review_id":3455546260,"id":2519839302,"node_id":"PRRC_kwDODNqesM6WMbJG","diff_hunk":"@@ -105,3 +115,211 @@ func createDefaultInput() *commonpb.Payloads {\n \t\t},\n \t}\n }\n+\n+func (s *standaloneActivityTestSuite) Test_PollActivityExecution_NoWait() {\n+\t// Long poll for any state change. PollActivityTaskQueue is used to cause a state change.\n+\tt := s.T()\n+\tctx, cancel := context.WithTimeout(t.Context(), 10*time.Second)\n+\tdefer cancel()\n+\tactivityID := testcore.RandomizeStr(t.Name())\n+\ttaskQueue := uuid.New().String()\n+\n+\tstartResp, err := s.startActivity(ctx, activityID, taskQueue)\n+\trequire.NoError(t, err)\n+\n+\tpollResp, err := s.FrontendClient().PollActivityExecution(ctx, &workflowservice.PollActivityExecutionRequest{\n+\t\tNamespace:   s.Namespace().String(),\n+\t\tActivityId:  activityID,\n+\t\tRunId:       startResp.RunId,\n+\t\tIncludeInfo: true,\n+\t})\n+\trequire.NoError(t, err)\n+\trequire.NotNil(t, pollResp.StateChangeLongPollToken)\n+\trequire.NotNil(t, pollResp.Info)\n+\n+\ts.assertActivityExecutionInfo(\n+\t\tt,\n+\t\tpollResp.Info,\n+\t\tactivityID,\n+\t\tstartResp.RunId,\n+\t\tenumspb.PENDING_ACTIVITY_STATE_SCHEDULED,\n+\t)\n+\n+}\n+\n+func (s *standaloneActivityTestSuite) Test_PollActivityExecution_WaitAnyStateChange() {\n+\t// Long poll for any state change. PollActivityTaskQueue is used to cause a state change.\n+\tt := s.T()\n+\tctx, cancel := context.WithTimeout(t.Context(), 10*time.Second)\n+\tdefer cancel()\n+\tactivityID := testcore.RandomizeStr(t.Name())\n+\ttaskQueue := uuid.New().String()\n+\n+\tstartResp, err := s.startActivity(ctx, activityID, taskQueue)\n+\trequire.NoError(t, err)\n+\n+\t// First poll lacks token and therefore responds immediately, returning a token\n+\tfirstPollResp, err := s.FrontendClient().PollActivityExecution(ctx, &workflowservice.PollActivityExecutionRequest{\n+\t\tNamespace:  s.Namespace().String(),\n+\t\tActivityId: activityID,\n+\t\tRunId:      startResp.RunId,\n+\t\tWaitPolicy: &workflowservice.PollActivityExecutionRequest_WaitAnyStateChange{\n+\t\t\tWaitAnyStateChange: &workflowservice.PollActivityExecutionRequest_StateChangeWaitOptions{},\n+\t\t},\n+\t\tIncludeInfo: true,\n+\t})\n+\trequire.NoError(t, err)\n+\trequire.NotNil(t, firstPollResp.StateChangeLongPollToken)\n+\trequire.NotNil(t, firstPollResp.Info)\n+\n+\ts.assertActivityExecutionInfo(\n+\t\tt,\n+\t\tfirstPollResp.Info,\n+\t\tactivityID,\n+\t\tstartResp.RunId,\n+\t\tenumspb.PENDING_ACTIVITY_STATE_SCHEDULED,\n+\t)\n+\n+\ttaskQueuePollErr := make(chan error, 1)\n+\tactivityPollDone := make(chan struct{})\n+\tvar activityPollResp *workflowservice.PollActivityExecutionResponse\n+\tvar activityPollErr error\n+\n+\tgo func() {\n+\t\tdefer close(activityPollDone)\n+\t\t// Second poll uses token and therefore waits for a state transition\n+\t\tactivityPollResp, activityPollErr = s.FrontendClient().PollActivityExecution(ctx, &workflowservice.PollActivityExecutionRequest{\n+\t\t\tNamespace:   s.Namespace().String(),\n+\t\t\tActivityId:  activityID,\n+\t\t\tRunId:       startResp.RunId,\n+\t\t\tIncludeInfo: true,\n+\t\t\tWaitPolicy: &workflowservice.PollActivityExecutionRequest_WaitAnyStateChange{\n+\t\t\t\tWaitAnyStateChange: &workflowservice.PollActivityExecutionRequest_StateChangeWaitOptions{\n+\t\t\t\t\tLongPollToken: firstPollResp.StateChangeLongPollToken,\n+\t\t\t\t},\n+\t\t\t},\n+\t\t})\n+\t}()\n+\n+\t// TODO(dan): race here: subscription might not be established yet","path":"tests/standalone_activity_test.go","commit_id":"1d59e66d0ce5d91819f92c428ef5ab4c4efca1fb","original_commit_id":"dcaa0b9d4d5752530e4b403d80b6d6539cd5036b","user":{"login":"cursor[bot]","id":206951365,"node_id":"BOT_kgDODFXTxQ","avatar_url":"https://avatars.githubusercontent.com/in/1210556?v=4","gravatar_id":"","url":"https://api.github.com/users/cursor%5Bbot%5D","html_url":"https://github.com/apps/cursor","followers_url":"https://api.github.com/users/cursor%5Bbot%5D/followers","following_url":"https://api.github.com/users/cursor%5Bbot%5D/following{/other_user}","gists_url":"https://api.github.com/users/cursor%5Bbot%5D/gists{/gist_id}","starred_url":"https://api.github.com/users/cursor%5Bbot%5D/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/cursor%5Bbot%5D/subscriptions","organizations_url":"https://api.github.com/users/cursor%5Bbot%5D/orgs","repos_url":"https://api.github.com/users/cursor%5Bbot%5D/repos","events_url":"https://api.github.com/users/cursor%5Bbot%5D/events{/privacy}","received_events_url":"https://api.github.com/users/cursor%5Bbot%5D/received_events","type":"Bot","user_view_type":"public","site_admin":false},"body":"### Bug: Asynchronous Race Causes Test Hang\n\n<!-- **Medium Severity** -->\n\n<!-- DESCRIPTION START -->\nRace condition between subscription and notification in the long-poll test. The test starts a goroutine to poll for activity state changes, then immediately starts another goroutine to trigger the state change via `pollActivityTaskQueue`. However, the subscription inside `PollComponent` might not be established before the notification is sent by the update, causing the test to potentially miss the notification and hang until timeout.\n<!-- DESCRIPTION END -->\n\n<!-- LOCATIONS START\ntests/standalone_activity_test.go#L203-L204\nLOCATIONS END -->\n<a href=\"https://cursor.com/open?data=eyJhbGciOiJSUzI1NiIsInR5cCI6IkpXVCIsImtpZCI6ImJ1Z2JvdC12MSJ9.eyJ2ZXJzaW9uIjoxLCJ0eXBlIjoiQlVHQk9UX0ZJWF9JTl9DVVJTT1IiLCJkYXRhIjp7InJlZGlzS2V5IjoiYnVnYm90OjZlOTdhM2VlLWE5ODEtNGMwOS05MGFjLWZlMGNhZmMyNTZiNCIsImVuY3J5cHRpb25LZXkiOiJnOGNnT2FGazRSc2FTcFJXWVZMVE9IT2pYSUdwdW93elV1dE1Md0JMMGI4IiwiYnJhbmNoIjoicG9sbC1jb21wb25lbnQifSwiaWF0IjoxNzYyOTgyMDI0LCJleHAiOjE3NjM1ODY4MjR9.AN0nIJEtyAB57toUm81-iS3lJASR7F73wtual_voecx51KXHtZd9Vryk_wbdU3JCnQ0VgPLMfu_MCs6eVG36i2ESyGhnNlT8RskHkT1lwEwtZUyAvUba_-v5pWVxAuX0h6Vrts6W-saOJFxXfxmEsXaEVbzOeWqY3--klksQJeMibfGrRRWUOq1YMGG_GYKgXaKlXxrZwOjfdS6JmLP_GPSDwFKzyq7u6x6x7QWXe7GQj3D3m6iRZwu-iaeYMV-y1n1vmADp4KaDtK4r33LTWBZEJUukU3-L7QOIxIz_CIlHHvrXl3wet0-w9aw7ZgxprU2VjA7gl_a047ykpSyn7A\"><picture><source media=\"(prefers-color-scheme: dark)\" srcset=\"https://cursor.com/fix-in-cursor-dark.svg\"><source media=\"(prefers-color-scheme: light)\" srcset=\"https://cursor.com/fix-in-cursor-light.svg\"><img alt=\"Fix in Cursor\" src=\"https://cursor.com/fix-in-cursor.svg\"></picture></a>&nbsp;<a href=\"https://cursor.com/agents?data=eyJhbGciOiJSUzI1NiIsInR5cCI6IkpXVCIsImtpZCI6ImJ1Z2JvdC12MSJ9.eyJ2ZXJzaW9uIjoxLCJ0eXBlIjoiQlVHQk9UX0ZJWF9JTl9XRUIiLCJkYXRhIjp7InJlZGlzS2V5IjoiYnVnYm90OjZlOTdhM2VlLWE5ODEtNGMwOS05MGFjLWZlMGNhZmMyNTZiNCIsImVuY3J5cHRpb25LZXkiOiJnOGNnT2FGazRSc2FTcFJXWVZMVE9IT2pYSUdwdW93elV1dE1Md0JMMGI4IiwiYnJhbmNoIjoicG9sbC1jb21wb25lbnQiLCJyZXBvT3duZXIiOiJ0ZW1wb3JhbGlvIiwicmVwb05hbWUiOiJ0ZW1wb3JhbCIsInByTnVtYmVyIjo4NTYzLCJjb21taXRTaGEiOiJkY2FhMGI5ZDRkNTc1MjUzMGU0YjQwM2Q4MGI2ZDY1MzljZDUwMzZiIn0sImlhdCI6MTc2Mjk4MjAyNCwiZXhwIjoxNzYzNTg2ODI0fQ.L_L78XzHddJS0xsHbAzLUaTwyWyNni5MGzTXxW4uj8A6-V0P_KxpqP6P-IJA_uj4_GlmL_4mXzaHtNB2lveFGMIYFfJdkVrMcP5ePxE9FPs5F7FcTdP_1DBKvBlwRxvPPxyeLJKLo-RkfcmszVA-AI0qpe6tIaKdNweqpF3ocUjOKmvnBMcJ9CprS7oEtmxx8cVxuRoW4zswFUqS5BVhof2OsDqtXjYitiA0DGvmAWacjf48QbtY4hac7Dupb3CuNGNd3PIfzpFpldtUx72Zwu8lqBpsnEprVDM90uMkazaNoWfufhYKZ358TK9vavsTmwMwVBQLYoCjuGPbGsnlMA\"><picture><source media=\"(prefers-color-scheme: dark)\" srcset=\"https://cursor.com/fix-in-web-dark.svg\"><source media=\"(prefers-color-scheme: light)\" srcset=\"https://cursor.com/fix-in-web-light.svg\"><img alt=\"Fix in Web\" src=\"https://cursor.com/fix-in-web.svg\"></picture></a>\n\n","created_at":"2025-11-12T21:13:45Z","updated_at":"2025-11-12T21:13:45Z","html_url":"https://github.com/temporalio/temporal/pull/8563#discussion_r2519839302","pull_request_url":"https://api.github.com/repos/temporalio/temporal/pulls/8563","_links":{"self":{"href":"https://api.github.com/repos/temporalio/temporal/pulls/comments/2519839302"},"html":{"href":"https://github.com/temporalio/temporal/pull/8563#discussion_r2519839302"},"pull_request":{"href":"https://api.github.com/repos/temporalio/temporal/pulls/8563"}},"reactions":{"url":"https://api.github.com/repos/temporalio/temporal/pulls/comments/2519839302/reactions","total_count":0,"+1":0,"-1":0,"laugh":0,"hooray":0,"confused":0,"heart":0,"rocket":0,"eyes":0},"start_line":null,"original_start_line":null,"start_side":null,"line":315,"original_line":207,"side":"RIGHT","author_association":"NONE","original_position":135,"position":299,"subject_type":"line"},{"url":"https://api.github.com/repos/temporalio/temporal/pulls/comments/2519914516","pull_request_review_id":3454066296,"id":2519914516,"node_id":"PRRC_kwDODNqesM6WMtgU","diff_hunk":"@@ -241,14 +280,159 @@ func (e *ChasmEngine) ReadComponent(\n \treturn readFn(chasmContext, component)\n }\n \n+// PollComponent waits until the supplied predicate is satisfied when evaluated against the\n+// component identified by the supplied component reference. It returns a component reference\n+// identifying the state at which the predicate was satisfied. An error is returned if entity\n+// transition history is (after reloading from persistence) behind the requested ref, or if the ref\n+// is not interpretable as part of the entity transition history. Thus when the predicate function\n+// is evaluated, it is guaranteed that the entity VT >= requestRef VT.\n func (e *ChasmEngine) PollComponent(\n \tctx context.Context,\n-\tentityRef chasm.ComponentRef,\n-\tpredicateFn func(chasm.Context, chasm.Component) (any, bool, error),\n-\toperationFn func(chasm.MutableContext, chasm.Component, any) error,\n+\trequestRef chasm.ComponentRef,\n+\tpredicateFn func(chasm.Context, chasm.Component) (bool, error),\n \topts ...chasm.TransitionOption,\n-) (newEntityRef []byte, retError error) {\n-\treturn nil, serviceerror.NewUnimplemented(\"PollComponent is not yet supported\")\n+) ([]byte, error) {\n+\t// 1. Acquire lock\n+\t// 2. Error if shard entity VT < requestRef VT ('stale state')\n+\t// 3. If predicate satisfied, release lock and return\n+\t// 4. Subscribe to notifications for this entity\n+\t// 5. Release lock\n+\t// 6. On notification repeat (1) and (2)\n+\n+\tshardContext, executionLease, err := e.getExecutionLease(ctx, requestRef)\n+\tif err != nil {\n+\t\t// E.g. requestRef VT inconsistent with shard VT ('stale reference')\n+\t\treturn nil, err\n+\t}\n+\n+\t// hold lock until return or subscription established\n+\treleased := false\n+\tdefer func() {\n+\t\tif !released {\n+\t\t\t// read-only operation; don't pass error\n+\t\t\texecutionLease.GetReleaseFn()(nil)\n+\t\t}\n+\t}()\n+\n+\t// At this point it's possible that shard VT < requestRef VT (getExecutionLease does not\n+\t// guarantee that returned shard state is non-stale w.r.t. requestRef).\n+\tcurrentRef, err := e.checkPredicate(ctx, requestRef, executionLease, predicateFn)\n+\tif err != nil {\n+\t\treturn nil, err\n+\t}\n+\t// shard VT >= requestRef VT (enforced by checkPredicate)\n+\n+\tif currentRef != nil {\n+\t\t// wait condition was satisfied\n+\t\treturn currentRef, nil\n+\t}\n+\n+\t// Wait condition not satisfied; long-poll\n+\n+\tchannel, subscriberID, err := e.notifier.Subscribe(requestRef.EntityKey)\n+\tif err != nil {\n+\t\treturn nil, err\n+\t}\n+\tdefer func() {\n+\t\t_ = e.notifier.Unsubscribe(requestRef.EntityKey, subscriberID)\n+\t}()\n+\n+\t// Release the lock, now that we are subscribed\n+\texecutionLease.GetReleaseFn()(nil)\n+\treleased = true\n+\n+\tnamespaceRegistry, err := shardContext.GetNamespaceRegistry().GetNamespaceByID(\n+\t\tnamespace.ID(requestRef.EntityKey.NamespaceID),\n+\t)\n+\tif err != nil {\n+\t\treturn nil, err\n+\t}\n+\n+\t// TODO(dan): check desired timeout logic here\n+\tctx, cancel := contextutil.WithDeadlineBuffer(\n+\t\tctx,\n+\t\tshardContext.GetConfig().LongPollExpirationInterval(namespaceRegistry.Name().String()),\n+\t\ttime.Second,\n+\t)\n+\tdefer cancel()\n+\n+\tfor {\n+\t\tselect {\n+\t\tcase notification := <-channel:\n+\t\t\tif notification == nil {\n+\t\t\t\treturn nil, serviceerror.NewInternal(\"nil component notification\")\n+\t\t\t}\n+\t\t\t// Received a notification. Re-acquire the lock and check the predicate.\n+\t\t\t_, executionLease, err := e.getExecutionLease(ctx, requestRef)\n+\t\t\tif err != nil {\n+\t\t\t\treturn nil, err\n+\t\t\t}\n+\n+\t\t\tnewRef, err := e.checkPredicate(ctx, requestRef, executionLease, predicateFn)\n+\t\t\texecutionLease.GetReleaseFn()(nil)\n+\t\t\tif err != nil {\n+\t\t\t\treturn nil, err\n+\t\t\t}\n+\t\t\tif newRef != nil {\n+\t\t\t\t// wait condition was satisfied\n+\t\t\t\treturn newRef, nil\n+\t\t\t}","path":"service/history/chasm_engine.go","commit_id":"da6009564e796063faf853352077eecdc1473612","original_commit_id":"28665bbdf70db031950bf4cf81f5c4f30f518b42","user":{"login":"dandavison","id":52205,"node_id":"MDQ6VXNlcjUyMjA1","avatar_url":"https://avatars.githubusercontent.com/u/52205?v=4","gravatar_id":"","url":"https://api.github.com/users/dandavison","html_url":"https://github.com/dandavison","followers_url":"https://api.github.com/users/dandavison/followers","following_url":"https://api.github.com/users/dandavison/following{/other_user}","gists_url":"https://api.github.com/users/dandavison/gists{/gist_id}","starred_url":"https://api.github.com/users/dandavison/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/dandavison/subscriptions","organizations_url":"https://api.github.com/users/dandavison/orgs","repos_url":"https://api.github.com/users/dandavison/repos","events_url":"https://api.github.com/users/dandavison/events{/privacy}","received_events_url":"https://api.github.com/users/dandavison/received_events","type":"User","user_view_type":"public","site_admin":false},"body":"These claims aren't valid. We don't want to hold subscriptions open across retries and at line 377 the predicate is satisfied.","created_at":"2025-11-12T21:46:22Z","updated_at":"2025-11-12T21:52:35Z","html_url":"https://github.com/temporalio/temporal/pull/8563#discussion_r2519914516","pull_request_url":"https://api.github.com/repos/temporalio/temporal/pulls/8563","_links":{"self":{"href":"https://api.github.com/repos/temporalio/temporal/pulls/comments/2519914516"},"html":{"href":"https://github.com/temporalio/temporal/pull/8563#discussion_r2519914516"},"pull_request":{"href":"https://api.github.com/repos/temporalio/temporal/pulls/8563"}},"reactions":{"url":"https://api.github.com/repos/temporalio/temporal/pulls/comments/2519914516/reactions","total_count":0,"+1":0,"-1":0,"laugh":0,"hooray":0,"confused":0,"heart":0,"rocket":0,"eyes":0},"start_line":null,"original_start_line":null,"start_side":null,"line":323,"original_line":379,"side":"RIGHT","in_reply_to_id":2519658327,"author_association":"MEMBER","original_position":212,"position":1,"subject_type":"line"},{"url":"https://api.github.com/repos/temporalio/temporal/pulls/comments/2520018342","pull_request_review_id":3455788347,"id":2520018342,"node_id":"PRRC_kwDODNqesM6WNG2m","diff_hunk":"@@ -314,3 +314,124 @@ func (a *Activity) RecordHeartbeat(ctx chasm.MutableContext, details *commonpb.P\n \t})\n \treturn nil, nil\n }\n+\n+func (a *Activity) buildActivityExecutionInfo(ctx chasm.Context, key chasm.EntityKey) (*activity.ActivityExecutionInfo, error) {\n+\tif a.ActivityState == nil {\n+\t\treturn nil, errors.New(\"activity state is nil\")\n+\t}\n+\n+\t// TODO(dan): support pause states\n+\tvar status enumspb.ActivityExecutionStatus\n+\tvar runState enumspb.PendingActivityState\n+\tswitch a.GetStatus() {","path":"chasm/lib/activity/activity.go","commit_id":"1d59e66d0ce5d91819f92c428ef5ab4c4efca1fb","original_commit_id":"a1b89b2df945362cc0235d9a826c6646855b3d6f","user":{"login":"fretz12","id":41805201,"node_id":"MDQ6VXNlcjQxODA1MjAx","avatar_url":"https://avatars.githubusercontent.com/u/41805201?v=4","gravatar_id":"","url":"https://api.github.com/users/fretz12","html_url":"https://github.com/fretz12","followers_url":"https://api.github.com/users/fretz12/followers","following_url":"https://api.github.com/users/fretz12/following{/other_user}","gists_url":"https://api.github.com/users/fretz12/gists{/gist_id}","starred_url":"https://api.github.com/users/fretz12/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/fretz12/subscriptions","organizations_url":"https://api.github.com/users/fretz12/orgs","repos_url":"https://api.github.com/users/fretz12/repos","events_url":"https://api.github.com/users/fretz12/events{/privacy}","received_events_url":"https://api.github.com/users/fretz12/received_events","type":"User","user_view_type":"public","site_admin":false},"body":"I think you handled all the statuses but it will be good practice to handle the default case with an error.","created_at":"2025-11-12T22:33:28Z","updated_at":"2025-11-13T00:18:10Z","html_url":"https://github.com/temporalio/temporal/pull/8563#discussion_r2520018342","pull_request_url":"https://api.github.com/repos/temporalio/temporal/pulls/8563","_links":{"self":{"href":"https://api.github.com/repos/temporalio/temporal/pulls/comments/2520018342"},"html":{"href":"https://github.com/temporalio/temporal/pull/8563#discussion_r2520018342"},"pull_request":{"href":"https://api.github.com/repos/temporalio/temporal/pulls/8563"}},"reactions":{"url":"https://api.github.com/repos/temporalio/temporal/pulls/comments/2520018342/reactions","total_count":0,"+1":0,"-1":0,"laugh":0,"hooray":0,"confused":0,"heart":0,"rocket":0,"eyes":0},"start_line":null,"original_start_line":null,"start_side":null,"line":322,"original_line":326,"side":"RIGHT","author_association":"MEMBER","original_position":41,"position":38,"subject_type":"line"},{"url":"https://api.github.com/repos/temporalio/temporal/pulls/comments/2520056230","pull_request_review_id":3455788347,"id":2520056230,"node_id":"PRRC_kwDODNqesM6WNQGm","diff_hunk":"@@ -314,3 +314,124 @@ func (a *Activity) RecordHeartbeat(ctx chasm.MutableContext, details *commonpb.P\n \t})\n \treturn nil, nil\n }\n+\n+func (a *Activity) buildActivityExecutionInfo(ctx chasm.Context, key chasm.EntityKey) (*activity.ActivityExecutionInfo, error) {\n+\tif a.ActivityState == nil {\n+\t\treturn nil, errors.New(\"activity state is nil\")\n+\t}\n+\n+\t// TODO(dan): support pause states\n+\tvar status enumspb.ActivityExecutionStatus\n+\tvar runState enumspb.PendingActivityState\n+\tswitch a.GetStatus() {\n+\tcase activitypb.ACTIVITY_EXECUTION_STATUS_UNSPECIFIED:\n+\t\tstatus = enumspb.ACTIVITY_EXECUTION_STATUS_UNSPECIFIED\n+\t\trunState = enumspb.PENDING_ACTIVITY_STATE_UNSPECIFIED\n+\tcase activitypb.ACTIVITY_EXECUTION_STATUS_SCHEDULED:\n+\t\tstatus = enumspb.ACTIVITY_EXECUTION_STATUS_RUNNING\n+\t\trunState = enumspb.PENDING_ACTIVITY_STATE_SCHEDULED\n+\tcase activitypb.ACTIVITY_EXECUTION_STATUS_STARTED:\n+\t\tstatus = enumspb.ACTIVITY_EXECUTION_STATUS_RUNNING\n+\t\trunState = enumspb.PENDING_ACTIVITY_STATE_STARTED\n+\tcase activitypb.ACTIVITY_EXECUTION_STATUS_CANCEL_REQUESTED:\n+\t\tstatus = enumspb.ACTIVITY_EXECUTION_STATUS_RUNNING\n+\t\trunState = enumspb.PENDING_ACTIVITY_STATE_CANCEL_REQUESTED\n+\tcase activitypb.ACTIVITY_EXECUTION_STATUS_COMPLETED:\n+\t\tstatus = enumspb.ACTIVITY_EXECUTION_STATUS_COMPLETED\n+\t\trunState = enumspb.PENDING_ACTIVITY_STATE_UNSPECIFIED\n+\tcase activitypb.ACTIVITY_EXECUTION_STATUS_FAILED:\n+\t\tstatus = enumspb.ACTIVITY_EXECUTION_STATUS_FAILED\n+\t\trunState = enumspb.PENDING_ACTIVITY_STATE_UNSPECIFIED\n+\tcase activitypb.ACTIVITY_EXECUTION_STATUS_CANCELED:\n+\t\tstatus = enumspb.ACTIVITY_EXECUTION_STATUS_CANCELED\n+\t\trunState = enumspb.PENDING_ACTIVITY_STATE_UNSPECIFIED\n+\tcase activitypb.ACTIVITY_EXECUTION_STATUS_TERMINATED:\n+\t\tstatus = enumspb.ACTIVITY_EXECUTION_STATUS_TERMINATED\n+\t\trunState = enumspb.PENDING_ACTIVITY_STATE_UNSPECIFIED\n+\tcase activitypb.ACTIVITY_EXECUTION_STATUS_TIMED_OUT:\n+\t\tstatus = enumspb.ACTIVITY_EXECUTION_STATUS_TIMED_OUT\n+\t\trunState = enumspb.PENDING_ACTIVITY_STATE_UNSPECIFIED\n+\t}\n+\n+\trequestData, err := a.RequestData.Get(ctx)\n+\tif err != nil {\n+\t\treturn nil, err\n+\t}\n+\n+\tinfo := &activity.ActivityExecutionInfo{\n+\t\tActivityId:    key.BusinessID,\n+\t\tRunId:         key.EntityID,\n+\t\tActivityType:  a.GetActivityType(),\n+\t\tStatus:        status,\n+\t\tRunState:      runState,\n+\t\tScheduledTime: a.GetScheduledTime(),\n+\t\tPriority:      a.GetPriority(),\n+\t\tHeader:        requestData.GetHeader(),\n+\t\t// TODO(dan): populate remaining fields\n+\t}\n+\n+\treturn info, nil\n+}\n+\n+func (a *Activity) buildPollActivityExecutionResponse(\n+\tctx chasm.Context,\n+\treq *activitypb.PollActivityExecutionRequest,\n+) (*activitypb.PollActivityExecutionResponse, error) {\n+\tvar err error","path":"chasm/lib/activity/activity.go","commit_id":"f8ccafbb3c10a723c3180b7c0da6caee9ff4f073","original_commit_id":"a1b89b2df945362cc0235d9a826c6646855b3d6f","user":{"login":"fretz12","id":41805201,"node_id":"MDQ6VXNlcjQxODA1MjAx","avatar_url":"https://avatars.githubusercontent.com/u/41805201?v=4","gravatar_id":"","url":"https://api.github.com/users/fretz12","html_url":"https://github.com/fretz12","followers_url":"https://api.github.com/users/fretz12/followers","following_url":"https://api.github.com/users/fretz12/following{/other_user}","gists_url":"https://api.github.com/users/fretz12/gists{/gist_id}","starred_url":"https://api.github.com/users/fretz12/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/fretz12/subscriptions","organizations_url":"https://api.github.com/users/fretz12/orgs","repos_url":"https://api.github.com/users/fretz12/repos","events_url":"https://api.github.com/users/fretz12/events{/privacy}","received_events_url":"https://api.github.com/users/fretz12/received_events","type":"User","user_view_type":"public","site_admin":false},"body":"separate declaration not required","created_at":"2025-11-12T22:52:07Z","updated_at":"2025-11-13T00:18:10Z","html_url":"https://github.com/temporalio/temporal/pull/8563#discussion_r2520056230","pull_request_url":"https://api.github.com/repos/temporalio/temporal/pulls/8563","_links":{"self":{"href":"https://api.github.com/repos/temporalio/temporal/pulls/comments/2520056230"},"html":{"href":"https://github.com/temporalio/temporal/pull/8563#discussion_r2520056230"},"pull_request":{"href":"https://api.github.com/repos/temporalio/temporal/pulls/8563"}},"reactions":{"url":"https://api.github.com/repos/temporalio/temporal/pulls/comments/2520056230/reactions","total_count":0,"+1":0,"-1":0,"laugh":0,"hooray":0,"confused":0,"heart":0,"rocket":0,"eyes":0},"start_line":null,"original_start_line":null,"start_side":null,"line":null,"original_line":380,"side":"RIGHT","author_association":"MEMBER","original_position":95,"position":1,"subject_type":"line"},{"url":"https://api.github.com/repos/temporalio/temporal/pulls/comments/2520083941","pull_request_review_id":3455788347,"id":2520083941,"node_id":"PRRC_kwDODNqesM6WNW3l","diff_hunk":"@@ -51,3 +53,177 @@ func (h *handler) StartActivityExecution(ctx context.Context, req *activitypb.St\n \t\tFrontendResponse: response,\n \t}, nil\n }\n+\n+// PollActivityExecution handles PollActivityExecutionRequest from frontend. This method supports\n+// querying current activity state, optionally as a long-poll that waits for certain state changes.\n+// It is used by clients to poll for activity state and/or result.\n+func (h *handler) PollActivityExecution(\n+\tctx context.Context,\n+\treq *activitypb.PollActivityExecutionRequest,\n+) (*activitypb.PollActivityExecutionResponse, error) {\n+\n+\twaitPolicy := req.GetFrontendRequest().GetWaitPolicy()\n+\tif waitPolicy == nil {\n+\t\treturn chasm.ReadComponent(\n+\t\t\tctx,\n+\t\t\tchasm.NewComponentRef[*Activity](chasm.EntityKey{\n+\t\t\t\tNamespaceID: req.GetNamespaceId(),\n+\t\t\t\tBusinessID:  req.GetFrontendRequest().GetActivityId(),\n+\t\t\t\tEntityID:    req.GetFrontendRequest().GetRunId(),\n+\t\t\t}),\n+\t\t\t(*Activity).buildPollActivityExecutionResponse,\n+\t\t\treq,\n+\t\t\tnil,\n+\t\t)\n+\t}\n+\n+\tvar response *activitypb.PollActivityExecutionResponse\n+\tvar newRef []byte\n+\tvar err error\n+\n+\tswitch waitPolicy.(type) {\n+\tcase *workflowservice.PollActivityExecutionRequest_WaitAnyStateChange:\n+\t\tresponse, newRef, err = pollActivityExecutionWaitAnyStateChange(ctx, req)\n+\tcase *workflowservice.PollActivityExecutionRequest_WaitCompletion:\n+\t\tresponse, newRef, err = pollActivityExecutionWaitCompletion(ctx, req)\n+\tdefault:\n+\t\treturn nil, fmt.Errorf(\"unexpected wait policy type: %T\", waitPolicy)\n+\t}\n+\tif err != nil {\n+\t\treturn nil, err\n+\t}\n+\tresponse.GetFrontendResponse().StateChangeLongPollToken = newRef","path":"chasm/lib/activity/handler.go","commit_id":"f8ccafbb3c10a723c3180b7c0da6caee9ff4f073","original_commit_id":"a1b89b2df945362cc0235d9a826c6646855b3d6f","user":{"login":"fretz12","id":41805201,"node_id":"MDQ6VXNlcjQxODA1MjAx","avatar_url":"https://avatars.githubusercontent.com/u/41805201?v=4","gravatar_id":"","url":"https://api.github.com/users/fretz12","html_url":"https://github.com/fretz12","followers_url":"https://api.github.com/users/fretz12/followers","following_url":"https://api.github.com/users/fretz12/following{/other_user}","gists_url":"https://api.github.com/users/fretz12/gists{/gist_id}","starred_url":"https://api.github.com/users/fretz12/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/fretz12/subscriptions","organizations_url":"https://api.github.com/users/fretz12/orgs","repos_url":"https://api.github.com/users/fretz12/repos","events_url":"https://api.github.com/users/fretz12/events{/privacy}","received_events_url":"https://api.github.com/users/fretz12/received_events","type":"User","user_view_type":"public","site_admin":false},"body":"why not populate this inside the poll funcs?","created_at":"2025-11-12T23:07:05Z","updated_at":"2025-11-13T00:18:10Z","html_url":"https://github.com/temporalio/temporal/pull/8563#discussion_r2520083941","pull_request_url":"https://api.github.com/repos/temporalio/temporal/pulls/8563","_links":{"self":{"href":"https://api.github.com/repos/temporalio/temporal/pulls/comments/2520083941"},"html":{"href":"https://github.com/temporalio/temporal/pull/8563#discussion_r2520083941"},"pull_request":{"href":"https://api.github.com/repos/temporalio/temporal/pulls/8563"}},"reactions":{"url":"https://api.github.com/repos/temporalio/temporal/pulls/comments/2520083941/reactions","total_count":0,"+1":0,"-1":0,"laugh":0,"hooray":0,"confused":0,"heart":0,"rocket":0,"eyes":0},"start_line":null,"original_start_line":null,"start_side":null,"line":null,"original_line":95,"side":"RIGHT","author_association":"MEMBER","original_position":53,"position":1,"subject_type":"line"},{"url":"https://api.github.com/repos/temporalio/temporal/pulls/comments/2520106683","pull_request_review_id":3455917565,"id":2520106683,"node_id":"PRRC_kwDODNqesM6WNca7","diff_hunk":"@@ -241,14 +280,159 @@ func (e *ChasmEngine) ReadComponent(\n \treturn readFn(chasmContext, component)\n }\n \n+// PollComponent waits until the supplied predicate is satisfied when evaluated against the\n+// component identified by the supplied component reference. It returns a component reference\n+// identifying the state at which the predicate was satisfied. An error is returned if entity\n+// transition history is (after reloading from persistence) behind the requested ref, or if the ref\n+// is not interpretable as part of the entity transition history. Thus when the predicate function\n+// is evaluated, it is guaranteed that the entity VT >= requestRef VT.\n func (e *ChasmEngine) PollComponent(\n \tctx context.Context,\n-\tentityRef chasm.ComponentRef,\n-\tpredicateFn func(chasm.Context, chasm.Component) (any, bool, error),\n-\toperationFn func(chasm.MutableContext, chasm.Component, any) error,\n+\trequestRef chasm.ComponentRef,\n+\tpredicateFn func(chasm.Context, chasm.Component) (bool, error),\n \topts ...chasm.TransitionOption,\n-) (newEntityRef []byte, retError error) {\n-\treturn nil, serviceerror.NewUnimplemented(\"PollComponent is not yet supported\")\n+) ([]byte, error) {\n+\t// 1. Acquire lock\n+\t// 2. Error if shard entity VT < requestRef VT ('stale state')\n+\t// 3. If predicate satisfied, release lock and return\n+\t// 4. Subscribe to notifications for this entity\n+\t// 5. Release lock\n+\t// 6. On notification repeat (1) and (2)\n+\n+\tshardContext, executionLease, err := e.getExecutionLease(ctx, requestRef)\n+\tif err != nil {\n+\t\t// E.g. requestRef VT inconsistent with shard VT ('stale reference')\n+\t\treturn nil, err\n+\t}\n+\n+\t// hold lock until return or subscription established\n+\treleased := false\n+\tdefer func() {\n+\t\tif !released {\n+\t\t\t// read-only operation; don't pass error\n+\t\t\texecutionLease.GetReleaseFn()(nil)\n+\t\t}\n+\t}()\n+\n+\t// At this point it's possible that shard VT < requestRef VT (getExecutionLease does not\n+\t// guarantee that returned shard state is non-stale w.r.t. requestRef).\n+\tcurrentRef, err := e.checkPredicate(ctx, requestRef, executionLease, predicateFn)\n+\tif err != nil {\n+\t\treturn nil, err\n+\t}\n+\t// shard VT >= requestRef VT (enforced by checkPredicate)\n+\n+\tif currentRef != nil {\n+\t\t// wait condition was satisfied\n+\t\treturn currentRef, nil\n+\t}\n+\n+\t// Wait condition not satisfied; long-poll\n+\n+\tchannel, subscriberID, err := e.notifier.Subscribe(requestRef.EntityKey)\n+\tif err != nil {\n+\t\treturn nil, err\n+\t}\n+\tdefer func() {\n+\t\t_ = e.notifier.Unsubscribe(requestRef.EntityKey, subscriberID)\n+\t}()\n+\n+\t// Release the lock, now that we are subscribed\n+\texecutionLease.GetReleaseFn()(nil)\n+\treleased = true\n+\n+\tnamespaceRegistry, err := shardContext.GetNamespaceRegistry().GetNamespaceByID(\n+\t\tnamespace.ID(requestRef.EntityKey.NamespaceID),\n+\t)\n+\tif err != nil {\n+\t\treturn nil, err\n+\t}\n+\n+\t// TODO(dan): check desired timeout logic here\n+\tctx, cancel := contextutil.WithDeadlineBuffer(\n+\t\tctx,\n+\t\tshardContext.GetConfig().LongPollExpirationInterval(namespaceRegistry.Name().String()),\n+\t\ttime.Second,\n+\t)\n+\tdefer cancel()\n+\n+\tfor {\n+\t\tselect {\n+\t\tcase notification := <-channel:\n+\t\t\tif notification == nil {\n+\t\t\t\treturn nil, serviceerror.NewInternal(\"nil component notification\")\n+\t\t\t}\n+\t\t\t// Received a notification. Re-acquire the lock and check the predicate.\n+\t\t\t_, executionLease, err := e.getExecutionLease(ctx, requestRef)\n+\t\t\tif err != nil {\n+\t\t\t\treturn nil, err\n+\t\t\t}\n+\n+\t\t\tnewRef, err := e.checkPredicate(ctx, requestRef, executionLease, predicateFn)\n+\t\t\texecutionLease.GetReleaseFn()(nil)\n+\t\t\tif err != nil {\n+\t\t\t\treturn nil, err\n+\t\t\t}\n+\t\t\tif newRef != nil {\n+\t\t\t\t// wait condition was satisfied\n+\t\t\t\treturn newRef, nil\n+\t\t\t}","path":"service/history/chasm_engine.go","commit_id":"da6009564e796063faf853352077eecdc1473612","original_commit_id":"f8ccafbb3c10a723c3180b7c0da6caee9ff4f073","user":{"login":"cursor[bot]","id":206951365,"node_id":"BOT_kgDODFXTxQ","avatar_url":"https://avatars.githubusercontent.com/in/1210556?v=4","gravatar_id":"","url":"https://api.github.com/users/cursor%5Bbot%5D","html_url":"https://github.com/apps/cursor","followers_url":"https://api.github.com/users/cursor%5Bbot%5D/followers","following_url":"https://api.github.com/users/cursor%5Bbot%5D/following{/other_user}","gists_url":"https://api.github.com/users/cursor%5Bbot%5D/gists{/gist_id}","starred_url":"https://api.github.com/users/cursor%5Bbot%5D/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/cursor%5Bbot%5D/subscriptions","organizations_url":"https://api.github.com/users/cursor%5Bbot%5D/orgs","repos_url":"https://api.github.com/users/cursor%5Bbot%5D/repos","events_url":"https://api.github.com/users/cursor%5Bbot%5D/events{/privacy}","received_events_url":"https://api.github.com/users/cursor%5Bbot%5D/received_events","type":"Bot","user_view_type":"public","site_admin":false},"body":"### Bug: Lock Leak: Workflow Stuck on Error\n\n<!-- **High Severity** -->\n\n<!-- DESCRIPTION START -->\nLock leak in `PollComponent` when `getExecutionLease` fails in the notification loop. After the initial lock is released at line 341, subsequent calls to `getExecutionLease` at line 366 acquire a new lock. If this call fails with an error, the function returns immediately at line 368 without releasing the lock. The error path bypasses the `executionLease.GetReleaseFn()(nil)` call at line 372, causing the workflow lock to remain held indefinitely.\n<!-- DESCRIPTION END -->\n\n<!-- LOCATIONS START\nservice/history/chasm_engine.go#L365-L379\nLOCATIONS END -->\n<a href=\"https://cursor.com/open?data=eyJhbGciOiJSUzI1NiIsInR5cCI6IkpXVCIsImtpZCI6ImJ1Z2JvdC12MSJ9.eyJ2ZXJzaW9uIjoxLCJ0eXBlIjoiQlVHQk9UX0ZJWF9JTl9DVVJTT1IiLCJkYXRhIjp7InJlZGlzS2V5IjoiYnVnYm90OmNmMzE1YzYwLTIzMzEtNGYxNi05N2ZkLTMxMWMwMDRjYTliZSIsImVuY3J5cHRpb25LZXkiOiI0M3docVNZU0h5YlNEVkVKbjVPOUdJYVdoR3JuMUVJNEpiRFIwNExHVVBnIiwiYnJhbmNoIjoicG9sbC1jb21wb25lbnQifSwiaWF0IjoxNzYyOTg5Mzg1LCJleHAiOjE3NjM1OTQxODV9.Y8S2KivpsA21mMBnEaebiz8dFxDMAgs-HgHdV03ush1Bhrreb7ZbeoNyWkwiHsx1cDdrNsndchdbdHJNupSiQ1xfabAoIj0Mbjm7ZG4_dARMvX5yJFyLpLJu6jOTkiLjG4SwBrF6vGSuCH5G1FG3huS6sXpF2hLuewlkCU_BRSkjWkl1I_2Gp7SJBaXkGyTOCM1UaIpKExJazhClMs_SOBUx44oBGPehi955VyvO2YoqZUd4o9ss3esQugukvGtTrWMpMKPf3lcLIcTN6yqRkFdolQm26u0EA9JY4nNxPYawJ20B0DmdnCn_rgdaCr-qljzTN7CWf4EV7yGMBrQ8lw\"><picture><source media=\"(prefers-color-scheme: dark)\" srcset=\"https://cursor.com/fix-in-cursor-dark.svg\"><source media=\"(prefers-color-scheme: light)\" srcset=\"https://cursor.com/fix-in-cursor-light.svg\"><img alt=\"Fix in Cursor\" src=\"https://cursor.com/fix-in-cursor.svg\"></picture></a>&nbsp;<a href=\"https://cursor.com/agents?data=eyJhbGciOiJSUzI1NiIsInR5cCI6IkpXVCIsImtpZCI6ImJ1Z2JvdC12MSJ9.eyJ2ZXJzaW9uIjoxLCJ0eXBlIjoiQlVHQk9UX0ZJWF9JTl9XRUIiLCJkYXRhIjp7InJlZGlzS2V5IjoiYnVnYm90OmNmMzE1YzYwLTIzMzEtNGYxNi05N2ZkLTMxMWMwMDRjYTliZSIsImVuY3J5cHRpb25LZXkiOiI0M3docVNZU0h5YlNEVkVKbjVPOUdJYVdoR3JuMUVJNEpiRFIwNExHVVBnIiwiYnJhbmNoIjoicG9sbC1jb21wb25lbnQiLCJyZXBvT3duZXIiOiJ0ZW1wb3JhbGlvIiwicmVwb05hbWUiOiJ0ZW1wb3JhbCIsInByTnVtYmVyIjo4NTYzLCJjb21taXRTaGEiOiJmOGNjYWZiYjNjMTBhNzIzYzMxODBiN2MwZGE2Y2FlZTlmZjRmMDczIn0sImlhdCI6MTc2Mjk4OTM4NSwiZXhwIjoxNzYzNTk0MTg1fQ.Bkl5wagrNRHbv3OBkrXLy3vUohU0gcipBmoObq-OhOzI7Wev9InoA6R13oDjULJt1ZAAQlnRgA3ft6y7px4LctXvz3tZeqtB2U5Z-O_41mm7jXH9i_TUHA-5e_lRSn9f5S6qLlbj9s6LXd6Wyb21Nk9mKv4uodipgdP3Q2PV0b4Xzcrms06bFOoK_7lW5etWNrQd7AJDvFHnxSHcbNE9XFtiNtJ9MDbo8qS0Y4tCTUiPneEyJywULK7SRJ9AaXW6mjigeLf-GUZu-JrtgOo-u6MDk3H8Yd1l-5rd8nRcRD4GP7XZ6UWLx0Tdj2XfbBojTXG0Cj-KsrP6QXsxgE-hGA\"><picture><source media=\"(prefers-color-scheme: dark)\" srcset=\"https://cursor.com/fix-in-web-dark.svg\"><source media=\"(prefers-color-scheme: light)\" srcset=\"https://cursor.com/fix-in-web-light.svg\"><img alt=\"Fix in Web\" src=\"https://cursor.com/fix-in-web.svg\"></picture></a>\n\n","created_at":"2025-11-12T23:16:25Z","updated_at":"2025-11-12T23:16:25Z","html_url":"https://github.com/temporalio/temporal/pull/8563#discussion_r2520106683","pull_request_url":"https://api.github.com/repos/temporalio/temporal/pulls/8563","_links":{"self":{"href":"https://api.github.com/repos/temporalio/temporal/pulls/comments/2520106683"},"html":{"href":"https://github.com/temporalio/temporal/pull/8563#discussion_r2520106683"},"pull_request":{"href":"https://api.github.com/repos/temporalio/temporal/pulls/8563"}},"reactions":{"url":"https://api.github.com/repos/temporalio/temporal/pulls/comments/2520106683/reactions","total_count":1,"+1":0,"-1":1,"laugh":0,"hooray":0,"confused":0,"heart":0,"rocket":0,"eyes":0},"start_line":null,"original_start_line":null,"start_side":null,"line":323,"original_line":379,"side":"RIGHT","author_association":"NONE","original_position":212,"position":1,"subject_type":"line"},{"url":"https://api.github.com/repos/temporalio/temporal/pulls/comments/2520108689","pull_request_review_id":3455788347,"id":2520108689,"node_id":"PRRC_kwDODNqesM6WNc6R","diff_hunk":"@@ -51,3 +53,177 @@ func (h *handler) StartActivityExecution(ctx context.Context, req *activitypb.St\n \t\tFrontendResponse: response,\n \t}, nil\n }\n+\n+// PollActivityExecution handles PollActivityExecutionRequest from frontend. This method supports\n+// querying current activity state, optionally as a long-poll that waits for certain state changes.\n+// It is used by clients to poll for activity state and/or result.\n+func (h *handler) PollActivityExecution(\n+\tctx context.Context,\n+\treq *activitypb.PollActivityExecutionRequest,\n+) (*activitypb.PollActivityExecutionResponse, error) {\n+\n+\twaitPolicy := req.GetFrontendRequest().GetWaitPolicy()\n+\tif waitPolicy == nil {\n+\t\treturn chasm.ReadComponent(\n+\t\t\tctx,\n+\t\t\tchasm.NewComponentRef[*Activity](chasm.EntityKey{\n+\t\t\t\tNamespaceID: req.GetNamespaceId(),\n+\t\t\t\tBusinessID:  req.GetFrontendRequest().GetActivityId(),\n+\t\t\t\tEntityID:    req.GetFrontendRequest().GetRunId(),\n+\t\t\t}),\n+\t\t\t(*Activity).buildPollActivityExecutionResponse,\n+\t\t\treq,\n+\t\t\tnil,\n+\t\t)\n+\t}\n+\n+\tvar response *activitypb.PollActivityExecutionResponse\n+\tvar newRef []byte\n+\tvar err error\n+\n+\tswitch waitPolicy.(type) {\n+\tcase *workflowservice.PollActivityExecutionRequest_WaitAnyStateChange:\n+\t\tresponse, newRef, err = pollActivityExecutionWaitAnyStateChange(ctx, req)\n+\tcase *workflowservice.PollActivityExecutionRequest_WaitCompletion:\n+\t\tresponse, newRef, err = pollActivityExecutionWaitCompletion(ctx, req)\n+\tdefault:\n+\t\treturn nil, fmt.Errorf(\"unexpected wait policy type: %T\", waitPolicy)\n+\t}\n+\tif err != nil {\n+\t\treturn nil, err\n+\t}\n+\tresponse.GetFrontendResponse().StateChangeLongPollToken = newRef\n+\treturn response, nil\n+}\n+\n+// pollActivityExecutionWaitAnyStateChange waits until the activity state has advanced beyond that\n+// specified by the submitted token. If no token was submitted, it returns the current state without\n+// waiting.\n+func pollActivityExecutionWaitAnyStateChange(\n+\tctx context.Context,\n+\treq *activitypb.PollActivityExecutionRequest,\n+) (*activitypb.PollActivityExecutionResponse, []byte, error) {\n+\n+\t// TODO(dan): do we want to guarantee that response data will differ from that received when the\n+\t// token was obtained? It's potentially confusing for the server to say \"there's been a change\"\n+\t// while returning data in which the change is not apparent.\n+\n+\trefBytesFromToken := req.GetFrontendRequest().\n+\t\tGetWaitPolicy().(*workflowservice.PollActivityExecutionRequest_WaitAnyStateChange).\n+\t\tWaitAnyStateChange.GetLongPollToken()\n+\n+\tvar lastSeenRef chasm.ComponentRef\n+\tif refBytesFromToken != nil {","path":"chasm/lib/activity/handler.go","commit_id":"c88896985ee8b4a5cd9c508293e4431293e28fde","original_commit_id":"f8ccafbb3c10a723c3180b7c0da6caee9ff4f073","user":{"login":"fretz12","id":41805201,"node_id":"MDQ6VXNlcjQxODA1MjAx","avatar_url":"https://avatars.githubusercontent.com/u/41805201?v=4","gravatar_id":"","url":"https://api.github.com/users/fretz12","html_url":"https://github.com/fretz12","followers_url":"https://api.github.com/users/fretz12/followers","following_url":"https://api.github.com/users/fretz12/following{/other_user}","gists_url":"https://api.github.com/users/fretz12/gists{/gist_id}","starred_url":"https://api.github.com/users/fretz12/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/fretz12/subscriptions","organizations_url":"https://api.github.com/users/fretz12/orgs","repos_url":"https://api.github.com/users/fretz12/repos","events_url":"https://api.github.com/users/fretz12/events{/privacy}","received_events_url":"https://api.github.com/users/fretz12/received_events","type":"User","user_view_type":"public","site_admin":false},"body":"Seems confusing we allow ref extraction from both the token or the req fields directly. And if we get it from the token we validate it with the req fields. But maybe there's a use case I'm not understanding.","created_at":"2025-11-12T23:17:14Z","updated_at":"2025-11-13T00:18:10Z","html_url":"https://github.com/temporalio/temporal/pull/8563#discussion_r2520108689","pull_request_url":"https://api.github.com/repos/temporalio/temporal/pulls/8563","_links":{"self":{"href":"https://api.github.com/repos/temporalio/temporal/pulls/comments/2520108689"},"html":{"href":"https://github.com/temporalio/temporal/pull/8563#discussion_r2520108689"},"pull_request":{"href":"https://api.github.com/repos/temporalio/temporal/pulls/8563"}},"reactions":{"url":"https://api.github.com/repos/temporalio/temporal/pulls/comments/2520108689/reactions","total_count":1,"+1":0,"-1":0,"laugh":0,"hooray":0,"confused":0,"heart":0,"rocket":0,"eyes":1},"start_line":null,"original_start_line":null,"start_side":null,"line":null,"original_line":116,"side":"RIGHT","author_association":"MEMBER","original_position":74,"position":1,"subject_type":"line"},{"url":"https://api.github.com/repos/temporalio/temporal/pulls/comments/2520118188","pull_request_review_id":3455937419,"id":2520118188,"node_id":"PRRC_kwDODNqesM6WNfOs","diff_hunk":"@@ -241,14 +280,159 @@ func (e *ChasmEngine) ReadComponent(\n \treturn readFn(chasmContext, component)\n }\n \n+// PollComponent waits until the supplied predicate is satisfied when evaluated against the\n+// component identified by the supplied component reference. It returns a component reference\n+// identifying the state at which the predicate was satisfied. An error is returned if entity\n+// transition history is (after reloading from persistence) behind the requested ref, or if the ref\n+// is not interpretable as part of the entity transition history. Thus when the predicate function\n+// is evaluated, it is guaranteed that the entity VT >= requestRef VT.\n func (e *ChasmEngine) PollComponent(\n \tctx context.Context,\n-\tentityRef chasm.ComponentRef,\n-\tpredicateFn func(chasm.Context, chasm.Component) (any, bool, error),\n-\toperationFn func(chasm.MutableContext, chasm.Component, any) error,\n+\trequestRef chasm.ComponentRef,\n+\tpredicateFn func(chasm.Context, chasm.Component) (bool, error),\n \topts ...chasm.TransitionOption,\n-) (newEntityRef []byte, retError error) {\n-\treturn nil, serviceerror.NewUnimplemented(\"PollComponent is not yet supported\")\n+) ([]byte, error) {\n+\t// 1. Acquire lock\n+\t// 2. Error if shard entity VT < requestRef VT ('stale state')\n+\t// 3. If predicate satisfied, release lock and return\n+\t// 4. Subscribe to notifications for this entity\n+\t// 5. Release lock\n+\t// 6. On notification repeat (1) and (2)\n+\n+\tshardContext, executionLease, err := e.getExecutionLease(ctx, requestRef)\n+\tif err != nil {\n+\t\t// E.g. requestRef VT inconsistent with shard VT ('stale reference')\n+\t\treturn nil, err\n+\t}\n+\n+\t// hold lock until return or subscription established\n+\treleased := false\n+\tdefer func() {\n+\t\tif !released {\n+\t\t\t// read-only operation; don't pass error\n+\t\t\texecutionLease.GetReleaseFn()(nil)\n+\t\t}\n+\t}()\n+\n+\t// At this point it's possible that shard VT < requestRef VT (getExecutionLease does not\n+\t// guarantee that returned shard state is non-stale w.r.t. requestRef).\n+\tcurrentRef, err := e.checkPredicate(ctx, requestRef, executionLease, predicateFn)\n+\tif err != nil {\n+\t\treturn nil, err\n+\t}\n+\t// shard VT >= requestRef VT (enforced by checkPredicate)\n+\n+\tif currentRef != nil {\n+\t\t// wait condition was satisfied\n+\t\treturn currentRef, nil\n+\t}\n+\n+\t// Wait condition not satisfied; long-poll\n+\n+\tchannel, subscriberID, err := e.notifier.Subscribe(requestRef.EntityKey)\n+\tif err != nil {\n+\t\treturn nil, err\n+\t}\n+\tdefer func() {\n+\t\t_ = e.notifier.Unsubscribe(requestRef.EntityKey, subscriberID)\n+\t}()\n+\n+\t// Release the lock, now that we are subscribed\n+\texecutionLease.GetReleaseFn()(nil)\n+\treleased = true\n+\n+\tnamespaceRegistry, err := shardContext.GetNamespaceRegistry().GetNamespaceByID(\n+\t\tnamespace.ID(requestRef.EntityKey.NamespaceID),\n+\t)\n+\tif err != nil {\n+\t\treturn nil, err\n+\t}\n+\n+\t// TODO(dan): check desired timeout logic here\n+\tctx, cancel := contextutil.WithDeadlineBuffer(\n+\t\tctx,\n+\t\tshardContext.GetConfig().LongPollExpirationInterval(namespaceRegistry.Name().String()),\n+\t\ttime.Second,\n+\t)\n+\tdefer cancel()\n+\n+\tfor {\n+\t\tselect {\n+\t\tcase notification := <-channel:\n+\t\t\tif notification == nil {\n+\t\t\t\treturn nil, serviceerror.NewInternal(\"nil component notification\")\n+\t\t\t}\n+\t\t\t// Received a notification. Re-acquire the lock and check the predicate.\n+\t\t\t_, executionLease, err := e.getExecutionLease(ctx, requestRef)\n+\t\t\tif err != nil {\n+\t\t\t\treturn nil, err\n+\t\t\t}\n+\n+\t\t\tnewRef, err := e.checkPredicate(ctx, requestRef, executionLease, predicateFn)\n+\t\t\texecutionLease.GetReleaseFn()(nil)\n+\t\t\tif err != nil {\n+\t\t\t\treturn nil, err\n+\t\t\t}\n+\t\t\tif newRef != nil {\n+\t\t\t\t// wait condition was satisfied\n+\t\t\t\treturn newRef, nil\n+\t\t\t}","path":"service/history/chasm_engine.go","commit_id":"da6009564e796063faf853352077eecdc1473612","original_commit_id":"f8ccafbb3c10a723c3180b7c0da6caee9ff4f073","user":{"login":"dandavison","id":52205,"node_id":"MDQ6VXNlcjUyMjA1","avatar_url":"https://avatars.githubusercontent.com/u/52205?v=4","gravatar_id":"","url":"https://api.github.com/users/dandavison","html_url":"https://github.com/dandavison","followers_url":"https://api.github.com/users/dandavison/followers","following_url":"https://api.github.com/users/dandavison/following{/other_user}","gists_url":"https://api.github.com/users/dandavison/gists{/gist_id}","starred_url":"https://api.github.com/users/dandavison/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/dandavison/subscriptions","organizations_url":"https://api.github.com/users/dandavison/orgs","repos_url":"https://api.github.com/users/dandavison/repos","events_url":"https://api.github.com/users/dandavison/events{/privacy}","received_events_url":"https://api.github.com/users/dandavison/received_events","type":"User","user_view_type":"public","site_admin":false},"body":"Not true. `getExecutionLease` does not hold a lock if it returns with error.","created_at":"2025-11-12T23:21:12Z","updated_at":"2025-11-12T23:21:12Z","html_url":"https://github.com/temporalio/temporal/pull/8563#discussion_r2520118188","pull_request_url":"https://api.github.com/repos/temporalio/temporal/pulls/8563","_links":{"self":{"href":"https://api.github.com/repos/temporalio/temporal/pulls/comments/2520118188"},"html":{"href":"https://github.com/temporalio/temporal/pull/8563#discussion_r2520118188"},"pull_request":{"href":"https://api.github.com/repos/temporalio/temporal/pulls/8563"}},"reactions":{"url":"https://api.github.com/repos/temporalio/temporal/pulls/comments/2520118188/reactions","total_count":0,"+1":0,"-1":0,"laugh":0,"hooray":0,"confused":0,"heart":0,"rocket":0,"eyes":0},"start_line":null,"original_start_line":null,"start_side":null,"line":323,"original_line":379,"side":"RIGHT","in_reply_to_id":2520106683,"author_association":"MEMBER","original_position":212,"position":1,"subject_type":"line"},{"url":"https://api.github.com/repos/temporalio/temporal/pulls/comments/2520276996","pull_request_review_id":3455788347,"id":2520276996,"node_id":"PRRC_kwDODNqesM6WOGAE","diff_hunk":"@@ -51,3 +53,177 @@ func (h *handler) StartActivityExecution(ctx context.Context, req *activitypb.St\n \t\tFrontendResponse: response,\n \t}, nil\n }\n+\n+// PollActivityExecution handles PollActivityExecutionRequest from frontend. This method supports\n+// querying current activity state, optionally as a long-poll that waits for certain state changes.\n+// It is used by clients to poll for activity state and/or result.\n+func (h *handler) PollActivityExecution(\n+\tctx context.Context,\n+\treq *activitypb.PollActivityExecutionRequest,\n+) (*activitypb.PollActivityExecutionResponse, error) {\n+\n+\twaitPolicy := req.GetFrontendRequest().GetWaitPolicy()\n+\tif waitPolicy == nil {\n+\t\treturn chasm.ReadComponent(\n+\t\t\tctx,\n+\t\t\tchasm.NewComponentRef[*Activity](chasm.EntityKey{\n+\t\t\t\tNamespaceID: req.GetNamespaceId(),\n+\t\t\t\tBusinessID:  req.GetFrontendRequest().GetActivityId(),\n+\t\t\t\tEntityID:    req.GetFrontendRequest().GetRunId(),\n+\t\t\t}),\n+\t\t\t(*Activity).buildPollActivityExecutionResponse,\n+\t\t\treq,\n+\t\t\tnil,\n+\t\t)\n+\t}\n+\n+\tvar response *activitypb.PollActivityExecutionResponse\n+\tvar newRef []byte\n+\tvar err error\n+\n+\tswitch waitPolicy.(type) {\n+\tcase *workflowservice.PollActivityExecutionRequest_WaitAnyStateChange:\n+\t\tresponse, newRef, err = pollActivityExecutionWaitAnyStateChange(ctx, req)\n+\tcase *workflowservice.PollActivityExecutionRequest_WaitCompletion:\n+\t\tresponse, newRef, err = pollActivityExecutionWaitCompletion(ctx, req)\n+\tdefault:\n+\t\treturn nil, fmt.Errorf(\"unexpected wait policy type: %T\", waitPolicy)\n+\t}\n+\tif err != nil {\n+\t\treturn nil, err\n+\t}\n+\tresponse.GetFrontendResponse().StateChangeLongPollToken = newRef\n+\treturn response, nil\n+}\n+\n+// pollActivityExecutionWaitAnyStateChange waits until the activity state has advanced beyond that\n+// specified by the submitted token. If no token was submitted, it returns the current state without\n+// waiting.\n+func pollActivityExecutionWaitAnyStateChange(\n+\tctx context.Context,\n+\treq *activitypb.PollActivityExecutionRequest,\n+) (*activitypb.PollActivityExecutionResponse, []byte, error) {\n+\n+\t// TODO(dan): do we want to guarantee that response data will differ from that received when the\n+\t// token was obtained? It's potentially confusing for the server to say \"there's been a change\"\n+\t// while returning data in which the change is not apparent.\n+\n+\trefBytesFromToken := req.GetFrontendRequest().\n+\t\tGetWaitPolicy().(*workflowservice.PollActivityExecutionRequest_WaitAnyStateChange).\n+\t\tWaitAnyStateChange.GetLongPollToken()\n+\n+\tvar lastSeenRef chasm.ComponentRef\n+\tif refBytesFromToken != nil {\n+\t\tvar err error\n+\t\tlastSeenRef, err = chasm.DeserializeComponentRef(refBytesFromToken)\n+\t\tif err != nil {\n+\t\t\treturn nil, nil, serviceerror.NewInvalidArgument(\"invalid long poll token\")\n+\t\t}\n+\t\tif lastSeenRef.NamespaceID != req.GetNamespaceId() ||\n+\t\t\tlastSeenRef.BusinessID != req.GetFrontendRequest().GetActivityId() ||\n+\t\t\tlastSeenRef.EntityID != req.GetFrontendRequest().GetRunId() {\n+\t\t\t// token is inconsistent with request\n+\t\t\treturn nil, nil, serviceerror.NewInvalidArgument(\"invalid long poll token\")\n+\t\t}\n+\t} else {\n+\t\t// This ref will compare less than currentRef in the comparison below.\n+\t\tlastSeenRef = chasm.NewComponentRef[*Activity](chasm.EntityKey{\n+\t\t\tNamespaceID: req.GetNamespaceId(),\n+\t\t\tBusinessID:  req.GetFrontendRequest().GetActivityId(),\n+\t\t\tEntityID:    req.GetFrontendRequest().GetRunId(),\n+\t\t})\n+\t}\n+\n+\t// PollComponent will return an error if lastSeenRef is not consistent with the entity\n+\t// transition history on this shard, or if the state on this shard is behind the ref after a\n+\t// reload.\n+\t// TODO(dan): retryability of these errors\n+\treturn chasm.PollComponent(\n+\t\tctx,\n+\t\tlastSeenRef,\n+\t\tfunc(\n+\t\t\ta *Activity,\n+\t\t\tctx chasm.Context,\n+\t\t\treq *activitypb.PollActivityExecutionRequest,\n+\t\t) (*activitypb.PollActivityExecutionResponse, bool, error) {\n+\t\t\t// TODO(dan): we're walking the tree to construct a ref when all we want here is the\n+\t\t\t// root/entity VT. Would it make sense for Context to provide access to root node?\n+\t\t\tcurrentRefBytes, err := ctx.Ref(a)\n+\t\t\tif err != nil {\n+\t\t\t\treturn nil, false, err\n+\t\t\t}\n+\t\t\tcurrentRef, err := chasm.DeserializeComponentRef(currentRefBytes)\n+\t\t\tif err != nil {\n+\t\t\t\treturn nil, false, err\n+\t\t\t}\n+\n+\t\t\tif lastSeenRef.EntityID != currentRef.EntityID {\n+\t\t\t\t// The runID from the token doesn't match this shard's state. We return immediately,\n+\t\t\t\t// on the basis that this constitutes a state change. If the runID from the token is\n+\t\t\t\t// ahead of this shard's state then this will be detected by shard ownership or\n+\t\t\t\t// staleness checks and the caller will receive an error.\n+\t\t\t\tresponse, err := a.buildPollActivityExecutionResponse(ctx, req)\n+\t\t\t\tif err != nil {\n+\t\t\t\t\treturn nil, true, err\n+\t\t\t\t}\n+\t\t\t\treturn response, true, nil","path":"chasm/lib/activity/handler.go","commit_id":"b24a0220435f567e7e3cacb95bd8fe78c17dc67b","original_commit_id":"f8ccafbb3c10a723c3180b7c0da6caee9ff4f073","user":{"login":"fretz12","id":41805201,"node_id":"MDQ6VXNlcjQxODA1MjAx","avatar_url":"https://avatars.githubusercontent.com/u/41805201?v=4","gravatar_id":"","url":"https://api.github.com/users/fretz12","html_url":"https://github.com/fretz12","followers_url":"https://api.github.com/users/fretz12/followers","following_url":"https://api.github.com/users/fretz12/following{/other_user}","gists_url":"https://api.github.com/users/fretz12/gists{/gist_id}","starred_url":"https://api.github.com/users/fretz12/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/fretz12/subscriptions","organizations_url":"https://api.github.com/users/fretz12/orgs","repos_url":"https://api.github.com/users/fretz12/repos","events_url":"https://api.github.com/users/fretz12/events{/privacy}","received_events_url":"https://api.github.com/users/fretz12/received_events","type":"User","user_view_type":"public","site_admin":false},"body":"maybe I'm misunderstanding, but if the runIDs don't match, should we return an error here?","created_at":"2025-11-12T23:55:24Z","updated_at":"2025-11-13T00:18:10Z","html_url":"https://github.com/temporalio/temporal/pull/8563#discussion_r2520276996","pull_request_url":"https://api.github.com/repos/temporalio/temporal/pulls/8563","_links":{"self":{"href":"https://api.github.com/repos/temporalio/temporal/pulls/comments/2520276996"},"html":{"href":"https://github.com/temporalio/temporal/pull/8563#discussion_r2520276996"},"pull_request":{"href":"https://api.github.com/repos/temporalio/temporal/pulls/8563"}},"reactions":{"url":"https://api.github.com/repos/temporalio/temporal/pulls/comments/2520276996/reactions","total_count":0,"+1":0,"-1":0,"laugh":0,"hooray":0,"confused":0,"heart":0,"rocket":0,"eyes":0},"start_line":null,"original_start_line":null,"start_side":null,"line":null,"original_line":169,"side":"RIGHT","author_association":"MEMBER","original_position":127,"position":1,"subject_type":"line"},{"url":"https://api.github.com/repos/temporalio/temporal/pulls/comments/2520298163","pull_request_review_id":3455788347,"id":2520298163,"node_id":"PRRC_kwDODNqesM6WOLKz","diff_hunk":"@@ -51,3 +53,177 @@ func (h *handler) StartActivityExecution(ctx context.Context, req *activitypb.St\n \t\tFrontendResponse: response,\n \t}, nil\n }\n+\n+// PollActivityExecution handles PollActivityExecutionRequest from frontend. This method supports\n+// querying current activity state, optionally as a long-poll that waits for certain state changes.\n+// It is used by clients to poll for activity state and/or result.\n+func (h *handler) PollActivityExecution(\n+\tctx context.Context,\n+\treq *activitypb.PollActivityExecutionRequest,\n+) (*activitypb.PollActivityExecutionResponse, error) {\n+\n+\twaitPolicy := req.GetFrontendRequest().GetWaitPolicy()\n+\tif waitPolicy == nil {\n+\t\treturn chasm.ReadComponent(\n+\t\t\tctx,\n+\t\t\tchasm.NewComponentRef[*Activity](chasm.EntityKey{\n+\t\t\t\tNamespaceID: req.GetNamespaceId(),\n+\t\t\t\tBusinessID:  req.GetFrontendRequest().GetActivityId(),\n+\t\t\t\tEntityID:    req.GetFrontendRequest().GetRunId(),\n+\t\t\t}),\n+\t\t\t(*Activity).buildPollActivityExecutionResponse,\n+\t\t\treq,\n+\t\t\tnil,\n+\t\t)\n+\t}\n+\n+\tvar response *activitypb.PollActivityExecutionResponse\n+\tvar newRef []byte\n+\tvar err error\n+\n+\tswitch waitPolicy.(type) {\n+\tcase *workflowservice.PollActivityExecutionRequest_WaitAnyStateChange:\n+\t\tresponse, newRef, err = pollActivityExecutionWaitAnyStateChange(ctx, req)\n+\tcase *workflowservice.PollActivityExecutionRequest_WaitCompletion:\n+\t\tresponse, newRef, err = pollActivityExecutionWaitCompletion(ctx, req)\n+\tdefault:\n+\t\treturn nil, fmt.Errorf(\"unexpected wait policy type: %T\", waitPolicy)\n+\t}\n+\tif err != nil {\n+\t\treturn nil, err\n+\t}\n+\tresponse.GetFrontendResponse().StateChangeLongPollToken = newRef\n+\treturn response, nil\n+}\n+\n+// pollActivityExecutionWaitAnyStateChange waits until the activity state has advanced beyond that\n+// specified by the submitted token. If no token was submitted, it returns the current state without\n+// waiting.\n+func pollActivityExecutionWaitAnyStateChange(\n+\tctx context.Context,\n+\treq *activitypb.PollActivityExecutionRequest,\n+) (*activitypb.PollActivityExecutionResponse, []byte, error) {\n+\n+\t// TODO(dan): do we want to guarantee that response data will differ from that received when the\n+\t// token was obtained? It's potentially confusing for the server to say \"there's been a change\"\n+\t// while returning data in which the change is not apparent.\n+\n+\trefBytesFromToken := req.GetFrontendRequest().\n+\t\tGetWaitPolicy().(*workflowservice.PollActivityExecutionRequest_WaitAnyStateChange).\n+\t\tWaitAnyStateChange.GetLongPollToken()\n+\n+\tvar lastSeenRef chasm.ComponentRef\n+\tif refBytesFromToken != nil {\n+\t\tvar err error\n+\t\tlastSeenRef, err = chasm.DeserializeComponentRef(refBytesFromToken)\n+\t\tif err != nil {\n+\t\t\treturn nil, nil, serviceerror.NewInvalidArgument(\"invalid long poll token\")\n+\t\t}\n+\t\tif lastSeenRef.NamespaceID != req.GetNamespaceId() ||\n+\t\t\tlastSeenRef.BusinessID != req.GetFrontendRequest().GetActivityId() ||\n+\t\t\tlastSeenRef.EntityID != req.GetFrontendRequest().GetRunId() {\n+\t\t\t// token is inconsistent with request\n+\t\t\treturn nil, nil, serviceerror.NewInvalidArgument(\"invalid long poll token\")\n+\t\t}\n+\t} else {\n+\t\t// This ref will compare less than currentRef in the comparison below.\n+\t\tlastSeenRef = chasm.NewComponentRef[*Activity](chasm.EntityKey{\n+\t\t\tNamespaceID: req.GetNamespaceId(),\n+\t\t\tBusinessID:  req.GetFrontendRequest().GetActivityId(),\n+\t\t\tEntityID:    req.GetFrontendRequest().GetRunId(),\n+\t\t})\n+\t}\n+\n+\t// PollComponent will return an error if lastSeenRef is not consistent with the entity\n+\t// transition history on this shard, or if the state on this shard is behind the ref after a\n+\t// reload.\n+\t// TODO(dan): retryability of these errors\n+\treturn chasm.PollComponent(\n+\t\tctx,\n+\t\tlastSeenRef,\n+\t\tfunc(\n+\t\t\ta *Activity,\n+\t\t\tctx chasm.Context,\n+\t\t\treq *activitypb.PollActivityExecutionRequest,\n+\t\t) (*activitypb.PollActivityExecutionResponse, bool, error) {\n+\t\t\t// TODO(dan): we're walking the tree to construct a ref when all we want here is the\n+\t\t\t// root/entity VT. Would it make sense for Context to provide access to root node?\n+\t\t\tcurrentRefBytes, err := ctx.Ref(a)\n+\t\t\tif err != nil {\n+\t\t\t\treturn nil, false, err\n+\t\t\t}\n+\t\t\tcurrentRef, err := chasm.DeserializeComponentRef(currentRefBytes)\n+\t\t\tif err != nil {\n+\t\t\t\treturn nil, false, err\n+\t\t\t}\n+\n+\t\t\tif lastSeenRef.EntityID != currentRef.EntityID {\n+\t\t\t\t// The runID from the token doesn't match this shard's state. We return immediately,\n+\t\t\t\t// on the basis that this constitutes a state change. If the runID from the token is\n+\t\t\t\t// ahead of this shard's state then this will be detected by shard ownership or\n+\t\t\t\t// staleness checks and the caller will receive an error.\n+\t\t\t\tresponse, err := a.buildPollActivityExecutionResponse(ctx, req)\n+\t\t\t\tif err != nil {\n+\t\t\t\t\treturn nil, true, err\n+\t\t\t\t}\n+\t\t\t\treturn response, true, nil\n+\t\t\t}\n+\n+\t\t\trefComparison, err := chasm.CompareComponentRefs(&lastSeenRef, &currentRef)\n+\t\t\tif err != nil {\n+\t\t\t\treturn nil, false, err\n+\t\t\t}\n+\t\t\tswitch refComparison {\n+\t\t\tcase -1:\n+\t\t\t\t// state has advanced beyond last seen: this is what we're waiting for\n+\t\t\t\tresponse, err := a.buildPollActivityExecutionResponse(ctx, req)\n+\t\t\t\tif err != nil {\n+\t\t\t\t\treturn nil, true, err\n+\t\t\t\t}\n+\t\t\t\treturn response, true, nil\n+\t\t\tcase 0:\n+\t\t\t\t// state is same as last seen: keep waiting\n+\t\t\t\treturn nil, false, nil\n+\t\t\tcase 1:\n+\t\t\t\t// Impossible: PollComponent guarantees that at this point, current VT >= lastSeen VT.\n+\t\t\t\treturn nil, false, serviceerror.NewFailedPrecondition(\"submitted long-poll token represents a state beyond current\")\n+\t\t\tdefault:\n+\t\t\t\t// Impossible\n+\t\t\t\treturn nil, false, serviceerror.NewInternal(\"unexpected transition history comparison result\")\n+\t\t\t}\n+\t\t},\n+\t\treq,\n+\t)\n+}\n+\n+// pollActivityExecutionWaitCompletion waits until the activity is completed.\n+func pollActivityExecutionWaitCompletion(\n+\tctx context.Context,\n+\treq *activitypb.PollActivityExecutionRequest,\n+) (*activitypb.PollActivityExecutionResponse, []byte, error) {\n+\t// TODO(dan): implement functional test when RecordActivityTaskCompleted is implemented\n+\treturn chasm.PollComponent(\n+\t\tctx,\n+\t\tchasm.NewComponentRef[*Activity](chasm.EntityKey{\n+\t\t\tNamespaceID: req.GetNamespaceId(),\n+\t\t\tBusinessID:  req.GetFrontendRequest().GetActivityId(),\n+\t\t\tEntityID:    req.GetFrontendRequest().GetRunId(),\n+\t\t}),\n+\t\tfunc(\n+\t\t\ta *Activity,\n+\t\t\tctx chasm.Context,\n+\t\t\treq *activitypb.PollActivityExecutionRequest,\n+\t\t) (*activitypb.PollActivityExecutionResponse, bool, error) {\n+\t\t\tcompleted := a.StateMachineState() == activitypb.ACTIVITY_EXECUTION_STATUS_COMPLETED","path":"chasm/lib/activity/handler.go","commit_id":"a9026f431e35dbc9797001b54748761bd5d9cbd4","original_commit_id":"f8ccafbb3c10a723c3180b7c0da6caee9ff4f073","user":{"login":"fretz12","id":41805201,"node_id":"MDQ6VXNlcjQxODA1MjAx","avatar_url":"https://avatars.githubusercontent.com/u/41805201?v=4","gravatar_id":"","url":"https://api.github.com/users/fretz12","html_url":"https://github.com/fretz12","followers_url":"https://api.github.com/users/fretz12/followers","following_url":"https://api.github.com/users/fretz12/following{/other_user}","gists_url":"https://api.github.com/users/fretz12/gists{/gist_id}","starred_url":"https://api.github.com/users/fretz12/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/fretz12/subscriptions","organizations_url":"https://api.github.com/users/fretz12/orgs","repos_url":"https://api.github.com/users/fretz12/repos","events_url":"https://api.github.com/users/fretz12/events{/privacy}","received_events_url":"https://api.github.com/users/fretz12/received_events","type":"User","user_view_type":"public","site_admin":false},"body":"should wait for completion encompass any terminal state (failed, timedout, completed, terminated, cancelled), or just the successful state?","created_at":"2025-11-13T00:00:21Z","updated_at":"2025-11-13T00:18:10Z","html_url":"https://github.com/temporalio/temporal/pull/8563#discussion_r2520298163","pull_request_url":"https://api.github.com/repos/temporalio/temporal/pulls/8563","_links":{"self":{"href":"https://api.github.com/repos/temporalio/temporal/pulls/comments/2520298163"},"html":{"href":"https://github.com/temporalio/temporal/pull/8563#discussion_r2520298163"},"pull_request":{"href":"https://api.github.com/repos/temporalio/temporal/pulls/8563"}},"reactions":{"url":"https://api.github.com/repos/temporalio/temporal/pulls/comments/2520298163/reactions","total_count":0,"+1":0,"-1":0,"laugh":0,"hooray":0,"confused":0,"heart":0,"rocket":0,"eyes":0},"start_line":null,"original_start_line":null,"start_side":null,"line":null,"original_line":217,"side":"RIGHT","author_association":"MEMBER","original_position":175,"position":1,"subject_type":"line"},{"url":"https://api.github.com/repos/temporalio/temporal/pulls/comments/2520424015","pull_request_review_id":3456299008,"id":2520424015,"node_id":"PRRC_kwDODNqesM6WOp5P","diff_hunk":"@@ -314,3 +314,124 @@ func (a *Activity) RecordHeartbeat(ctx chasm.MutableContext, details *commonpb.P\n \t})\n \treturn nil, nil\n }\n+\n+func (a *Activity) buildActivityExecutionInfo(ctx chasm.Context, key chasm.EntityKey) (*activity.ActivityExecutionInfo, error) {\n+\tif a.ActivityState == nil {\n+\t\treturn nil, errors.New(\"activity state is nil\")\n+\t}\n+\n+\t// TODO(dan): support pause states\n+\tvar status enumspb.ActivityExecutionStatus\n+\tvar runState enumspb.PendingActivityState\n+\tswitch a.GetStatus() {","path":"chasm/lib/activity/activity.go","commit_id":"1d59e66d0ce5d91819f92c428ef5ab4c4efca1fb","original_commit_id":"a1b89b2df945362cc0235d9a826c6646855b3d6f","user":{"login":"dandavison","id":52205,"node_id":"MDQ6VXNlcjUyMjA1","avatar_url":"https://avatars.githubusercontent.com/u/52205?v=4","gravatar_id":"","url":"https://api.github.com/users/dandavison","html_url":"https://github.com/dandavison","followers_url":"https://api.github.com/users/dandavison/followers","following_url":"https://api.github.com/users/dandavison/following{/other_user}","gists_url":"https://api.github.com/users/dandavison/gists{/gist_id}","starred_url":"https://api.github.com/users/dandavison/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/dandavison/subscriptions","organizations_url":"https://api.github.com/users/dandavison/orgs","repos_url":"https://api.github.com/users/dandavison/repos","events_url":"https://api.github.com/users/dandavison/events{/privacy}","received_events_url":"https://api.github.com/users/dandavison/received_events","type":"User","user_view_type":"public","site_admin":false},"body":"Thanks, added that.","created_at":"2025-11-13T00:26:40Z","updated_at":"2025-11-13T01:02:29Z","html_url":"https://github.com/temporalio/temporal/pull/8563#discussion_r2520424015","pull_request_url":"https://api.github.com/repos/temporalio/temporal/pulls/8563","_links":{"self":{"href":"https://api.github.com/repos/temporalio/temporal/pulls/comments/2520424015"},"html":{"href":"https://github.com/temporalio/temporal/pull/8563#discussion_r2520424015"},"pull_request":{"href":"https://api.github.com/repos/temporalio/temporal/pulls/8563"}},"reactions":{"url":"https://api.github.com/repos/temporalio/temporal/pulls/comments/2520424015/reactions","total_count":0,"+1":0,"-1":0,"laugh":0,"hooray":0,"confused":0,"heart":0,"rocket":0,"eyes":0},"start_line":null,"original_start_line":null,"start_side":null,"line":322,"original_line":326,"side":"RIGHT","in_reply_to_id":2520018342,"author_association":"MEMBER","original_position":41,"position":38,"subject_type":"line"},{"url":"https://api.github.com/repos/temporalio/temporal/pulls/comments/2520432511","pull_request_review_id":3456299008,"id":2520432511,"node_id":"PRRC_kwDODNqesM6WOr9_","diff_hunk":"@@ -314,3 +314,124 @@ func (a *Activity) RecordHeartbeat(ctx chasm.MutableContext, details *commonpb.P\n \t})\n \treturn nil, nil\n }\n+\n+func (a *Activity) buildActivityExecutionInfo(ctx chasm.Context, key chasm.EntityKey) (*activity.ActivityExecutionInfo, error) {\n+\tif a.ActivityState == nil {\n+\t\treturn nil, errors.New(\"activity state is nil\")\n+\t}\n+\n+\t// TODO(dan): support pause states\n+\tvar status enumspb.ActivityExecutionStatus\n+\tvar runState enumspb.PendingActivityState\n+\tswitch a.GetStatus() {\n+\tcase activitypb.ACTIVITY_EXECUTION_STATUS_UNSPECIFIED:\n+\t\tstatus = enumspb.ACTIVITY_EXECUTION_STATUS_UNSPECIFIED\n+\t\trunState = enumspb.PENDING_ACTIVITY_STATE_UNSPECIFIED\n+\tcase activitypb.ACTIVITY_EXECUTION_STATUS_SCHEDULED:\n+\t\tstatus = enumspb.ACTIVITY_EXECUTION_STATUS_RUNNING\n+\t\trunState = enumspb.PENDING_ACTIVITY_STATE_SCHEDULED\n+\tcase activitypb.ACTIVITY_EXECUTION_STATUS_STARTED:\n+\t\tstatus = enumspb.ACTIVITY_EXECUTION_STATUS_RUNNING\n+\t\trunState = enumspb.PENDING_ACTIVITY_STATE_STARTED\n+\tcase activitypb.ACTIVITY_EXECUTION_STATUS_CANCEL_REQUESTED:\n+\t\tstatus = enumspb.ACTIVITY_EXECUTION_STATUS_RUNNING\n+\t\trunState = enumspb.PENDING_ACTIVITY_STATE_CANCEL_REQUESTED\n+\tcase activitypb.ACTIVITY_EXECUTION_STATUS_COMPLETED:\n+\t\tstatus = enumspb.ACTIVITY_EXECUTION_STATUS_COMPLETED\n+\t\trunState = enumspb.PENDING_ACTIVITY_STATE_UNSPECIFIED\n+\tcase activitypb.ACTIVITY_EXECUTION_STATUS_FAILED:\n+\t\tstatus = enumspb.ACTIVITY_EXECUTION_STATUS_FAILED\n+\t\trunState = enumspb.PENDING_ACTIVITY_STATE_UNSPECIFIED\n+\tcase activitypb.ACTIVITY_EXECUTION_STATUS_CANCELED:\n+\t\tstatus = enumspb.ACTIVITY_EXECUTION_STATUS_CANCELED\n+\t\trunState = enumspb.PENDING_ACTIVITY_STATE_UNSPECIFIED\n+\tcase activitypb.ACTIVITY_EXECUTION_STATUS_TERMINATED:\n+\t\tstatus = enumspb.ACTIVITY_EXECUTION_STATUS_TERMINATED\n+\t\trunState = enumspb.PENDING_ACTIVITY_STATE_UNSPECIFIED\n+\tcase activitypb.ACTIVITY_EXECUTION_STATUS_TIMED_OUT:\n+\t\tstatus = enumspb.ACTIVITY_EXECUTION_STATUS_TIMED_OUT\n+\t\trunState = enumspb.PENDING_ACTIVITY_STATE_UNSPECIFIED\n+\t}\n+\n+\trequestData, err := a.RequestData.Get(ctx)\n+\tif err != nil {\n+\t\treturn nil, err\n+\t}\n+\n+\tinfo := &activity.ActivityExecutionInfo{\n+\t\tActivityId:    key.BusinessID,\n+\t\tRunId:         key.EntityID,\n+\t\tActivityType:  a.GetActivityType(),\n+\t\tStatus:        status,\n+\t\tRunState:      runState,\n+\t\tScheduledTime: a.GetScheduledTime(),\n+\t\tPriority:      a.GetPriority(),\n+\t\tHeader:        requestData.GetHeader(),\n+\t\t// TODO(dan): populate remaining fields\n+\t}\n+\n+\treturn info, nil\n+}\n+\n+func (a *Activity) buildPollActivityExecutionResponse(\n+\tctx chasm.Context,\n+\treq *activitypb.PollActivityExecutionRequest,\n+) (*activitypb.PollActivityExecutionResponse, error) {\n+\tvar err error","path":"chasm/lib/activity/activity.go","commit_id":"f8ccafbb3c10a723c3180b7c0da6caee9ff4f073","original_commit_id":"a1b89b2df945362cc0235d9a826c6646855b3d6f","user":{"login":"dandavison","id":52205,"node_id":"MDQ6VXNlcjUyMjA1","avatar_url":"https://avatars.githubusercontent.com/u/52205?v=4","gravatar_id":"","url":"https://api.github.com/users/dandavison","html_url":"https://github.com/dandavison","followers_url":"https://api.github.com/users/dandavison/followers","following_url":"https://api.github.com/users/dandavison/following{/other_user}","gists_url":"https://api.github.com/users/dandavison/gists{/gist_id}","starred_url":"https://api.github.com/users/dandavison/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/dandavison/subscriptions","organizations_url":"https://api.github.com/users/dandavison/orgs","repos_url":"https://api.github.com/users/dandavison/repos","events_url":"https://api.github.com/users/dandavison/events{/privacy}","received_events_url":"https://api.github.com/users/dandavison/received_events","type":"User","user_view_type":"public","site_admin":false},"body":"Right! Done.","created_at":"2025-11-13T00:28:25Z","updated_at":"2025-11-13T01:02:29Z","html_url":"https://github.com/temporalio/temporal/pull/8563#discussion_r2520432511","pull_request_url":"https://api.github.com/repos/temporalio/temporal/pulls/8563","_links":{"self":{"href":"https://api.github.com/repos/temporalio/temporal/pulls/comments/2520432511"},"html":{"href":"https://github.com/temporalio/temporal/pull/8563#discussion_r2520432511"},"pull_request":{"href":"https://api.github.com/repos/temporalio/temporal/pulls/8563"}},"reactions":{"url":"https://api.github.com/repos/temporalio/temporal/pulls/comments/2520432511/reactions","total_count":0,"+1":0,"-1":0,"laugh":0,"hooray":0,"confused":0,"heart":0,"rocket":0,"eyes":0},"start_line":null,"original_start_line":null,"start_side":null,"line":null,"original_line":380,"side":"RIGHT","in_reply_to_id":2520056230,"author_association":"MEMBER","original_position":95,"position":1,"subject_type":"line"},{"url":"https://api.github.com/repos/temporalio/temporal/pulls/comments/2520476417","pull_request_review_id":3456299008,"id":2520476417,"node_id":"PRRC_kwDODNqesM6WO2sB","diff_hunk":"@@ -51,3 +53,177 @@ func (h *handler) StartActivityExecution(ctx context.Context, req *activitypb.St\n \t\tFrontendResponse: response,\n \t}, nil\n }\n+\n+// PollActivityExecution handles PollActivityExecutionRequest from frontend. This method supports\n+// querying current activity state, optionally as a long-poll that waits for certain state changes.\n+// It is used by clients to poll for activity state and/or result.\n+func (h *handler) PollActivityExecution(\n+\tctx context.Context,\n+\treq *activitypb.PollActivityExecutionRequest,\n+) (*activitypb.PollActivityExecutionResponse, error) {\n+\n+\twaitPolicy := req.GetFrontendRequest().GetWaitPolicy()\n+\tif waitPolicy == nil {\n+\t\treturn chasm.ReadComponent(\n+\t\t\tctx,\n+\t\t\tchasm.NewComponentRef[*Activity](chasm.EntityKey{\n+\t\t\t\tNamespaceID: req.GetNamespaceId(),\n+\t\t\t\tBusinessID:  req.GetFrontendRequest().GetActivityId(),\n+\t\t\t\tEntityID:    req.GetFrontendRequest().GetRunId(),\n+\t\t\t}),\n+\t\t\t(*Activity).buildPollActivityExecutionResponse,\n+\t\t\treq,\n+\t\t\tnil,\n+\t\t)\n+\t}\n+\n+\tvar response *activitypb.PollActivityExecutionResponse\n+\tvar newRef []byte\n+\tvar err error\n+\n+\tswitch waitPolicy.(type) {\n+\tcase *workflowservice.PollActivityExecutionRequest_WaitAnyStateChange:\n+\t\tresponse, newRef, err = pollActivityExecutionWaitAnyStateChange(ctx, req)\n+\tcase *workflowservice.PollActivityExecutionRequest_WaitCompletion:\n+\t\tresponse, newRef, err = pollActivityExecutionWaitCompletion(ctx, req)\n+\tdefault:\n+\t\treturn nil, fmt.Errorf(\"unexpected wait policy type: %T\", waitPolicy)\n+\t}\n+\tif err != nil {\n+\t\treturn nil, err\n+\t}\n+\tresponse.GetFrontendResponse().StateChangeLongPollToken = newRef\n+\treturn response, nil\n+}\n+\n+// pollActivityExecutionWaitAnyStateChange waits until the activity state has advanced beyond that\n+// specified by the submitted token. If no token was submitted, it returns the current state without\n+// waiting.\n+func pollActivityExecutionWaitAnyStateChange(\n+\tctx context.Context,\n+\treq *activitypb.PollActivityExecutionRequest,\n+) (*activitypb.PollActivityExecutionResponse, []byte, error) {\n+\n+\t// TODO(dan): do we want to guarantee that response data will differ from that received when the\n+\t// token was obtained? It's potentially confusing for the server to say \"there's been a change\"\n+\t// while returning data in which the change is not apparent.\n+\n+\trefBytesFromToken := req.GetFrontendRequest().\n+\t\tGetWaitPolicy().(*workflowservice.PollActivityExecutionRequest_WaitAnyStateChange).\n+\t\tWaitAnyStateChange.GetLongPollToken()\n+\n+\tvar lastSeenRef chasm.ComponentRef\n+\tif refBytesFromToken != nil {\n+\t\tvar err error\n+\t\tlastSeenRef, err = chasm.DeserializeComponentRef(refBytesFromToken)\n+\t\tif err != nil {\n+\t\t\treturn nil, nil, serviceerror.NewInvalidArgument(\"invalid long poll token\")\n+\t\t}\n+\t\tif lastSeenRef.NamespaceID != req.GetNamespaceId() ||\n+\t\t\tlastSeenRef.BusinessID != req.GetFrontendRequest().GetActivityId() ||\n+\t\t\tlastSeenRef.EntityID != req.GetFrontendRequest().GetRunId() {\n+\t\t\t// token is inconsistent with request\n+\t\t\treturn nil, nil, serviceerror.NewInvalidArgument(\"invalid long poll token\")\n+\t\t}\n+\t} else {\n+\t\t// This ref will compare less than currentRef in the comparison below.\n+\t\tlastSeenRef = chasm.NewComponentRef[*Activity](chasm.EntityKey{\n+\t\t\tNamespaceID: req.GetNamespaceId(),\n+\t\t\tBusinessID:  req.GetFrontendRequest().GetActivityId(),\n+\t\t\tEntityID:    req.GetFrontendRequest().GetRunId(),\n+\t\t})\n+\t}\n+\n+\t// PollComponent will return an error if lastSeenRef is not consistent with the entity\n+\t// transition history on this shard, or if the state on this shard is behind the ref after a\n+\t// reload.\n+\t// TODO(dan): retryability of these errors\n+\treturn chasm.PollComponent(\n+\t\tctx,\n+\t\tlastSeenRef,\n+\t\tfunc(\n+\t\t\ta *Activity,\n+\t\t\tctx chasm.Context,\n+\t\t\treq *activitypb.PollActivityExecutionRequest,\n+\t\t) (*activitypb.PollActivityExecutionResponse, bool, error) {\n+\t\t\t// TODO(dan): we're walking the tree to construct a ref when all we want here is the\n+\t\t\t// root/entity VT. Would it make sense for Context to provide access to root node?\n+\t\t\tcurrentRefBytes, err := ctx.Ref(a)\n+\t\t\tif err != nil {\n+\t\t\t\treturn nil, false, err\n+\t\t\t}\n+\t\t\tcurrentRef, err := chasm.DeserializeComponentRef(currentRefBytes)\n+\t\t\tif err != nil {\n+\t\t\t\treturn nil, false, err\n+\t\t\t}\n+\n+\t\t\tif lastSeenRef.EntityID != currentRef.EntityID {\n+\t\t\t\t// The runID from the token doesn't match this shard's state. We return immediately,\n+\t\t\t\t// on the basis that this constitutes a state change. If the runID from the token is\n+\t\t\t\t// ahead of this shard's state then this will be detected by shard ownership or\n+\t\t\t\t// staleness checks and the caller will receive an error.\n+\t\t\t\tresponse, err := a.buildPollActivityExecutionResponse(ctx, req)\n+\t\t\t\tif err != nil {\n+\t\t\t\t\treturn nil, true, err\n+\t\t\t\t}\n+\t\t\t\treturn response, true, nil","path":"chasm/lib/activity/handler.go","commit_id":"b24a0220435f567e7e3cacb95bd8fe78c17dc67b","original_commit_id":"f8ccafbb3c10a723c3180b7c0da6caee9ff4f073","user":{"login":"dandavison","id":52205,"node_id":"MDQ6VXNlcjUyMjA1","avatar_url":"https://avatars.githubusercontent.com/u/52205?v=4","gravatar_id":"","url":"https://api.github.com/users/dandavison","html_url":"https://github.com/dandavison","followers_url":"https://api.github.com/users/dandavison/followers","following_url":"https://api.github.com/users/dandavison/following{/other_user}","gists_url":"https://api.github.com/users/dandavison/gists{/gist_id}","starred_url":"https://api.github.com/users/dandavison/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/dandavison/subscriptions","organizations_url":"https://api.github.com/users/dandavison/orgs","repos_url":"https://api.github.com/users/dandavison/repos","events_url":"https://api.github.com/users/dandavison/events{/privacy}","received_events_url":"https://api.github.com/users/dandavison/received_events","type":"User","user_view_type":"public","site_admin":false},"body":"I think this is correct. Suppose we have this sequence:\r\n\r\n1. caller long-polls for first time, gets token\r\n2. activity fails and retries => runID changes\r\n3. caller sends second long-poll request, with token \r\n\r\nThe desired behavior now is for the server to respond immediately saying \"the state of your activity has changed since the last response I gave you; here's the latest state\".","created_at":"2025-11-13T00:38:01Z","updated_at":"2025-11-13T01:02:29Z","html_url":"https://github.com/temporalio/temporal/pull/8563#discussion_r2520476417","pull_request_url":"https://api.github.com/repos/temporalio/temporal/pulls/8563","_links":{"self":{"href":"https://api.github.com/repos/temporalio/temporal/pulls/comments/2520476417"},"html":{"href":"https://github.com/temporalio/temporal/pull/8563#discussion_r2520476417"},"pull_request":{"href":"https://api.github.com/repos/temporalio/temporal/pulls/8563"}},"reactions":{"url":"https://api.github.com/repos/temporalio/temporal/pulls/comments/2520476417/reactions","total_count":0,"+1":0,"-1":0,"laugh":0,"hooray":0,"confused":0,"heart":0,"rocket":0,"eyes":0},"start_line":null,"original_start_line":null,"start_side":null,"line":null,"original_line":169,"side":"RIGHT","in_reply_to_id":2520276996,"author_association":"MEMBER","original_position":127,"position":1,"subject_type":"line"},{"url":"https://api.github.com/repos/temporalio/temporal/pulls/comments/2520546887","pull_request_review_id":3456424590,"id":2520546887,"node_id":"PRRC_kwDODNqesM6WPH5H","diff_hunk":"@@ -51,3 +52,174 @@ func (h *handler) StartActivityExecution(ctx context.Context, req *activitypb.St\n \t\tFrontendResponse: response,\n \t}, nil\n }\n+\n+// PollActivityExecution handles PollActivityExecutionRequest from frontend. This method supports\n+// querying current activity state, optionally as a long-poll that waits for certain state changes.\n+// It is used by clients to poll for activity state and/or result.\n+func (h *handler) PollActivityExecution(\n+\tctx context.Context,\n+\treq *activitypb.PollActivityExecutionRequest,\n+) (*activitypb.PollActivityExecutionResponse, error) {\n+\tswitch req.GetFrontendRequest().GetWaitPolicy().(type) {\n+\tcase nil:\n+\t\treturn chasm.ReadComponent(\n+\t\t\tctx,\n+\t\t\tchasm.NewComponentRef[*Activity](chasm.EntityKey{\n+\t\t\t\tNamespaceID: req.GetNamespaceId(),\n+\t\t\t\tBusinessID:  req.GetFrontendRequest().GetActivityId(),\n+\t\t\t\tEntityID:    req.GetFrontendRequest().GetRunId(),\n+\t\t\t}),\n+\t\t\t(*Activity).buildPollActivityExecutionResponse,\n+\t\t\treq,\n+\t\t\tnil,\n+\t\t)\n+\tcase *workflowservice.PollActivityExecutionRequest_WaitAnyStateChange:\n+\t\treturn pollActivityExecutionWaitAnyStateChange(ctx, req)\n+\tcase *workflowservice.PollActivityExecutionRequest_WaitCompletion:\n+\t\treturn pollActivityExecutionWaitCompletion(ctx, req)\n+\tdefault:\n+\t\treturn nil, serviceerror.NewInvalidArgumentf(\"unexpected wait policy type: %T\", req.GetFrontendRequest().GetWaitPolicy())\n+\t}\n+}\n+\n+// pollActivityExecutionWaitAnyStateChange waits until the activity state has advanced beyond that\n+// specified by the submitted token. If no token was submitted, it returns the current state without\n+// waiting.\n+func pollActivityExecutionWaitAnyStateChange(\n+\tctx context.Context,\n+\treq *activitypb.PollActivityExecutionRequest,\n+) (*activitypb.PollActivityExecutionResponse, error) {\n+\n+\t// TODO(dan): do we want to guarantee that response data will differ from that received when the\n+\t// token was obtained? It's potentially confusing for the server to say \"there's been a change\"\n+\t// while returning data in which the change is not apparent.\n+\n+\trefBytesFromToken := req.GetFrontendRequest().\n+\t\tGetWaitPolicy().(*workflowservice.PollActivityExecutionRequest_WaitAnyStateChange).\n+\t\tWaitAnyStateChange.GetLongPollToken()\n+\n+\tvar lastSeenRef chasm.ComponentRef\n+\tif refBytesFromToken != nil {\n+\t\tvar err error\n+\t\tlastSeenRef, err = chasm.DeserializeComponentRef(refBytesFromToken)\n+\t\tif err != nil {\n+\t\t\treturn nil, serviceerror.NewInvalidArgument(\"invalid long poll token\")\n+\t\t}\n+\t\tif lastSeenRef.NamespaceID != req.GetNamespaceId() ||\n+\t\t\tlastSeenRef.BusinessID != req.GetFrontendRequest().GetActivityId() ||\n+\t\t\tlastSeenRef.EntityID != req.GetFrontendRequest().GetRunId() {\n+\t\t\t// token is inconsistent with request\n+\t\t\treturn nil, serviceerror.NewInvalidArgument(\"invalid long poll token\")\n+\t\t}\n+\t} else {\n+\t\t// This ref will compare less than currentRef in the comparison below.\n+\t\tlastSeenRef = chasm.NewComponentRef[*Activity](chasm.EntityKey{\n+\t\t\tNamespaceID: req.GetNamespaceId(),\n+\t\t\tBusinessID:  req.GetFrontendRequest().GetActivityId(),\n+\t\t\tEntityID:    req.GetFrontendRequest().GetRunId(),\n+\t\t})\n+\t}\n+\n+\t// PollComponent will return an error if lastSeenRef is not consistent with the entity\n+\t// transition history on this shard, or if the state on this shard is behind the ref after a\n+\t// reload.\n+\t// TODO(dan): retryability of these errors\n+\tresponse, newRef, err := chasm.PollComponent(\n+\t\tctx,\n+\t\tlastSeenRef,\n+\t\tfunc(\n+\t\t\ta *Activity,\n+\t\t\tctx chasm.Context,\n+\t\t\treq *activitypb.PollActivityExecutionRequest,\n+\t\t) (*activitypb.PollActivityExecutionResponse, bool, error) {\n+\t\t\t// TODO(dan): we're walking the tree to construct a ref when all we want here is the\n+\t\t\t// root/entity VT. Would it make sense for Context to provide access to root node?\n+\t\t\tcurrentRefBytes, err := ctx.Ref(a)\n+\t\t\tif err != nil {\n+\t\t\t\treturn nil, false, err\n+\t\t\t}\n+\t\t\tcurrentRef, err := chasm.DeserializeComponentRef(currentRefBytes)\n+\t\t\tif err != nil {\n+\t\t\t\treturn nil, false, err\n+\t\t\t}\n+\n+\t\t\tif lastSeenRef.EntityID != currentRef.EntityID {\n+\t\t\t\t// The runID from the token doesn't match this shard's state. We return immediately,\n+\t\t\t\t// on the basis that this constitutes a state change. If the runID from the token is\n+\t\t\t\t// ahead of this shard's state then this will be detected by shard ownership or\n+\t\t\t\t// staleness checks and the caller will receive an error.\n+\t\t\t\tresponse, err := a.buildPollActivityExecutionResponse(ctx, req)\n+\t\t\t\tif err != nil {\n+\t\t\t\t\treturn nil, true, err\n+\t\t\t\t}\n+\t\t\t\treturn response, true, nil\n+\t\t\t}\n+\n+\t\t\trefComparison, err := chasm.CompareComponentRefs(&lastSeenRef, &currentRef)\n+\t\t\tif err != nil {\n+\t\t\t\treturn nil, false, err\n+\t\t\t}\n+\t\t\tswitch refComparison {\n+\t\t\tcase -1:\n+\t\t\t\t// state has advanced beyond last seen: this is what we're waiting for\n+\t\t\t\tresponse, err := a.buildPollActivityExecutionResponse(ctx, req)\n+\t\t\t\tif err != nil {\n+\t\t\t\t\treturn nil, true, err\n+\t\t\t\t}\n+\t\t\t\treturn response, true, nil\n+\t\t\tcase 0:\n+\t\t\t\t// state is same as last seen: keep waiting\n+\t\t\t\treturn nil, false, nil\n+\t\t\tcase 1:\n+\t\t\t\t// Impossible: PollComponent guarantees that at this point, current VT >= lastSeen VT.\n+\t\t\t\treturn nil, false, serviceerror.NewFailedPrecondition(\"submitted long-poll token represents a state beyond current\")\n+\t\t\tdefault:\n+\t\t\t\t// Impossible\n+\t\t\t\treturn nil, false, serviceerror.NewInternal(\"unexpected transition history comparison result\")\n+\t\t\t}\n+\t\t},\n+\t\treq,\n+\t)\n+\tif err != nil {\n+\t\treturn nil, err\n+\t}\n+\tresponse.GetFrontendResponse().StateChangeLongPollToken = newRef\n+\treturn response, nil\n+}\n+\n+// pollActivityExecutionWaitCompletion waits until the activity is completed.\n+func pollActivityExecutionWaitCompletion(\n+\tctx context.Context,\n+\treq *activitypb.PollActivityExecutionRequest,\n+) (*activitypb.PollActivityExecutionResponse, error) {\n+\t// TODO(dan): implement functional test when RecordActivityTaskCompleted is implemented\n+\tresponse, newRef, err := chasm.PollComponent(\n+\t\tctx,\n+\t\tchasm.NewComponentRef[*Activity](chasm.EntityKey{\n+\t\t\tNamespaceID: req.GetNamespaceId(),\n+\t\t\tBusinessID:  req.GetFrontendRequest().GetActivityId(),\n+\t\t\tEntityID:    req.GetFrontendRequest().GetRunId(),\n+\t\t}),\n+\t\tfunc(\n+\t\t\ta *Activity,\n+\t\t\tctx chasm.Context,\n+\t\t\treq *activitypb.PollActivityExecutionRequest,\n+\t\t) (*activitypb.PollActivityExecutionResponse, bool, error) {\n+\t\t\tcompleted := a.StateMachineState() == activitypb.ACTIVITY_EXECUTION_STATUS_COMPLETED","path":"chasm/lib/activity/handler.go","commit_id":"a9026f431e35dbc9797001b54748761bd5d9cbd4","original_commit_id":"a9026f431e35dbc9797001b54748761bd5d9cbd4","user":{"login":"cursor[bot]","id":206951365,"node_id":"BOT_kgDODFXTxQ","avatar_url":"https://avatars.githubusercontent.com/in/1210556?v=4","gravatar_id":"","url":"https://api.github.com/users/cursor%5Bbot%5D","html_url":"https://github.com/apps/cursor","followers_url":"https://api.github.com/users/cursor%5Bbot%5D/followers","following_url":"https://api.github.com/users/cursor%5Bbot%5D/following{/other_user}","gists_url":"https://api.github.com/users/cursor%5Bbot%5D/gists{/gist_id}","starred_url":"https://api.github.com/users/cursor%5Bbot%5D/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/cursor%5Bbot%5D/subscriptions","organizations_url":"https://api.github.com/users/cursor%5Bbot%5D/orgs","repos_url":"https://api.github.com/users/cursor%5Bbot%5D/repos","events_url":"https://api.github.com/users/cursor%5Bbot%5D/events{/privacy}","received_events_url":"https://api.github.com/users/cursor%5Bbot%5D/received_events","type":"Bot","user_view_type":"public","site_admin":false},"body":"### Bug: Activity wait hangs on terminal failures.\n\n<!-- **High Severity** -->\n\n<!-- DESCRIPTION START -->\nThe `pollActivityExecutionWaitCompletion` function only checks for `ACTIVITY_EXECUTION_STATUS_COMPLETED` status but doesn't handle terminal failure states like `ACTIVITY_EXECUTION_STATUS_FAILED`, `ACTIVITY_EXECUTION_STATUS_CANCELED`, `ACTIVITY_EXECUTION_STATUS_TERMINATED`, and `ACTIVITY_EXECUTION_STATUS_TIMED_OUT`. This causes the function to wait indefinitely when the activity reaches a terminal non-successful state instead of returning the outcome. Based on the PR discussion asking \"should wait for completion encompass any terminal state\", the current implementation incorrectly excludes terminal failure states.\n<!-- DESCRIPTION END -->\n\n<!-- LOCATIONS START\nchasm/lib/activity/handler.go#L207-L208\nLOCATIONS END -->\n<a href=\"https://cursor.com/open?data=eyJhbGciOiJSUzI1NiIsInR5cCI6IkpXVCIsImtpZCI6ImJ1Z2JvdC12MSJ9.eyJ2ZXJzaW9uIjoxLCJ0eXBlIjoiQlVHQk9UX0ZJWF9JTl9DVVJTT1IiLCJkYXRhIjp7InJlZGlzS2V5IjoiYnVnYm90OjY1ODBhMjc5LTE5ZDktNDA4NS05OTIwLWY5ZDdhNThiNWRjMyIsImVuY3J5cHRpb25LZXkiOiJaMmlweF8wT05QTFFJQ3JiWTdOdW1fQUczQ3I3Tlc4Um1IcGl0ZXJZeFF3IiwiYnJhbmNoIjoicG9sbC1jb21wb25lbnQifSwiaWF0IjoxNzYyOTk1MzQ3LCJleHAiOjE3NjM2MDAxNDd9.E0x2GWtZFf1Nt602L4xV85YFh8pOTbUA1x_UX-HlSAkcOdnCM-Idarqj1ZxcJTV0ByYB-AovT6MJkkZpzKIsKbWy694h9wLtqECiTa3mB-4JE6bQX_RwGGENdnNNfP1Yc-4kseO14Ui2054RSgCgbHTidW6BJAzc07dVVH_xE6M2-g-ru5pcZmFfHVIQrs7_QYyIZptDn52OL7dgGArXv6rD44T01dbL2f-qNsgVbPTUODtBBDwlmGCft_OOG42LnDxbUDRhtysc3_9KKgZhHT9l7qDu4YpNTf09qyrwmgqWZy7Z5L3qqHlxHVw2KJeduF2c6MheKagiVQTMck2-vQ\"><picture><source media=\"(prefers-color-scheme: dark)\" srcset=\"https://cursor.com/fix-in-cursor-dark.svg\"><source media=\"(prefers-color-scheme: light)\" srcset=\"https://cursor.com/fix-in-cursor-light.svg\"><img alt=\"Fix in Cursor\" src=\"https://cursor.com/fix-in-cursor.svg\"></picture></a>&nbsp;<a href=\"https://cursor.com/agents?data=eyJhbGciOiJSUzI1NiIsInR5cCI6IkpXVCIsImtpZCI6ImJ1Z2JvdC12MSJ9.eyJ2ZXJzaW9uIjoxLCJ0eXBlIjoiQlVHQk9UX0ZJWF9JTl9XRUIiLCJkYXRhIjp7InJlZGlzS2V5IjoiYnVnYm90OjY1ODBhMjc5LTE5ZDktNDA4NS05OTIwLWY5ZDdhNThiNWRjMyIsImVuY3J5cHRpb25LZXkiOiJaMmlweF8wT05QTFFJQ3JiWTdOdW1fQUczQ3I3Tlc4Um1IcGl0ZXJZeFF3IiwiYnJhbmNoIjoicG9sbC1jb21wb25lbnQiLCJyZXBvT3duZXIiOiJ0ZW1wb3JhbGlvIiwicmVwb05hbWUiOiJ0ZW1wb3JhbCIsInByTnVtYmVyIjo4NTYzLCJjb21taXRTaGEiOiJhOTAyNmY0MzFlMzVkYmM5Nzk3MDAxYjU0NzQ4NzYxYmQ1ZDljYmQ0In0sImlhdCI6MTc2Mjk5NTM0NywiZXhwIjoxNzYzNjAwMTQ3fQ.fKLqwQvx_C0--6wdrX4Fi7HWIDOesjZwWJC1YoHxQwUKmv435nC6vBPL2jbTRic3VaC_cAeCwXPKmGMKLxxDr83hBUiThBpuCtGa81L6Rcn5LCzzvAORbJk8HRqCOnpoud2spUGZbTBEYxjZlsw3mDICYh96hahPQgl_iqyXOZ3yM7tLDgh5fWdHXJaDBlSCSKW3yJHYinat7vNgNMrwW1O1j2L1Bhs9wpatYLeKO0yyG0KQif4nEs2LmFhXlsyJ3i81hx0A2PNjxPmZKvctrPPdXmYrkwS-xzkLBd-arviTIzMCzNyBpmAzjFebKvUc4nHzDSn5TxCyrrWKPB7lKw\"><picture><source media=\"(prefers-color-scheme: dark)\" srcset=\"https://cursor.com/fix-in-web-dark.svg\"><source media=\"(prefers-color-scheme: light)\" srcset=\"https://cursor.com/fix-in-web-light.svg\"><img alt=\"Fix in Web\" src=\"https://cursor.com/fix-in-web.svg\"></picture></a>\n\n","created_at":"2025-11-13T00:55:47Z","updated_at":"2025-11-13T00:55:47Z","html_url":"https://github.com/temporalio/temporal/pull/8563#discussion_r2520546887","pull_request_url":"https://api.github.com/repos/temporalio/temporal/pulls/8563","_links":{"self":{"href":"https://api.github.com/repos/temporalio/temporal/pulls/comments/2520546887"},"html":{"href":"https://github.com/temporalio/temporal/pull/8563#discussion_r2520546887"},"pull_request":{"href":"https://api.github.com/repos/temporalio/temporal/pulls/8563"}},"reactions":{"url":"https://api.github.com/repos/temporalio/temporal/pulls/comments/2520546887/reactions","total_count":0,"+1":0,"-1":0,"laugh":0,"hooray":0,"confused":0,"heart":0,"rocket":0,"eyes":0},"start_line":null,"original_start_line":null,"start_side":null,"line":null,"original_line":208,"side":"RIGHT","author_association":"NONE","original_position":165,"position":1,"subject_type":"line"},{"url":"https://api.github.com/repos/temporalio/temporal/pulls/comments/2520567497","pull_request_review_id":3456299008,"id":2520567497,"node_id":"PRRC_kwDODNqesM6WPM7J","diff_hunk":"@@ -51,3 +53,177 @@ func (h *handler) StartActivityExecution(ctx context.Context, req *activitypb.St\n \t\tFrontendResponse: response,\n \t}, nil\n }\n+\n+// PollActivityExecution handles PollActivityExecutionRequest from frontend. This method supports\n+// querying current activity state, optionally as a long-poll that waits for certain state changes.\n+// It is used by clients to poll for activity state and/or result.\n+func (h *handler) PollActivityExecution(\n+\tctx context.Context,\n+\treq *activitypb.PollActivityExecutionRequest,\n+) (*activitypb.PollActivityExecutionResponse, error) {\n+\n+\twaitPolicy := req.GetFrontendRequest().GetWaitPolicy()\n+\tif waitPolicy == nil {\n+\t\treturn chasm.ReadComponent(\n+\t\t\tctx,\n+\t\t\tchasm.NewComponentRef[*Activity](chasm.EntityKey{\n+\t\t\t\tNamespaceID: req.GetNamespaceId(),\n+\t\t\t\tBusinessID:  req.GetFrontendRequest().GetActivityId(),\n+\t\t\t\tEntityID:    req.GetFrontendRequest().GetRunId(),\n+\t\t\t}),\n+\t\t\t(*Activity).buildPollActivityExecutionResponse,\n+\t\t\treq,\n+\t\t\tnil,\n+\t\t)\n+\t}\n+\n+\tvar response *activitypb.PollActivityExecutionResponse\n+\tvar newRef []byte\n+\tvar err error\n+\n+\tswitch waitPolicy.(type) {\n+\tcase *workflowservice.PollActivityExecutionRequest_WaitAnyStateChange:\n+\t\tresponse, newRef, err = pollActivityExecutionWaitAnyStateChange(ctx, req)\n+\tcase *workflowservice.PollActivityExecutionRequest_WaitCompletion:\n+\t\tresponse, newRef, err = pollActivityExecutionWaitCompletion(ctx, req)\n+\tdefault:\n+\t\treturn nil, fmt.Errorf(\"unexpected wait policy type: %T\", waitPolicy)\n+\t}\n+\tif err != nil {\n+\t\treturn nil, err\n+\t}\n+\tresponse.GetFrontendResponse().StateChangeLongPollToken = newRef\n+\treturn response, nil\n+}\n+\n+// pollActivityExecutionWaitAnyStateChange waits until the activity state has advanced beyond that\n+// specified by the submitted token. If no token was submitted, it returns the current state without\n+// waiting.\n+func pollActivityExecutionWaitAnyStateChange(\n+\tctx context.Context,\n+\treq *activitypb.PollActivityExecutionRequest,\n+) (*activitypb.PollActivityExecutionResponse, []byte, error) {\n+\n+\t// TODO(dan): do we want to guarantee that response data will differ from that received when the\n+\t// token was obtained? It's potentially confusing for the server to say \"there's been a change\"\n+\t// while returning data in which the change is not apparent.\n+\n+\trefBytesFromToken := req.GetFrontendRequest().\n+\t\tGetWaitPolicy().(*workflowservice.PollActivityExecutionRequest_WaitAnyStateChange).\n+\t\tWaitAnyStateChange.GetLongPollToken()\n+\n+\tvar lastSeenRef chasm.ComponentRef\n+\tif refBytesFromToken != nil {\n+\t\tvar err error\n+\t\tlastSeenRef, err = chasm.DeserializeComponentRef(refBytesFromToken)\n+\t\tif err != nil {\n+\t\t\treturn nil, nil, serviceerror.NewInvalidArgument(\"invalid long poll token\")\n+\t\t}\n+\t\tif lastSeenRef.NamespaceID != req.GetNamespaceId() ||\n+\t\t\tlastSeenRef.BusinessID != req.GetFrontendRequest().GetActivityId() ||\n+\t\t\tlastSeenRef.EntityID != req.GetFrontendRequest().GetRunId() {\n+\t\t\t// token is inconsistent with request\n+\t\t\treturn nil, nil, serviceerror.NewInvalidArgument(\"invalid long poll token\")\n+\t\t}\n+\t} else {\n+\t\t// This ref will compare less than currentRef in the comparison below.\n+\t\tlastSeenRef = chasm.NewComponentRef[*Activity](chasm.EntityKey{\n+\t\t\tNamespaceID: req.GetNamespaceId(),\n+\t\t\tBusinessID:  req.GetFrontendRequest().GetActivityId(),\n+\t\t\tEntityID:    req.GetFrontendRequest().GetRunId(),\n+\t\t})\n+\t}\n+\n+\t// PollComponent will return an error if lastSeenRef is not consistent with the entity\n+\t// transition history on this shard, or if the state on this shard is behind the ref after a\n+\t// reload.\n+\t// TODO(dan): retryability of these errors\n+\treturn chasm.PollComponent(\n+\t\tctx,\n+\t\tlastSeenRef,\n+\t\tfunc(\n+\t\t\ta *Activity,\n+\t\t\tctx chasm.Context,\n+\t\t\treq *activitypb.PollActivityExecutionRequest,\n+\t\t) (*activitypb.PollActivityExecutionResponse, bool, error) {\n+\t\t\t// TODO(dan): we're walking the tree to construct a ref when all we want here is the\n+\t\t\t// root/entity VT. Would it make sense for Context to provide access to root node?\n+\t\t\tcurrentRefBytes, err := ctx.Ref(a)\n+\t\t\tif err != nil {\n+\t\t\t\treturn nil, false, err\n+\t\t\t}\n+\t\t\tcurrentRef, err := chasm.DeserializeComponentRef(currentRefBytes)\n+\t\t\tif err != nil {\n+\t\t\t\treturn nil, false, err\n+\t\t\t}\n+\n+\t\t\tif lastSeenRef.EntityID != currentRef.EntityID {\n+\t\t\t\t// The runID from the token doesn't match this shard's state. We return immediately,\n+\t\t\t\t// on the basis that this constitutes a state change. If the runID from the token is\n+\t\t\t\t// ahead of this shard's state then this will be detected by shard ownership or\n+\t\t\t\t// staleness checks and the caller will receive an error.\n+\t\t\t\tresponse, err := a.buildPollActivityExecutionResponse(ctx, req)\n+\t\t\t\tif err != nil {\n+\t\t\t\t\treturn nil, true, err\n+\t\t\t\t}\n+\t\t\t\treturn response, true, nil\n+\t\t\t}\n+\n+\t\t\trefComparison, err := chasm.CompareComponentRefs(&lastSeenRef, &currentRef)\n+\t\t\tif err != nil {\n+\t\t\t\treturn nil, false, err\n+\t\t\t}\n+\t\t\tswitch refComparison {\n+\t\t\tcase -1:\n+\t\t\t\t// state has advanced beyond last seen: this is what we're waiting for\n+\t\t\t\tresponse, err := a.buildPollActivityExecutionResponse(ctx, req)\n+\t\t\t\tif err != nil {\n+\t\t\t\t\treturn nil, true, err\n+\t\t\t\t}\n+\t\t\t\treturn response, true, nil\n+\t\t\tcase 0:\n+\t\t\t\t// state is same as last seen: keep waiting\n+\t\t\t\treturn nil, false, nil\n+\t\t\tcase 1:\n+\t\t\t\t// Impossible: PollComponent guarantees that at this point, current VT >= lastSeen VT.\n+\t\t\t\treturn nil, false, serviceerror.NewFailedPrecondition(\"submitted long-poll token represents a state beyond current\")\n+\t\t\tdefault:\n+\t\t\t\t// Impossible\n+\t\t\t\treturn nil, false, serviceerror.NewInternal(\"unexpected transition history comparison result\")\n+\t\t\t}\n+\t\t},\n+\t\treq,\n+\t)\n+}\n+\n+// pollActivityExecutionWaitCompletion waits until the activity is completed.\n+func pollActivityExecutionWaitCompletion(\n+\tctx context.Context,\n+\treq *activitypb.PollActivityExecutionRequest,\n+) (*activitypb.PollActivityExecutionResponse, []byte, error) {\n+\t// TODO(dan): implement functional test when RecordActivityTaskCompleted is implemented\n+\treturn chasm.PollComponent(\n+\t\tctx,\n+\t\tchasm.NewComponentRef[*Activity](chasm.EntityKey{\n+\t\t\tNamespaceID: req.GetNamespaceId(),\n+\t\t\tBusinessID:  req.GetFrontendRequest().GetActivityId(),\n+\t\t\tEntityID:    req.GetFrontendRequest().GetRunId(),\n+\t\t}),\n+\t\tfunc(\n+\t\t\ta *Activity,\n+\t\t\tctx chasm.Context,\n+\t\t\treq *activitypb.PollActivityExecutionRequest,\n+\t\t) (*activitypb.PollActivityExecutionResponse, bool, error) {\n+\t\t\tcompleted := a.StateMachineState() == activitypb.ACTIVITY_EXECUTION_STATUS_COMPLETED","path":"chasm/lib/activity/handler.go","commit_id":"a9026f431e35dbc9797001b54748761bd5d9cbd4","original_commit_id":"f8ccafbb3c10a723c3180b7c0da6caee9ff4f073","user":{"login":"dandavison","id":52205,"node_id":"MDQ6VXNlcjUyMjA1","avatar_url":"https://avatars.githubusercontent.com/u/52205?v=4","gravatar_id":"","url":"https://api.github.com/users/dandavison","html_url":"https://github.com/dandavison","followers_url":"https://api.github.com/users/dandavison/followers","following_url":"https://api.github.com/users/dandavison/following{/other_user}","gists_url":"https://api.github.com/users/dandavison/gists{/gist_id}","starred_url":"https://api.github.com/users/dandavison/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/dandavison/subscriptions","organizations_url":"https://api.github.com/users/dandavison/orgs","repos_url":"https://api.github.com/users/dandavison/repos","events_url":"https://api.github.com/users/dandavison/events{/privacy}","received_events_url":"https://api.github.com/users/dandavison/received_events","type":"User","user_view_type":"public","site_admin":false},"body":"Oops thanks, you're right. This method hasn't been tested at all (since we don't yet have completion APIs), and I haven't thought through the state transitions. I'm replacing this not-throught-through implementation with a panic and we can finish it when we do the completion APIs.","created_at":"2025-11-13T01:00:49Z","updated_at":"2025-11-13T11:13:35Z","html_url":"https://github.com/temporalio/temporal/pull/8563#discussion_r2520567497","pull_request_url":"https://api.github.com/repos/temporalio/temporal/pulls/8563","_links":{"self":{"href":"https://api.github.com/repos/temporalio/temporal/pulls/comments/2520567497"},"html":{"href":"https://github.com/temporalio/temporal/pull/8563#discussion_r2520567497"},"pull_request":{"href":"https://api.github.com/repos/temporalio/temporal/pulls/8563"}},"reactions":{"url":"https://api.github.com/repos/temporalio/temporal/pulls/comments/2520567497/reactions","total_count":0,"+1":0,"-1":0,"laugh":0,"hooray":0,"confused":0,"heart":0,"rocket":0,"eyes":0},"start_line":null,"original_start_line":null,"start_side":null,"line":null,"original_line":217,"side":"RIGHT","in_reply_to_id":2520298163,"author_association":"MEMBER","original_position":175,"position":1,"subject_type":"line"},{"url":"https://api.github.com/repos/temporalio/temporal/pulls/comments/2520588755","pull_request_review_id":3456465254,"id":2520588755,"node_id":"PRRC_kwDODNqesM6WPSHT","diff_hunk":"@@ -51,3 +53,177 @@ func (h *handler) StartActivityExecution(ctx context.Context, req *activitypb.St\n \t\tFrontendResponse: response,\n \t}, nil\n }\n+\n+// PollActivityExecution handles PollActivityExecutionRequest from frontend. This method supports\n+// querying current activity state, optionally as a long-poll that waits for certain state changes.\n+// It is used by clients to poll for activity state and/or result.\n+func (h *handler) PollActivityExecution(\n+\tctx context.Context,\n+\treq *activitypb.PollActivityExecutionRequest,\n+) (*activitypb.PollActivityExecutionResponse, error) {\n+\n+\twaitPolicy := req.GetFrontendRequest().GetWaitPolicy()\n+\tif waitPolicy == nil {\n+\t\treturn chasm.ReadComponent(\n+\t\t\tctx,\n+\t\t\tchasm.NewComponentRef[*Activity](chasm.EntityKey{\n+\t\t\t\tNamespaceID: req.GetNamespaceId(),\n+\t\t\t\tBusinessID:  req.GetFrontendRequest().GetActivityId(),\n+\t\t\t\tEntityID:    req.GetFrontendRequest().GetRunId(),\n+\t\t\t}),\n+\t\t\t(*Activity).buildPollActivityExecutionResponse,\n+\t\t\treq,\n+\t\t\tnil,\n+\t\t)\n+\t}\n+\n+\tvar response *activitypb.PollActivityExecutionResponse\n+\tvar newRef []byte\n+\tvar err error\n+\n+\tswitch waitPolicy.(type) {\n+\tcase *workflowservice.PollActivityExecutionRequest_WaitAnyStateChange:\n+\t\tresponse, newRef, err = pollActivityExecutionWaitAnyStateChange(ctx, req)\n+\tcase *workflowservice.PollActivityExecutionRequest_WaitCompletion:\n+\t\tresponse, newRef, err = pollActivityExecutionWaitCompletion(ctx, req)\n+\tdefault:\n+\t\treturn nil, fmt.Errorf(\"unexpected wait policy type: %T\", waitPolicy)\n+\t}\n+\tif err != nil {\n+\t\treturn nil, err\n+\t}\n+\tresponse.GetFrontendResponse().StateChangeLongPollToken = newRef","path":"chasm/lib/activity/handler.go","commit_id":"f8ccafbb3c10a723c3180b7c0da6caee9ff4f073","original_commit_id":"a1b89b2df945362cc0235d9a826c6646855b3d6f","user":{"login":"dandavison","id":52205,"node_id":"MDQ6VXNlcjUyMjA1","avatar_url":"https://avatars.githubusercontent.com/u/52205?v=4","gravatar_id":"","url":"https://api.github.com/users/dandavison","html_url":"https://github.com/dandavison","followers_url":"https://api.github.com/users/dandavison/followers","following_url":"https://api.github.com/users/dandavison/following{/other_user}","gists_url":"https://api.github.com/users/dandavison/gists{/gist_id}","starred_url":"https://api.github.com/users/dandavison/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/dandavison/subscriptions","organizations_url":"https://api.github.com/users/dandavison/orgs","repos_url":"https://api.github.com/users/dandavison/repos","events_url":"https://api.github.com/users/dandavison/events{/privacy}","received_events_url":"https://api.github.com/users/dandavison/received_events","type":"User","user_view_type":"public","site_admin":false},"body":"Thanks, I'd been going back and forwards on this part of the code and I realize that you're right -- I do prefer it the way you suggest. Changed!","created_at":"2025-11-13T01:06:06Z","updated_at":"2025-11-13T11:12:49Z","html_url":"https://github.com/temporalio/temporal/pull/8563#discussion_r2520588755","pull_request_url":"https://api.github.com/repos/temporalio/temporal/pulls/8563","_links":{"self":{"href":"https://api.github.com/repos/temporalio/temporal/pulls/comments/2520588755"},"html":{"href":"https://github.com/temporalio/temporal/pull/8563#discussion_r2520588755"},"pull_request":{"href":"https://api.github.com/repos/temporalio/temporal/pulls/8563"}},"reactions":{"url":"https://api.github.com/repos/temporalio/temporal/pulls/comments/2520588755/reactions","total_count":0,"+1":0,"-1":0,"laugh":0,"hooray":0,"confused":0,"heart":0,"rocket":0,"eyes":0},"start_line":null,"original_start_line":null,"start_side":null,"line":null,"original_line":95,"side":"RIGHT","in_reply_to_id":2520083941,"author_association":"MEMBER","original_position":53,"position":1,"subject_type":"line"},{"url":"https://api.github.com/repos/temporalio/temporal/pulls/comments/2524046642","pull_request_review_id":3460529613,"id":2524046642,"node_id":"PRRC_kwDODNqesM6WceUy","diff_hunk":"@@ -241,14 +278,173 @@ func (e *ChasmEngine) ReadComponent(\n \treturn readFn(chasmContext, component)\n }\n \n+// PollComponent waits until the supplied predicate is satisfied when evaluated against the\n+// component identified by the supplied component reference. If it times out due to the\n+// server-imposed long-poll timeout then it returns (nil, nil). Otherwise if there is no error, it\n+// returns (ref, nil) where ref is a component reference identifying the state at which the\n+// predicate was satisfied. It is an error if entity transition history is (after reloading from\n+// persistence) behind the requested ref, or if the ref is not consistent with entity transition\n+// history. Thus when the predicate function is evaluated, it is guaranteed that the entity VT >=\n+// requestRef VT.\n func (e *ChasmEngine) PollComponent(\n \tctx context.Context,\n-\tentityRef chasm.ComponentRef,\n-\tpredicateFn func(chasm.Context, chasm.Component) (any, bool, error),\n-\toperationFn func(chasm.MutableContext, chasm.Component, any) error,\n-\topts ...chasm.TransitionOption,\n-) (newEntityRef []byte, retError error) {\n-\treturn nil, serviceerror.NewUnimplemented(\"PollComponent is not yet supported\")\n+\trequestRef chasm.ComponentRef,\n+\tpredicateFn func(chasm.Context, chasm.Component) (bool, error),\n+) ([]byte, error) {\n+\t// 1. Acquire lock\n+\t// 2. Error if shard entity VT < requestRef VT ('stale state')\n+\t// 3. If predicate satisfied, release lock and return\n+\t// 4. Subscribe to notifications for this entity\n+\t// 5. Release lock\n+\t// 6. On notification repeat (1) and (2)\n+\n+\tshardContext, executionLease, err := e.getExecutionLease(ctx, requestRef)\n+\tif err != nil {\n+\t\t// E.g. requestRef VT inconsistent with shard VT ('stale reference')\n+\t\treturn nil, err\n+\t}\n+\n+\t// hold lock until return or subscription established\n+\treleased := false\n+\tdefer func() {\n+\t\tif !released {\n+\t\t\t// read-only operation; don't pass error\n+\t\t\texecutionLease.GetReleaseFn()(nil)\n+\t\t}\n+\t}()\n+\n+\t// At this point it's possible that shard VT < requestRef VT (getExecutionLease does not\n+\t// guarantee that returned shard state is non-stale w.r.t. requestRef).\n+\tcurrentRef, err := e.checkPredicate(ctx, requestRef, executionLease, predicateFn)\n+\tif err != nil {\n+\t\treturn nil, err\n+\t}\n+\t// shard VT >= requestRef VT (enforced by checkPredicate)\n+\n+\tif currentRef != nil {\n+\t\t// wait condition was satisfied\n+\t\treturn currentRef, nil\n+\t}\n+\n+\t// Wait condition not satisfied; long-poll\n+\n+\tchannel, subscriberID, err := e.notifier.Subscribe(requestRef.EntityKey)\n+\tif err != nil {\n+\t\treturn nil, err\n+\t}\n+\tdefer func() {\n+\t\t_ = e.notifier.Unsubscribe(requestRef.EntityKey, subscriberID)\n+\t}()\n+\n+\t// Release the lock, now that we are subscribed\n+\texecutionLease.GetReleaseFn()(nil)\n+\treleased = true\n+\n+\tnamespaceRegistry, err := shardContext.GetNamespaceRegistry().GetNamespaceByID(\n+\t\tnamespace.ID(requestRef.EntityKey.NamespaceID),\n+\t)\n+\tif err != nil {\n+\t\treturn nil, err\n+\t}\n+\n+\t// Long-poll timeout semantics are the same as PollWorkflowExecutionUpdate: if the long-poll\n+\t// times out due to the server-imposed soft timeout, then return a non-error empty response\n+\t// indicating to a caller that they should continue long-polling.\n+\n+\t// TODO(dan): GetOrPollMutableState uses\n+\t// longPollInterval := shardContext.GetConfig().LongPollExpirationInterval(namespaceRegistry.Name().String())\n+\t// longPollCtx, cancel := contextutil.WithDeadlineBuffer(ctx, longPollInterval, longPollSoftTimeout)\n+\tsoftTimeout := shardContext.GetConfig().LongPollExpirationInterval(namespaceRegistry.Name().String())\n+\tstCtx, stCancel := context.WithTimeout(ctx, softTimeout)\n+\tdefer stCancel()","path":"service/history/chasm_engine.go","commit_id":"da6009564e796063faf853352077eecdc1473612","original_commit_id":"6a143cd1b107c501afb04b509304e46a9da03e6d","user":{"login":"dandavison","id":52205,"node_id":"MDQ6VXNlcjUyMjA1","avatar_url":"https://avatars.githubusercontent.com/u/52205?v=4","gravatar_id":"","url":"https://api.github.com/users/dandavison","html_url":"https://github.com/dandavison","followers_url":"https://api.github.com/users/dandavison/followers","following_url":"https://api.github.com/users/dandavison/following{/other_user}","gists_url":"https://api.github.com/users/dandavison/gists{/gist_id}","starred_url":"https://api.github.com/users/dandavison/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/dandavison/subscriptions","organizations_url":"https://api.github.com/users/dandavison/orgs","repos_url":"https://api.github.com/users/dandavison/repos","events_url":"https://api.github.com/users/dandavison/events{/privacy}","received_events_url":"https://api.github.com/users/dandavison/received_events","type":"User","user_view_type":"public","site_admin":false},"body":"I'm still thinking about the timeouts and time budgeting here.","created_at":"2025-11-13T16:04:19Z","updated_at":"2025-11-13T17:25:34Z","html_url":"https://github.com/temporalio/temporal/pull/8563#discussion_r2524046642","pull_request_url":"https://api.github.com/repos/temporalio/temporal/pulls/8563","_links":{"self":{"href":"https://api.github.com/repos/temporalio/temporal/pulls/comments/2524046642"},"html":{"href":"https://github.com/temporalio/temporal/pull/8563#discussion_r2524046642"},"pull_request":{"href":"https://api.github.com/repos/temporalio/temporal/pulls/8563"}},"reactions":{"url":"https://api.github.com/repos/temporalio/temporal/pulls/comments/2524046642/reactions","total_count":0,"+1":0,"-1":0,"laugh":0,"hooray":0,"confused":0,"heart":0,"rocket":0,"eyes":0},"start_line":null,"original_start_line":null,"start_side":null,"line":null,"original_line":358,"side":"RIGHT","author_association":"MEMBER","original_position":180,"position":1,"subject_type":"line"},{"url":"https://api.github.com/repos/temporalio/temporal/pulls/comments/2524176351","pull_request_review_id":3460701024,"id":2524176351,"node_id":"PRRC_kwDODNqesM6Wc9_f","diff_hunk":"@@ -51,3 +53,177 @@ func (h *handler) StartActivityExecution(ctx context.Context, req *activitypb.St\n \t\tFrontendResponse: response,\n \t}, nil\n }\n+\n+// PollActivityExecution handles PollActivityExecutionRequest from frontend. This method supports\n+// querying current activity state, optionally as a long-poll that waits for certain state changes.\n+// It is used by clients to poll for activity state and/or result.\n+func (h *handler) PollActivityExecution(\n+\tctx context.Context,\n+\treq *activitypb.PollActivityExecutionRequest,\n+) (*activitypb.PollActivityExecutionResponse, error) {\n+\n+\twaitPolicy := req.GetFrontendRequest().GetWaitPolicy()\n+\tif waitPolicy == nil {\n+\t\treturn chasm.ReadComponent(\n+\t\t\tctx,\n+\t\t\tchasm.NewComponentRef[*Activity](chasm.EntityKey{\n+\t\t\t\tNamespaceID: req.GetNamespaceId(),\n+\t\t\t\tBusinessID:  req.GetFrontendRequest().GetActivityId(),\n+\t\t\t\tEntityID:    req.GetFrontendRequest().GetRunId(),\n+\t\t\t}),\n+\t\t\t(*Activity).buildPollActivityExecutionResponse,\n+\t\t\treq,\n+\t\t\tnil,\n+\t\t)\n+\t}\n+\n+\tvar response *activitypb.PollActivityExecutionResponse\n+\tvar newRef []byte\n+\tvar err error\n+\n+\tswitch waitPolicy.(type) {\n+\tcase *workflowservice.PollActivityExecutionRequest_WaitAnyStateChange:\n+\t\tresponse, newRef, err = pollActivityExecutionWaitAnyStateChange(ctx, req)\n+\tcase *workflowservice.PollActivityExecutionRequest_WaitCompletion:\n+\t\tresponse, newRef, err = pollActivityExecutionWaitCompletion(ctx, req)\n+\tdefault:\n+\t\treturn nil, fmt.Errorf(\"unexpected wait policy type: %T\", waitPolicy)\n+\t}\n+\tif err != nil {\n+\t\treturn nil, err\n+\t}\n+\tresponse.GetFrontendResponse().StateChangeLongPollToken = newRef\n+\treturn response, nil\n+}\n+\n+// pollActivityExecutionWaitAnyStateChange waits until the activity state has advanced beyond that\n+// specified by the submitted token. If no token was submitted, it returns the current state without\n+// waiting.\n+func pollActivityExecutionWaitAnyStateChange(\n+\tctx context.Context,\n+\treq *activitypb.PollActivityExecutionRequest,\n+) (*activitypb.PollActivityExecutionResponse, []byte, error) {\n+\n+\t// TODO(dan): do we want to guarantee that response data will differ from that received when the\n+\t// token was obtained? It's potentially confusing for the server to say \"there's been a change\"\n+\t// while returning data in which the change is not apparent.\n+\n+\trefBytesFromToken := req.GetFrontendRequest().\n+\t\tGetWaitPolicy().(*workflowservice.PollActivityExecutionRequest_WaitAnyStateChange).\n+\t\tWaitAnyStateChange.GetLongPollToken()\n+\n+\tvar lastSeenRef chasm.ComponentRef\n+\tif refBytesFromToken != nil {\n+\t\tvar err error\n+\t\tlastSeenRef, err = chasm.DeserializeComponentRef(refBytesFromToken)\n+\t\tif err != nil {\n+\t\t\treturn nil, nil, serviceerror.NewInvalidArgument(\"invalid long poll token\")\n+\t\t}\n+\t\tif lastSeenRef.NamespaceID != req.GetNamespaceId() ||\n+\t\t\tlastSeenRef.BusinessID != req.GetFrontendRequest().GetActivityId() ||\n+\t\t\tlastSeenRef.EntityID != req.GetFrontendRequest().GetRunId() {\n+\t\t\t// token is inconsistent with request\n+\t\t\treturn nil, nil, serviceerror.NewInvalidArgument(\"invalid long poll token\")\n+\t\t}\n+\t} else {\n+\t\t// This ref will compare less than currentRef in the comparison below.\n+\t\tlastSeenRef = chasm.NewComponentRef[*Activity](chasm.EntityKey{\n+\t\t\tNamespaceID: req.GetNamespaceId(),\n+\t\t\tBusinessID:  req.GetFrontendRequest().GetActivityId(),\n+\t\t\tEntityID:    req.GetFrontendRequest().GetRunId(),\n+\t\t})\n+\t}\n+\n+\t// PollComponent will return an error if lastSeenRef is not consistent with the entity\n+\t// transition history on this shard, or if the state on this shard is behind the ref after a\n+\t// reload.\n+\t// TODO(dan): retryability of these errors\n+\treturn chasm.PollComponent(\n+\t\tctx,\n+\t\tlastSeenRef,\n+\t\tfunc(\n+\t\t\ta *Activity,\n+\t\t\tctx chasm.Context,\n+\t\t\treq *activitypb.PollActivityExecutionRequest,\n+\t\t) (*activitypb.PollActivityExecutionResponse, bool, error) {\n+\t\t\t// TODO(dan): we're walking the tree to construct a ref when all we want here is the\n+\t\t\t// root/entity VT. Would it make sense for Context to provide access to root node?\n+\t\t\tcurrentRefBytes, err := ctx.Ref(a)\n+\t\t\tif err != nil {\n+\t\t\t\treturn nil, false, err\n+\t\t\t}\n+\t\t\tcurrentRef, err := chasm.DeserializeComponentRef(currentRefBytes)\n+\t\t\tif err != nil {\n+\t\t\t\treturn nil, false, err\n+\t\t\t}\n+\n+\t\t\tif lastSeenRef.EntityID != currentRef.EntityID {\n+\t\t\t\t// The runID from the token doesn't match this shard's state. We return immediately,\n+\t\t\t\t// on the basis that this constitutes a state change. If the runID from the token is\n+\t\t\t\t// ahead of this shard's state then this will be detected by shard ownership or\n+\t\t\t\t// staleness checks and the caller will receive an error.\n+\t\t\t\tresponse, err := a.buildPollActivityExecutionResponse(ctx, req)\n+\t\t\t\tif err != nil {\n+\t\t\t\t\treturn nil, true, err\n+\t\t\t\t}\n+\t\t\t\treturn response, true, nil","path":"chasm/lib/activity/handler.go","commit_id":"b24a0220435f567e7e3cacb95bd8fe78c17dc67b","original_commit_id":"f8ccafbb3c10a723c3180b7c0da6caee9ff4f073","user":{"login":"fretz12","id":41805201,"node_id":"MDQ6VXNlcjQxODA1MjAx","avatar_url":"https://avatars.githubusercontent.com/u/41805201?v=4","gravatar_id":"","url":"https://api.github.com/users/fretz12","html_url":"https://github.com/fretz12","followers_url":"https://api.github.com/users/fretz12/followers","following_url":"https://api.github.com/users/fretz12/following{/other_user}","gists_url":"https://api.github.com/users/fretz12/gists{/gist_id}","starred_url":"https://api.github.com/users/fretz12/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/fretz12/subscriptions","organizations_url":"https://api.github.com/users/fretz12/orgs","repos_url":"https://api.github.com/users/fretz12/repos","events_url":"https://api.github.com/users/fretz12/events{/privacy}","received_events_url":"https://api.github.com/users/fretz12/received_events","type":"User","user_view_type":"public","site_admin":false},"body":"ok, that behavior makes sense","created_at":"2025-11-13T16:40:49Z","updated_at":"2025-11-13T16:40:49Z","html_url":"https://github.com/temporalio/temporal/pull/8563#discussion_r2524176351","pull_request_url":"https://api.github.com/repos/temporalio/temporal/pulls/8563","_links":{"self":{"href":"https://api.github.com/repos/temporalio/temporal/pulls/comments/2524176351"},"html":{"href":"https://github.com/temporalio/temporal/pull/8563#discussion_r2524176351"},"pull_request":{"href":"https://api.github.com/repos/temporalio/temporal/pulls/8563"}},"reactions":{"url":"https://api.github.com/repos/temporalio/temporal/pulls/comments/2524176351/reactions","total_count":0,"+1":0,"-1":0,"laugh":0,"hooray":0,"confused":0,"heart":0,"rocket":0,"eyes":0},"start_line":null,"original_start_line":null,"start_side":null,"line":null,"original_line":169,"side":"RIGHT","in_reply_to_id":2520276996,"author_association":"MEMBER","original_position":127,"position":1,"subject_type":"line"},{"url":"https://api.github.com/repos/temporalio/temporal/pulls/comments/2525010020","pull_request_review_id":3461787224,"id":2525010020,"node_id":"PRRC_kwDODNqesM6WgJhk","diff_hunk":"@@ -51,3 +52,191 @@ func (h *handler) StartActivityExecution(ctx context.Context, req *activitypb.St\n \t\tFrontendResponse: response,\n \t}, nil\n }\n+\n+// PollActivityExecution handles PollActivityExecutionRequest from frontend. This method supports\n+// querying current activity state, optionally as a long-poll that waits for certain state changes.\n+// It is used by clients to poll for activity state and/or result.\n+func (h *handler) PollActivityExecution(\n+\tctx context.Context,\n+\treq *activitypb.PollActivityExecutionRequest,\n+) (*activitypb.PollActivityExecutionResponse, error) {\n+\tswitch req.GetFrontendRequest().GetWaitPolicy().(type) {\n+\tcase nil:\n+\t\treturn chasm.ReadComponent(\n+\t\t\tctx,\n+\t\t\tchasm.NewComponentRef[*Activity](chasm.EntityKey{\n+\t\t\t\tNamespaceID: req.GetNamespaceId(),\n+\t\t\t\tBusinessID:  req.GetFrontendRequest().GetActivityId(),\n+\t\t\t\tEntityID:    req.GetFrontendRequest().GetRunId(),\n+\t\t\t}),\n+\t\t\t(*Activity).buildPollActivityExecutionResponse,\n+\t\t\treq,\n+\t\t\tnil,\n+\t\t)\n+\tcase *workflowservice.PollActivityExecutionRequest_WaitAnyStateChange:\n+\t\treturn pollActivityExecutionWaitAnyStateChange(ctx, req)\n+\tcase *workflowservice.PollActivityExecutionRequest_WaitCompletion:\n+\t\treturn pollActivityExecutionWaitCompletion(ctx, req)\n+\tdefault:\n+\t\treturn nil, serviceerror.NewInvalidArgumentf(\"unexpected wait policy type: %T\", req.GetFrontendRequest().GetWaitPolicy())\n+\t}\n+}\n+\n+// pollActivityExecutionWaitAnyStateChange waits until the activity state has advanced beyond that\n+// specified by the submitted token. If no token was submitted, it returns the current state without\n+// waiting.\n+func pollActivityExecutionWaitAnyStateChange(\n+\tctx context.Context,\n+\treq *activitypb.PollActivityExecutionRequest,\n+) (*activitypb.PollActivityExecutionResponse, error) {\n+\n+\t// TODO(dan): do we want to guarantee that response data will differ from that received when the\n+\t// token was obtained? It's potentially confusing for the server to say \"there's been a change\"\n+\t// while returning data in which the change is not apparent.\n+\n+\trefBytesFromToken := req.GetFrontendRequest().\n+\t\tGetWaitPolicy().(*workflowservice.PollActivityExecutionRequest_WaitAnyStateChange).\n+\t\tWaitAnyStateChange.GetLongPollToken()\n+\n+\tvar lastSeenRef chasm.ComponentRef\n+\tif refBytesFromToken != nil {\n+\t\tvar err error\n+\t\tlastSeenRef, err = chasm.DeserializeComponentRef(refBytesFromToken)\n+\t\tif err != nil {\n+\t\t\treturn nil, serviceerror.NewInvalidArgument(\"invalid long poll token\")\n+\t\t}\n+\t\tif lastSeenRef.NamespaceID != req.GetNamespaceId() ||\n+\t\t\tlastSeenRef.BusinessID != req.GetFrontendRequest().GetActivityId() ||\n+\t\t\tlastSeenRef.EntityID != req.GetFrontendRequest().GetRunId() {\n+\t\t\t// token is inconsistent with request\n+\t\t\treturn nil, serviceerror.NewInvalidArgument(\"invalid long poll token\")\n+\t\t}\n+\t} else {\n+\t\t// This ref will compare less than currentRef in the comparison below.\n+\t\tlastSeenRef = chasm.NewComponentRef[*Activity](chasm.EntityKey{\n+\t\t\tNamespaceID: req.GetNamespaceId(),\n+\t\t\tBusinessID:  req.GetFrontendRequest().GetActivityId(),\n+\t\t\tEntityID:    req.GetFrontendRequest().GetRunId(),\n+\t\t})\n+\t}\n+\n+\t// PollComponent will return an error if lastSeenRef is not consistent with the entity\n+\t// transition history on this shard, or if the state on this shard is behind the ref after a\n+\t// reload.\n+\t// TODO(dan): retryability of these errors\n+\tresponse, newRef, err := chasm.PollComponent(\n+\t\tctx,\n+\t\tlastSeenRef,\n+\t\tfunc(\n+\t\t\ta *Activity,\n+\t\t\tctx chasm.Context,\n+\t\t\treq *activitypb.PollActivityExecutionRequest,\n+\t\t) (*activitypb.PollActivityExecutionResponse, bool, error) {\n+\t\t\t// TODO(dan): we're walking the tree to construct a ref when all we want here is the\n+\t\t\t// root/entity VT. Would it make sense for Context to provide access to root node?\n+\t\t\tcurrentRefBytes, err := ctx.Ref(a)\n+\t\t\tif err != nil {\n+\t\t\t\treturn nil, false, err\n+\t\t\t}\n+\t\t\tcurrentRef, err := chasm.DeserializeComponentRef(currentRefBytes)\n+\t\t\tif err != nil {\n+\t\t\t\treturn nil, false, err\n+\t\t\t}\n+\n+\t\t\tif lastSeenRef.EntityID != currentRef.EntityID {\n+\t\t\t\t// The runID from the token doesn't match this shard's state. We return immediately,\n+\t\t\t\t// on the basis that this constitutes a state change. If the runID from the token is\n+\t\t\t\t// ahead of this shard's state then this will be detected by shard ownership or\n+\t\t\t\t// staleness checks and the caller will receive an error.\n+\t\t\t\tresponse, err := a.buildPollActivityExecutionResponse(ctx, req)\n+\t\t\t\tif err != nil {\n+\t\t\t\t\treturn nil, true, err\n+\t\t\t\t}\n+\t\t\t\treturn response, true, nil\n+\t\t\t}\n+\n+\t\t\trefComparison, err := chasm.CompareComponentRefs(&lastSeenRef, &currentRef)\n+\t\t\tif err != nil {\n+\t\t\t\treturn nil, false, err\n+\t\t\t}\n+\t\t\tswitch refComparison {\n+\t\t\tcase -1:\n+\t\t\t\t// state has advanced beyond last seen: this is what we're waiting for\n+\t\t\t\tresponse, err := a.buildPollActivityExecutionResponse(ctx, req)\n+\t\t\t\tif err != nil {\n+\t\t\t\t\treturn nil, true, err\n+\t\t\t\t}\n+\t\t\t\treturn response, true, nil\n+\t\t\tcase 0:\n+\t\t\t\t// state is same as last seen: keep waiting\n+\t\t\t\treturn nil, false, nil\n+\t\t\tcase 1:\n+\t\t\t\t// Impossible: PollComponent guarantees that at this point, current VT >= lastSeen VT.\n+\t\t\t\treturn nil, false, serviceerror.NewFailedPrecondition(\"submitted long-poll token represents a state beyond current\")\n+\t\t\tdefault:\n+\t\t\t\t// Impossible\n+\t\t\t\treturn nil, false, serviceerror.NewInternal(\"unexpected transition history comparison result\")\n+\t\t\t}\n+\t\t},\n+\t\treq,\n+\t)\n+\tif err != nil {\n+\t\treturn nil, err\n+\t}\n+\tif response == nil {\n+\t\t// nil response indicates server-imposed long-poll timeout. Communicate this to callers by\n+\t\t// returning a non-error empty response.\n+\t\tresponse = &activitypb.PollActivityExecutionResponse{\n+\t\t\tFrontendResponse: &workflowservice.PollActivityExecutionResponse{},\n+\t\t}\n+\t} else {\n+\t\tresponse.GetFrontendResponse().StateChangeLongPollToken = newRef\n+\t}\n+\treturn response, nil\n+}\n+\n+// pollActivityExecutionWaitCompletion waits until the activity is completed.\n+func pollActivityExecutionWaitCompletion(\n+\tctx context.Context,\n+\treq *activitypb.PollActivityExecutionRequest,\n+) (*activitypb.PollActivityExecutionResponse, error) {\n+\t// TODO(dan): implement functional test when RecordActivityTaskCompleted is implemented\n+\tresponse, newRef, err := chasm.PollComponent(\n+\t\tctx,\n+\t\tchasm.NewComponentRef[*Activity](chasm.EntityKey{\n+\t\t\tNamespaceID: req.GetNamespaceId(),\n+\t\t\tBusinessID:  req.GetFrontendRequest().GetActivityId(),\n+\t\t\tEntityID:    req.GetFrontendRequest().GetRunId(),\n+\t\t}),\n+\t\tfunc(\n+\t\t\ta *Activity,\n+\t\t\tctx chasm.Context,\n+\t\t\treq *activitypb.PollActivityExecutionRequest,\n+\t\t) (*activitypb.PollActivityExecutionResponse, bool, error) {\n+\t\t\tpanic(\"TODO(dan): pollActivityExecutionWaitCompletion is not implemented\")","path":"chasm/lib/activity/handler.go","commit_id":"1107a99065abf8f8b3c62d31457284f2d37ac09d","original_commit_id":"fe2bcff1b2f1e1b4d1061ef272614218ddd59a5d","user":{"login":"cursor[bot]","id":206951365,"node_id":"BOT_kgDODFXTxQ","avatar_url":"https://avatars.githubusercontent.com/in/1210556?v=4","gravatar_id":"","url":"https://api.github.com/users/cursor%5Bbot%5D","html_url":"https://github.com/apps/cursor","followers_url":"https://api.github.com/users/cursor%5Bbot%5D/followers","following_url":"https://api.github.com/users/cursor%5Bbot%5D/following{/other_user}","gists_url":"https://api.github.com/users/cursor%5Bbot%5D/gists{/gist_id}","starred_url":"https://api.github.com/users/cursor%5Bbot%5D/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/cursor%5Bbot%5D/subscriptions","organizations_url":"https://api.github.com/users/cursor%5Bbot%5D/orgs","repos_url":"https://api.github.com/users/cursor%5Bbot%5D/repos","events_url":"https://api.github.com/users/cursor%5Bbot%5D/events{/privacy}","received_events_url":"https://api.github.com/users/cursor%5Bbot%5D/received_events","type":"Bot","user_view_type":"public","site_admin":false},"body":"### Bug: Unimplemented Code Path Crashes Production\n\n<!-- **High Severity** -->\n\n<!-- DESCRIPTION START -->\n`pollActivityExecutionWaitCompletion` panics when called in production. The function is invoked when clients poll with `WaitCompletion` policy, but contains an unimplemented `panic` statement that will crash the server. This should return an error instead or be fully implemented before allowing this code path to be reached.\n<!-- DESCRIPTION END -->\n\n<!-- LOCATIONS START\nchasm/lib/activity/handler.go#L215-L216\nLOCATIONS END -->\n<a href=\"https://cursor.com/open?data=eyJhbGciOiJSUzI1NiIsInR5cCI6IkpXVCIsImtpZCI6ImJ1Z2JvdC12MSJ9.eyJ2ZXJzaW9uIjoxLCJ0eXBlIjoiQlVHQk9UX0ZJWF9JTl9DVVJTT1IiLCJkYXRhIjp7InJlZGlzS2V5IjoiYnVnYm90OmVkZmRiNzJlLTc3N2EtNDMwMC1iNDlhLWU1YjU0ZmM3NmUxNiIsImVuY3J5cHRpb25LZXkiOiI5V3JTQlBsb09QV1BmZWIyd045aTRENGVxTWI2dFJCMTdUTm9zb0VBNV80IiwiYnJhbmNoIjoicG9sbC1jb21wb25lbnQifSwiaWF0IjoxNzYzMDY5NzYyLCJleHAiOjE3NjM2NzQ1NjJ9.TmeImbehsGYLRMZiFPHDUSB8QK1fzBeGyn2ROGpdQ51aVXnQtOu5IFMwGvW86YG1bn0wnTPVrJCBBn_bqmyddGBC5_OcwxIzS6HLzhSsXN26BWE-ZhDQUDH8_ts2WXrDtv7wNAgtXbPrgeOEoguOtK-oWEHmrY0-hrSa2Vao8FjhsjCjAc7mBF8oP7h1TJLLmQrY_KpAGbJRTe3vfMqTIN50YzaAEqy3bj0L2NiBYaA4BL5cwH83IxlTcbkeZsPTSqknXXguebS7DCYzIWz400If6dVJjxBuA5hvOyvyLL6pLbX6Lxm9V_VIXrzEXiz3unV2qS5LZDB-EKOKsbn5yQ\"><picture><source media=\"(prefers-color-scheme: dark)\" srcset=\"https://cursor.com/fix-in-cursor-dark.svg\"><source media=\"(prefers-color-scheme: light)\" srcset=\"https://cursor.com/fix-in-cursor-light.svg\"><img alt=\"Fix in Cursor\" src=\"https://cursor.com/fix-in-cursor.svg\"></picture></a>&nbsp;<a href=\"https://cursor.com/agents?data=eyJhbGciOiJSUzI1NiIsInR5cCI6IkpXVCIsImtpZCI6ImJ1Z2JvdC12MSJ9.eyJ2ZXJzaW9uIjoxLCJ0eXBlIjoiQlVHQk9UX0ZJWF9JTl9XRUIiLCJkYXRhIjp7InJlZGlzS2V5IjoiYnVnYm90OmVkZmRiNzJlLTc3N2EtNDMwMC1iNDlhLWU1YjU0ZmM3NmUxNiIsImVuY3J5cHRpb25LZXkiOiI5V3JTQlBsb09QV1BmZWIyd045aTRENGVxTWI2dFJCMTdUTm9zb0VBNV80IiwiYnJhbmNoIjoicG9sbC1jb21wb25lbnQiLCJyZXBvT3duZXIiOiJ0ZW1wb3JhbGlvIiwicmVwb05hbWUiOiJ0ZW1wb3JhbCIsInByTnVtYmVyIjo4NTYzLCJjb21taXRTaGEiOiJmZTJiY2ZmMWIyZjFlMWI0ZDEwNjFlZjI3MjYxNDIxOGRkZDU5YTVkIn0sImlhdCI6MTc2MzA2OTc2MiwiZXhwIjoxNzYzNjc0NTYyfQ.OH97ifbKh1rg04u1dt6ixZyO-WIB8yjlnjOtuCy2P3BdSTBGMrEF3HLdgdwHogeNnrFLyfedhFYi0a9KNZQBjBosFct_6nmURZZAoxjTv1v9k3PXQSR91AQA6-lqUIbnWthOKdHUInBenKntsitNW5fUMTRJCvIcutHker2C1VrCz3L8eQbruSQuxuTZZ1_eaDgoZvlL-6tsj3AF5obV6J_kQOROHl5oUfAZd2OhQaBEddiL80CUsL0GRsHVCdb3OY-n-Dte3XvTmg5KMkNm6ws0XkWImddda7uvPilJ1PVa1FYjljpyPwRCmmQOklRuIMdp9urZUyjpY9cH6cQu0g\"><picture><source media=\"(prefers-color-scheme: dark)\" srcset=\"https://cursor.com/fix-in-web-dark.svg\"><source media=\"(prefers-color-scheme: light)\" srcset=\"https://cursor.com/fix-in-web-light.svg\"><img alt=\"Fix in Web\" src=\"https://cursor.com/fix-in-web.svg\"></picture></a>\n\n","created_at":"2025-11-13T21:36:02Z","updated_at":"2025-11-13T21:36:03Z","html_url":"https://github.com/temporalio/temporal/pull/8563#discussion_r2525010020","pull_request_url":"https://api.github.com/repos/temporalio/temporal/pulls/8563","_links":{"self":{"href":"https://api.github.com/repos/temporalio/temporal/pulls/comments/2525010020"},"html":{"href":"https://github.com/temporalio/temporal/pull/8563#discussion_r2525010020"},"pull_request":{"href":"https://api.github.com/repos/temporalio/temporal/pulls/8563"}},"reactions":{"url":"https://api.github.com/repos/temporalio/temporal/pulls/comments/2525010020/reactions","total_count":0,"+1":0,"-1":0,"laugh":0,"hooray":0,"confused":0,"heart":0,"rocket":0,"eyes":0},"start_line":null,"original_start_line":null,"start_side":null,"line":null,"original_line":216,"side":"RIGHT","author_association":"NONE","original_position":173,"position":1,"subject_type":"line"},{"url":"https://api.github.com/repos/temporalio/temporal/pulls/comments/2525412953","pull_request_review_id":3462342142,"id":2525412953,"node_id":"PRRC_kwDODNqesM6Whr5Z","diff_hunk":"@@ -51,3 +52,191 @@ func (h *handler) StartActivityExecution(ctx context.Context, req *activitypb.St\n \t\tFrontendResponse: response,\n \t}, nil\n }\n+\n+// PollActivityExecution handles PollActivityExecutionRequest from frontend. This method supports\n+// querying current activity state, optionally as a long-poll that waits for certain state changes.\n+// It is used by clients to poll for activity state and/or result.\n+func (h *handler) PollActivityExecution(\n+\tctx context.Context,\n+\treq *activitypb.PollActivityExecutionRequest,\n+) (*activitypb.PollActivityExecutionResponse, error) {\n+\tswitch req.GetFrontendRequest().GetWaitPolicy().(type) {\n+\tcase nil:\n+\t\treturn chasm.ReadComponent(\n+\t\t\tctx,\n+\t\t\tchasm.NewComponentRef[*Activity](chasm.EntityKey{\n+\t\t\t\tNamespaceID: req.GetNamespaceId(),\n+\t\t\t\tBusinessID:  req.GetFrontendRequest().GetActivityId(),\n+\t\t\t\tEntityID:    req.GetFrontendRequest().GetRunId(),\n+\t\t\t}),\n+\t\t\t(*Activity).buildPollActivityExecutionResponse,\n+\t\t\treq,\n+\t\t\tnil,\n+\t\t)\n+\tcase *workflowservice.PollActivityExecutionRequest_WaitAnyStateChange:\n+\t\treturn pollActivityExecutionWaitAnyStateChange(ctx, req)\n+\tcase *workflowservice.PollActivityExecutionRequest_WaitCompletion:\n+\t\treturn pollActivityExecutionWaitCompletion(ctx, req)\n+\tdefault:\n+\t\treturn nil, serviceerror.NewInvalidArgumentf(\"unexpected wait policy type: %T\", req.GetFrontendRequest().GetWaitPolicy())\n+\t}\n+}\n+\n+// pollActivityExecutionWaitAnyStateChange waits until the activity state has advanced beyond that\n+// specified by the submitted token. If no token was submitted, it returns the current state without\n+// waiting.\n+func pollActivityExecutionWaitAnyStateChange(\n+\tctx context.Context,\n+\treq *activitypb.PollActivityExecutionRequest,\n+) (*activitypb.PollActivityExecutionResponse, error) {\n+\n+\t// TODO(dan): do we want to guarantee that response data will differ from that received when the\n+\t// token was obtained? It's potentially confusing for the server to say \"there's been a change\"\n+\t// while returning data in which the change is not apparent.\n+\n+\trefBytesFromToken := req.GetFrontendRequest().\n+\t\tGetWaitPolicy().(*workflowservice.PollActivityExecutionRequest_WaitAnyStateChange).\n+\t\tWaitAnyStateChange.GetLongPollToken()\n+\n+\tvar lastSeenRef chasm.ComponentRef\n+\tif refBytesFromToken != nil {\n+\t\tvar err error\n+\t\tlastSeenRef, err = chasm.DeserializeComponentRef(refBytesFromToken)\n+\t\tif err != nil {\n+\t\t\treturn nil, serviceerror.NewInvalidArgument(\"invalid long poll token\")\n+\t\t}\n+\t\tif lastSeenRef.NamespaceID != req.GetNamespaceId() ||\n+\t\t\tlastSeenRef.BusinessID != req.GetFrontendRequest().GetActivityId() ||\n+\t\t\tlastSeenRef.EntityID != req.GetFrontendRequest().GetRunId() {\n+\t\t\t// token is inconsistent with request\n+\t\t\treturn nil, serviceerror.NewInvalidArgument(\"invalid long poll token\")\n+\t\t}\n+\t} else {\n+\t\t// This ref will compare less than currentRef in the comparison below.\n+\t\tlastSeenRef = chasm.NewComponentRef[*Activity](chasm.EntityKey{\n+\t\t\tNamespaceID: req.GetNamespaceId(),\n+\t\t\tBusinessID:  req.GetFrontendRequest().GetActivityId(),\n+\t\t\tEntityID:    req.GetFrontendRequest().GetRunId(),\n+\t\t})\n+\t}\n+\n+\t// PollComponent will return an error if lastSeenRef is not consistent with the entity\n+\t// transition history on this shard, or if the state on this shard is behind the ref after a\n+\t// reload.\n+\t// TODO(dan): retryability of these errors\n+\tresponse, newRef, err := chasm.PollComponent(\n+\t\tctx,\n+\t\tlastSeenRef,\n+\t\tfunc(\n+\t\t\ta *Activity,\n+\t\t\tctx chasm.Context,\n+\t\t\treq *activitypb.PollActivityExecutionRequest,\n+\t\t) (*activitypb.PollActivityExecutionResponse, bool, error) {\n+\t\t\t// TODO(dan): we're walking the tree to construct a ref when all we want here is the\n+\t\t\t// root/entity VT. Would it make sense for Context to provide access to root node?\n+\t\t\tcurrentRefBytes, err := ctx.Ref(a)","path":"chasm/lib/activity/handler.go","commit_id":"c88896985ee8b4a5cd9c508293e4431293e28fde","original_commit_id":"b24a0220435f567e7e3cacb95bd8fe78c17dc67b","user":{"login":"yycptt","id":7754120,"node_id":"MDQ6VXNlcjc3NTQxMjA=","avatar_url":"https://avatars.githubusercontent.com/u/7754120?v=4","gravatar_id":"","url":"https://api.github.com/users/yycptt","html_url":"https://github.com/yycptt","followers_url":"https://api.github.com/users/yycptt/followers","following_url":"https://api.github.com/users/yycptt/following{/other_user}","gists_url":"https://api.github.com/users/yycptt/gists{/gist_id}","starred_url":"https://api.github.com/users/yycptt/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/yycptt/subscriptions","organizations_url":"https://api.github.com/users/yycptt/orgs","repos_url":"https://api.github.com/users/yycptt/repos","events_url":"https://api.github.com/users/yycptt/events{/privacy}","received_events_url":"https://api.github.com/users/yycptt/received_events","type":"User","user_view_type":"public","site_admin":false},"body":"not sure what's intention here. The predicateFn should be implemented based on the Activity's state, like for example the execution status of the activity, and see if it's in completed state.\n\nThe returned Ref shouldn't be decoded by application logic, I should un-export the DeserializeComponentRef function.","created_at":"2025-11-14T01:13:10Z","updated_at":"2025-11-14T01:13:10Z","html_url":"https://github.com/temporalio/temporal/pull/8563#discussion_r2525412953","pull_request_url":"https://api.github.com/repos/temporalio/temporal/pulls/8563","_links":{"self":{"href":"https://api.github.com/repos/temporalio/temporal/pulls/comments/2525412953"},"html":{"href":"https://github.com/temporalio/temporal/pull/8563#discussion_r2525412953"},"pull_request":{"href":"https://api.github.com/repos/temporalio/temporal/pulls/8563"}},"reactions":{"url":"https://api.github.com/repos/temporalio/temporal/pulls/comments/2525412953/reactions","total_count":0,"+1":0,"-1":0,"laugh":0,"hooray":0,"confused":0,"heart":0,"rocket":0,"eyes":0},"start_line":null,"original_start_line":null,"start_side":null,"line":null,"original_line":137,"side":"RIGHT","author_association":"MEMBER","original_position":94,"position":1,"subject_type":"line"},{"url":"https://api.github.com/repos/temporalio/temporal/pulls/comments/2525414437","pull_request_review_id":3462344105,"id":2525414437,"node_id":"PRRC_kwDODNqesM6WhsQl","diff_hunk":"@@ -155,3 +156,16 @@ func ProtoRefToComponentRef(pRef *persistencespb.ChasmComponentRef) ComponentRef\n \t\tcomponentInitialVT: pRef.ComponentInitialVersionedTransition,\n \t}\n }\n+\n+// TODO(dan): is this leaking too much detail about VTs?","path":"chasm/ref.go","commit_id":"384f23bf064696e80ccc71056daf19a1c8d1edea","original_commit_id":"b24a0220435f567e7e3cacb95bd8fe78c17dc67b","user":{"login":"yycptt","id":7754120,"node_id":"MDQ6VXNlcjc3NTQxMjA=","avatar_url":"https://avatars.githubusercontent.com/u/7754120?v=4","gravatar_id":"","url":"https://api.github.com/users/yycptt","html_url":"https://github.com/yycptt","followers_url":"https://api.github.com/users/yycptt/followers","following_url":"https://api.github.com/users/yycptt/following{/other_user}","gists_url":"https://api.github.com/users/yycptt/gists{/gist_id}","starred_url":"https://api.github.com/users/yycptt/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/yycptt/subscriptions","organizations_url":"https://api.github.com/users/yycptt/orgs","repos_url":"https://api.github.com/users/yycptt/repos","events_url":"https://api.github.com/users/yycptt/events{/privacy}","received_events_url":"https://api.github.com/users/yycptt/received_events","type":"User","user_view_type":"public","site_admin":false},"body":"I think so, yeah. The predicate fn should not be implemented based on ref.","created_at":"2025-11-14T01:14:11Z","updated_at":"2025-11-14T01:31:45Z","html_url":"https://github.com/temporalio/temporal/pull/8563#discussion_r2525414437","pull_request_url":"https://api.github.com/repos/temporalio/temporal/pulls/8563","_links":{"self":{"href":"https://api.github.com/repos/temporalio/temporal/pulls/comments/2525414437"},"html":{"href":"https://github.com/temporalio/temporal/pull/8563#discussion_r2525414437"},"pull_request":{"href":"https://api.github.com/repos/temporalio/temporal/pulls/8563"}},"reactions":{"url":"https://api.github.com/repos/temporalio/temporal/pulls/comments/2525414437/reactions","total_count":0,"+1":0,"-1":0,"laugh":0,"hooray":0,"confused":0,"heart":0,"rocket":0,"eyes":0},"start_line":null,"original_start_line":null,"start_side":null,"line":null,"original_line":160,"side":"RIGHT","author_association":"MEMBER","original_position":13,"position":1,"subject_type":"line"},{"url":"https://api.github.com/repos/temporalio/temporal/pulls/comments/2525420163","pull_request_review_id":3462344105,"id":2525420163,"node_id":"PRRC_kwDODNqesM6WhtqD","diff_hunk":"@@ -204,9 +235,17 @@ func (e *ChasmEngine) UpdateComponent(\n \t\treturn nil, serviceerror.NewInternalf(\"componentRef: %+v: %s\", ref, err)\n \t}\n \n+\te.notifier.Notify(&ChasmComponentNotification{\n+\t\tKey: ref.EntityKey,\n+\t\tRef: newSerializedRef,\n+\t})","path":"service/history/chasm_engine.go","commit_id":"da6009564e796063faf853352077eecdc1473612","original_commit_id":"eb1ded5ef804505544b0ab631d660b43072ee6f6","user":{"login":"yycptt","id":7754120,"node_id":"MDQ6VXNlcjc3NTQxMjA=","avatar_url":"https://avatars.githubusercontent.com/u/7754120?v=4","gravatar_id":"","url":"https://api.github.com/users/yycptt","html_url":"https://github.com/yycptt","followers_url":"https://api.github.com/users/yycptt/followers","following_url":"https://api.github.com/users/yycptt/following{/other_user}","gists_url":"https://api.github.com/users/yycptt/gists{/gist_id}","starred_url":"https://api.github.com/users/yycptt/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/yycptt/subscriptions","organizations_url":"https://api.github.com/users/yycptt/orgs","repos_url":"https://api.github.com/users/yycptt/repos","events_url":"https://api.github.com/users/yycptt/events{/privacy}","received_events_url":"https://api.github.com/users/yycptt/received_events","type":"User","user_view_type":"public","site_admin":false},"body":"> The PR does not yet emit notifications at any other component lifecycle transition.\n\nI guess that's why in my mind this needs to be done at a lower level (e.g. transactionImpl), or we won't be able to send out notifications for system triggered transitions, like force termination. But those are rare.","created_at":"2025-11-14T01:17:45Z","updated_at":"2025-11-14T01:31:45Z","html_url":"https://github.com/temporalio/temporal/pull/8563#discussion_r2525420163","pull_request_url":"https://api.github.com/repos/temporalio/temporal/pulls/8563","_links":{"self":{"href":"https://api.github.com/repos/temporalio/temporal/pulls/comments/2525420163"},"html":{"href":"https://github.com/temporalio/temporal/pull/8563#discussion_r2525420163"},"pull_request":{"href":"https://api.github.com/repos/temporalio/temporal/pulls/8563"}},"reactions":{"url":"https://api.github.com/repos/temporalio/temporal/pulls/comments/2525420163/reactions","total_count":0,"+1":0,"-1":0,"laugh":0,"hooray":0,"confused":0,"heart":0,"rocket":0,"eyes":0},"start_line":null,"original_start_line":null,"start_side":null,"line":null,"original_line":241,"side":"RIGHT","in_reply_to_id":2519344176,"author_association":"MEMBER","original_position":96,"position":1,"subject_type":"line"},{"url":"https://api.github.com/repos/temporalio/temporal/pulls/comments/2525429310","pull_request_review_id":3462362851,"id":2525429310,"node_id":"PRRC_kwDODNqesM6Whv4-","diff_hunk":"@@ -314,3 +315,125 @@ func (a *Activity) RecordHeartbeat(ctx chasm.MutableContext, details *commonpb.P\n \t})\n \treturn nil, nil\n }\n+\n+func (a *Activity) buildActivityExecutionInfo(ctx chasm.Context, key chasm.EntityKey) (*activity.ActivityExecutionInfo, error) {\n+\tif a.ActivityState == nil {\n+\t\treturn nil, errors.New(\"activity state is nil\")\n+\t}\n+\n+\t// TODO(dan): support pause states\n+\tvar status enumspb.ActivityExecutionStatus\n+\tvar runState enumspb.PendingActivityState\n+\tswitch a.GetStatus() {\n+\tcase activitypb.ACTIVITY_EXECUTION_STATUS_UNSPECIFIED:\n+\t\tstatus = enumspb.ACTIVITY_EXECUTION_STATUS_UNSPECIFIED\n+\t\trunState = enumspb.PENDING_ACTIVITY_STATE_UNSPECIFIED\n+\tcase activitypb.ACTIVITY_EXECUTION_STATUS_SCHEDULED:\n+\t\tstatus = enumspb.ACTIVITY_EXECUTION_STATUS_RUNNING\n+\t\trunState = enumspb.PENDING_ACTIVITY_STATE_SCHEDULED\n+\tcase activitypb.ACTIVITY_EXECUTION_STATUS_STARTED:\n+\t\tstatus = enumspb.ACTIVITY_EXECUTION_STATUS_RUNNING\n+\t\trunState = enumspb.PENDING_ACTIVITY_STATE_STARTED\n+\tcase activitypb.ACTIVITY_EXECUTION_STATUS_CANCEL_REQUESTED:\n+\t\tstatus = enumspb.ACTIVITY_EXECUTION_STATUS_RUNNING\n+\t\trunState = enumspb.PENDING_ACTIVITY_STATE_CANCEL_REQUESTED\n+\tcase activitypb.ACTIVITY_EXECUTION_STATUS_COMPLETED:\n+\t\tstatus = enumspb.ACTIVITY_EXECUTION_STATUS_COMPLETED\n+\t\trunState = enumspb.PENDING_ACTIVITY_STATE_UNSPECIFIED\n+\tcase activitypb.ACTIVITY_EXECUTION_STATUS_FAILED:\n+\t\tstatus = enumspb.ACTIVITY_EXECUTION_STATUS_FAILED\n+\t\trunState = enumspb.PENDING_ACTIVITY_STATE_UNSPECIFIED\n+\tcase activitypb.ACTIVITY_EXECUTION_STATUS_CANCELED:\n+\t\tstatus = enumspb.ACTIVITY_EXECUTION_STATUS_CANCELED\n+\t\trunState = enumspb.PENDING_ACTIVITY_STATE_UNSPECIFIED\n+\tcase activitypb.ACTIVITY_EXECUTION_STATUS_TERMINATED:\n+\t\tstatus = enumspb.ACTIVITY_EXECUTION_STATUS_TERMINATED\n+\t\trunState = enumspb.PENDING_ACTIVITY_STATE_UNSPECIFIED\n+\tcase activitypb.ACTIVITY_EXECUTION_STATUS_TIMED_OUT:\n+\t\tstatus = enumspb.ACTIVITY_EXECUTION_STATUS_TIMED_OUT\n+\t\trunState = enumspb.PENDING_ACTIVITY_STATE_UNSPECIFIED\n+\tdefault:\n+\t\treturn nil, serviceerror.NewInternalf(\"unknown activity execution status: %s\", a.GetStatus())\n+\t}\n+\n+\trequestData, err := a.RequestData.Get(ctx)\n+\tif err != nil {\n+\t\treturn nil, err\n+\t}\n+\n+\tinfo := &activity.ActivityExecutionInfo{\n+\t\tActivityId:    key.BusinessID,\n+\t\tRunId:         key.EntityID,\n+\t\tActivityType:  a.GetActivityType(),\n+\t\tStatus:        status,\n+\t\tRunState:      runState,\n+\t\tScheduledTime: a.GetScheduledTime(),\n+\t\tPriority:      a.GetPriority(),\n+\t\tHeader:        requestData.GetHeader(),\n+\t\t// TODO(dan): populate remaining fields\n+\t}\n+\n+\treturn info, nil\n+}\n+\n+func (a *Activity) buildPollActivityExecutionResponse(\n+\tctx chasm.Context,\n+\treq *activitypb.PollActivityExecutionRequest,\n+) (*activitypb.PollActivityExecutionResponse, error) {\n+\trequest := req.GetFrontendRequest()\n+\n+\t// TODO(dan): pass ref into this function?\n+\tref, err := ctx.Ref(a)\n+\tif err != nil {\n+\t\treturn nil, err\n+\t}\n+\n+\tvar info *activity.ActivityExecutionInfo\n+\tif request.GetIncludeInfo() {\n+\t\tinfo, err = a.buildActivityExecutionInfo(ctx, chasm.EntityKey{","path":"chasm/lib/activity/activity.go","commit_id":"384f23bf064696e80ccc71056daf19a1c8d1edea","original_commit_id":"b24a0220435f567e7e3cacb95bd8fe78c17dc67b","user":{"login":"bergundy","id":52304,"node_id":"MDQ6VXNlcjUyMzA0","avatar_url":"https://avatars.githubusercontent.com/u/52304?v=4","gravatar_id":"","url":"https://api.github.com/users/bergundy","html_url":"https://github.com/bergundy","followers_url":"https://api.github.com/users/bergundy/followers","following_url":"https://api.github.com/users/bergundy/following{/other_user}","gists_url":"https://api.github.com/users/bergundy/gists{/gist_id}","starred_url":"https://api.github.com/users/bergundy/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/bergundy/subscriptions","organizations_url":"https://api.github.com/users/bergundy/orgs","repos_url":"https://api.github.com/users/bergundy/repos","events_url":"https://api.github.com/users/bergundy/events{/privacy}","received_events_url":"https://api.github.com/users/bergundy/received_events","type":"User","user_view_type":"public","site_admin":false},"body":"No need to pass the entity key, use `ctx.ExecutionKey()` (the API name is different because we are in the middle of finalizing the concepts)","created_at":"2025-11-14T01:22:53Z","updated_at":"2025-11-14T01:29:56Z","html_url":"https://github.com/temporalio/temporal/pull/8563#discussion_r2525429310","pull_request_url":"https://api.github.com/repos/temporalio/temporal/pulls/8563","_links":{"self":{"href":"https://api.github.com/repos/temporalio/temporal/pulls/comments/2525429310"},"html":{"href":"https://github.com/temporalio/temporal/pull/8563#discussion_r2525429310"},"pull_request":{"href":"https://api.github.com/repos/temporalio/temporal/pulls/8563"}},"reactions":{"url":"https://api.github.com/repos/temporalio/temporal/pulls/comments/2525429310/reactions","total_count":0,"+1":0,"-1":0,"laugh":0,"hooray":0,"confused":0,"heart":0,"rocket":0,"eyes":0},"start_line":null,"original_start_line":null,"start_side":null,"line":null,"original_line":393,"side":"RIGHT","author_association":"MEMBER","original_position":113,"position":1,"subject_type":"line"},{"url":"https://api.github.com/repos/temporalio/temporal/pulls/comments/2525430246","pull_request_review_id":3462362851,"id":2525430246,"node_id":"PRRC_kwDODNqesM6WhwHm","diff_hunk":"@@ -314,3 +315,125 @@ func (a *Activity) RecordHeartbeat(ctx chasm.MutableContext, details *commonpb.P\n \t})\n \treturn nil, nil\n }\n+\n+func (a *Activity) buildActivityExecutionInfo(ctx chasm.Context, key chasm.EntityKey) (*activity.ActivityExecutionInfo, error) {\n+\tif a.ActivityState == nil {\n+\t\treturn nil, errors.New(\"activity state is nil\")\n+\t}\n+\n+\t// TODO(dan): support pause states\n+\tvar status enumspb.ActivityExecutionStatus\n+\tvar runState enumspb.PendingActivityState\n+\tswitch a.GetStatus() {\n+\tcase activitypb.ACTIVITY_EXECUTION_STATUS_UNSPECIFIED:\n+\t\tstatus = enumspb.ACTIVITY_EXECUTION_STATUS_UNSPECIFIED\n+\t\trunState = enumspb.PENDING_ACTIVITY_STATE_UNSPECIFIED\n+\tcase activitypb.ACTIVITY_EXECUTION_STATUS_SCHEDULED:\n+\t\tstatus = enumspb.ACTIVITY_EXECUTION_STATUS_RUNNING\n+\t\trunState = enumspb.PENDING_ACTIVITY_STATE_SCHEDULED\n+\tcase activitypb.ACTIVITY_EXECUTION_STATUS_STARTED:\n+\t\tstatus = enumspb.ACTIVITY_EXECUTION_STATUS_RUNNING\n+\t\trunState = enumspb.PENDING_ACTIVITY_STATE_STARTED\n+\tcase activitypb.ACTIVITY_EXECUTION_STATUS_CANCEL_REQUESTED:\n+\t\tstatus = enumspb.ACTIVITY_EXECUTION_STATUS_RUNNING\n+\t\trunState = enumspb.PENDING_ACTIVITY_STATE_CANCEL_REQUESTED\n+\tcase activitypb.ACTIVITY_EXECUTION_STATUS_COMPLETED:\n+\t\tstatus = enumspb.ACTIVITY_EXECUTION_STATUS_COMPLETED\n+\t\trunState = enumspb.PENDING_ACTIVITY_STATE_UNSPECIFIED\n+\tcase activitypb.ACTIVITY_EXECUTION_STATUS_FAILED:\n+\t\tstatus = enumspb.ACTIVITY_EXECUTION_STATUS_FAILED\n+\t\trunState = enumspb.PENDING_ACTIVITY_STATE_UNSPECIFIED\n+\tcase activitypb.ACTIVITY_EXECUTION_STATUS_CANCELED:\n+\t\tstatus = enumspb.ACTIVITY_EXECUTION_STATUS_CANCELED\n+\t\trunState = enumspb.PENDING_ACTIVITY_STATE_UNSPECIFIED\n+\tcase activitypb.ACTIVITY_EXECUTION_STATUS_TERMINATED:\n+\t\tstatus = enumspb.ACTIVITY_EXECUTION_STATUS_TERMINATED\n+\t\trunState = enumspb.PENDING_ACTIVITY_STATE_UNSPECIFIED\n+\tcase activitypb.ACTIVITY_EXECUTION_STATUS_TIMED_OUT:\n+\t\tstatus = enumspb.ACTIVITY_EXECUTION_STATUS_TIMED_OUT\n+\t\trunState = enumspb.PENDING_ACTIVITY_STATE_UNSPECIFIED\n+\tdefault:\n+\t\treturn nil, serviceerror.NewInternalf(\"unknown activity execution status: %s\", a.GetStatus())\n+\t}\n+\n+\trequestData, err := a.RequestData.Get(ctx)\n+\tif err != nil {\n+\t\treturn nil, err\n+\t}\n+\n+\tinfo := &activity.ActivityExecutionInfo{\n+\t\tActivityId:    key.BusinessID,\n+\t\tRunId:         key.EntityID,\n+\t\tActivityType:  a.GetActivityType(),\n+\t\tStatus:        status,\n+\t\tRunState:      runState,\n+\t\tScheduledTime: a.GetScheduledTime(),\n+\t\tPriority:      a.GetPriority(),\n+\t\tHeader:        requestData.GetHeader(),\n+\t\t// TODO(dan): populate remaining fields\n+\t}\n+\n+\treturn info, nil\n+}\n+\n+func (a *Activity) buildPollActivityExecutionResponse(\n+\tctx chasm.Context,\n+\treq *activitypb.PollActivityExecutionRequest,\n+) (*activitypb.PollActivityExecutionResponse, error) {\n+\trequest := req.GetFrontendRequest()\n+\n+\t// TODO(dan): pass ref into this function?\n+\tref, err := ctx.Ref(a)\n+\tif err != nil {\n+\t\treturn nil, err\n+\t}\n+\n+\tvar info *activity.ActivityExecutionInfo\n+\tif request.GetIncludeInfo() {\n+\t\tinfo, err = a.buildActivityExecutionInfo(ctx, chasm.EntityKey{","path":"chasm/lib/activity/activity.go","commit_id":"384f23bf064696e80ccc71056daf19a1c8d1edea","original_commit_id":"b24a0220435f567e7e3cacb95bd8fe78c17dc67b","user":{"login":"bergundy","id":52304,"node_id":"MDQ6VXNlcjUyMzA0","avatar_url":"https://avatars.githubusercontent.com/u/52304?v=4","gravatar_id":"","url":"https://api.github.com/users/bergundy","html_url":"https://github.com/bergundy","followers_url":"https://api.github.com/users/bergundy/followers","following_url":"https://api.github.com/users/bergundy/following{/other_user}","gists_url":"https://api.github.com/users/bergundy/gists{/gist_id}","starred_url":"https://api.github.com/users/bergundy/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/bergundy/subscriptions","organizations_url":"https://api.github.com/users/bergundy/orgs","repos_url":"https://api.github.com/users/bergundy/repos","events_url":"https://api.github.com/users/bergundy/events{/privacy}","received_events_url":"https://api.github.com/users/bergundy/received_events","type":"User","user_view_type":"public","site_admin":false},"body":"Also the run ID in the request could be empty and you need to return the current run ID.","created_at":"2025-11-14T01:23:37Z","updated_at":"2025-11-14T01:29:56Z","html_url":"https://github.com/temporalio/temporal/pull/8563#discussion_r2525430246","pull_request_url":"https://api.github.com/repos/temporalio/temporal/pulls/8563","_links":{"self":{"href":"https://api.github.com/repos/temporalio/temporal/pulls/comments/2525430246"},"html":{"href":"https://github.com/temporalio/temporal/pull/8563#discussion_r2525430246"},"pull_request":{"href":"https://api.github.com/repos/temporalio/temporal/pulls/8563"}},"reactions":{"url":"https://api.github.com/repos/temporalio/temporal/pulls/comments/2525430246/reactions","total_count":1,"+1":0,"-1":0,"laugh":0,"hooray":0,"confused":0,"heart":0,"rocket":0,"eyes":1},"start_line":null,"original_start_line":null,"start_side":null,"line":null,"original_line":393,"side":"RIGHT","in_reply_to_id":2525429310,"author_association":"MEMBER","original_position":113,"position":1,"subject_type":"line"},{"url":"https://api.github.com/repos/temporalio/temporal/pulls/comments/2525431130","pull_request_review_id":3462362851,"id":2525431130,"node_id":"PRRC_kwDODNqesM6WhwVa","diff_hunk":"@@ -314,3 +315,125 @@ func (a *Activity) RecordHeartbeat(ctx chasm.MutableContext, details *commonpb.P\n \t})\n \treturn nil, nil\n }\n+\n+func (a *Activity) buildActivityExecutionInfo(ctx chasm.Context, key chasm.EntityKey) (*activity.ActivityExecutionInfo, error) {\n+\tif a.ActivityState == nil {\n+\t\treturn nil, errors.New(\"activity state is nil\")\n+\t}\n+\n+\t// TODO(dan): support pause states\n+\tvar status enumspb.ActivityExecutionStatus\n+\tvar runState enumspb.PendingActivityState\n+\tswitch a.GetStatus() {\n+\tcase activitypb.ACTIVITY_EXECUTION_STATUS_UNSPECIFIED:\n+\t\tstatus = enumspb.ACTIVITY_EXECUTION_STATUS_UNSPECIFIED\n+\t\trunState = enumspb.PENDING_ACTIVITY_STATE_UNSPECIFIED\n+\tcase activitypb.ACTIVITY_EXECUTION_STATUS_SCHEDULED:\n+\t\tstatus = enumspb.ACTIVITY_EXECUTION_STATUS_RUNNING\n+\t\trunState = enumspb.PENDING_ACTIVITY_STATE_SCHEDULED\n+\tcase activitypb.ACTIVITY_EXECUTION_STATUS_STARTED:\n+\t\tstatus = enumspb.ACTIVITY_EXECUTION_STATUS_RUNNING\n+\t\trunState = enumspb.PENDING_ACTIVITY_STATE_STARTED\n+\tcase activitypb.ACTIVITY_EXECUTION_STATUS_CANCEL_REQUESTED:\n+\t\tstatus = enumspb.ACTIVITY_EXECUTION_STATUS_RUNNING\n+\t\trunState = enumspb.PENDING_ACTIVITY_STATE_CANCEL_REQUESTED\n+\tcase activitypb.ACTIVITY_EXECUTION_STATUS_COMPLETED:\n+\t\tstatus = enumspb.ACTIVITY_EXECUTION_STATUS_COMPLETED\n+\t\trunState = enumspb.PENDING_ACTIVITY_STATE_UNSPECIFIED\n+\tcase activitypb.ACTIVITY_EXECUTION_STATUS_FAILED:\n+\t\tstatus = enumspb.ACTIVITY_EXECUTION_STATUS_FAILED\n+\t\trunState = enumspb.PENDING_ACTIVITY_STATE_UNSPECIFIED\n+\tcase activitypb.ACTIVITY_EXECUTION_STATUS_CANCELED:\n+\t\tstatus = enumspb.ACTIVITY_EXECUTION_STATUS_CANCELED\n+\t\trunState = enumspb.PENDING_ACTIVITY_STATE_UNSPECIFIED\n+\tcase activitypb.ACTIVITY_EXECUTION_STATUS_TERMINATED:\n+\t\tstatus = enumspb.ACTIVITY_EXECUTION_STATUS_TERMINATED\n+\t\trunState = enumspb.PENDING_ACTIVITY_STATE_UNSPECIFIED\n+\tcase activitypb.ACTIVITY_EXECUTION_STATUS_TIMED_OUT:\n+\t\tstatus = enumspb.ACTIVITY_EXECUTION_STATUS_TIMED_OUT\n+\t\trunState = enumspb.PENDING_ACTIVITY_STATE_UNSPECIFIED\n+\tdefault:\n+\t\treturn nil, serviceerror.NewInternalf(\"unknown activity execution status: %s\", a.GetStatus())\n+\t}\n+\n+\trequestData, err := a.RequestData.Get(ctx)\n+\tif err != nil {\n+\t\treturn nil, err\n+\t}\n+\n+\tinfo := &activity.ActivityExecutionInfo{\n+\t\tActivityId:    key.BusinessID,\n+\t\tRunId:         key.EntityID,\n+\t\tActivityType:  a.GetActivityType(),\n+\t\tStatus:        status,\n+\t\tRunState:      runState,\n+\t\tScheduledTime: a.GetScheduledTime(),\n+\t\tPriority:      a.GetPriority(),\n+\t\tHeader:        requestData.GetHeader(),\n+\t\t// TODO(dan): populate remaining fields\n+\t}\n+\n+\treturn info, nil\n+}\n+\n+func (a *Activity) buildPollActivityExecutionResponse(\n+\tctx chasm.Context,\n+\treq *activitypb.PollActivityExecutionRequest,\n+) (*activitypb.PollActivityExecutionResponse, error) {\n+\trequest := req.GetFrontendRequest()\n+\n+\t// TODO(dan): pass ref into this function?\n+\tref, err := ctx.Ref(a)\n+\tif err != nil {\n+\t\treturn nil, err\n+\t}\n+\n+\tvar info *activity.ActivityExecutionInfo\n+\tif request.GetIncludeInfo() {\n+\t\tinfo, err = a.buildActivityExecutionInfo(ctx, chasm.EntityKey{\n+\t\t\tNamespaceID: req.GetNamespaceId(),\n+\t\t\tBusinessID:  request.GetActivityId(),\n+\t\t\tEntityID:    request.GetRunId(),\n+\t\t})\n+\t\tif err != nil {\n+\t\t\treturn nil, err\n+\t\t}\n+\t}\n+\n+\tvar input *commonpb.Payloads\n+\tif request.GetIncludeInput() {\n+\t\tactivityRequest, err := a.RequestData.Get(ctx)\n+\t\tif err != nil {\n+\t\t\treturn nil, err\n+\t\t}\n+\t\tinput = activityRequest.Input","path":"chasm/lib/activity/activity.go","commit_id":"384f23bf064696e80ccc71056daf19a1c8d1edea","original_commit_id":"b24a0220435f567e7e3cacb95bd8fe78c17dc67b","user":{"login":"bergundy","id":52304,"node_id":"MDQ6VXNlcjUyMzA0","avatar_url":"https://avatars.githubusercontent.com/u/52304?v=4","gravatar_id":"","url":"https://api.github.com/users/bergundy","html_url":"https://github.com/bergundy","followers_url":"https://api.github.com/users/bergundy/followers","following_url":"https://api.github.com/users/bergundy/following{/other_user}","gists_url":"https://api.github.com/users/bergundy/gists{/gist_id}","starred_url":"https://api.github.com/users/bergundy/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/bergundy/subscriptions","organizations_url":"https://api.github.com/users/bergundy/orgs","repos_url":"https://api.github.com/users/bergundy/repos","events_url":"https://api.github.com/users/bergundy/events{/privacy}","received_events_url":"https://api.github.com/users/bergundy/received_events","type":"User","user_view_type":"public","site_admin":false},"body":"nit: `GetInput()`?","created_at":"2025-11-14T01:24:12Z","updated_at":"2025-11-14T01:29:56Z","html_url":"https://github.com/temporalio/temporal/pull/8563#discussion_r2525431130","pull_request_url":"https://api.github.com/repos/temporalio/temporal/pulls/8563","_links":{"self":{"href":"https://api.github.com/repos/temporalio/temporal/pulls/comments/2525431130"},"html":{"href":"https://github.com/temporalio/temporal/pull/8563#discussion_r2525431130"},"pull_request":{"href":"https://api.github.com/repos/temporalio/temporal/pulls/8563"}},"reactions":{"url":"https://api.github.com/repos/temporalio/temporal/pulls/comments/2525431130/reactions","total_count":0,"+1":0,"-1":0,"laugh":0,"hooray":0,"confused":0,"heart":0,"rocket":0,"eyes":0},"start_line":null,"original_start_line":null,"start_side":null,"line":null,"original_line":409,"side":"RIGHT","author_association":"MEMBER","original_position":129,"position":1,"subject_type":"line"},{"url":"https://api.github.com/repos/temporalio/temporal/pulls/comments/2525433786","pull_request_review_id":3462362851,"id":2525433786,"node_id":"PRRC_kwDODNqesM6Whw-6","diff_hunk":"@@ -314,3 +315,125 @@ func (a *Activity) RecordHeartbeat(ctx chasm.MutableContext, details *commonpb.P\n \t})\n \treturn nil, nil\n }\n+\n+func (a *Activity) buildActivityExecutionInfo(ctx chasm.Context, key chasm.EntityKey) (*activity.ActivityExecutionInfo, error) {\n+\tif a.ActivityState == nil {\n+\t\treturn nil, errors.New(\"activity state is nil\")\n+\t}\n+\n+\t// TODO(dan): support pause states\n+\tvar status enumspb.ActivityExecutionStatus\n+\tvar runState enumspb.PendingActivityState\n+\tswitch a.GetStatus() {\n+\tcase activitypb.ACTIVITY_EXECUTION_STATUS_UNSPECIFIED:\n+\t\tstatus = enumspb.ACTIVITY_EXECUTION_STATUS_UNSPECIFIED\n+\t\trunState = enumspb.PENDING_ACTIVITY_STATE_UNSPECIFIED\n+\tcase activitypb.ACTIVITY_EXECUTION_STATUS_SCHEDULED:\n+\t\tstatus = enumspb.ACTIVITY_EXECUTION_STATUS_RUNNING\n+\t\trunState = enumspb.PENDING_ACTIVITY_STATE_SCHEDULED\n+\tcase activitypb.ACTIVITY_EXECUTION_STATUS_STARTED:\n+\t\tstatus = enumspb.ACTIVITY_EXECUTION_STATUS_RUNNING\n+\t\trunState = enumspb.PENDING_ACTIVITY_STATE_STARTED\n+\tcase activitypb.ACTIVITY_EXECUTION_STATUS_CANCEL_REQUESTED:\n+\t\tstatus = enumspb.ACTIVITY_EXECUTION_STATUS_RUNNING\n+\t\trunState = enumspb.PENDING_ACTIVITY_STATE_CANCEL_REQUESTED\n+\tcase activitypb.ACTIVITY_EXECUTION_STATUS_COMPLETED:\n+\t\tstatus = enumspb.ACTIVITY_EXECUTION_STATUS_COMPLETED\n+\t\trunState = enumspb.PENDING_ACTIVITY_STATE_UNSPECIFIED\n+\tcase activitypb.ACTIVITY_EXECUTION_STATUS_FAILED:\n+\t\tstatus = enumspb.ACTIVITY_EXECUTION_STATUS_FAILED\n+\t\trunState = enumspb.PENDING_ACTIVITY_STATE_UNSPECIFIED\n+\tcase activitypb.ACTIVITY_EXECUTION_STATUS_CANCELED:\n+\t\tstatus = enumspb.ACTIVITY_EXECUTION_STATUS_CANCELED\n+\t\trunState = enumspb.PENDING_ACTIVITY_STATE_UNSPECIFIED\n+\tcase activitypb.ACTIVITY_EXECUTION_STATUS_TERMINATED:\n+\t\tstatus = enumspb.ACTIVITY_EXECUTION_STATUS_TERMINATED\n+\t\trunState = enumspb.PENDING_ACTIVITY_STATE_UNSPECIFIED\n+\tcase activitypb.ACTIVITY_EXECUTION_STATUS_TIMED_OUT:\n+\t\tstatus = enumspb.ACTIVITY_EXECUTION_STATUS_TIMED_OUT\n+\t\trunState = enumspb.PENDING_ACTIVITY_STATE_UNSPECIFIED\n+\tdefault:\n+\t\treturn nil, serviceerror.NewInternalf(\"unknown activity execution status: %s\", a.GetStatus())\n+\t}\n+\n+\trequestData, err := a.RequestData.Get(ctx)\n+\tif err != nil {\n+\t\treturn nil, err\n+\t}\n+\n+\tinfo := &activity.ActivityExecutionInfo{\n+\t\tActivityId:    key.BusinessID,\n+\t\tRunId:         key.EntityID,\n+\t\tActivityType:  a.GetActivityType(),\n+\t\tStatus:        status,\n+\t\tRunState:      runState,\n+\t\tScheduledTime: a.GetScheduledTime(),\n+\t\tPriority:      a.GetPriority(),\n+\t\tHeader:        requestData.GetHeader(),\n+\t\t// TODO(dan): populate remaining fields\n+\t}\n+\n+\treturn info, nil\n+}\n+\n+func (a *Activity) buildPollActivityExecutionResponse(\n+\tctx chasm.Context,\n+\treq *activitypb.PollActivityExecutionRequest,\n+) (*activitypb.PollActivityExecutionResponse, error) {\n+\trequest := req.GetFrontendRequest()\n+\n+\t// TODO(dan): pass ref into this function?\n+\tref, err := ctx.Ref(a)\n+\tif err != nil {\n+\t\treturn nil, err\n+\t}\n+\n+\tvar info *activity.ActivityExecutionInfo\n+\tif request.GetIncludeInfo() {\n+\t\tinfo, err = a.buildActivityExecutionInfo(ctx, chasm.EntityKey{\n+\t\t\tNamespaceID: req.GetNamespaceId(),\n+\t\t\tBusinessID:  request.GetActivityId(),\n+\t\t\tEntityID:    request.GetRunId(),\n+\t\t})\n+\t\tif err != nil {\n+\t\t\treturn nil, err\n+\t\t}\n+\t}\n+\n+\tvar input *commonpb.Payloads\n+\tif request.GetIncludeInput() {\n+\t\tactivityRequest, err := a.RequestData.Get(ctx)\n+\t\tif err != nil {\n+\t\t\treturn nil, err\n+\t\t}\n+\t\tinput = activityRequest.Input\n+\t}\n+\n+\tresponse := &workflowservice.PollActivityExecutionResponse{\n+\t\tInfo:                     info,\n+\t\tRunId:                    ctx.ExecutionKey().EntityID,","path":"chasm/lib/activity/activity.go","commit_id":"1d59e66d0ce5d91819f92c428ef5ab4c4efca1fb","original_commit_id":"b24a0220435f567e7e3cacb95bd8fe78c17dc67b","user":{"login":"bergundy","id":52304,"node_id":"MDQ6VXNlcjUyMzA0","avatar_url":"https://avatars.githubusercontent.com/u/52304?v=4","gravatar_id":"","url":"https://api.github.com/users/bergundy","html_url":"https://github.com/bergundy","followers_url":"https://api.github.com/users/bergundy/followers","following_url":"https://api.github.com/users/bergundy/following{/other_user}","gists_url":"https://api.github.com/users/bergundy/gists{/gist_id}","starred_url":"https://api.github.com/users/bergundy/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/bergundy/subscriptions","organizations_url":"https://api.github.com/users/bergundy/orgs","repos_url":"https://api.github.com/users/bergundy/repos","events_url":"https://api.github.com/users/bergundy/events{/privacy}","received_events_url":"https://api.github.com/users/bergundy/received_events","type":"User","user_view_type":"public","site_admin":false},"body":"Hmm... I see we have the run ID here too but here you used the right one.","created_at":"2025-11-14T01:25:06Z","updated_at":"2025-11-14T01:29:56Z","html_url":"https://github.com/temporalio/temporal/pull/8563#discussion_r2525433786","pull_request_url":"https://api.github.com/repos/temporalio/temporal/pulls/8563","_links":{"self":{"href":"https://api.github.com/repos/temporalio/temporal/pulls/comments/2525433786"},"html":{"href":"https://github.com/temporalio/temporal/pull/8563#discussion_r2525433786"},"pull_request":{"href":"https://api.github.com/repos/temporalio/temporal/pulls/8563"}},"reactions":{"url":"https://api.github.com/repos/temporalio/temporal/pulls/comments/2525433786/reactions","total_count":1,"+1":1,"-1":0,"laugh":0,"hooray":0,"confused":0,"heart":0,"rocket":0,"eyes":0},"start_line":null,"original_start_line":null,"start_side":null,"line":411,"original_line":414,"side":"RIGHT","author_association":"MEMBER","original_position":134,"position":127,"subject_type":"line"},{"url":"https://api.github.com/repos/temporalio/temporal/pulls/comments/2525436567","pull_request_review_id":3462362851,"id":2525436567,"node_id":"PRRC_kwDODNqesM6WhxqX","diff_hunk":"@@ -314,3 +315,125 @@ func (a *Activity) RecordHeartbeat(ctx chasm.MutableContext, details *commonpb.P\n \t})\n \treturn nil, nil\n }\n+\n+func (a *Activity) buildActivityExecutionInfo(ctx chasm.Context, key chasm.EntityKey) (*activity.ActivityExecutionInfo, error) {\n+\tif a.ActivityState == nil {\n+\t\treturn nil, errors.New(\"activity state is nil\")\n+\t}\n+\n+\t// TODO(dan): support pause states\n+\tvar status enumspb.ActivityExecutionStatus\n+\tvar runState enumspb.PendingActivityState\n+\tswitch a.GetStatus() {\n+\tcase activitypb.ACTIVITY_EXECUTION_STATUS_UNSPECIFIED:\n+\t\tstatus = enumspb.ACTIVITY_EXECUTION_STATUS_UNSPECIFIED\n+\t\trunState = enumspb.PENDING_ACTIVITY_STATE_UNSPECIFIED\n+\tcase activitypb.ACTIVITY_EXECUTION_STATUS_SCHEDULED:\n+\t\tstatus = enumspb.ACTIVITY_EXECUTION_STATUS_RUNNING\n+\t\trunState = enumspb.PENDING_ACTIVITY_STATE_SCHEDULED\n+\tcase activitypb.ACTIVITY_EXECUTION_STATUS_STARTED:\n+\t\tstatus = enumspb.ACTIVITY_EXECUTION_STATUS_RUNNING\n+\t\trunState = enumspb.PENDING_ACTIVITY_STATE_STARTED\n+\tcase activitypb.ACTIVITY_EXECUTION_STATUS_CANCEL_REQUESTED:\n+\t\tstatus = enumspb.ACTIVITY_EXECUTION_STATUS_RUNNING\n+\t\trunState = enumspb.PENDING_ACTIVITY_STATE_CANCEL_REQUESTED\n+\tcase activitypb.ACTIVITY_EXECUTION_STATUS_COMPLETED:\n+\t\tstatus = enumspb.ACTIVITY_EXECUTION_STATUS_COMPLETED\n+\t\trunState = enumspb.PENDING_ACTIVITY_STATE_UNSPECIFIED\n+\tcase activitypb.ACTIVITY_EXECUTION_STATUS_FAILED:\n+\t\tstatus = enumspb.ACTIVITY_EXECUTION_STATUS_FAILED\n+\t\trunState = enumspb.PENDING_ACTIVITY_STATE_UNSPECIFIED\n+\tcase activitypb.ACTIVITY_EXECUTION_STATUS_CANCELED:\n+\t\tstatus = enumspb.ACTIVITY_EXECUTION_STATUS_CANCELED\n+\t\trunState = enumspb.PENDING_ACTIVITY_STATE_UNSPECIFIED\n+\tcase activitypb.ACTIVITY_EXECUTION_STATUS_TERMINATED:\n+\t\tstatus = enumspb.ACTIVITY_EXECUTION_STATUS_TERMINATED\n+\t\trunState = enumspb.PENDING_ACTIVITY_STATE_UNSPECIFIED\n+\tcase activitypb.ACTIVITY_EXECUTION_STATUS_TIMED_OUT:\n+\t\tstatus = enumspb.ACTIVITY_EXECUTION_STATUS_TIMED_OUT\n+\t\trunState = enumspb.PENDING_ACTIVITY_STATE_UNSPECIFIED\n+\tdefault:\n+\t\treturn nil, serviceerror.NewInternalf(\"unknown activity execution status: %s\", a.GetStatus())\n+\t}\n+\n+\trequestData, err := a.RequestData.Get(ctx)\n+\tif err != nil {\n+\t\treturn nil, err\n+\t}\n+\n+\tinfo := &activity.ActivityExecutionInfo{\n+\t\tActivityId:    key.BusinessID,\n+\t\tRunId:         key.EntityID,\n+\t\tActivityType:  a.GetActivityType(),\n+\t\tStatus:        status,\n+\t\tRunState:      runState,\n+\t\tScheduledTime: a.GetScheduledTime(),\n+\t\tPriority:      a.GetPriority(),\n+\t\tHeader:        requestData.GetHeader(),\n+\t\t// TODO(dan): populate remaining fields\n+\t}\n+\n+\treturn info, nil\n+}\n+\n+func (a *Activity) buildPollActivityExecutionResponse(\n+\tctx chasm.Context,\n+\treq *activitypb.PollActivityExecutionRequest,\n+) (*activitypb.PollActivityExecutionResponse, error) {\n+\trequest := req.GetFrontendRequest()\n+\n+\t// TODO(dan): pass ref into this function?\n+\tref, err := ctx.Ref(a)\n+\tif err != nil {\n+\t\treturn nil, err\n+\t}\n+\n+\tvar info *activity.ActivityExecutionInfo\n+\tif request.GetIncludeInfo() {\n+\t\tinfo, err = a.buildActivityExecutionInfo(ctx, chasm.EntityKey{\n+\t\t\tNamespaceID: req.GetNamespaceId(),\n+\t\t\tBusinessID:  request.GetActivityId(),\n+\t\t\tEntityID:    request.GetRunId(),\n+\t\t})\n+\t\tif err != nil {\n+\t\t\treturn nil, err\n+\t\t}\n+\t}\n+\n+\tvar input *commonpb.Payloads\n+\tif request.GetIncludeInput() {\n+\t\tactivityRequest, err := a.RequestData.Get(ctx)\n+\t\tif err != nil {\n+\t\t\treturn nil, err\n+\t\t}\n+\t\tinput = activityRequest.Input\n+\t}\n+\n+\tresponse := &workflowservice.PollActivityExecutionResponse{\n+\t\tInfo:                     info,\n+\t\tRunId:                    ctx.ExecutionKey().EntityID,\n+\t\tInput:                    input,\n+\t\tStateChangeLongPollToken: ref,\n+\t}\n+\n+\tif request.GetIncludeOutcome() {\n+\t\tactivityOutcome, err := a.Outcome.Get(ctx)\n+\t\tif err != nil {\n+\t\t\treturn nil, err\n+\t\t}\n+\t\tswitch v := activityOutcome.GetVariant().(type) {\n+\t\tcase *activitypb.ActivityOutcome_Failed_:\n+\t\t\tresponse.Outcome = &workflowservice.PollActivityExecutionResponse_Failure{\n+\t\t\t\tFailure: v.Failed.GetFailure(),","path":"chasm/lib/activity/activity.go","commit_id":"109a90fe02cb145ef9d0481242c354b066ca027d","original_commit_id":"b24a0220435f567e7e3cacb95bd8fe78c17dc67b","user":{"login":"bergundy","id":52304,"node_id":"MDQ6VXNlcjUyMzA0","avatar_url":"https://avatars.githubusercontent.com/u/52304?v=4","gravatar_id":"","url":"https://api.github.com/users/bergundy","html_url":"https://github.com/bergundy","followers_url":"https://api.github.com/users/bergundy/followers","following_url":"https://api.github.com/users/bergundy/following{/other_user}","gists_url":"https://api.github.com/users/bergundy/gists{/gist_id}","starred_url":"https://api.github.com/users/bergundy/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/bergundy/subscriptions","organizations_url":"https://api.github.com/users/bergundy/orgs","repos_url":"https://api.github.com/users/bergundy/repos","events_url":"https://api.github.com/users/bergundy/events{/privacy}","received_events_url":"https://api.github.com/users/bergundy/received_events","type":"User","user_view_type":"public","site_admin":false},"body":"This could be empty and you'd need to populate it from the last attempt failure in some cases. See the proto definitions for when to use one vs. the other.","created_at":"2025-11-14T01:26:30Z","updated_at":"2025-11-14T01:29:56Z","html_url":"https://github.com/temporalio/temporal/pull/8563#discussion_r2525436567","pull_request_url":"https://api.github.com/repos/temporalio/temporal/pulls/8563","_links":{"self":{"href":"https://api.github.com/repos/temporalio/temporal/pulls/comments/2525436567"},"html":{"href":"https://github.com/temporalio/temporal/pull/8563#discussion_r2525436567"},"pull_request":{"href":"https://api.github.com/repos/temporalio/temporal/pulls/8563"}},"reactions":{"url":"https://api.github.com/repos/temporalio/temporal/pulls/comments/2525436567/reactions","total_count":1,"+1":0,"-1":0,"laugh":0,"hooray":0,"confused":0,"heart":0,"rocket":0,"eyes":1},"start_line":null,"original_start_line":null,"start_side":null,"line":null,"original_line":427,"side":"RIGHT","author_association":"MEMBER","original_position":147,"position":1,"subject_type":"line"},{"url":"https://api.github.com/repos/temporalio/temporal/pulls/comments/2525508778","pull_request_review_id":3462457440,"id":2525508778,"node_id":"PRRC_kwDODNqesM6WiDSq","diff_hunk":"@@ -51,3 +53,177 @@ func (h *handler) StartActivityExecution(ctx context.Context, req *activitypb.St\n \t\tFrontendResponse: response,\n \t}, nil\n }\n+\n+// PollActivityExecution handles PollActivityExecutionRequest from frontend. This method supports\n+// querying current activity state, optionally as a long-poll that waits for certain state changes.\n+// It is used by clients to poll for activity state and/or result.\n+func (h *handler) PollActivityExecution(\n+\tctx context.Context,\n+\treq *activitypb.PollActivityExecutionRequest,\n+) (*activitypb.PollActivityExecutionResponse, error) {\n+\n+\twaitPolicy := req.GetFrontendRequest().GetWaitPolicy()\n+\tif waitPolicy == nil {\n+\t\treturn chasm.ReadComponent(\n+\t\t\tctx,\n+\t\t\tchasm.NewComponentRef[*Activity](chasm.EntityKey{\n+\t\t\t\tNamespaceID: req.GetNamespaceId(),\n+\t\t\t\tBusinessID:  req.GetFrontendRequest().GetActivityId(),\n+\t\t\t\tEntityID:    req.GetFrontendRequest().GetRunId(),\n+\t\t\t}),\n+\t\t\t(*Activity).buildPollActivityExecutionResponse,\n+\t\t\treq,\n+\t\t\tnil,\n+\t\t)\n+\t}\n+\n+\tvar response *activitypb.PollActivityExecutionResponse\n+\tvar newRef []byte\n+\tvar err error\n+\n+\tswitch waitPolicy.(type) {\n+\tcase *workflowservice.PollActivityExecutionRequest_WaitAnyStateChange:\n+\t\tresponse, newRef, err = pollActivityExecutionWaitAnyStateChange(ctx, req)\n+\tcase *workflowservice.PollActivityExecutionRequest_WaitCompletion:\n+\t\tresponse, newRef, err = pollActivityExecutionWaitCompletion(ctx, req)\n+\tdefault:\n+\t\treturn nil, fmt.Errorf(\"unexpected wait policy type: %T\", waitPolicy)\n+\t}\n+\tif err != nil {\n+\t\treturn nil, err\n+\t}\n+\tresponse.GetFrontendResponse().StateChangeLongPollToken = newRef\n+\treturn response, nil\n+}\n+\n+// pollActivityExecutionWaitAnyStateChange waits until the activity state has advanced beyond that\n+// specified by the submitted token. If no token was submitted, it returns the current state without\n+// waiting.\n+func pollActivityExecutionWaitAnyStateChange(\n+\tctx context.Context,\n+\treq *activitypb.PollActivityExecutionRequest,\n+) (*activitypb.PollActivityExecutionResponse, []byte, error) {\n+\n+\t// TODO(dan): do we want to guarantee that response data will differ from that received when the\n+\t// token was obtained? It's potentially confusing for the server to say \"there's been a change\"\n+\t// while returning data in which the change is not apparent.\n+\n+\trefBytesFromToken := req.GetFrontendRequest().\n+\t\tGetWaitPolicy().(*workflowservice.PollActivityExecutionRequest_WaitAnyStateChange).\n+\t\tWaitAnyStateChange.GetLongPollToken()\n+\n+\tvar lastSeenRef chasm.ComponentRef\n+\tif refBytesFromToken != nil {\n+\t\tvar err error\n+\t\tlastSeenRef, err = chasm.DeserializeComponentRef(refBytesFromToken)\n+\t\tif err != nil {\n+\t\t\treturn nil, nil, serviceerror.NewInvalidArgument(\"invalid long poll token\")\n+\t\t}\n+\t\tif lastSeenRef.NamespaceID != req.GetNamespaceId() ||\n+\t\t\tlastSeenRef.BusinessID != req.GetFrontendRequest().GetActivityId() ||\n+\t\t\tlastSeenRef.EntityID != req.GetFrontendRequest().GetRunId() {\n+\t\t\t// token is inconsistent with request\n+\t\t\treturn nil, nil, serviceerror.NewInvalidArgument(\"invalid long poll token\")\n+\t\t}\n+\t} else {\n+\t\t// This ref will compare less than currentRef in the comparison below.\n+\t\tlastSeenRef = chasm.NewComponentRef[*Activity](chasm.EntityKey{\n+\t\t\tNamespaceID: req.GetNamespaceId(),\n+\t\t\tBusinessID:  req.GetFrontendRequest().GetActivityId(),\n+\t\t\tEntityID:    req.GetFrontendRequest().GetRunId(),\n+\t\t})\n+\t}\n+\n+\t// PollComponent will return an error if lastSeenRef is not consistent with the entity\n+\t// transition history on this shard, or if the state on this shard is behind the ref after a\n+\t// reload.\n+\t// TODO(dan): retryability of these errors\n+\treturn chasm.PollComponent(\n+\t\tctx,\n+\t\tlastSeenRef,\n+\t\tfunc(\n+\t\t\ta *Activity,\n+\t\t\tctx chasm.Context,\n+\t\t\treq *activitypb.PollActivityExecutionRequest,\n+\t\t) (*activitypb.PollActivityExecutionResponse, bool, error) {\n+\t\t\t// TODO(dan): we're walking the tree to construct a ref when all we want here is the\n+\t\t\t// root/entity VT. Would it make sense for Context to provide access to root node?\n+\t\t\tcurrentRefBytes, err := ctx.Ref(a)\n+\t\t\tif err != nil {\n+\t\t\t\treturn nil, false, err\n+\t\t\t}\n+\t\t\tcurrentRef, err := chasm.DeserializeComponentRef(currentRefBytes)\n+\t\t\tif err != nil {\n+\t\t\t\treturn nil, false, err\n+\t\t\t}\n+\n+\t\t\tif lastSeenRef.EntityID != currentRef.EntityID {\n+\t\t\t\t// The runID from the token doesn't match this shard's state. We return immediately,\n+\t\t\t\t// on the basis that this constitutes a state change. If the runID from the token is\n+\t\t\t\t// ahead of this shard's state then this will be detected by shard ownership or\n+\t\t\t\t// staleness checks and the caller will receive an error.\n+\t\t\t\tresponse, err := a.buildPollActivityExecutionResponse(ctx, req)\n+\t\t\t\tif err != nil {\n+\t\t\t\t\treturn nil, true, err\n+\t\t\t\t}\n+\t\t\t\treturn response, true, nil","path":"chasm/lib/activity/handler.go","commit_id":"b24a0220435f567e7e3cacb95bd8fe78c17dc67b","original_commit_id":"f8ccafbb3c10a723c3180b7c0da6caee9ff4f073","user":{"login":"dandavison","id":52205,"node_id":"MDQ6VXNlcjUyMjA1","avatar_url":"https://avatars.githubusercontent.com/u/52205?v=4","gravatar_id":"","url":"https://api.github.com/users/dandavison","html_url":"https://github.com/dandavison","followers_url":"https://api.github.com/users/dandavison/followers","following_url":"https://api.github.com/users/dandavison/following{/other_user}","gists_url":"https://api.github.com/users/dandavison/gists{/gist_id}","starred_url":"https://api.github.com/users/dandavison/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/dandavison/subscriptions","organizations_url":"https://api.github.com/users/dandavison/orgs","repos_url":"https://api.github.com/users/dandavison/repos","events_url":"https://api.github.com/users/dandavison/events{/privacy}","received_events_url":"https://api.github.com/users/dandavison/received_events","type":"User","user_view_type":"public","site_admin":false},"body":"I think I was wrong and you were right. Changed!","created_at":"2025-11-14T02:01:57Z","updated_at":"2025-11-14T02:01:57Z","html_url":"https://github.com/temporalio/temporal/pull/8563#discussion_r2525508778","pull_request_url":"https://api.github.com/repos/temporalio/temporal/pulls/8563","_links":{"self":{"href":"https://api.github.com/repos/temporalio/temporal/pulls/comments/2525508778"},"html":{"href":"https://github.com/temporalio/temporal/pull/8563#discussion_r2525508778"},"pull_request":{"href":"https://api.github.com/repos/temporalio/temporal/pulls/8563"}},"reactions":{"url":"https://api.github.com/repos/temporalio/temporal/pulls/comments/2525508778/reactions","total_count":0,"+1":0,"-1":0,"laugh":0,"hooray":0,"confused":0,"heart":0,"rocket":0,"eyes":0},"start_line":null,"original_start_line":null,"start_side":null,"line":null,"original_line":169,"side":"RIGHT","in_reply_to_id":2520276996,"author_association":"MEMBER","original_position":127,"position":1,"subject_type":"line"},{"url":"https://api.github.com/repos/temporalio/temporal/pulls/comments/2525522960","pull_request_review_id":3462473542,"id":2525522960,"node_id":"PRRC_kwDODNqesM6WiGwQ","diff_hunk":"@@ -0,0 +1,176 @@\n+// This file implements ChasmNotifier, which allows subscribers to subscribe to notifications\n+// relating to components in a specified CHASM entity. It is based on the events.Notifier\n+// implementation.\n+package history\n+\n+import (\n+\t\"sync/atomic\"\n+\t\"time\"\n+\n+\t\"github.com/dgryski/go-farm\"\n+\t\"github.com/google/uuid\"\n+\t\"go.temporal.io/api/serviceerror\"\n+\t\"go.temporal.io/server/chasm\"\n+\t\"go.temporal.io/server/common\"\n+\t\"go.temporal.io/server/common/clock\"\n+\t\"go.temporal.io/server/common/collection\"\n+\t\"go.temporal.io/server/common/metrics\"\n+\t\"go.temporal.io/server/service/history/configs\"\n+)\n+\n+type (\n+\t// ChasmNotifier allows subscribers to subscribe to notifications relating to components in a\n+\t// specified CHASM entity.\n+\tChasmNotifier struct {\n+\t\ttimeSource      clock.TimeSource\n+\t\tmetricsHandler  metrics.Handler\n+\t\tstatus          int32\n+\t\tnotificationsCh chan *ChasmComponentNotification\n+\t\tstopCh          chan bool\n+\t\tsubscribers     collection.ConcurrentTxMap\n+\t}\n+\n+\t// ChasmComponentNotification is a notification relating to a CHASM component.\n+\tChasmComponentNotification struct {\n+\t\t// TODO(dan): confirm that we want Key in addition to the key in serialized ref\n+\t\tKey       chasm.EntityKey\n+\t\tRef       []byte\n+\t\ttimestamp time.Time\n+\t}\n+)\n+\n+// NewChasmNotifier creates a new instance of ChasmNotifier allowing subscribers to subscribe to\n+// notifications relating to components in a specified CHASM entity.\n+func NewChasmNotifier(\n+\ttimeSource clock.TimeSource,\n+\tmetricsHandler metrics.Handler,\n+\tconfig *configs.Config,\n+) *ChasmNotifier {\n+\treturn &ChasmNotifier{\n+\t\ttimeSource:      timeSource,\n+\t\tmetricsHandler:  metricsHandler.WithTags(metrics.OperationTag(metrics.ChasmComponentNotificationScope)),\n+\t\tstatus:          common.DaemonStatusInitialized,\n+\t\tstopCh:          make(chan bool),\n+\t\tnotificationsCh: make(chan *ChasmComponentNotification, 1000),\n+\t\tsubscribers: collection.NewShardedConcurrentTxMap(1024, func(key any) uint32 {\n+\t\t\tentityKey, ok := key.(chasm.EntityKey)\n+\t\t\tif !ok {\n+\t\t\t\treturn 0\n+\t\t\t}\n+\t\t\treturn farm.Fingerprint32([]byte(entityKey.NamespaceID + \"_\" + entityKey.BusinessID))\n+\t\t}),\n+\t}\n+}\n+\n+// Start starts the ChasmNotifier.\n+func (n *ChasmNotifier) Start() {\n+\tif !atomic.CompareAndSwapInt32(&n.status, common.DaemonStatusInitialized, common.DaemonStatusStarted) {\n+\t\treturn\n+\t}\n+\tgo n.dequeueLoop()\n+}\n+\n+// Stop stops the ChasmNotifier.\n+func (n *ChasmNotifier) Stop() {\n+\tif !atomic.CompareAndSwapInt32(&n.status, common.DaemonStatusStarted, common.DaemonStatusStopped) {\n+\t\treturn\n+\t}\n+\tclose(n.stopCh)\n+}\n+\n+// Notify sends a notification about a CHASM component.\n+func (n *ChasmNotifier) Notify(notification *ChasmComponentNotification) {\n+\tn.enqueue(notification)\n+}\n+\n+// Subscribe returns a channel that will receive notifications relating to the entity,\n+// along with a subscriber ID that can be passed to UnsubscribeNotification.\n+func (n *ChasmNotifier) Subscribe(key chasm.EntityKey) (chan *ChasmComponentNotification, string, error) {\n+\tchannel := make(chan *ChasmComponentNotification, 1)\n+\tsubscriberID := uuid.NewString()\n+\n+\t// TODO(dan): This allocates a value that will not be used if key already has subscribers (code\n+\t// copied from events.Notifier)\n+\tsubscribers := map[string]chan *ChasmComponentNotification{\n+\t\tsubscriberID: channel,\n+\t}\n+\n+\t// If key exists then add new subscriber to that second-level map. Otherwise, add a new\n+\t// second-level map containing the new subscriber.\n+\t_, _, err := n.subscribers.PutOrDo(key, subscribers, func(key any, value any) error {\n+\t\tsubscribers := value.(map[string]chan *ChasmComponentNotification)\n+\t\tif _, ok := subscribers[subscriberID]; ok {\n+\t\t\t// uuid collision\n+\t\t\treturn serviceerror.NewUnavailable(\"Unable to watch component.\")\n+\t\t}\n+\t\tsubscribers[subscriberID] = channel\n+\t\treturn nil\n+\t})\n+\tif err != nil {\n+\t\treturn nil, \"\", err\n+\t}\n+\treturn channel, subscriberID, nil\n+}\n+\n+// Unsubscribe unsubscribes the subscriber from notifications relating to the entity.\n+func (n *ChasmNotifier) Unsubscribe(key chasm.EntityKey, subscriberID string) error {\n+\tsuccess := true\n+\tn.subscribers.RemoveIf(key, func(key any, value any) bool {\n+\t\tsubscribers := value.(map[string]chan *ChasmComponentNotification)\n+\t\tif _, ok := subscribers[subscriberID]; !ok {\n+\t\t\tsuccess = false\n+\t\t} else {\n+\t\t\tdelete(subscribers, subscriberID)\n+\t\t}\n+\t\treturn len(subscribers) == 0\n+\t})\n+\tif !success {\n+\t\t// This indicates a bug\n+\t\treturn serviceerror.NewInternal(\"Unable to unwatch component.\")\n+\t}\n+\treturn nil\n+}\n+\n+func (n *ChasmNotifier) enqueue(notification *ChasmComponentNotification) {\n+\t// TODO(dan) This enqueues to an intermediate channel which might fill up, thus dropping\n+\t// notifications for all subscribers. Consider broadcasting synchronously on enqueue instead.\n+\tnotification.timestamp = n.timeSource.Now()\n+\tselect {\n+\tcase n.notificationsCh <- notification:\n+\tdefault:\n+\t\tmetrics.ChasmComponentNotificationFailDeliveryCount.With(n.metricsHandler).Record(1)\n+\t}\n+}\n+\n+func (n *ChasmNotifier) dequeueLoop() {\n+\tfor {\n+\t\tmetrics.ChasmComponentNotificationInFlightMessageGauge.With(n.metricsHandler).Record(float64(len(n.notificationsCh)))\n+\t\tselect {\n+\t\tcase notification := <-n.notificationsCh:\n+\t\t\tmetrics.ChasmComponentNotificationQueueingLatency.With(n.metricsHandler).Record(time.Since(notification.timestamp))\n+\t\t\tn.broadcast(notification)\n+\t\tcase <-n.stopCh:\n+\t\t\treturn\n+\t\t}\n+\t}\n+}\n+\n+func (n *ChasmNotifier) broadcast(notification *ChasmComponentNotification) {\n+\tstartTime := time.Now().UTC()\n+\tdefer func() {\n+\t\t// TODO(dan): retaining \"Fanout\" name for consistency with events.Notifier for now\n+\t\tmetrics.ChasmComponentNotificationFanoutLatency.With(n.metricsHandler).Record(time.Since(startTime))\n+\t}()\n+\t_, _, _ = n.subscribers.GetAndDo(notification.Key, func(key any, value any) error {\n+\t\tsubscribers := value.(map[string]chan *ChasmComponentNotification)\n+\t\tfor _, ch := range subscribers {\n+\t\t\tselect {\n+\t\t\tcase ch <- notification:\n+\t\t\tdefault:\n+\t\t\t\t// Subscriber channel is full.\n+\t\t\t\t// TODO(dan): metric? log?","path":"service/history/chasm_notifier.go","commit_id":"9f8d762f3279f3b16d2217ae254bb3f85df69b44","original_commit_id":"c88896985ee8b4a5cd9c508293e4431293e28fde","user":{"login":"cursor[bot]","id":206951365,"node_id":"BOT_kgDODFXTxQ","avatar_url":"https://avatars.githubusercontent.com/in/1210556?v=4","gravatar_id":"","url":"https://api.github.com/users/cursor%5Bbot%5D","html_url":"https://github.com/apps/cursor","followers_url":"https://api.github.com/users/cursor%5Bbot%5D/followers","following_url":"https://api.github.com/users/cursor%5Bbot%5D/following{/other_user}","gists_url":"https://api.github.com/users/cursor%5Bbot%5D/gists{/gist_id}","starred_url":"https://api.github.com/users/cursor%5Bbot%5D/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/cursor%5Bbot%5D/subscriptions","organizations_url":"https://api.github.com/users/cursor%5Bbot%5D/orgs","repos_url":"https://api.github.com/users/cursor%5Bbot%5D/repos","events_url":"https://api.github.com/users/cursor%5Bbot%5D/events{/privacy}","received_events_url":"https://api.github.com/users/cursor%5Bbot%5D/received_events","type":"Bot","user_view_type":"public","site_admin":false},"body":"### Bug: Silent Drops Cause Indefinite Long-Poll Hangs\n\n<!-- **High Severity** -->\n\n<!-- DESCRIPTION START -->\nNotifications are silently dropped when the subscriber channel is full (buffer size 1). Since `PollComponent` in `chasm_engine.go` relies on receiving notifications to wake up after predicate checks, a dropped notification can cause the long-poll to hang indefinitely waiting for a state change that already occurred. This breaks the core functionality of the long-polling mechanism.\n<!-- DESCRIPTION END -->\n\n<!-- LOCATIONS START\nservice/history/chasm_notifier.go#L166-L171\nLOCATIONS END -->\n<a href=\"https://cursor.com/open?data=eyJhbGciOiJSUzI1NiIsInR5cCI6IkpXVCIsImtpZCI6ImJ1Z2JvdC12MSJ9.eyJ2ZXJzaW9uIjoxLCJ0eXBlIjoiQlVHQk9UX0ZJWF9JTl9DVVJTT1IiLCJkYXRhIjp7InJlZGlzS2V5IjoiYnVnYm90OmU3Yzk3ZDBkLWM5NDgtNDBjNy05MmM0LWUyMDMxNDU1MmU2ZSIsImVuY3J5cHRpb25LZXkiOiJuTTJNcHhwR1lwRk9PQjBBYkh2NXg5N0NFMHJkcXR6V29RSjFEOEpFU1JFIiwiYnJhbmNoIjoicG9sbC1jb21wb25lbnQifSwiaWF0IjoxNzYzMDg2MjQzLCJleHAiOjE3NjM2OTEwNDN9.MJz8tIrMf8D1beG_air1Er7dB-8T07FNNpQU6uDm2SDspsizBZKIyqnxaNW_ubDRASt9rBfTID08jUG3R4RuuGP2bRi9Py_zaxh3sKsIrWKNIbh2nhk0s2xTKahsPo4zH4u8b0hGiIYlkzKMBxrAFfLZLFKtQzIYlkzqOJ9Goul6spFIwSmPLJgrniaz3BfpChcvyERrEbJaJ_eK8hWFii9VLc2R-4XTs_ONuftPso6IQd4tVpeFjNUesI7UgClnDiNU6DyT_9Ta0ndETHWI34Ehr0Nx7oLvB_x_ufD2zZWwc6zaEDbiDr4qzX7a1cRgFHdpleq6Zc7Tj5ng5ZTHuA\"><picture><source media=\"(prefers-color-scheme: dark)\" srcset=\"https://cursor.com/fix-in-cursor-dark.svg\"><source media=\"(prefers-color-scheme: light)\" srcset=\"https://cursor.com/fix-in-cursor-light.svg\"><img alt=\"Fix in Cursor\" src=\"https://cursor.com/fix-in-cursor.svg\"></picture></a>&nbsp;<a href=\"https://cursor.com/agents?data=eyJhbGciOiJSUzI1NiIsInR5cCI6IkpXVCIsImtpZCI6ImJ1Z2JvdC12MSJ9.eyJ2ZXJzaW9uIjoxLCJ0eXBlIjoiQlVHQk9UX0ZJWF9JTl9XRUIiLCJkYXRhIjp7InJlZGlzS2V5IjoiYnVnYm90OmU3Yzk3ZDBkLWM5NDgtNDBjNy05MmM0LWUyMDMxNDU1MmU2ZSIsImVuY3J5cHRpb25LZXkiOiJuTTJNcHhwR1lwRk9PQjBBYkh2NXg5N0NFMHJkcXR6V29RSjFEOEpFU1JFIiwiYnJhbmNoIjoicG9sbC1jb21wb25lbnQiLCJyZXBvT3duZXIiOiJ0ZW1wb3JhbGlvIiwicmVwb05hbWUiOiJ0ZW1wb3JhbCIsInByTnVtYmVyIjo4NTYzLCJjb21taXRTaGEiOiJjODg4OTY5ODVlZThiNGE1Y2Q5YzUwODI5M2U0NDMxMjkzZTI4ZmRlIn0sImlhdCI6MTc2MzA4NjI0MywiZXhwIjoxNzYzNjkxMDQzfQ.jEo47ix5yReM6wyZ8ftI69W9ijPusvc8t5oa-DVbhd_vIFdbcFaQwS8DIzc4fi0wLMDdUXwD2oFhLbXDNo02dURFS2GaG1txlJTxG2OORUyI-vW0rHr9GHddycU_hw-hyOdIgpSEoX4Q1AO-1QSxkwt2CQ6A4mnTCIb5KeMZlrq08EAOyvZbNRyl73egcbgD7dMgf26gi-98z-PaVJfVpidpcrUfsqmBpm6k8nw6Ur0QpapWukAIDtQ_gWFzzerYEE8v8ShkRx3PP0oSEyZT7qVt3qD66HUaVYuAIogb16c9o23iuU-VKp4nxlvj5AjwRP8nNmrb8E4d_Rnj9w3GiA\"><picture><source media=\"(prefers-color-scheme: dark)\" srcset=\"https://cursor.com/fix-in-web-dark.svg\"><source media=\"(prefers-color-scheme: light)\" srcset=\"https://cursor.com/fix-in-web-light.svg\"><img alt=\"Fix in Web\" src=\"https://cursor.com/fix-in-web.svg\"></picture></a>\n\n","created_at":"2025-11-14T02:10:43Z","updated_at":"2025-11-14T02:10:44Z","html_url":"https://github.com/temporalio/temporal/pull/8563#discussion_r2525522960","pull_request_url":"https://api.github.com/repos/temporalio/temporal/pulls/8563","_links":{"self":{"href":"https://api.github.com/repos/temporalio/temporal/pulls/comments/2525522960"},"html":{"href":"https://github.com/temporalio/temporal/pull/8563#discussion_r2525522960"},"pull_request":{"href":"https://api.github.com/repos/temporalio/temporal/pulls/8563"}},"reactions":{"url":"https://api.github.com/repos/temporalio/temporal/pulls/comments/2525522960/reactions","total_count":0,"+1":0,"-1":0,"laugh":0,"hooray":0,"confused":0,"heart":0,"rocket":0,"eyes":0},"start_line":null,"original_start_line":null,"start_side":null,"line":null,"original_line":171,"side":"RIGHT","author_association":"NONE","original_position":171,"position":1,"subject_type":"line"},{"url":"https://api.github.com/repos/temporalio/temporal/pulls/comments/2529210255","pull_request_review_id":3467161791,"id":2529210255,"node_id":"PRRC_kwDODNqesM6WwK-P","diff_hunk":"@@ -204,9 +235,17 @@ func (e *ChasmEngine) UpdateComponent(\n \t\treturn nil, serviceerror.NewInternalf(\"componentRef: %+v: %s\", ref, err)\n \t}\n \n+\te.notifier.Notify(&ChasmComponentNotification{\n+\t\tKey: ref.EntityKey,\n+\t\tRef: newSerializedRef,\n+\t})","path":"service/history/chasm_engine.go","commit_id":"da6009564e796063faf853352077eecdc1473612","original_commit_id":"eb1ded5ef804505544b0ab631d660b43072ee6f6","user":{"login":"dandavison","id":52205,"node_id":"MDQ6VXNlcjUyMjA1","avatar_url":"https://avatars.githubusercontent.com/u/52205?v=4","gravatar_id":"","url":"https://api.github.com/users/dandavison","html_url":"https://github.com/dandavison","followers_url":"https://api.github.com/users/dandavison/followers","following_url":"https://api.github.com/users/dandavison/following{/other_user}","gists_url":"https://api.github.com/users/dandavison/gists{/gist_id}","starred_url":"https://api.github.com/users/dandavison/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/dandavison/subscriptions","organizations_url":"https://api.github.com/users/dandavison/orgs","repos_url":"https://api.github.com/users/dandavison/repos","events_url":"https://api.github.com/users/dandavison/events{/privacy}","received_events_url":"https://api.github.com/users/dandavison/received_events","type":"User","user_view_type":"public","site_admin":false},"body":"Do you recommend we merge this as-is and address this later?","created_at":"2025-11-14T23:14:50Z","updated_at":"2025-11-14T23:14:50Z","html_url":"https://github.com/temporalio/temporal/pull/8563#discussion_r2529210255","pull_request_url":"https://api.github.com/repos/temporalio/temporal/pulls/8563","_links":{"self":{"href":"https://api.github.com/repos/temporalio/temporal/pulls/comments/2529210255"},"html":{"href":"https://github.com/temporalio/temporal/pull/8563#discussion_r2529210255"},"pull_request":{"href":"https://api.github.com/repos/temporalio/temporal/pulls/8563"}},"reactions":{"url":"https://api.github.com/repos/temporalio/temporal/pulls/comments/2529210255/reactions","total_count":0,"+1":0,"-1":0,"laugh":0,"hooray":0,"confused":0,"heart":0,"rocket":0,"eyes":0},"start_line":null,"original_start_line":null,"start_side":null,"line":null,"original_line":241,"side":"RIGHT","in_reply_to_id":2519344176,"author_association":"MEMBER","original_position":96,"position":1,"subject_type":"line"},{"url":"https://api.github.com/repos/temporalio/temporal/pulls/comments/2529211548","pull_request_review_id":3467163514,"id":2529211548,"node_id":"PRRC_kwDODNqesM6WwLSc","diff_hunk":"@@ -51,3 +53,177 @@ func (h *handler) StartActivityExecution(ctx context.Context, req *activitypb.St\n \t\tFrontendResponse: response,\n \t}, nil\n }\n+\n+// PollActivityExecution handles PollActivityExecutionRequest from frontend. This method supports\n+// querying current activity state, optionally as a long-poll that waits for certain state changes.\n+// It is used by clients to poll for activity state and/or result.\n+func (h *handler) PollActivityExecution(\n+\tctx context.Context,\n+\treq *activitypb.PollActivityExecutionRequest,\n+) (*activitypb.PollActivityExecutionResponse, error) {\n+\n+\twaitPolicy := req.GetFrontendRequest().GetWaitPolicy()\n+\tif waitPolicy == nil {\n+\t\treturn chasm.ReadComponent(\n+\t\t\tctx,\n+\t\t\tchasm.NewComponentRef[*Activity](chasm.EntityKey{\n+\t\t\t\tNamespaceID: req.GetNamespaceId(),\n+\t\t\t\tBusinessID:  req.GetFrontendRequest().GetActivityId(),\n+\t\t\t\tEntityID:    req.GetFrontendRequest().GetRunId(),\n+\t\t\t}),\n+\t\t\t(*Activity).buildPollActivityExecutionResponse,\n+\t\t\treq,\n+\t\t\tnil,\n+\t\t)\n+\t}\n+\n+\tvar response *activitypb.PollActivityExecutionResponse\n+\tvar newRef []byte\n+\tvar err error\n+\n+\tswitch waitPolicy.(type) {\n+\tcase *workflowservice.PollActivityExecutionRequest_WaitAnyStateChange:\n+\t\tresponse, newRef, err = pollActivityExecutionWaitAnyStateChange(ctx, req)\n+\tcase *workflowservice.PollActivityExecutionRequest_WaitCompletion:\n+\t\tresponse, newRef, err = pollActivityExecutionWaitCompletion(ctx, req)\n+\tdefault:\n+\t\treturn nil, fmt.Errorf(\"unexpected wait policy type: %T\", waitPolicy)\n+\t}\n+\tif err != nil {\n+\t\treturn nil, err\n+\t}\n+\tresponse.GetFrontendResponse().StateChangeLongPollToken = newRef\n+\treturn response, nil\n+}\n+\n+// pollActivityExecutionWaitAnyStateChange waits until the activity state has advanced beyond that\n+// specified by the submitted token. If no token was submitted, it returns the current state without\n+// waiting.\n+func pollActivityExecutionWaitAnyStateChange(\n+\tctx context.Context,\n+\treq *activitypb.PollActivityExecutionRequest,\n+) (*activitypb.PollActivityExecutionResponse, []byte, error) {\n+\n+\t// TODO(dan): do we want to guarantee that response data will differ from that received when the\n+\t// token was obtained? It's potentially confusing for the server to say \"there's been a change\"\n+\t// while returning data in which the change is not apparent.\n+\n+\trefBytesFromToken := req.GetFrontendRequest().\n+\t\tGetWaitPolicy().(*workflowservice.PollActivityExecutionRequest_WaitAnyStateChange).\n+\t\tWaitAnyStateChange.GetLongPollToken()\n+\n+\tvar lastSeenRef chasm.ComponentRef\n+\tif refBytesFromToken != nil {","path":"chasm/lib/activity/handler.go","commit_id":"c88896985ee8b4a5cd9c508293e4431293e28fde","original_commit_id":"f8ccafbb3c10a723c3180b7c0da6caee9ff4f073","user":{"login":"dandavison","id":52205,"node_id":"MDQ6VXNlcjUyMjA1","avatar_url":"https://avatars.githubusercontent.com/u/52205?v=4","gravatar_id":"","url":"https://api.github.com/users/dandavison","html_url":"https://github.com/dandavison","followers_url":"https://api.github.com/users/dandavison/followers","following_url":"https://api.github.com/users/dandavison/following{/other_user}","gists_url":"https://api.github.com/users/dandavison/gists{/gist_id}","starred_url":"https://api.github.com/users/dandavison/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/dandavison/subscriptions","organizations_url":"https://api.github.com/users/dandavison/orgs","repos_url":"https://api.github.com/users/dandavison/repos","events_url":"https://api.github.com/users/dandavison/events{/privacy}","received_events_url":"https://api.github.com/users/dandavison/received_events","type":"User","user_view_type":"public","site_admin":false},"body":"Thanks, this is no longer the case: the token now contains the VT only. ","created_at":"2025-11-14T23:15:56Z","updated_at":"2025-11-14T23:15:57Z","html_url":"https://github.com/temporalio/temporal/pull/8563#discussion_r2529211548","pull_request_url":"https://api.github.com/repos/temporalio/temporal/pulls/8563","_links":{"self":{"href":"https://api.github.com/repos/temporalio/temporal/pulls/comments/2529211548"},"html":{"href":"https://github.com/temporalio/temporal/pull/8563#discussion_r2529211548"},"pull_request":{"href":"https://api.github.com/repos/temporalio/temporal/pulls/8563"}},"reactions":{"url":"https://api.github.com/repos/temporalio/temporal/pulls/comments/2529211548/reactions","total_count":0,"+1":0,"-1":0,"laugh":0,"hooray":0,"confused":0,"heart":0,"rocket":0,"eyes":0},"start_line":null,"original_start_line":null,"start_side":null,"line":null,"original_line":116,"side":"RIGHT","in_reply_to_id":2520108689,"author_association":"MEMBER","original_position":74,"position":1,"subject_type":"line"},{"url":"https://api.github.com/repos/temporalio/temporal/pulls/comments/2529214480","pull_request_review_id":3467167053,"id":2529214480,"node_id":"PRRC_kwDODNqesM6WwMAQ","diff_hunk":"@@ -51,3 +52,191 @@ func (h *handler) StartActivityExecution(ctx context.Context, req *activitypb.St\n \t\tFrontendResponse: response,\n \t}, nil\n }\n+\n+// PollActivityExecution handles PollActivityExecutionRequest from frontend. This method supports\n+// querying current activity state, optionally as a long-poll that waits for certain state changes.\n+// It is used by clients to poll for activity state and/or result.\n+func (h *handler) PollActivityExecution(\n+\tctx context.Context,\n+\treq *activitypb.PollActivityExecutionRequest,\n+) (*activitypb.PollActivityExecutionResponse, error) {\n+\tswitch req.GetFrontendRequest().GetWaitPolicy().(type) {\n+\tcase nil:\n+\t\treturn chasm.ReadComponent(\n+\t\t\tctx,\n+\t\t\tchasm.NewComponentRef[*Activity](chasm.EntityKey{\n+\t\t\t\tNamespaceID: req.GetNamespaceId(),\n+\t\t\t\tBusinessID:  req.GetFrontendRequest().GetActivityId(),\n+\t\t\t\tEntityID:    req.GetFrontendRequest().GetRunId(),\n+\t\t\t}),\n+\t\t\t(*Activity).buildPollActivityExecutionResponse,\n+\t\t\treq,\n+\t\t\tnil,\n+\t\t)\n+\tcase *workflowservice.PollActivityExecutionRequest_WaitAnyStateChange:\n+\t\treturn pollActivityExecutionWaitAnyStateChange(ctx, req)\n+\tcase *workflowservice.PollActivityExecutionRequest_WaitCompletion:\n+\t\treturn pollActivityExecutionWaitCompletion(ctx, req)\n+\tdefault:\n+\t\treturn nil, serviceerror.NewInvalidArgumentf(\"unexpected wait policy type: %T\", req.GetFrontendRequest().GetWaitPolicy())\n+\t}\n+}\n+\n+// pollActivityExecutionWaitAnyStateChange waits until the activity state has advanced beyond that\n+// specified by the submitted token. If no token was submitted, it returns the current state without\n+// waiting.\n+func pollActivityExecutionWaitAnyStateChange(\n+\tctx context.Context,\n+\treq *activitypb.PollActivityExecutionRequest,\n+) (*activitypb.PollActivityExecutionResponse, error) {\n+\n+\t// TODO(dan): do we want to guarantee that response data will differ from that received when the\n+\t// token was obtained? It's potentially confusing for the server to say \"there's been a change\"\n+\t// while returning data in which the change is not apparent.\n+\n+\trefBytesFromToken := req.GetFrontendRequest().\n+\t\tGetWaitPolicy().(*workflowservice.PollActivityExecutionRequest_WaitAnyStateChange).\n+\t\tWaitAnyStateChange.GetLongPollToken()\n+\n+\tvar lastSeenRef chasm.ComponentRef\n+\tif refBytesFromToken != nil {\n+\t\tvar err error\n+\t\tlastSeenRef, err = chasm.DeserializeComponentRef(refBytesFromToken)\n+\t\tif err != nil {\n+\t\t\treturn nil, serviceerror.NewInvalidArgument(\"invalid long poll token\")\n+\t\t}\n+\t\tif lastSeenRef.NamespaceID != req.GetNamespaceId() ||\n+\t\t\tlastSeenRef.BusinessID != req.GetFrontendRequest().GetActivityId() ||\n+\t\t\tlastSeenRef.EntityID != req.GetFrontendRequest().GetRunId() {\n+\t\t\t// token is inconsistent with request\n+\t\t\treturn nil, serviceerror.NewInvalidArgument(\"invalid long poll token\")\n+\t\t}\n+\t} else {\n+\t\t// This ref will compare less than currentRef in the comparison below.\n+\t\tlastSeenRef = chasm.NewComponentRef[*Activity](chasm.EntityKey{\n+\t\t\tNamespaceID: req.GetNamespaceId(),\n+\t\t\tBusinessID:  req.GetFrontendRequest().GetActivityId(),\n+\t\t\tEntityID:    req.GetFrontendRequest().GetRunId(),\n+\t\t})\n+\t}\n+\n+\t// PollComponent will return an error if lastSeenRef is not consistent with the entity\n+\t// transition history on this shard, or if the state on this shard is behind the ref after a\n+\t// reload.\n+\t// TODO(dan): retryability of these errors\n+\tresponse, newRef, err := chasm.PollComponent(\n+\t\tctx,\n+\t\tlastSeenRef,\n+\t\tfunc(\n+\t\t\ta *Activity,\n+\t\t\tctx chasm.Context,\n+\t\t\treq *activitypb.PollActivityExecutionRequest,\n+\t\t) (*activitypb.PollActivityExecutionResponse, bool, error) {\n+\t\t\t// TODO(dan): we're walking the tree to construct a ref when all we want here is the\n+\t\t\t// root/entity VT. Would it make sense for Context to provide access to root node?\n+\t\t\tcurrentRefBytes, err := ctx.Ref(a)","path":"chasm/lib/activity/handler.go","commit_id":"c88896985ee8b4a5cd9c508293e4431293e28fde","original_commit_id":"b24a0220435f567e7e3cacb95bd8fe78c17dc67b","user":{"login":"dandavison","id":52205,"node_id":"MDQ6VXNlcjUyMjA1","avatar_url":"https://avatars.githubusercontent.com/u/52205?v=4","gravatar_id":"","url":"https://api.github.com/users/dandavison","html_url":"https://github.com/dandavison","followers_url":"https://api.github.com/users/dandavison/followers","following_url":"https://api.github.com/users/dandavison/following{/other_user}","gists_url":"https://api.github.com/users/dandavison/gists{/gist_id}","starred_url":"https://api.github.com/users/dandavison/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/dandavison/subscriptions","organizations_url":"https://api.github.com/users/dandavison/orgs","repos_url":"https://api.github.com/users/dandavison/repos","events_url":"https://api.github.com/users/dandavison/events{/privacy}","received_events_url":"https://api.github.com/users/dandavison/received_events","type":"User","user_view_type":"public","site_admin":false},"body":"Thanks, following discussion the PR has been updated to use a framework-provided function (currently named `chasm.HasStateAdvanced`) and application logic no longer decodes any ref.","created_at":"2025-11-14T23:17:59Z","updated_at":"2025-11-14T23:17:59Z","html_url":"https://github.com/temporalio/temporal/pull/8563#discussion_r2529214480","pull_request_url":"https://api.github.com/repos/temporalio/temporal/pulls/8563","_links":{"self":{"href":"https://api.github.com/repos/temporalio/temporal/pulls/comments/2529214480"},"html":{"href":"https://github.com/temporalio/temporal/pull/8563#discussion_r2529214480"},"pull_request":{"href":"https://api.github.com/repos/temporalio/temporal/pulls/8563"}},"reactions":{"url":"https://api.github.com/repos/temporalio/temporal/pulls/comments/2529214480/reactions","total_count":0,"+1":0,"-1":0,"laugh":0,"hooray":0,"confused":0,"heart":0,"rocket":0,"eyes":0},"start_line":null,"original_start_line":null,"start_side":null,"line":null,"original_line":137,"side":"RIGHT","in_reply_to_id":2525412953,"author_association":"MEMBER","original_position":94,"position":1,"subject_type":"line"},{"url":"https://api.github.com/repos/temporalio/temporal/pulls/comments/2529214917","pull_request_review_id":3467167534,"id":2529214917,"node_id":"PRRC_kwDODNqesM6WwMHF","diff_hunk":"@@ -314,3 +315,125 @@ func (a *Activity) RecordHeartbeat(ctx chasm.MutableContext, details *commonpb.P\n \t})\n \treturn nil, nil\n }\n+\n+func (a *Activity) buildActivityExecutionInfo(ctx chasm.Context, key chasm.EntityKey) (*activity.ActivityExecutionInfo, error) {\n+\tif a.ActivityState == nil {\n+\t\treturn nil, errors.New(\"activity state is nil\")\n+\t}\n+\n+\t// TODO(dan): support pause states\n+\tvar status enumspb.ActivityExecutionStatus\n+\tvar runState enumspb.PendingActivityState\n+\tswitch a.GetStatus() {\n+\tcase activitypb.ACTIVITY_EXECUTION_STATUS_UNSPECIFIED:\n+\t\tstatus = enumspb.ACTIVITY_EXECUTION_STATUS_UNSPECIFIED\n+\t\trunState = enumspb.PENDING_ACTIVITY_STATE_UNSPECIFIED\n+\tcase activitypb.ACTIVITY_EXECUTION_STATUS_SCHEDULED:\n+\t\tstatus = enumspb.ACTIVITY_EXECUTION_STATUS_RUNNING\n+\t\trunState = enumspb.PENDING_ACTIVITY_STATE_SCHEDULED\n+\tcase activitypb.ACTIVITY_EXECUTION_STATUS_STARTED:\n+\t\tstatus = enumspb.ACTIVITY_EXECUTION_STATUS_RUNNING\n+\t\trunState = enumspb.PENDING_ACTIVITY_STATE_STARTED\n+\tcase activitypb.ACTIVITY_EXECUTION_STATUS_CANCEL_REQUESTED:\n+\t\tstatus = enumspb.ACTIVITY_EXECUTION_STATUS_RUNNING\n+\t\trunState = enumspb.PENDING_ACTIVITY_STATE_CANCEL_REQUESTED\n+\tcase activitypb.ACTIVITY_EXECUTION_STATUS_COMPLETED:\n+\t\tstatus = enumspb.ACTIVITY_EXECUTION_STATUS_COMPLETED\n+\t\trunState = enumspb.PENDING_ACTIVITY_STATE_UNSPECIFIED\n+\tcase activitypb.ACTIVITY_EXECUTION_STATUS_FAILED:\n+\t\tstatus = enumspb.ACTIVITY_EXECUTION_STATUS_FAILED\n+\t\trunState = enumspb.PENDING_ACTIVITY_STATE_UNSPECIFIED\n+\tcase activitypb.ACTIVITY_EXECUTION_STATUS_CANCELED:\n+\t\tstatus = enumspb.ACTIVITY_EXECUTION_STATUS_CANCELED\n+\t\trunState = enumspb.PENDING_ACTIVITY_STATE_UNSPECIFIED\n+\tcase activitypb.ACTIVITY_EXECUTION_STATUS_TERMINATED:\n+\t\tstatus = enumspb.ACTIVITY_EXECUTION_STATUS_TERMINATED\n+\t\trunState = enumspb.PENDING_ACTIVITY_STATE_UNSPECIFIED\n+\tcase activitypb.ACTIVITY_EXECUTION_STATUS_TIMED_OUT:\n+\t\tstatus = enumspb.ACTIVITY_EXECUTION_STATUS_TIMED_OUT\n+\t\trunState = enumspb.PENDING_ACTIVITY_STATE_UNSPECIFIED\n+\tdefault:\n+\t\treturn nil, serviceerror.NewInternalf(\"unknown activity execution status: %s\", a.GetStatus())\n+\t}\n+\n+\trequestData, err := a.RequestData.Get(ctx)\n+\tif err != nil {\n+\t\treturn nil, err\n+\t}\n+\n+\tinfo := &activity.ActivityExecutionInfo{\n+\t\tActivityId:    key.BusinessID,\n+\t\tRunId:         key.EntityID,\n+\t\tActivityType:  a.GetActivityType(),\n+\t\tStatus:        status,\n+\t\tRunState:      runState,\n+\t\tScheduledTime: a.GetScheduledTime(),\n+\t\tPriority:      a.GetPriority(),\n+\t\tHeader:        requestData.GetHeader(),\n+\t\t// TODO(dan): populate remaining fields\n+\t}\n+\n+\treturn info, nil\n+}\n+\n+func (a *Activity) buildPollActivityExecutionResponse(\n+\tctx chasm.Context,\n+\treq *activitypb.PollActivityExecutionRequest,\n+) (*activitypb.PollActivityExecutionResponse, error) {\n+\trequest := req.GetFrontendRequest()\n+\n+\t// TODO(dan): pass ref into this function?\n+\tref, err := ctx.Ref(a)\n+\tif err != nil {\n+\t\treturn nil, err\n+\t}\n+\n+\tvar info *activity.ActivityExecutionInfo\n+\tif request.GetIncludeInfo() {\n+\t\tinfo, err = a.buildActivityExecutionInfo(ctx, chasm.EntityKey{\n+\t\t\tNamespaceID: req.GetNamespaceId(),\n+\t\t\tBusinessID:  request.GetActivityId(),\n+\t\t\tEntityID:    request.GetRunId(),\n+\t\t})\n+\t\tif err != nil {\n+\t\t\treturn nil, err\n+\t\t}\n+\t}\n+\n+\tvar input *commonpb.Payloads\n+\tif request.GetIncludeInput() {\n+\t\tactivityRequest, err := a.RequestData.Get(ctx)\n+\t\tif err != nil {\n+\t\t\treturn nil, err\n+\t\t}\n+\t\tinput = activityRequest.Input","path":"chasm/lib/activity/activity.go","commit_id":"384f23bf064696e80ccc71056daf19a1c8d1edea","original_commit_id":"b24a0220435f567e7e3cacb95bd8fe78c17dc67b","user":{"login":"dandavison","id":52205,"node_id":"MDQ6VXNlcjUyMjA1","avatar_url":"https://avatars.githubusercontent.com/u/52205?v=4","gravatar_id":"","url":"https://api.github.com/users/dandavison","html_url":"https://github.com/dandavison","followers_url":"https://api.github.com/users/dandavison/followers","following_url":"https://api.github.com/users/dandavison/following{/other_user}","gists_url":"https://api.github.com/users/dandavison/gists{/gist_id}","starred_url":"https://api.github.com/users/dandavison/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/dandavison/subscriptions","organizations_url":"https://api.github.com/users/dandavison/orgs","repos_url":"https://api.github.com/users/dandavison/repos","events_url":"https://api.github.com/users/dandavison/events{/privacy}","received_events_url":"https://api.github.com/users/dandavison/received_events","type":"User","user_view_type":"public","site_admin":false},"body":"Done","created_at":"2025-11-14T23:18:24Z","updated_at":"2025-11-14T23:18:24Z","html_url":"https://github.com/temporalio/temporal/pull/8563#discussion_r2529214917","pull_request_url":"https://api.github.com/repos/temporalio/temporal/pulls/8563","_links":{"self":{"href":"https://api.github.com/repos/temporalio/temporal/pulls/comments/2529214917"},"html":{"href":"https://github.com/temporalio/temporal/pull/8563#discussion_r2529214917"},"pull_request":{"href":"https://api.github.com/repos/temporalio/temporal/pulls/8563"}},"reactions":{"url":"https://api.github.com/repos/temporalio/temporal/pulls/comments/2529214917/reactions","total_count":0,"+1":0,"-1":0,"laugh":0,"hooray":0,"confused":0,"heart":0,"rocket":0,"eyes":0},"start_line":null,"original_start_line":null,"start_side":null,"line":null,"original_line":409,"side":"RIGHT","in_reply_to_id":2525431130,"author_association":"MEMBER","original_position":129,"position":1,"subject_type":"line"},{"url":"https://api.github.com/repos/temporalio/temporal/pulls/comments/2529215299","pull_request_review_id":3467167870,"id":2529215299,"node_id":"PRRC_kwDODNqesM6WwMND","diff_hunk":"@@ -155,3 +156,16 @@ func ProtoRefToComponentRef(pRef *persistencespb.ChasmComponentRef) ComponentRef\n \t\tcomponentInitialVT: pRef.ComponentInitialVersionedTransition,\n \t}\n }\n+\n+// TODO(dan): is this leaking too much detail about VTs?","path":"chasm/ref.go","commit_id":"384f23bf064696e80ccc71056daf19a1c8d1edea","original_commit_id":"b24a0220435f567e7e3cacb95bd8fe78c17dc67b","user":{"login":"dandavison","id":52205,"node_id":"MDQ6VXNlcjUyMjA1","avatar_url":"https://avatars.githubusercontent.com/u/52205?v=4","gravatar_id":"","url":"https://api.github.com/users/dandavison","html_url":"https://github.com/dandavison","followers_url":"https://api.github.com/users/dandavison/followers","following_url":"https://api.github.com/users/dandavison/following{/other_user}","gists_url":"https://api.github.com/users/dandavison/gists{/gist_id}","starred_url":"https://api.github.com/users/dandavison/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/dandavison/subscriptions","organizations_url":"https://api.github.com/users/dandavison/orgs","repos_url":"https://api.github.com/users/dandavison/repos","events_url":"https://api.github.com/users/dandavison/events{/privacy}","received_events_url":"https://api.github.com/users/dandavison/received_events","type":"User","user_view_type":"public","site_admin":false},"body":"Thanks. This function no longer exists.","created_at":"2025-11-14T23:18:44Z","updated_at":"2025-11-14T23:18:44Z","html_url":"https://github.com/temporalio/temporal/pull/8563#discussion_r2529215299","pull_request_url":"https://api.github.com/repos/temporalio/temporal/pulls/8563","_links":{"self":{"href":"https://api.github.com/repos/temporalio/temporal/pulls/comments/2529215299"},"html":{"href":"https://github.com/temporalio/temporal/pull/8563#discussion_r2529215299"},"pull_request":{"href":"https://api.github.com/repos/temporalio/temporal/pulls/8563"}},"reactions":{"url":"https://api.github.com/repos/temporalio/temporal/pulls/comments/2529215299/reactions","total_count":0,"+1":0,"-1":0,"laugh":0,"hooray":0,"confused":0,"heart":0,"rocket":0,"eyes":0},"start_line":null,"original_start_line":null,"start_side":null,"line":null,"original_line":160,"side":"RIGHT","in_reply_to_id":2525414437,"author_association":"MEMBER","original_position":13,"position":1,"subject_type":"line"},{"url":"https://api.github.com/repos/temporalio/temporal/pulls/comments/2529915071","pull_request_review_id":3468101959,"id":2529915071,"node_id":"PRRC_kwDODNqesM6Wy3C_","diff_hunk":"@@ -1204,9 +1204,14 @@ func (n *Node) Ref(\n \t\t\t\t\tEntityID:    workflowKey.RunID,\n \t\t\t\t},\n \t\t\t\tarchetype: n.Archetype(),\n-\t\t\t\t// TODO: Consider using node's LastUpdateVersionedTransition for checking staleness here.\n+\t\t\t\t// TODO: Consider using componentLastUpdateVT for checking staleness.\n \t\t\t\t// Using VersionedTransition of the entire tree might be too strict.\n-\t\t\t\tentityLastUpdateVT: transitionhistory.CopyVersionedTransition(node.backend.CurrentVersionedTransition()),\n+\t\t\t\tentityLastUpdateVT: transitionhistory.CopyVersionedTransition(\n+\t\t\t\t\tnode.backend.CurrentVersionedTransition(),\n+\t\t\t\t),\n+\t\t\t\tcomponentLastUpdateVT: transitionhistory.CopyVersionedTransition(","path":"chasm/tree.go","commit_id":"cb73f640a752856bfda67c8fac746a5e64069447","original_commit_id":"cb73f640a752856bfda67c8fac746a5e64069447","user":{"login":"cursor[bot]","id":206951365,"node_id":"BOT_kgDODFXTxQ","avatar_url":"https://avatars.githubusercontent.com/in/1210556?v=4","gravatar_id":"","url":"https://api.github.com/users/cursor%5Bbot%5D","html_url":"https://github.com/apps/cursor","followers_url":"https://api.github.com/users/cursor%5Bbot%5D/followers","following_url":"https://api.github.com/users/cursor%5Bbot%5D/following{/other_user}","gists_url":"https://api.github.com/users/cursor%5Bbot%5D/gists{/gist_id}","starred_url":"https://api.github.com/users/cursor%5Bbot%5D/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/cursor%5Bbot%5D/subscriptions","organizations_url":"https://api.github.com/users/cursor%5Bbot%5D/orgs","repos_url":"https://api.github.com/users/cursor%5Bbot%5D/repos","events_url":"https://api.github.com/users/cursor%5Bbot%5D/events{/privacy}","received_events_url":"https://api.github.com/users/cursor%5Bbot%5D/received_events","type":"Bot","user_view_type":"public","site_admin":false},"body":"### Bug: Premature State Access Causes `nil` For New Components\n\n<!-- **High Severity** -->\n\n<!-- DESCRIPTION START -->\nThe `componentLastUpdateVT` field in `ComponentRef` is populated from `GetLastUpdateVersionedTransition()` which returns `nil` for newly created components before transaction close. This occurs because `updateLastUpdateVersionedTransition()` is only called during `serialize()` at transaction close. When a ref is created for a new component before the transaction closes, `componentLastUpdateVT` will be `nil`, causing incorrect state comparison in `HasStateAdvanced()` during long-polling, as `nil` is treated as the zero/empty versioned transition.\n<!-- DESCRIPTION END -->\n\n<!-- LOCATIONS START\nchasm/tree.go#L1206-L1212\nLOCATIONS END -->\n<a href=\"https://cursor.com/open?data=eyJhbGciOiJSUzI1NiIsInR5cCI6IkpXVCIsImtpZCI6ImJ1Z2JvdC12MSJ9.eyJ2ZXJzaW9uIjoxLCJ0eXBlIjoiQlVHQk9UX0ZJWF9JTl9DVVJTT1IiLCJkYXRhIjp7InJlZGlzS2V5IjoiYnVnYm90OmY4ODY0ZmZkLTJmZjgtNGYyOS1hZjg1LTYxNzliNjZjYTNjYyIsImVuY3J5cHRpb25LZXkiOiJUZ21PejBZN3pMekV3azEybVNCV09VUzJEbFEtdmZiWW96eFRjN0pTLVpVIiwiYnJhbmNoIjoicG9sbC1jb21wb25lbnQifSwiaWF0IjoxNzYzMjE2MDMxLCJleHAiOjE3NjM4MjA4MzF9.gaJ2e6tc7pEPrM8xxm2wH7oqYZTvm8bVVCT7duM1kI8ZZr6RL2hTAeydql0PfP_BUKxk5L2QjKNJLb4UzjWhTlwbwmhNyTNQOscVBIA8_gBC4zN-ByZErJubzz7MkA8lboOZXbk6r98bwRygEwCd9VVGa3MquHs3ocVgjMlIkEDd8s0oGtym-XKEhFvWbDYBzKdjUI54G9tVlKA3cIKv3l9fZemH0z4f3jkjAWFqnmkfPYtqKf05Thy8svfLwqb61LZR81gsDIXx2nHqz3X0qj_zZVlv-LDY16uK_rHDcyYHy0oMlHtPDisp9ee4A3NlRFObpysVf-J42PmuHfaAxg\"><picture><source media=\"(prefers-color-scheme: dark)\" srcset=\"https://cursor.com/fix-in-cursor-dark.svg\"><source media=\"(prefers-color-scheme: light)\" srcset=\"https://cursor.com/fix-in-cursor-light.svg\"><img alt=\"Fix in Cursor\" src=\"https://cursor.com/fix-in-cursor.svg\"></picture></a>&nbsp;<a href=\"https://cursor.com/agents?data=eyJhbGciOiJSUzI1NiIsInR5cCI6IkpXVCIsImtpZCI6ImJ1Z2JvdC12MSJ9.eyJ2ZXJzaW9uIjoxLCJ0eXBlIjoiQlVHQk9UX0ZJWF9JTl9XRUIiLCJkYXRhIjp7InJlZGlzS2V5IjoiYnVnYm90OmY4ODY0ZmZkLTJmZjgtNGYyOS1hZjg1LTYxNzliNjZjYTNjYyIsImVuY3J5cHRpb25LZXkiOiJUZ21PejBZN3pMekV3azEybVNCV09VUzJEbFEtdmZiWW96eFRjN0pTLVpVIiwiYnJhbmNoIjoicG9sbC1jb21wb25lbnQiLCJyZXBvT3duZXIiOiJ0ZW1wb3JhbGlvIiwicmVwb05hbWUiOiJ0ZW1wb3JhbCIsInByTnVtYmVyIjo4NTYzLCJjb21taXRTaGEiOiJjYjczZjY0MGE3NTI4NTZiZmRhNjdjOGZhYzc0NmE1ZTY0MDY5NDQ3In0sImlhdCI6MTc2MzIxNjAzMSwiZXhwIjoxNzYzODIwODMxfQ.ZefTVlAvFCVJ-yxpOR9k_wJlcdOvAVezGI7vP6QIMUGZ1xxEnwa8emTo0ErIST6r2GY7G50gLxfbS4JqevQpBTKiFnFPtuZz3cE5sAOjVkaegTOx75VLOJlv6zR3x90H6dFKT69msJMmHjKrmAg_3rzda0XMT3fkDvK_-aiWCXcl6Txc9H1l67MJxUEK7-LlGvCsW8cauDh4CJv0VliKAQZASf-D8hkZZ2AMYV7mNCCcHZdHaAWCdD0dmpC9msfrpRCLJFHJWBIRBTIw2ZEYjnZGyeOB_eCZze6JdlHXIFBpQMiTg5q1srfWPZsyiQcZPoSB1DlqYaJOAoIn5hlL6g\"><picture><source media=\"(prefers-color-scheme: dark)\" srcset=\"https://cursor.com/fix-in-web-dark.svg\"><source media=\"(prefers-color-scheme: light)\" srcset=\"https://cursor.com/fix-in-web-light.svg\"><img alt=\"Fix in Web\" src=\"https://cursor.com/fix-in-web.svg\"></picture></a>\n\n","created_at":"2025-11-15T14:13:51Z","updated_at":"2025-11-15T14:13:51Z","html_url":"https://github.com/temporalio/temporal/pull/8563#discussion_r2529915071","pull_request_url":"https://api.github.com/repos/temporalio/temporal/pulls/8563","_links":{"self":{"href":"https://api.github.com/repos/temporalio/temporal/pulls/comments/2529915071"},"html":{"href":"https://github.com/temporalio/temporal/pull/8563#discussion_r2529915071"},"pull_request":{"href":"https://api.github.com/repos/temporalio/temporal/pulls/8563"}},"reactions":{"url":"https://api.github.com/repos/temporalio/temporal/pulls/comments/2529915071/reactions","total_count":0,"+1":0,"-1":0,"laugh":0,"hooray":0,"confused":0,"heart":0,"rocket":0,"eyes":0},"start_line":null,"original_start_line":null,"start_side":null,"line":null,"original_line":1212,"side":"RIGHT","author_association":"NONE","original_position":11,"position":1,"subject_type":"line"},{"url":"https://api.github.com/repos/temporalio/temporal/pulls/comments/2534664450","pull_request_review_id":3473465376,"id":2534664450,"node_id":"PRRC_kwDODNqesM6XE-kC","diff_hunk":"@@ -0,0 +1,65 @@\n+package chasm\n+\n+import (\n+\t\"go.temporal.io/api/serviceerror\"\n+\t\"go.temporal.io/server/chasm/lib/activity/gen/activitypb/v1\"\n+\t\"go.temporal.io/server/common/persistence/transitionhistory\"\n+\t\"go.temporal.io/server/service/history/consts\"\n+\t\"google.golang.org/protobuf/proto\"\n+)\n+\n+// HasStateAdvanced returns a ref for the component if component state has advanced beyond the state\n+// encoded in stateToken.\n+func HasStateAdvanced(c Component, ctx Context, stateToken []byte) ([]byte, bool, error) {\n+\trefBytes, err := ctx.Ref(c)\n+\tif err != nil {\n+\t\treturn nil, false, err\n+\t}\n+\tref, err := DeserializeComponentRef(refBytes)\n+\tif err != nil {\n+\t\treturn nil, false, err\n+\t}\n+\n+\ttoken, err := decodeComponentStateToken(stateToken)\n+\tif err != nil {\n+\t\treturn nil, false, err\n+\t}\n+\n+\tswitch transitionhistory.Compare(token.VersionedTransition, ref.componentVT) {\n+\tcase -1:\n+\t\t// State has advanced beyond stateToken\n+\t\treturn refBytes, true, nil\n+\tcase 0:\n+\t\t// stateToken matches current state\n+\t\treturn nil, false, nil\n+\tcase 1:\n+\t\t// StateToken is ahead of current state\n+\t\treturn nil, false, consts.ErrStaleState\n+\tdefault:\n+\t\t// Impossible: Compare only returns -1, 0, or 1\n+\t\treturn nil, false, serviceerror.NewInternal(\"unexpected transition history comparison result\")\n+\t}\n+\n+}","path":"chasm/component_state_token.go","commit_id":"00ef0ffe1af3e597ed1ceaeea57222d9f6efeb44","original_commit_id":"6a63222c510662f2d578e56ded5b303cb0458068","user":{"login":"cursor[bot]","id":206951365,"node_id":"BOT_kgDODFXTxQ","avatar_url":"https://avatars.githubusercontent.com/in/1210556?v=4","gravatar_id":"","url":"https://api.github.com/users/cursor%5Bbot%5D","html_url":"https://github.com/apps/cursor","followers_url":"https://api.github.com/users/cursor%5Bbot%5D/followers","following_url":"https://api.github.com/users/cursor%5Bbot%5D/following{/other_user}","gists_url":"https://api.github.com/users/cursor%5Bbot%5D/gists{/gist_id}","starred_url":"https://api.github.com/users/cursor%5Bbot%5D/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/cursor%5Bbot%5D/subscriptions","organizations_url":"https://api.github.com/users/cursor%5Bbot%5D/orgs","repos_url":"https://api.github.com/users/cursor%5Bbot%5D/repos","events_url":"https://api.github.com/users/cursor%5Bbot%5D/events{/privacy}","received_events_url":"https://api.github.com/users/cursor%5Bbot%5D/received_events","type":"Bot","user_view_type":"public","site_admin":false},"body":"### Bug\n\n<!-- **Medium Severity** -->\n\n<!-- DESCRIPTION START -->\nWhen `stateToken` is empty (first long-poll request without a token), `decodeComponentStateToken` returns a `ComponentStateToken` with nil `VersionedTransition`. The `transitionhistory.Compare` function then compares `nil` against `ref.componentVT`. According to the `Compare` semantics, nil is considered smaller than any non-nil transition, so this returns `-1`, causing `HasStateAdvanced` to return `(refBytes, true, nil)`. This means an empty token is treated as \"state has advanced\", which returns immediately with current statethe correct behavior. However, if `ref.componentVT` is also nil (which can happen for newly created components before any transitions), `Compare` returns `0`, causing the function to return `(nil, false, nil)`, indicating no state change. This means callers with an empty token polling a brand-new component with no versioned transition will incorrectly get \"no change\" instead of immediately receiving current state.\n<!-- DESCRIPTION END -->\n\n<!-- LOCATIONS START\nchasm/component_state_token.go#L12-L43\nLOCATIONS END -->\n<a href=\"https://cursor.com/open?data=eyJhbGciOiJSUzI1NiIsInR5cCI6IkpXVCIsImtpZCI6ImJ1Z2JvdC12MSJ9.eyJ2ZXJzaW9uIjoxLCJ0eXBlIjoiQlVHQk9UX0ZJWF9JTl9DVVJTT1IiLCJkYXRhIjp7InJlZGlzS2V5IjoiYnVnYm90Ojg1MmVjOTUzLWQwYzAtNGRkYy1hMDdiLTZkYmMwMjVlNzFmYiIsImVuY3J5cHRpb25LZXkiOiJVMUhzUm9UUkRId0JkeElqQkJIWXpnWHdfTUo0WG9LNU93SUFXcEpYaE5NIiwiYnJhbmNoIjoicG9sbC1jb21wb25lbnQifSwiaWF0IjoxNzYzMzk1NDE3LCJleHAiOjE3NjQwMDAyMTd9.hyZiF2z3o9ZlsIjPkqNS9yCHfxmwftMYo3QCgPIG1i3aiX7YjN97S29i3VnTwnZ8t43tLRDeSYRC-pIQIlHvKx4Pv0QaaAnugOItCeYRivaRvPWQRyKhgikAtRSSgeqiEctWljm_-uXMRI43vMYxvA2zsZ4qJQR1Y5RhZ-zz_QEbO53vXN263UKUiqSsdOjkiuQJ0W05NDeNaI1ze8v2eExW_c0PJZENlVeaqyEwgmv4PcO27_HvKAZMhWF6KYI7ok8G9uhhl95qQDmznNwIU9aNFqfg3Y5cr99n1aeJ6Otq-c_1BvI3cYqwJfidaYtG1xHpw0k7KCSnPFIPq6ZNrg\"><picture><source media=\"(prefers-color-scheme: dark)\" srcset=\"https://cursor.com/fix-in-cursor-dark.svg\"><source media=\"(prefers-color-scheme: light)\" srcset=\"https://cursor.com/fix-in-cursor-light.svg\"><img alt=\"Fix in Cursor\" src=\"https://cursor.com/fix-in-cursor.svg\"></picture></a>&nbsp;<a href=\"https://cursor.com/agents?data=eyJhbGciOiJSUzI1NiIsInR5cCI6IkpXVCIsImtpZCI6ImJ1Z2JvdC12MSJ9.eyJ2ZXJzaW9uIjoxLCJ0eXBlIjoiQlVHQk9UX0ZJWF9JTl9XRUIiLCJkYXRhIjp7InJlZGlzS2V5IjoiYnVnYm90Ojg1MmVjOTUzLWQwYzAtNGRkYy1hMDdiLTZkYmMwMjVlNzFmYiIsImVuY3J5cHRpb25LZXkiOiJVMUhzUm9UUkRId0JkeElqQkJIWXpnWHdfTUo0WG9LNU93SUFXcEpYaE5NIiwiYnJhbmNoIjoicG9sbC1jb21wb25lbnQiLCJyZXBvT3duZXIiOiJ0ZW1wb3JhbGlvIiwicmVwb05hbWUiOiJ0ZW1wb3JhbCIsInByTnVtYmVyIjo4NTYzLCJjb21taXRTaGEiOiI2YTYzMjIyYzUxMDY2MmYyZDU3OGU1NmRlZDViMzAzY2IwNDU4MDY4In0sImlhdCI6MTc2MzM5NTQxNywiZXhwIjoxNzY0MDAwMjE3fQ.KwMXvTQBAlxHJPRRfF0BHMpPrQZ7KqZ7b62kPPs78kyprjZfAXJRe9vvb9X1Mc6ejHPljuD0MOBCGTroKtAUWjNq9CVYw3ZGwudWr1aXEFps_WWSMadej60AkE-THxknhMro3u4aiBwcWGt5iwkWc5VVo18fH653yeA_7pPFTFaejFXKknn6k53Xa6zEfZG_xK-5pg5TUNtsGzbYJAKKl6E_jpsJRU2Br2okAidCrETYjq-456IE5Zac92usmT5NQ7Nxl8Y-Vd1jhzUuDBhSJE9gj91hgaBba0YOXcOyk0SGYhCAJbXrvhpLy3R5_dwCaM-NJNf9tAkmErgBIVmcCA\"><picture><source media=\"(prefers-color-scheme: dark)\" srcset=\"https://cursor.com/fix-in-web-dark.svg\"><source media=\"(prefers-color-scheme: light)\" srcset=\"https://cursor.com/fix-in-web-light.svg\"><img alt=\"Fix in Web\" src=\"https://cursor.com/fix-in-web.svg\"></picture></a>\n\n","created_at":"2025-11-17T16:03:38Z","updated_at":"2025-11-17T16:03:38Z","html_url":"https://github.com/temporalio/temporal/pull/8563#discussion_r2534664450","pull_request_url":"https://api.github.com/repos/temporalio/temporal/pulls/8563","_links":{"self":{"href":"https://api.github.com/repos/temporalio/temporal/pulls/comments/2534664450"},"html":{"href":"https://github.com/temporalio/temporal/pull/8563#discussion_r2534664450"},"pull_request":{"href":"https://api.github.com/repos/temporalio/temporal/pulls/8563"}},"reactions":{"url":"https://api.github.com/repos/temporalio/temporal/pulls/comments/2534664450/reactions","total_count":0,"+1":0,"-1":0,"laugh":0,"hooray":0,"confused":0,"heart":0,"rocket":0,"eyes":0},"start_line":null,"original_start_line":null,"start_side":null,"line":null,"original_line":43,"side":"RIGHT","author_association":"NONE","original_position":43,"position":1,"subject_type":"line"},{"url":"https://api.github.com/repos/temporalio/temporal/pulls/comments/2535081763","pull_request_review_id":3473997248,"id":2535081763,"node_id":"PRRC_kwDODNqesM6XGkcj","diff_hunk":"@@ -204,9 +235,22 @@ func (e *ChasmEngine) UpdateComponent(\n \t\treturn nil, serviceerror.NewInternalf(\"componentRef: %+v: %s\", ref, err)\n \t}\n \n+\t// TODO(dan) For now, UpdateComponent emits execution-level notifications, and PollComponent\n+\t// subscribes to execution-level notifications. This means that PollComponent may be woken up\n+\t// unnecessarily, but it will not miss notifications. In the future we may want to change\n+\t// PollComponent to subscribe to component-level notifications, and change UpdateComponent so\n+\t// that notifications are emitted only for nodes that were mutated in the transaction.","path":"service/history/chasm_engine.go","commit_id":"da6009564e796063faf853352077eecdc1473612","original_commit_id":"39043551da41db7bc113a0b17f41844717b44458","user":{"login":"dandavison","id":52205,"node_id":"MDQ6VXNlcjUyMjA1","avatar_url":"https://avatars.githubusercontent.com/u/52205?v=4","gravatar_id":"","url":"https://api.github.com/users/dandavison","html_url":"https://github.com/dandavison","followers_url":"https://api.github.com/users/dandavison/followers","following_url":"https://api.github.com/users/dandavison/following{/other_user}","gists_url":"https://api.github.com/users/dandavison/gists{/gist_id}","starred_url":"https://api.github.com/users/dandavison/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/dandavison/subscriptions","organizations_url":"https://api.github.com/users/dandavison/orgs","repos_url":"https://api.github.com/users/dandavison/repos","events_url":"https://api.github.com/users/dandavison/events{/privacy}","received_events_url":"https://api.github.com/users/dandavison/received_events","type":"User","user_view_type":"public","site_admin":false},"body":"Currently subscription and notification is execution-level only, so in theory may wake up pollers unnecessarily. I've added this TODO comment at the notify and subscribe points docuementing that we may want to support component-level subscriptions. ","created_at":"2025-11-17T18:15:06Z","updated_at":"2025-11-17T18:19:32Z","html_url":"https://github.com/temporalio/temporal/pull/8563#discussion_r2535081763","pull_request_url":"https://api.github.com/repos/temporalio/temporal/pulls/8563","_links":{"self":{"href":"https://api.github.com/repos/temporalio/temporal/pulls/comments/2535081763"},"html":{"href":"https://github.com/temporalio/temporal/pull/8563#discussion_r2535081763"},"pull_request":{"href":"https://api.github.com/repos/temporalio/temporal/pulls/8563"}},"reactions":{"url":"https://api.github.com/repos/temporalio/temporal/pulls/comments/2535081763/reactions","total_count":1,"+1":1,"-1":0,"laugh":0,"hooray":0,"confused":0,"heart":0,"rocket":0,"eyes":0},"start_line":null,"original_start_line":null,"start_side":null,"line":null,"original_line":242,"side":"RIGHT","author_association":"MEMBER","original_position":97,"position":1,"subject_type":"line"},{"url":"https://api.github.com/repos/temporalio/temporal/pulls/comments/2535088053","pull_request_review_id":3473997248,"id":2535088053,"node_id":"PRRC_kwDODNqesM6XGl-1","diff_hunk":"@@ -105,3 +117,377 @@ func createDefaultInput() *commonpb.Payloads {\n \t\t},\n \t}\n }\n+\n+func (s *standaloneActivityTestSuite) Test_PollActivityExecution_NoWait() {\n+\t// Long poll for any state change. PollActivityTaskQueue is used to cause a state change.\n+\tt := s.T()\n+\tctx, cancel := context.WithTimeout(t.Context(), 10*time.Second)\n+\tdefer cancel()\n+\tactivityID := testcore.RandomizeStr(t.Name())\n+\ttaskQueue := uuid.New().String()\n+\n+\tstartResp, err := s.startActivity(ctx, activityID, taskQueue)\n+\trequire.NoError(t, err)\n+\n+\tpollResp, err := s.FrontendClient().PollActivityExecution(ctx, &workflowservice.PollActivityExecutionRequest{\n+\t\tNamespace:    s.Namespace().String(),\n+\t\tActivityId:   activityID,\n+\t\tRunId:        startResp.RunId,\n+\t\tIncludeInfo:  true,\n+\t\tIncludeInput: true,\n+\t})\n+\trequire.NoError(t, err)\n+\trequire.NotNil(t, pollResp.StateChangeLongPollToken)\n+\trequire.NotNil(t, pollResp.Info)\n+\ts.assertActivityExecutionInfo(\n+\t\tt,\n+\t\tpollResp.Info,\n+\t\tactivityID,\n+\t\tstartResp.RunId,\n+\t\tenumspb.PENDING_ACTIVITY_STATE_SCHEDULED,\n+\t)\n+\trequire.NotNil(t, pollResp.Input)\n+\trequire.Equal(t, \"test-activity-input\", string(pollResp.Input.Payloads[0].Data))\n+\t// TODO(dan): test IncludeOutcome\n+}\n+\n+func (s *standaloneActivityTestSuite) Test_PollActivityExecution_WaitAnyStateChange() {\n+\t// Long poll for any state change. PollActivityTaskQueue is used to cause a state change.\n+\tt := s.T()\n+\tctx, cancel := context.WithTimeout(t.Context(), 10*time.Second)\n+\tdefer cancel()\n+\tactivityID := testcore.RandomizeStr(t.Name())\n+\ttaskQueue := uuid.New().String()\n+\n+\tstartResp, err := s.startActivity(ctx, activityID, taskQueue)\n+\trequire.NoError(t, err)\n+\n+\t// First poll lacks token and therefore responds immediately, returning a token\n+\tfirstPollResp, err := s.FrontendClient().PollActivityExecution(ctx, &workflowservice.PollActivityExecutionRequest{\n+\t\tNamespace:  s.Namespace().String(),\n+\t\tActivityId: activityID,\n+\t\tRunId:      startResp.RunId,\n+\t\tWaitPolicy: &workflowservice.PollActivityExecutionRequest_WaitAnyStateChange{\n+\t\t\tWaitAnyStateChange: &workflowservice.PollActivityExecutionRequest_StateChangeWaitOptions{},\n+\t\t},\n+\t\tIncludeInfo:  true,\n+\t\tIncludeInput: true,\n+\t})\n+\trequire.NoError(t, err)\n+\trequire.NotNil(t, firstPollResp.StateChangeLongPollToken)\n+\trequire.NotNil(t, firstPollResp.Info)\n+\ts.assertActivityExecutionInfo(\n+\t\tt,\n+\t\tfirstPollResp.Info,\n+\t\tactivityID,\n+\t\tstartResp.RunId,\n+\t\tenumspb.PENDING_ACTIVITY_STATE_SCHEDULED,\n+\t)\n+\n+\ttaskQueuePollErr := make(chan error, 1)\n+\tactivityPollDone := make(chan struct{})\n+\tvar activityPollResp *workflowservice.PollActivityExecutionResponse\n+\tvar activityPollErr error\n+\n+\tgo func() {\n+\t\tdefer close(activityPollDone)\n+\t\t// Second poll uses token and therefore waits for a state transition\n+\t\tactivityPollResp, activityPollErr = s.FrontendClient().PollActivityExecution(ctx, &workflowservice.PollActivityExecutionRequest{\n+\t\t\tNamespace:    s.Namespace().String(),\n+\t\t\tActivityId:   activityID,\n+\t\t\tRunId:        startResp.RunId,\n+\t\t\tIncludeInfo:  true,\n+\t\t\tIncludeInput: true,\n+\t\t\tWaitPolicy: &workflowservice.PollActivityExecutionRequest_WaitAnyStateChange{\n+\t\t\t\tWaitAnyStateChange: &workflowservice.PollActivityExecutionRequest_StateChangeWaitOptions{\n+\t\t\t\t\tLongPollToken: firstPollResp.StateChangeLongPollToken,\n+\t\t\t\t},\n+\t\t\t},\n+\t\t})\n+\t}()\n+\n+\t// TODO(dan): race here: subscription might not be established yet\n+\n+\t// Worker picks up activity task, triggering transition (via RecordActivityTaskStarted)\n+\tgo func() {\n+\t\t_, err := s.pollActivityTaskQueue(ctx, taskQueue)\n+\t\ttaskQueuePollErr <- err\n+\t}()\n+\n+\tselect {\n+\tcase <-activityPollDone:\n+\t\trequire.NoError(t, activityPollErr)\n+\t\trequire.NotNil(t, activityPollResp)\n+\t\trequire.NotNil(t, activityPollResp.Info)\n+\t\ts.assertActivityExecutionInfo(\n+\t\t\tt,\n+\t\t\tactivityPollResp.Info,\n+\t\t\tactivityID,\n+\t\t\tstartResp.RunId,\n+\t\t\tenumspb.PENDING_ACTIVITY_STATE_STARTED,\n+\t\t)\n+\t\trequire.NotNil(t, activityPollResp.Input)\n+\t\trequire.Equal(t, \"test-activity-input\", string(activityPollResp.Input.Payloads[0].Data))\n+\n+\tcase <-ctx.Done():\n+\t\tt.Fatal(\"PollActivityExecution timed out\")\n+\t}\n+\n+\terr = <-taskQueuePollErr\n+\trequire.NoError(t, err)\n+\n+\t// Manipulate the token to verify token staleness checks (simulate ErrStaleReference). To do so\n+\t// we make use of the internal implementation detail that the bytes are a serialized ref.\n+\ttoken := firstPollResp.StateChangeLongPollToken\n+\tvar tokenProto chasmactivitypb.ComponentStateToken\n+\terr = tokenProto.Unmarshal(token)\n+\trequire.NoError(t, err)\n+\tif tokenProto.VersionedTransition != nil {\n+\t\ttokenProto.VersionedTransition.NamespaceFailoverVersion += 1\n+\t}\n+\ttoken, err = tokenProto.Marshal()\n+\trequire.NoError(t, err)\n+\n+\t_, err = s.FrontendClient().PollActivityExecution(ctx, &workflowservice.PollActivityExecutionRequest{\n+\t\tNamespace:  s.Namespace().String(),\n+\t\tActivityId: activityID,\n+\t\tRunId:      startResp.RunId,\n+\t\tWaitPolicy: &workflowservice.PollActivityExecutionRequest_WaitAnyStateChange{\n+\t\t\tWaitAnyStateChange: &workflowservice.PollActivityExecutionRequest_StateChangeWaitOptions{\n+\t\t\t\tLongPollToken: token,\n+\t\t\t},\n+\t\t},\n+\t})\n+\trequire.Error(t, err)\n+\trequire.ErrorContains(t, err, \"cached mutable state could potentially be stale\")\n+}\n+\n+func (s *standaloneActivityTestSuite) Test_PollActivityExecution_WaitCompletion() {\n+\tt := s.T()\n+\tt.Skip(\"TODO(dan): implement test when RecordActivityTaskCompleted is implemented\")\n+}\n+\n+func (s *standaloneActivityTestSuite) Test_PollActivityExecution_WaitAnyStateChange_Success_UpdateComponent() {\n+\tt := s.T()\n+\tctx, cancel := context.WithTimeout(t.Context(), 10*time.Second)\n+\tdefer cancel()\n+\tctx = chasm.NewEngineContext(ctx, s.chasmEngine)\n+\n+\tactivityID := testcore.RandomizeStr(t.Name())\n+\ttaskQueue := uuid.New().String()\n+\n+\tstartResp, err := s.startActivity(ctx, activityID, taskQueue)\n+\trequire.NoError(t, err)\n+\tentityKey := chasm.EntityKey{\n+\t\tNamespaceID: s.NamespaceID().String(),\n+\t\tBusinessID:  activityID,\n+\t\tEntityID:    startResp.RunId,\n+\t}\n+\n+\t// Test PollActivityExecution(WaitAnyStateChange) without a long-poll token.\n+\tpollResp, err := s.FrontendClient().PollActivityExecution(ctx, &workflowservice.PollActivityExecutionRequest{\n+\t\tNamespace:  s.Namespace().String(),\n+\t\tActivityId: activityID,\n+\t\tRunId:      startResp.RunId,\n+\t\tWaitPolicy: &workflowservice.PollActivityExecutionRequest_WaitAnyStateChange{\n+\t\t\tWaitAnyStateChange: &workflowservice.PollActivityExecutionRequest_StateChangeWaitOptions{},\n+\t\t},\n+\t})\n+\trequire.NoError(t, err)\n+\trequire.NotNil(t, pollResp.GetStateChangeLongPollToken())\n+\trequire.Equal(t, startResp.GetRunId(), pollResp.GetRunId())\n+\n+\t_, _, err = chasm.UpdateComponent(\n+\t\tctx,\n+\t\tchasm.NewComponentRef[*activity.Activity](entityKey),\n+\t\tfunc(a *activity.Activity, ctx chasm.MutableContext, _ any) (any, error) {\n+\t\t\t// Don't actually mutate; just trigger the notification\n+\t\t\treturn nil, nil\n+\t\t}, nil)\n+\trequire.NoError(t, err)\n+\n+\t// Test PollActivityExecution(WaitAnyStateChange) with a long-poll token.\n+\tsecondPollResp, err := s.FrontendClient().PollActivityExecution(ctx, &workflowservice.PollActivityExecutionRequest{\n+\t\tNamespace:  s.Namespace().String(),\n+\t\tActivityId: activityID,\n+\t\tRunId:      startResp.RunId,\n+\t\tWaitPolicy: &workflowservice.PollActivityExecutionRequest_WaitAnyStateChange{\n+\t\t\tWaitAnyStateChange: &workflowservice.PollActivityExecutionRequest_StateChangeWaitOptions{\n+\t\t\t\tLongPollToken: pollResp.GetStateChangeLongPollToken(),\n+\t\t\t},\n+\t\t},\n+\t})\n+\trequire.NoError(t, err)\n+\trequire.NotNil(t, secondPollResp.StateChangeLongPollToken)\n+}\n+\n+// Test_PollVisibility_UpdateFromParent tests that polling for visibility component is woken up when\n+// the parent activity is updated and modifies the visibility.\n+// TODO(dan): this test uses chasm APIs (ReadComponent, UpdateComponent, PollComponent) directly. Is\n+// this illegitimate in tests/?","path":"tests/standalone_activity_test.go","commit_id":"ee79ea9d2857dc0da255fec35a8ec05b24ecc8c6","original_commit_id":"39043551da41db7bc113a0b17f41844717b44458","user":{"login":"dandavison","id":52205,"node_id":"MDQ6VXNlcjUyMjA1","avatar_url":"https://avatars.githubusercontent.com/u/52205?v=4","gravatar_id":"","url":"https://api.github.com/users/dandavison","html_url":"https://github.com/dandavison","followers_url":"https://api.github.com/users/dandavison/followers","following_url":"https://api.github.com/users/dandavison/following{/other_user}","gists_url":"https://api.github.com/users/dandavison/gists{/gist_id}","starred_url":"https://api.github.com/users/dandavison/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/dandavison/subscriptions","organizations_url":"https://api.github.com/users/dandavison/orgs","repos_url":"https://api.github.com/users/dandavison/repos","events_url":"https://api.github.com/users/dandavison/events{/privacy}","received_events_url":"https://api.github.com/users/dandavison/received_events","type":"User","user_view_type":"public","site_admin":false},"body":"This test uses chasm APIs (ReadComponent, UpdateComponent, PollComponent) directly. It's illegitimate to do this in `tests/`, correct? I do want something like this test.","created_at":"2025-11-17T18:17:40Z","updated_at":"2025-11-17T18:19:32Z","html_url":"https://github.com/temporalio/temporal/pull/8563#discussion_r2535088053","pull_request_url":"https://api.github.com/repos/temporalio/temporal/pulls/8563","_links":{"self":{"href":"https://api.github.com/repos/temporalio/temporal/pulls/comments/2535088053"},"html":{"href":"https://github.com/temporalio/temporal/pull/8563#discussion_r2535088053"},"pull_request":{"href":"https://api.github.com/repos/temporalio/temporal/pulls/8563"}},"reactions":{"url":"https://api.github.com/repos/temporalio/temporal/pulls/comments/2535088053/reactions","total_count":0,"+1":0,"-1":0,"laugh":0,"hooray":0,"confused":0,"heart":0,"rocket":0,"eyes":0},"start_line":null,"original_start_line":null,"start_side":null,"line":null,"original_line":327,"side":"RIGHT","author_association":"MEMBER","original_position":259,"position":1,"subject_type":"line"},{"url":"https://api.github.com/repos/temporalio/temporal/pulls/comments/2535862852","pull_request_review_id":3474969049,"id":2535862852,"node_id":"PRRC_kwDODNqesM6XJjJE","diff_hunk":"@@ -51,3 +52,90 @@ func (h *handler) StartActivityExecution(ctx context.Context, req *activitypb.St\n \t\tFrontendResponse: response,\n \t}, nil\n }\n+\n+// PollActivityExecution handles PollActivityExecutionRequest from frontend. This method supports\n+// querying current activity state, optionally as a long-poll that waits for certain state changes.\n+// It is used by clients to poll for activity state and/or result.\n+func (h *handler) PollActivityExecution(\n+\tctx context.Context,\n+\treq *activitypb.PollActivityExecutionRequest,\n+) (response *activitypb.PollActivityExecutionResponse, err error) {\n+\tref := chasm.NewComponentRef[*Activity](chasm.EntityKey{\n+\t\tNamespaceID: req.GetNamespaceId(),\n+\t\tBusinessID:  req.GetFrontendRequest().GetActivityId(),\n+\t\tEntityID:    req.GetFrontendRequest().GetRunId(),\n+\t})","path":"chasm/lib/activity/handler.go","commit_id":"1d59e66d0ce5d91819f92c428ef5ab4c4efca1fb","original_commit_id":"00ef0ffe1af3e597ed1ceaeea57222d9f6efeb44","user":{"login":"cursor[bot]","id":206951365,"node_id":"BOT_kgDODFXTxQ","avatar_url":"https://avatars.githubusercontent.com/in/1210556?v=4","gravatar_id":"","url":"https://api.github.com/users/cursor%5Bbot%5D","html_url":"https://github.com/apps/cursor","followers_url":"https://api.github.com/users/cursor%5Bbot%5D/followers","following_url":"https://api.github.com/users/cursor%5Bbot%5D/following{/other_user}","gists_url":"https://api.github.com/users/cursor%5Bbot%5D/gists{/gist_id}","starred_url":"https://api.github.com/users/cursor%5Bbot%5D/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/cursor%5Bbot%5D/subscriptions","organizations_url":"https://api.github.com/users/cursor%5Bbot%5D/orgs","repos_url":"https://api.github.com/users/cursor%5Bbot%5D/repos","events_url":"https://api.github.com/users/cursor%5Bbot%5D/events{/privacy}","received_events_url":"https://api.github.com/users/cursor%5Bbot%5D/received_events","type":"Bot","user_view_type":"public","site_admin":false},"body":"### Bug: RunId Gap Stops Activity Execution\n\n<!-- **Medium Severity** -->\n\n<!-- DESCRIPTION START -->\nMissing handling for empty `RunId` in `PollActivityExecution`. When `req.GetFrontendRequest().GetRunId()` is empty, the code should retrieve the current run ID for the activity, but instead creates a component ref with an empty `EntityID`, which will fail to locate the activity execution.\n<!-- DESCRIPTION END -->\n\n<!-- LOCATIONS START\nchasm/lib/activity/handler.go#L62-L67\nLOCATIONS END -->\n<a href=\"https://cursor.com/open?data=eyJhbGciOiJSUzI1NiIsInR5cCI6IkpXVCIsImtpZCI6ImJ1Z2JvdC12MSJ9.eyJ2ZXJzaW9uIjoxLCJ0eXBlIjoiQlVHQk9UX0ZJWF9JTl9DVVJTT1IiLCJkYXRhIjp7InJlZGlzS2V5IjoiYnVnYm90OjNmMmVlMzM5LWU3NDYtNDc2Mi05ZGQxLWZkOGVlMGFlNjM2OSIsImVuY3J5cHRpb25LZXkiOiIyTVFsTGxwMTNWX2lLcklta2ppaXJ4eGs4ZzYtU281bTlkc2t6a21rUzVvIiwiYnJhbmNoIjoicG9sbC1jb21wb25lbnQifSwiaWF0IjoxNzYzNDIzNjkzLCJleHAiOjE3NjQwMjg0OTN9.QycrJlwSOqa2Ht5M3U0ZwrPX0VsOGg0YJfaRcbZb8Ouu6jz7Flu0JgpWDL9VfbDQhjyRx_gOwdO29MQ5YXCMo_LjQ-kceWWebcGgneAFMi1o4dyWwz5m9fVIabHgR2qDDiPaShe5rQ0fJsuj5g5C9oju5ojftJB8BvmlHZPL4glRUQNbYwAmjXeF7RK6ia1Ri8kiuSWyCHhBwg8MOEiEtOLPCRZ-OnfkuX83OCx7KRTHygGt11pJPyRZcxlrVPGhmhzrZiPkHKYnS4X7m2yGisQMQAMVzXl2uRxdMjhU2Cy5N4nbyR1T8cQM3FsrIe8L3Y9NOYLag5EclAaAY_lY_Q\"><picture><source media=\"(prefers-color-scheme: dark)\" srcset=\"https://cursor.com/fix-in-cursor-dark.svg\"><source media=\"(prefers-color-scheme: light)\" srcset=\"https://cursor.com/fix-in-cursor-light.svg\"><img alt=\"Fix in Cursor\" src=\"https://cursor.com/fix-in-cursor.svg\"></picture></a>&nbsp;<a href=\"https://cursor.com/agents?data=eyJhbGciOiJSUzI1NiIsInR5cCI6IkpXVCIsImtpZCI6ImJ1Z2JvdC12MSJ9.eyJ2ZXJzaW9uIjoxLCJ0eXBlIjoiQlVHQk9UX0ZJWF9JTl9XRUIiLCJkYXRhIjp7InJlZGlzS2V5IjoiYnVnYm90OjNmMmVlMzM5LWU3NDYtNDc2Mi05ZGQxLWZkOGVlMGFlNjM2OSIsImVuY3J5cHRpb25LZXkiOiIyTVFsTGxwMTNWX2lLcklta2ppaXJ4eGs4ZzYtU281bTlkc2t6a21rUzVvIiwiYnJhbmNoIjoicG9sbC1jb21wb25lbnQiLCJyZXBvT3duZXIiOiJ0ZW1wb3JhbGlvIiwicmVwb05hbWUiOiJ0ZW1wb3JhbCIsInByTnVtYmVyIjo4NTYzLCJjb21taXRTaGEiOiIwMGVmMGZmZTFhZjNlNTk3ZWQxY2VhZWVhNTcyMjJkOWY2ZWZlYjQ0In0sImlhdCI6MTc2MzQyMzY5MywiZXhwIjoxNzY0MDI4NDkzfQ.Ru_PTst_JXIBP1U3jGaK7u6jwS7D15yzLlbehmPySqzBCleDjGPUmL4HO3hZOjsNbii5raR4_gTVo7iAgDYKkZucLzXZpHjWWFzagS4QRZtHww4zK0OwRpsie4mC3xL4VNDeTKfEUFo9Gj_8D28u-Yt7E5uzLWqZusIFzkiJSIeWeM4Xdz0VIBTMXvPTb-QCJqqgmPh6p2pal5QVwsAsQdmjhsEjJm1_hq-b2OQ_cL6daMQtQYlnTaEzjF9lQWH6kQJrcEEDeAJuEGu9m6gHsIch7pcytXASDNKsoX0S2fCDnyFQl3P--B-YO16T8yBd8EHpF5s-fwBLNKejjTUzpA\"><picture><source media=\"(prefers-color-scheme: dark)\" srcset=\"https://cursor.com/fix-in-web-dark.svg\"><source media=\"(prefers-color-scheme: light)\" srcset=\"https://cursor.com/fix-in-web-light.svg\"><img alt=\"Fix in Web\" src=\"https://cursor.com/fix-in-web.svg\"></picture></a>\n\n","created_at":"2025-11-17T23:54:54Z","updated_at":"2025-11-17T23:54:54Z","html_url":"https://github.com/temporalio/temporal/pull/8563#discussion_r2535862852","pull_request_url":"https://api.github.com/repos/temporalio/temporal/pulls/8563","_links":{"self":{"href":"https://api.github.com/repos/temporalio/temporal/pulls/comments/2535862852"},"html":{"href":"https://github.com/temporalio/temporal/pull/8563#discussion_r2535862852"},"pull_request":{"href":"https://api.github.com/repos/temporalio/temporal/pulls/8563"}},"reactions":{"url":"https://api.github.com/repos/temporalio/temporal/pulls/comments/2535862852/reactions","total_count":1,"+1":0,"-1":1,"laugh":0,"hooray":0,"confused":0,"heart":0,"rocket":0,"eyes":0},"start_line":null,"original_start_line":null,"start_side":null,"line":81,"original_line":67,"side":"RIGHT","author_association":"NONE","original_position":24,"position":50,"subject_type":"line"},{"url":"https://api.github.com/repos/temporalio/temporal/pulls/comments/2539837922","pull_request_review_id":3479944087,"id":2539837922,"node_id":"PRRC_kwDODNqesM6XYtni","diff_hunk":"@@ -314,3 +315,123 @@ func (a *Activity) RecordHeartbeat(ctx chasm.MutableContext, details *commonpb.P\n \t})\n \treturn nil, nil\n }\n+\n+func (a *Activity) buildActivityExecutionInfo(ctx chasm.Context) (*activity.ActivityExecutionInfo, error) {\n+\tif a.ActivityState == nil {\n+\t\treturn nil, errors.New(\"activity state is nil\")\n+\t}\n+\n+\t// TODO(dan): support pause states\n+\tvar status enumspb.ActivityExecutionStatus\n+\tvar runState enumspb.PendingActivityState\n+\tswitch a.GetStatus() {\n+\tcase activitypb.ACTIVITY_EXECUTION_STATUS_UNSPECIFIED:\n+\t\tstatus = enumspb.ACTIVITY_EXECUTION_STATUS_UNSPECIFIED\n+\t\trunState = enumspb.PENDING_ACTIVITY_STATE_UNSPECIFIED\n+\tcase activitypb.ACTIVITY_EXECUTION_STATUS_SCHEDULED:\n+\t\tstatus = enumspb.ACTIVITY_EXECUTION_STATUS_RUNNING\n+\t\trunState = enumspb.PENDING_ACTIVITY_STATE_SCHEDULED\n+\tcase activitypb.ACTIVITY_EXECUTION_STATUS_STARTED:\n+\t\tstatus = enumspb.ACTIVITY_EXECUTION_STATUS_RUNNING\n+\t\trunState = enumspb.PENDING_ACTIVITY_STATE_STARTED\n+\tcase activitypb.ACTIVITY_EXECUTION_STATUS_CANCEL_REQUESTED:\n+\t\tstatus = enumspb.ACTIVITY_EXECUTION_STATUS_RUNNING\n+\t\trunState = enumspb.PENDING_ACTIVITY_STATE_CANCEL_REQUESTED\n+\tcase activitypb.ACTIVITY_EXECUTION_STATUS_COMPLETED:\n+\t\tstatus = enumspb.ACTIVITY_EXECUTION_STATUS_COMPLETED\n+\t\trunState = enumspb.PENDING_ACTIVITY_STATE_UNSPECIFIED\n+\tcase activitypb.ACTIVITY_EXECUTION_STATUS_FAILED:\n+\t\tstatus = enumspb.ACTIVITY_EXECUTION_STATUS_FAILED\n+\t\trunState = enumspb.PENDING_ACTIVITY_STATE_UNSPECIFIED\n+\tcase activitypb.ACTIVITY_EXECUTION_STATUS_CANCELED:\n+\t\tstatus = enumspb.ACTIVITY_EXECUTION_STATUS_CANCELED\n+\t\trunState = enumspb.PENDING_ACTIVITY_STATE_UNSPECIFIED\n+\tcase activitypb.ACTIVITY_EXECUTION_STATUS_TERMINATED:\n+\t\tstatus = enumspb.ACTIVITY_EXECUTION_STATUS_TERMINATED\n+\t\trunState = enumspb.PENDING_ACTIVITY_STATE_UNSPECIFIED\n+\tcase activitypb.ACTIVITY_EXECUTION_STATUS_TIMED_OUT:\n+\t\tstatus = enumspb.ACTIVITY_EXECUTION_STATUS_TIMED_OUT\n+\t\trunState = enumspb.PENDING_ACTIVITY_STATE_UNSPECIFIED\n+\tdefault:\n+\t\treturn nil, serviceerror.NewInternalf(\"unknown activity execution status: %s\", a.GetStatus())\n+\t}\n+\n+\trequestData, err := a.RequestData.Get(ctx)\n+\tif err != nil {\n+\t\treturn nil, err\n+\t}\n+\n+\tkey := ctx.ExecutionKey()\n+\n+\tinfo := &activity.ActivityExecutionInfo{\n+\t\tActivityId:    key.BusinessID,\n+\t\tRunId:         key.EntityID,\n+\t\tActivityType:  a.GetActivityType(),\n+\t\tStatus:        status,\n+\t\tRunState:      runState,\n+\t\tScheduledTime: a.GetScheduledTime(),\n+\t\tPriority:      a.GetPriority(),\n+\t\tHeader:        requestData.GetHeader(),\n+\t\t// TODO(dan): populate remaining fields\n+\t}\n+\n+\treturn info, nil\n+}\n+\n+func (a *Activity) buildPollActivityExecutionResponse(\n+\tctx chasm.Context,\n+\treq *activitypb.PollActivityExecutionRequest,\n+) (*activitypb.PollActivityExecutionResponse, error) {\n+\trequest := req.GetFrontendRequest()\n+\n+\t// TODO(dan): pass ref into this function?","path":"chasm/lib/activity/activity.go","commit_id":"109a90fe02cb145ef9d0481242c354b066ca027d","original_commit_id":"da6009564e796063faf853352077eecdc1473612","user":{"login":"bergundy","id":52304,"node_id":"MDQ6VXNlcjUyMzA0","avatar_url":"https://avatars.githubusercontent.com/u/52304?v=4","gravatar_id":"","url":"https://api.github.com/users/bergundy","html_url":"https://github.com/bergundy","followers_url":"https://api.github.com/users/bergundy/followers","following_url":"https://api.github.com/users/bergundy/following{/other_user}","gists_url":"https://api.github.com/users/bergundy/gists{/gist_id}","starred_url":"https://api.github.com/users/bergundy/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/bergundy/subscriptions","organizations_url":"https://api.github.com/users/bergundy/orgs","repos_url":"https://api.github.com/users/bergundy/repos","events_url":"https://api.github.com/users/bergundy/events{/privacy}","received_events_url":"https://api.github.com/users/bergundy/received_events","type":"User","user_view_type":"public","site_admin":false},"body":"I don't think it's necessary TBH, it's nice to have the logic self contained IMHO.","created_at":"2025-11-18T22:36:28Z","updated_at":"2025-11-19T01:17:28Z","html_url":"https://github.com/temporalio/temporal/pull/8563#discussion_r2539837922","pull_request_url":"https://api.github.com/repos/temporalio/temporal/pulls/8563","_links":{"self":{"href":"https://api.github.com/repos/temporalio/temporal/pulls/comments/2539837922"},"html":{"href":"https://github.com/temporalio/temporal/pull/8563#discussion_r2539837922"},"pull_request":{"href":"https://api.github.com/repos/temporalio/temporal/pulls/8563"}},"reactions":{"url":"https://api.github.com/repos/temporalio/temporal/pulls/comments/2539837922/reactions","total_count":1,"+1":1,"-1":0,"laugh":0,"hooray":0,"confused":0,"heart":0,"rocket":0,"eyes":0},"start_line":null,"original_start_line":null,"start_side":null,"line":null,"original_line":387,"side":"RIGHT","author_association":"MEMBER","original_position":107,"position":1,"subject_type":"line"},{"url":"https://api.github.com/repos/temporalio/temporal/pulls/comments/2539839248","pull_request_review_id":3479944087,"id":2539839248,"node_id":"PRRC_kwDODNqesM6XYt8Q","diff_hunk":"@@ -314,3 +315,123 @@ func (a *Activity) RecordHeartbeat(ctx chasm.MutableContext, details *commonpb.P\n \t})\n \treturn nil, nil\n }\n+\n+func (a *Activity) buildActivityExecutionInfo(ctx chasm.Context) (*activity.ActivityExecutionInfo, error) {\n+\tif a.ActivityState == nil {\n+\t\treturn nil, errors.New(\"activity state is nil\")\n+\t}\n+\n+\t// TODO(dan): support pause states\n+\tvar status enumspb.ActivityExecutionStatus\n+\tvar runState enumspb.PendingActivityState\n+\tswitch a.GetStatus() {\n+\tcase activitypb.ACTIVITY_EXECUTION_STATUS_UNSPECIFIED:\n+\t\tstatus = enumspb.ACTIVITY_EXECUTION_STATUS_UNSPECIFIED\n+\t\trunState = enumspb.PENDING_ACTIVITY_STATE_UNSPECIFIED\n+\tcase activitypb.ACTIVITY_EXECUTION_STATUS_SCHEDULED:\n+\t\tstatus = enumspb.ACTIVITY_EXECUTION_STATUS_RUNNING\n+\t\trunState = enumspb.PENDING_ACTIVITY_STATE_SCHEDULED\n+\tcase activitypb.ACTIVITY_EXECUTION_STATUS_STARTED:\n+\t\tstatus = enumspb.ACTIVITY_EXECUTION_STATUS_RUNNING\n+\t\trunState = enumspb.PENDING_ACTIVITY_STATE_STARTED\n+\tcase activitypb.ACTIVITY_EXECUTION_STATUS_CANCEL_REQUESTED:\n+\t\tstatus = enumspb.ACTIVITY_EXECUTION_STATUS_RUNNING\n+\t\trunState = enumspb.PENDING_ACTIVITY_STATE_CANCEL_REQUESTED\n+\tcase activitypb.ACTIVITY_EXECUTION_STATUS_COMPLETED:\n+\t\tstatus = enumspb.ACTIVITY_EXECUTION_STATUS_COMPLETED\n+\t\trunState = enumspb.PENDING_ACTIVITY_STATE_UNSPECIFIED\n+\tcase activitypb.ACTIVITY_EXECUTION_STATUS_FAILED:\n+\t\tstatus = enumspb.ACTIVITY_EXECUTION_STATUS_FAILED\n+\t\trunState = enumspb.PENDING_ACTIVITY_STATE_UNSPECIFIED\n+\tcase activitypb.ACTIVITY_EXECUTION_STATUS_CANCELED:\n+\t\tstatus = enumspb.ACTIVITY_EXECUTION_STATUS_CANCELED\n+\t\trunState = enumspb.PENDING_ACTIVITY_STATE_UNSPECIFIED\n+\tcase activitypb.ACTIVITY_EXECUTION_STATUS_TERMINATED:\n+\t\tstatus = enumspb.ACTIVITY_EXECUTION_STATUS_TERMINATED\n+\t\trunState = enumspb.PENDING_ACTIVITY_STATE_UNSPECIFIED\n+\tcase activitypb.ACTIVITY_EXECUTION_STATUS_TIMED_OUT:\n+\t\tstatus = enumspb.ACTIVITY_EXECUTION_STATUS_TIMED_OUT\n+\t\trunState = enumspb.PENDING_ACTIVITY_STATE_UNSPECIFIED\n+\tdefault:\n+\t\treturn nil, serviceerror.NewInternalf(\"unknown activity execution status: %s\", a.GetStatus())\n+\t}\n+\n+\trequestData, err := a.RequestData.Get(ctx)\n+\tif err != nil {\n+\t\treturn nil, err\n+\t}\n+\n+\tkey := ctx.ExecutionKey()\n+\n+\tinfo := &activity.ActivityExecutionInfo{\n+\t\tActivityId:    key.BusinessID,\n+\t\tRunId:         key.EntityID,\n+\t\tActivityType:  a.GetActivityType(),\n+\t\tStatus:        status,\n+\t\tRunState:      runState,\n+\t\tScheduledTime: a.GetScheduledTime(),\n+\t\tPriority:      a.GetPriority(),\n+\t\tHeader:        requestData.GetHeader(),\n+\t\t// TODO(dan): populate remaining fields\n+\t}\n+\n+\treturn info, nil\n+}\n+\n+func (a *Activity) buildPollActivityExecutionResponse(\n+\tctx chasm.Context,\n+\treq *activitypb.PollActivityExecutionRequest,","path":"chasm/lib/activity/activity.go","commit_id":"1d59e66d0ce5d91819f92c428ef5ab4c4efca1fb","original_commit_id":"da6009564e796063faf853352077eecdc1473612","user":{"login":"bergundy","id":52304,"node_id":"MDQ6VXNlcjUyMzA0","avatar_url":"https://avatars.githubusercontent.com/u/52304?v=4","gravatar_id":"","url":"https://api.github.com/users/bergundy","html_url":"https://github.com/bergundy","followers_url":"https://api.github.com/users/bergundy/followers","following_url":"https://api.github.com/users/bergundy/following{/other_user}","gists_url":"https://api.github.com/users/bergundy/gists{/gist_id}","starred_url":"https://api.github.com/users/bergundy/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/bergundy/subscriptions","organizations_url":"https://api.github.com/users/bergundy/orgs","repos_url":"https://api.github.com/users/bergundy/repos","events_url":"https://api.github.com/users/bergundy/events{/privacy}","received_events_url":"https://api.github.com/users/bergundy/received_events","type":"User","user_view_type":"public","site_admin":false},"body":"You can just pass in the frontend request here and save the conversion and confusion between `req` and `request`.","created_at":"2025-11-18T22:37:07Z","updated_at":"2025-11-19T01:17:28Z","html_url":"https://github.com/temporalio/temporal/pull/8563#discussion_r2539839248","pull_request_url":"https://api.github.com/repos/temporalio/temporal/pulls/8563","_links":{"self":{"href":"https://api.github.com/repos/temporalio/temporal/pulls/comments/2539839248"},"html":{"href":"https://github.com/temporalio/temporal/pull/8563#discussion_r2539839248"},"pull_request":{"href":"https://api.github.com/repos/temporalio/temporal/pulls/8563"}},"reactions":{"url":"https://api.github.com/repos/temporalio/temporal/pulls/comments/2539839248/reactions","total_count":0,"+1":0,"-1":0,"laugh":0,"hooray":0,"confused":0,"heart":0,"rocket":0,"eyes":0},"start_line":null,"original_start_line":null,"start_side":null,"line":383,"original_line":383,"side":"RIGHT","author_association":"MEMBER","original_position":103,"position":99,"subject_type":"line"},{"url":"https://api.github.com/repos/temporalio/temporal/pulls/comments/2539840350","pull_request_review_id":3479944087,"id":2539840350,"node_id":"PRRC_kwDODNqesM6XYuNe","diff_hunk":"@@ -314,3 +315,125 @@ func (a *Activity) RecordHeartbeat(ctx chasm.MutableContext, details *commonpb.P\n \t})\n \treturn nil, nil\n }\n+\n+func (a *Activity) buildActivityExecutionInfo(ctx chasm.Context, key chasm.EntityKey) (*activity.ActivityExecutionInfo, error) {\n+\tif a.ActivityState == nil {\n+\t\treturn nil, errors.New(\"activity state is nil\")\n+\t}\n+\n+\t// TODO(dan): support pause states\n+\tvar status enumspb.ActivityExecutionStatus\n+\tvar runState enumspb.PendingActivityState\n+\tswitch a.GetStatus() {\n+\tcase activitypb.ACTIVITY_EXECUTION_STATUS_UNSPECIFIED:\n+\t\tstatus = enumspb.ACTIVITY_EXECUTION_STATUS_UNSPECIFIED\n+\t\trunState = enumspb.PENDING_ACTIVITY_STATE_UNSPECIFIED\n+\tcase activitypb.ACTIVITY_EXECUTION_STATUS_SCHEDULED:\n+\t\tstatus = enumspb.ACTIVITY_EXECUTION_STATUS_RUNNING\n+\t\trunState = enumspb.PENDING_ACTIVITY_STATE_SCHEDULED\n+\tcase activitypb.ACTIVITY_EXECUTION_STATUS_STARTED:\n+\t\tstatus = enumspb.ACTIVITY_EXECUTION_STATUS_RUNNING\n+\t\trunState = enumspb.PENDING_ACTIVITY_STATE_STARTED\n+\tcase activitypb.ACTIVITY_EXECUTION_STATUS_CANCEL_REQUESTED:\n+\t\tstatus = enumspb.ACTIVITY_EXECUTION_STATUS_RUNNING\n+\t\trunState = enumspb.PENDING_ACTIVITY_STATE_CANCEL_REQUESTED\n+\tcase activitypb.ACTIVITY_EXECUTION_STATUS_COMPLETED:\n+\t\tstatus = enumspb.ACTIVITY_EXECUTION_STATUS_COMPLETED\n+\t\trunState = enumspb.PENDING_ACTIVITY_STATE_UNSPECIFIED\n+\tcase activitypb.ACTIVITY_EXECUTION_STATUS_FAILED:\n+\t\tstatus = enumspb.ACTIVITY_EXECUTION_STATUS_FAILED\n+\t\trunState = enumspb.PENDING_ACTIVITY_STATE_UNSPECIFIED\n+\tcase activitypb.ACTIVITY_EXECUTION_STATUS_CANCELED:\n+\t\tstatus = enumspb.ACTIVITY_EXECUTION_STATUS_CANCELED\n+\t\trunState = enumspb.PENDING_ACTIVITY_STATE_UNSPECIFIED\n+\tcase activitypb.ACTIVITY_EXECUTION_STATUS_TERMINATED:\n+\t\tstatus = enumspb.ACTIVITY_EXECUTION_STATUS_TERMINATED\n+\t\trunState = enumspb.PENDING_ACTIVITY_STATE_UNSPECIFIED\n+\tcase activitypb.ACTIVITY_EXECUTION_STATUS_TIMED_OUT:\n+\t\tstatus = enumspb.ACTIVITY_EXECUTION_STATUS_TIMED_OUT\n+\t\trunState = enumspb.PENDING_ACTIVITY_STATE_UNSPECIFIED\n+\tdefault:\n+\t\treturn nil, serviceerror.NewInternalf(\"unknown activity execution status: %s\", a.GetStatus())\n+\t}\n+\n+\trequestData, err := a.RequestData.Get(ctx)\n+\tif err != nil {\n+\t\treturn nil, err\n+\t}\n+\n+\tinfo := &activity.ActivityExecutionInfo{\n+\t\tActivityId:    key.BusinessID,\n+\t\tRunId:         key.EntityID,\n+\t\tActivityType:  a.GetActivityType(),\n+\t\tStatus:        status,\n+\t\tRunState:      runState,\n+\t\tScheduledTime: a.GetScheduledTime(),\n+\t\tPriority:      a.GetPriority(),\n+\t\tHeader:        requestData.GetHeader(),\n+\t\t// TODO(dan): populate remaining fields\n+\t}\n+\n+\treturn info, nil\n+}\n+\n+func (a *Activity) buildPollActivityExecutionResponse(\n+\tctx chasm.Context,\n+\treq *activitypb.PollActivityExecutionRequest,\n+) (*activitypb.PollActivityExecutionResponse, error) {\n+\trequest := req.GetFrontendRequest()\n+\n+\t// TODO(dan): pass ref into this function?\n+\tref, err := ctx.Ref(a)\n+\tif err != nil {\n+\t\treturn nil, err\n+\t}\n+\n+\tvar info *activity.ActivityExecutionInfo\n+\tif request.GetIncludeInfo() {\n+\t\tinfo, err = a.buildActivityExecutionInfo(ctx, chasm.EntityKey{\n+\t\t\tNamespaceID: req.GetNamespaceId(),\n+\t\t\tBusinessID:  request.GetActivityId(),\n+\t\t\tEntityID:    request.GetRunId(),\n+\t\t})\n+\t\tif err != nil {\n+\t\t\treturn nil, err\n+\t\t}\n+\t}\n+\n+\tvar input *commonpb.Payloads\n+\tif request.GetIncludeInput() {\n+\t\tactivityRequest, err := a.RequestData.Get(ctx)\n+\t\tif err != nil {\n+\t\t\treturn nil, err\n+\t\t}\n+\t\tinput = activityRequest.Input\n+\t}\n+\n+\tresponse := &workflowservice.PollActivityExecutionResponse{\n+\t\tInfo:                     info,\n+\t\tRunId:                    ctx.ExecutionKey().EntityID,\n+\t\tInput:                    input,\n+\t\tStateChangeLongPollToken: ref,\n+\t}\n+\n+\tif request.GetIncludeOutcome() {\n+\t\tactivityOutcome, err := a.Outcome.Get(ctx)\n+\t\tif err != nil {\n+\t\t\treturn nil, err\n+\t\t}\n+\t\tswitch v := activityOutcome.GetVariant().(type) {\n+\t\tcase *activitypb.ActivityOutcome_Failed_:\n+\t\t\tresponse.Outcome = &workflowservice.PollActivityExecutionResponse_Failure{\n+\t\t\t\tFailure: v.Failed.GetFailure(),","path":"chasm/lib/activity/activity.go","commit_id":"109a90fe02cb145ef9d0481242c354b066ca027d","original_commit_id":"b24a0220435f567e7e3cacb95bd8fe78c17dc67b","user":{"login":"bergundy","id":52304,"node_id":"MDQ6VXNlcjUyMzA0","avatar_url":"https://avatars.githubusercontent.com/u/52304?v=4","gravatar_id":"","url":"https://api.github.com/users/bergundy","html_url":"https://github.com/bergundy","followers_url":"https://api.github.com/users/bergundy/followers","following_url":"https://api.github.com/users/bergundy/following{/other_user}","gists_url":"https://api.github.com/users/bergundy/gists{/gist_id}","starred_url":"https://api.github.com/users/bergundy/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/bergundy/subscriptions","organizations_url":"https://api.github.com/users/bergundy/orgs","repos_url":"https://api.github.com/users/bergundy/repos","events_url":"https://api.github.com/users/bergundy/events{/privacy}","received_events_url":"https://api.github.com/users/bergundy/received_events","type":"User","user_view_type":"public","site_admin":false},"body":"FYI this is a blocking comment.","created_at":"2025-11-18T22:37:40Z","updated_at":"2025-11-19T01:17:28Z","html_url":"https://github.com/temporalio/temporal/pull/8563#discussion_r2539840350","pull_request_url":"https://api.github.com/repos/temporalio/temporal/pulls/8563","_links":{"self":{"href":"https://api.github.com/repos/temporalio/temporal/pulls/comments/2539840350"},"html":{"href":"https://github.com/temporalio/temporal/pull/8563#discussion_r2539840350"},"pull_request":{"href":"https://api.github.com/repos/temporalio/temporal/pulls/8563"}},"reactions":{"url":"https://api.github.com/repos/temporalio/temporal/pulls/comments/2539840350/reactions","total_count":1,"+1":1,"-1":0,"laugh":0,"hooray":0,"confused":0,"heart":0,"rocket":0,"eyes":0},"start_line":null,"original_start_line":null,"start_side":null,"line":null,"original_line":427,"side":"RIGHT","in_reply_to_id":2525436567,"author_association":"MEMBER","original_position":147,"position":1,"subject_type":"line"},{"url":"https://api.github.com/repos/temporalio/temporal/pulls/comments/2539894829","pull_request_review_id":3479944087,"id":2539894829,"node_id":"PRRC_kwDODNqesM6XY7gt","diff_hunk":"@@ -53,3 +52,90 @@ func (h *handler) StartActivityExecution(ctx context.Context, req *activitypb.St\n \t\tFrontendResponse: response,\n \t}, nil\n }\n+\n+// PollActivityExecution handles PollActivityExecutionRequest from frontend. This method supports\n+// querying current activity state, optionally as a long-poll that waits for certain state changes.\n+// It is used by clients to poll for activity state and/or result.\n+func (h *handler) PollActivityExecution(\n+\tctx context.Context,\n+\treq *activitypb.PollActivityExecutionRequest,\n+) (response *activitypb.PollActivityExecutionResponse, err error) {\n+\tref := chasm.NewComponentRef[*Activity](chasm.EntityKey{\n+\t\tNamespaceID: req.GetNamespaceId(),\n+\t\tBusinessID:  req.GetFrontendRequest().GetActivityId(),\n+\t\tEntityID:    req.GetFrontendRequest().GetRunId(),\n+\t})\n+\twaitPolicy := req.GetFrontendRequest().GetWaitPolicy()\n+\n+\tif waitPolicy == nil {\n+\t\treturn chasm.ReadComponent(ctx, ref, (*Activity).buildPollActivityExecutionResponse, req, nil)\n+\t}\n+\n+\tswitch waitPolicy.(type) {\n+\tcase *workflowservice.PollActivityExecutionRequest_WaitAnyStateChange:\n+\t\ttoken := req.GetFrontendRequest().\n+\t\t\tGetWaitPolicy().(*workflowservice.PollActivityExecutionRequest_WaitAnyStateChange).\n+\t\t\tWaitAnyStateChange.GetLongPollToken()\n+\t\tresponse, _, err = chasm.PollComponent(ctx, ref, func(\n+\t\t\ta *Activity,\n+\t\t\tctx chasm.Context,\n+\t\t\treq *activitypb.PollActivityExecutionRequest,\n+\t\t) (*activitypb.PollActivityExecutionResponse, bool, error) {\n+\t\t\t_, changed, err := chasm.ExecutionStateChanged(a, ctx, token)\n+\t\t\tif err != nil {\n+\t\t\t\treturn nil, false, err\n+\t\t\t}\n+\t\t\tif changed {\n+\t\t\t\t// TODO(dan): pass ref returned by HasStateAdvanced into this?\n+\t\t\t\tresponse, err := a.buildPollActivityExecutionResponse(ctx, req)\n+\t\t\t\tif err != nil {\n+\t\t\t\t\treturn nil, true, err\n+\t\t\t\t}\n+\t\t\t\treturn response, true, nil","path":"chasm/lib/activity/handler.go","commit_id":"ee79ea9d2857dc0da255fec35a8ec05b24ecc8c6","original_commit_id":"da6009564e796063faf853352077eecdc1473612","user":{"login":"bergundy","id":52304,"node_id":"MDQ6VXNlcjUyMzA0","avatar_url":"https://avatars.githubusercontent.com/u/52304?v=4","gravatar_id":"","url":"https://api.github.com/users/bergundy","html_url":"https://github.com/bergundy","followers_url":"https://api.github.com/users/bergundy/followers","following_url":"https://api.github.com/users/bergundy/following{/other_user}","gists_url":"https://api.github.com/users/bergundy/gists{/gist_id}","starred_url":"https://api.github.com/users/bergundy/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/bergundy/subscriptions","organizations_url":"https://api.github.com/users/bergundy/orgs","repos_url":"https://api.github.com/users/bergundy/repos","events_url":"https://api.github.com/users/bergundy/events{/privacy}","received_events_url":"https://api.github.com/users/bergundy/received_events","type":"User","user_view_type":"public","site_admin":false},"body":"nit:\n\n\n```suggestion\n\t\t\t\treturn response, true, err\n```","created_at":"2025-11-18T23:06:28Z","updated_at":"2025-11-19T01:17:28Z","html_url":"https://github.com/temporalio/temporal/pull/8563#discussion_r2539894829","pull_request_url":"https://api.github.com/repos/temporalio/temporal/pulls/8563","_links":{"self":{"href":"https://api.github.com/repos/temporalio/temporal/pulls/comments/2539894829"},"html":{"href":"https://github.com/temporalio/temporal/pull/8563#discussion_r2539894829"},"pull_request":{"href":"https://api.github.com/repos/temporalio/temporal/pulls/8563"}},"reactions":{"url":"https://api.github.com/repos/temporalio/temporal/pulls/comments/2539894829/reactions","total_count":0,"+1":0,"-1":0,"laugh":0,"hooray":0,"confused":0,"heart":0,"rocket":0,"eyes":0},"start_line":null,"original_start_line":91,"start_side":"RIGHT","line":null,"original_line":94,"side":"RIGHT","author_association":"MEMBER","original_position":62,"position":1,"subject_type":"line"},{"url":"https://api.github.com/repos/temporalio/temporal/pulls/comments/2539902611","pull_request_review_id":3479944087,"id":2539902611,"node_id":"PRRC_kwDODNqesM6XY9aT","diff_hunk":"@@ -42,8 +42,7 @@ type Engine interface {\n \tPollComponent(\n \t\tcontext.Context,\n \t\tComponentRef,\n-\t\tfunc(Context, Component) (any, bool, error),\n-\t\tfunc(MutableContext, Component, any) error,\n+\t\tfunc(Context, Component) (bool, error),","path":"chasm/engine.go","commit_id":"1d59e66d0ce5d91819f92c428ef5ab4c4efca1fb","original_commit_id":"e38f646f2a658deac110ca4c0e25da54378b685f","user":{"login":"bergundy","id":52304,"node_id":"MDQ6VXNlcjUyMzA0","avatar_url":"https://avatars.githubusercontent.com/u/52304?v=4","gravatar_id":"","url":"https://api.github.com/users/bergundy","html_url":"https://github.com/bergundy","followers_url":"https://api.github.com/users/bergundy/followers","following_url":"https://api.github.com/users/bergundy/following{/other_user}","gists_url":"https://api.github.com/users/bergundy/gists{/gist_id}","starred_url":"https://api.github.com/users/bergundy/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/bergundy/subscriptions","organizations_url":"https://api.github.com/users/bergundy/orgs","repos_url":"https://api.github.com/users/bergundy/repos","events_url":"https://api.github.com/users/bergundy/events{/privacy}","received_events_url":"https://api.github.com/users/bergundy/received_events","type":"User","user_view_type":"public","site_admin":false},"body":"This totally works for me. We can discuss how to introduce this when the requirement comes up.","created_at":"2025-11-18T23:09:55Z","updated_at":"2025-11-19T01:17:28Z","html_url":"https://github.com/temporalio/temporal/pull/8563#discussion_r2539902611","pull_request_url":"https://api.github.com/repos/temporalio/temporal/pulls/8563","_links":{"self":{"href":"https://api.github.com/repos/temporalio/temporal/pulls/comments/2539902611"},"html":{"href":"https://github.com/temporalio/temporal/pull/8563#discussion_r2539902611"},"pull_request":{"href":"https://api.github.com/repos/temporalio/temporal/pulls/8563"}},"reactions":{"url":"https://api.github.com/repos/temporalio/temporal/pulls/comments/2539902611/reactions","total_count":0,"+1":0,"-1":0,"laugh":0,"hooray":0,"confused":0,"heart":0,"rocket":0,"eyes":0},"start_line":null,"original_start_line":null,"start_side":null,"line":45,"original_line":45,"side":"RIGHT","in_reply_to_id":2518779377,"author_association":"MEMBER","original_position":6,"position":6,"subject_type":"line"},{"url":"https://api.github.com/repos/temporalio/temporal/pulls/comments/2539914786","pull_request_review_id":3479944087,"id":2539914786,"node_id":"PRRC_kwDODNqesM6XZAYi","diff_hunk":"@@ -85,6 +85,24 @@ func (h *frontendHandler) StartActivityExecution(ctx context.Context, req *workf\n \treturn resp.GetFrontendResponse(), err\n }\n \n+// PollActivityExecution handles PollActivityExecutionRequest. This method supports querying current\n+// activity state, optionally as a long-poll that waits for certain state changes. It is used by\n+// clients to poll for activity state and/or result.\n+func (h *frontendHandler) PollActivityExecution(","path":"chasm/lib/activity/frontend.go","commit_id":"1d59e66d0ce5d91819f92c428ef5ab4c4efca1fb","original_commit_id":"da6009564e796063faf853352077eecdc1473612","user":{"login":"bergundy","id":52304,"node_id":"MDQ6VXNlcjUyMzA0","avatar_url":"https://avatars.githubusercontent.com/u/52304?v=4","gravatar_id":"","url":"https://api.github.com/users/bergundy","html_url":"https://github.com/bergundy","followers_url":"https://api.github.com/users/bergundy/followers","following_url":"https://api.github.com/users/bergundy/following{/other_user}","gists_url":"https://api.github.com/users/bergundy/gists{/gist_id}","starred_url":"https://api.github.com/users/bergundy/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/bergundy/subscriptions","organizations_url":"https://api.github.com/users/bergundy/orgs","repos_url":"https://api.github.com/users/bergundy/repos","events_url":"https://api.github.com/users/bergundy/events{/privacy}","received_events_url":"https://api.github.com/users/bergundy/received_events","type":"User","user_view_type":"public","site_admin":false},"body":"You're missing validation here. At minimum, we'll need to validate that the activity ID is not empty and a check that run ID is provided if long poll token is provided.","created_at":"2025-11-18T23:16:05Z","updated_at":"2025-11-19T01:17:28Z","html_url":"https://github.com/temporalio/temporal/pull/8563#discussion_r2539914786","pull_request_url":"https://api.github.com/repos/temporalio/temporal/pulls/8563","_links":{"self":{"href":"https://api.github.com/repos/temporalio/temporal/pulls/comments/2539914786"},"html":{"href":"https://github.com/temporalio/temporal/pull/8563#discussion_r2539914786"},"pull_request":{"href":"https://api.github.com/repos/temporalio/temporal/pulls/8563"}},"reactions":{"url":"https://api.github.com/repos/temporalio/temporal/pulls/comments/2539914786/reactions","total_count":0,"+1":0,"-1":0,"laugh":0,"hooray":0,"confused":0,"heart":0,"rocket":0,"eyes":0},"start_line":null,"original_start_line":null,"start_side":null,"line":91,"original_line":91,"side":"RIGHT","author_association":"MEMBER","original_position":7,"position":7,"subject_type":"line"},{"url":"https://api.github.com/repos/temporalio/temporal/pulls/comments/2539926841","pull_request_review_id":3479944087,"id":2539926841,"node_id":"PRRC_kwDODNqesM6XZDU5","diff_hunk":"@@ -0,0 +1,46 @@\n+package chasm\n+\n+import (\n+\t\"go.temporal.io/api/serviceerror\"\n+\t\"go.temporal.io/server/common/persistence/transitionhistory\"\n+\t\"go.temporal.io/server/service/history/consts\"\n+)\n+\n+// ExecutionStateChanged returns a ref for the component if execution state has advanced beyond the state\n+// encoded in ref.\n+func ExecutionStateChanged(c Component, ctx Context, refBytes []byte) ([]byte, bool, error) {\n+\tcurrentRefBytes, err := ctx.Ref(c)\n+\tif err != nil {\n+\t\treturn nil, false, err\n+\t}\n+\tcurrentRef, err := DeserializeComponentRef(currentRefBytes)\n+\tif err != nil {\n+\t\treturn nil, false, err\n+\t}\n+\n+\tref, err := DeserializeComponentRef(refBytes)\n+\tif err != nil {\n+\t\treturn nil, false, err\n+\t}\n+\n+\tif len(refBytes) > 0 && ref.EntityKey != currentRef.EntityKey {","path":"chasm/transition_history.go","commit_id":"1ad72b59ab2d1e2ef1c33d4a7f01caa9595736c9","original_commit_id":"da6009564e796063faf853352077eecdc1473612","user":{"login":"bergundy","id":52304,"node_id":"MDQ6VXNlcjUyMzA0","avatar_url":"https://avatars.githubusercontent.com/u/52304?v=4","gravatar_id":"","url":"https://api.github.com/users/bergundy","html_url":"https://github.com/bergundy","followers_url":"https://api.github.com/users/bergundy/followers","following_url":"https://api.github.com/users/bergundy/following{/other_user}","gists_url":"https://api.github.com/users/bergundy/gists{/gist_id}","starred_url":"https://api.github.com/users/bergundy/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/bergundy/subscriptions","organizations_url":"https://api.github.com/users/bergundy/orgs","repos_url":"https://api.github.com/users/bergundy/repos","events_url":"https://api.github.com/users/bergundy/events{/privacy}","received_events_url":"https://api.github.com/users/bergundy/received_events","type":"User","user_view_type":"public","site_admin":false},"body":"`len(refBytes) == 0` should result in an internal error. It's never valid for it to be empty. I think `DeserializeComponentRef` should ensure this already.","created_at":"2025-11-18T23:21:05Z","updated_at":"2025-11-19T01:17:28Z","html_url":"https://github.com/temporalio/temporal/pull/8563#discussion_r2539926841","pull_request_url":"https://api.github.com/repos/temporalio/temporal/pulls/8563","_links":{"self":{"href":"https://api.github.com/repos/temporalio/temporal/pulls/comments/2539926841"},"html":{"href":"https://github.com/temporalio/temporal/pull/8563#discussion_r2539926841"},"pull_request":{"href":"https://api.github.com/repos/temporalio/temporal/pulls/8563"}},"reactions":{"url":"https://api.github.com/repos/temporalio/temporal/pulls/comments/2539926841/reactions","total_count":0,"+1":0,"-1":0,"laugh":0,"hooray":0,"confused":0,"heart":0,"rocket":0,"eyes":0},"start_line":null,"original_start_line":null,"start_side":null,"line":null,"original_line":26,"side":"RIGHT","author_association":"MEMBER","original_position":26,"position":1,"subject_type":"line"},{"url":"https://api.github.com/repos/temporalio/temporal/pulls/comments/2539929730","pull_request_review_id":3479944087,"id":2539929730,"node_id":"PRRC_kwDODNqesM6XZECC","diff_hunk":"@@ -0,0 +1,46 @@\n+package chasm\n+\n+import (\n+\t\"go.temporal.io/api/serviceerror\"\n+\t\"go.temporal.io/server/common/persistence/transitionhistory\"\n+\t\"go.temporal.io/server/service/history/consts\"\n+)\n+\n+// ExecutionStateChanged returns a ref for the component if execution state has advanced beyond the state\n+// encoded in ref.\n+func ExecutionStateChanged(c Component, ctx Context, refBytes []byte) ([]byte, bool, error) {\n+\tcurrentRefBytes, err := ctx.Ref(c)\n+\tif err != nil {\n+\t\treturn nil, false, err\n+\t}\n+\tcurrentRef, err := DeserializeComponentRef(currentRefBytes)\n+\tif err != nil {\n+\t\treturn nil, false, err\n+\t}\n+\n+\tref, err := DeserializeComponentRef(refBytes)\n+\tif err != nil {\n+\t\treturn nil, false, err\n+\t}\n+\n+\tif len(refBytes) > 0 && ref.EntityKey != currentRef.EntityKey {\n+\t\treturn nil, false, serviceerror.NewInternalf(","path":"chasm/transition_history.go","commit_id":"e4dd35d8e015d10cbfbc5f7cf1cdf7ebf72be925","original_commit_id":"da6009564e796063faf853352077eecdc1473612","user":{"login":"bergundy","id":52304,"node_id":"MDQ6VXNlcjUyMzA0","avatar_url":"https://avatars.githubusercontent.com/u/52304?v=4","gravatar_id":"","url":"https://api.github.com/users/bergundy","html_url":"https://github.com/bergundy","followers_url":"https://api.github.com/users/bergundy/followers","following_url":"https://api.github.com/users/bergundy/following{/other_user}","gists_url":"https://api.github.com/users/bergundy/gists{/gist_id}","starred_url":"https://api.github.com/users/bergundy/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/bergundy/subscriptions","organizations_url":"https://api.github.com/users/bergundy/orgs","repos_url":"https://api.github.com/users/bergundy/repos","events_url":"https://api.github.com/users/bergundy/events{/privacy}","received_events_url":"https://api.github.com/users/bergundy/received_events","type":"User","user_view_type":"public","site_admin":false},"body":"I'm not sure when this would happen apart from when the provided ref is missing a run ID, which would be an error in the handler logic.\nYou should add a comment explaining why this is check is here.","created_at":"2025-11-18T23:22:20Z","updated_at":"2025-11-19T01:17:28Z","html_url":"https://github.com/temporalio/temporal/pull/8563#discussion_r2539929730","pull_request_url":"https://api.github.com/repos/temporalio/temporal/pulls/8563","_links":{"self":{"href":"https://api.github.com/repos/temporalio/temporal/pulls/comments/2539929730"},"html":{"href":"https://github.com/temporalio/temporal/pull/8563#discussion_r2539929730"},"pull_request":{"href":"https://api.github.com/repos/temporalio/temporal/pulls/8563"}},"reactions":{"url":"https://api.github.com/repos/temporalio/temporal/pulls/comments/2539929730/reactions","total_count":0,"+1":0,"-1":0,"laugh":0,"hooray":0,"confused":0,"heart":0,"rocket":0,"eyes":0},"start_line":null,"original_start_line":null,"start_side":null,"line":null,"original_line":27,"side":"RIGHT","author_association":"MEMBER","original_position":27,"position":1,"subject_type":"line"},{"url":"https://api.github.com/repos/temporalio/temporal/pulls/comments/2539934091","pull_request_review_id":3479944087,"id":2539934091,"node_id":"PRRC_kwDODNqesM6XZFGL","diff_hunk":"@@ -0,0 +1,46 @@\n+package chasm\n+\n+import (\n+\t\"go.temporal.io/api/serviceerror\"\n+\t\"go.temporal.io/server/common/persistence/transitionhistory\"\n+\t\"go.temporal.io/server/service/history/consts\"\n+)\n+\n+// ExecutionStateChanged returns a ref for the component if execution state has advanced beyond the state\n+// encoded in ref.\n+func ExecutionStateChanged(c Component, ctx Context, refBytes []byte) ([]byte, bool, error) {\n+\tcurrentRefBytes, err := ctx.Ref(c)\n+\tif err != nil {\n+\t\treturn nil, false, err\n+\t}\n+\tcurrentRef, err := DeserializeComponentRef(currentRefBytes)\n+\tif err != nil {\n+\t\treturn nil, false, err\n+\t}\n+\n+\tref, err := DeserializeComponentRef(refBytes)\n+\tif err != nil {\n+\t\treturn nil, false, err\n+\t}\n+\n+\tif len(refBytes) > 0 && ref.EntityKey != currentRef.EntityKey {\n+\t\treturn nil, false, serviceerror.NewInternalf(\n+\t\t\t\"ref execution key (%v) does not match component execution (%v)\", ref.EntityKey, currentRef.EntityKey)\n+\t}\n+\n+\tswitch transitionhistory.Compare(ref.entityLastUpdateVT, currentRef.entityLastUpdateVT) {\n+\tcase -1:\n+\t\t// Execution state has advanced beyond submitted ref\n+\t\treturn currentRefBytes, true, nil\n+\tcase 0:\n+\t\t// Execution state has not advanced beyond submitted ref\n+\t\treturn nil, false, nil\n+\tcase 1:\n+\t\t// Execution state is behind submitted ref\n+\t\treturn nil, false, consts.ErrStaleState\n+\tdefault:\n+\t\t// Impossible: Compare only returns -1, 0, or 1\n+\t\treturn nil, false, serviceerror.NewInternal(\"unexpected transition history comparison result\")","path":"chasm/transition_history.go","commit_id":"e95ab0ad0ba0c42c1e0e125042367ada0583ea76","original_commit_id":"da6009564e796063faf853352077eecdc1473612","user":{"login":"bergundy","id":52304,"node_id":"MDQ6VXNlcjUyMzA0","avatar_url":"https://avatars.githubusercontent.com/u/52304?v=4","gravatar_id":"","url":"https://api.github.com/users/bergundy","html_url":"https://github.com/bergundy","followers_url":"https://api.github.com/users/bergundy/followers","following_url":"https://api.github.com/users/bergundy/following{/other_user}","gists_url":"https://api.github.com/users/bergundy/gists{/gist_id}","starred_url":"https://api.github.com/users/bergundy/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/bergundy/subscriptions","organizations_url":"https://api.github.com/users/bergundy/orgs","repos_url":"https://api.github.com/users/bergundy/repos","events_url":"https://api.github.com/users/bergundy/events{/privacy}","received_events_url":"https://api.github.com/users/bergundy/received_events","type":"User","user_view_type":"public","site_admin":false},"body":"Be careful on what error message you expose here. Service errors are user facing errors and this error message is meaningless to users.\n\nAlternatively, you could panic or just not handle this unexpected case.","created_at":"2025-11-18T23:24:17Z","updated_at":"2025-11-19T01:17:28Z","html_url":"https://github.com/temporalio/temporal/pull/8563#discussion_r2539934091","pull_request_url":"https://api.github.com/repos/temporalio/temporal/pulls/8563","_links":{"self":{"href":"https://api.github.com/repos/temporalio/temporal/pulls/comments/2539934091"},"html":{"href":"https://github.com/temporalio/temporal/pull/8563#discussion_r2539934091"},"pull_request":{"href":"https://api.github.com/repos/temporalio/temporal/pulls/8563"}},"reactions":{"url":"https://api.github.com/repos/temporalio/temporal/pulls/comments/2539934091/reactions","total_count":0,"+1":0,"-1":0,"laugh":0,"hooray":0,"confused":0,"heart":0,"rocket":0,"eyes":0},"start_line":null,"original_start_line":null,"start_side":null,"line":null,"original_line":43,"side":"RIGHT","author_association":"MEMBER","original_position":43,"position":1,"subject_type":"line"},{"url":"https://api.github.com/repos/temporalio/temporal/pulls/comments/2539941018","pull_request_review_id":3479944087,"id":2539941018,"node_id":"PRRC_kwDODNqesM6XZGya","diff_hunk":"@@ -0,0 +1,46 @@\n+package chasm\n+\n+import (\n+\t\"go.temporal.io/api/serviceerror\"\n+\t\"go.temporal.io/server/common/persistence/transitionhistory\"\n+\t\"go.temporal.io/server/service/history/consts\"\n+)\n+\n+// ExecutionStateChanged returns a ref for the component if execution state has advanced beyond the state\n+// encoded in ref.\n+func ExecutionStateChanged(c Component, ctx Context, refBytes []byte) ([]byte, bool, error) {","path":"chasm/transition_history.go","commit_id":"e4dd35d8e015d10cbfbc5f7cf1cdf7ebf72be925","original_commit_id":"da6009564e796063faf853352077eecdc1473612","user":{"login":"bergundy","id":52304,"node_id":"MDQ6VXNlcjUyMzA0","avatar_url":"https://avatars.githubusercontent.com/u/52304?v=4","gravatar_id":"","url":"https://api.github.com/users/bergundy","html_url":"https://github.com/bergundy","followers_url":"https://api.github.com/users/bergundy/followers","following_url":"https://api.github.com/users/bergundy/following{/other_user}","gists_url":"https://api.github.com/users/bergundy/gists{/gist_id}","starred_url":"https://api.github.com/users/bergundy/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/bergundy/subscriptions","organizations_url":"https://api.github.com/users/bergundy/orgs","repos_url":"https://api.github.com/users/bergundy/repos","events_url":"https://api.github.com/users/bergundy/events{/privacy}","received_events_url":"https://api.github.com/users/bergundy/received_events","type":"User","user_view_type":"public","site_admin":false},"body":"Consider not returning the current ref, it's easy to obtain after the execution has resolved.","created_at":"2025-11-18T23:28:30Z","updated_at":"2025-11-19T01:17:28Z","html_url":"https://github.com/temporalio/temporal/pull/8563#discussion_r2539941018","pull_request_url":"https://api.github.com/repos/temporalio/temporal/pulls/8563","_links":{"self":{"href":"https://api.github.com/repos/temporalio/temporal/pulls/comments/2539941018"},"html":{"href":"https://github.com/temporalio/temporal/pull/8563#discussion_r2539941018"},"pull_request":{"href":"https://api.github.com/repos/temporalio/temporal/pulls/8563"}},"reactions":{"url":"https://api.github.com/repos/temporalio/temporal/pulls/comments/2539941018/reactions","total_count":0,"+1":0,"-1":0,"laugh":0,"hooray":0,"confused":0,"heart":0,"rocket":0,"eyes":0},"start_line":null,"original_start_line":null,"start_side":null,"line":null,"original_line":11,"side":"RIGHT","author_association":"MEMBER","original_position":11,"position":1,"subject_type":"line"},{"url":"https://api.github.com/repos/temporalio/temporal/pulls/comments/2539944243","pull_request_review_id":3479944087,"id":2539944243,"node_id":"PRRC_kwDODNqesM6XZHkz","diff_hunk":"@@ -712,21 +714,25 @@ var (\n \tHandoverWaitLatency   = NewTimerDef(\"handover_wait_latency\")\n \n \t// History\n-\tCacheRequests                                = NewCounterDef(\"cache_requests\")\n-\tCacheFailures                                = NewCounterDef(\"cache_errors\")\n-\tCacheLatency                                 = NewTimerDef(\"cache_latency\")\n-\tCacheMissCounter                             = NewCounterDef(\"cache_miss\")\n-\tCacheSize                                    = NewGaugeDef(\"cache_size\")\n-\tCacheUsage                                   = NewGaugeDef(\"cache_usage\")\n-\tCachePinnedUsage                             = NewGaugeDef(\"cache_pinned_usage\")\n-\tCacheTtl                                     = NewTimerDef(\"cache_ttl\")\n-\tCacheEntryAgeOnGet                           = NewTimerDef(\"cache_entry_age_on_get\")\n-\tCacheEntryAgeOnEviction                      = NewTimerDef(\"cache_entry_age_on_eviction\")\n-\tHistoryEventNotificationQueueingLatency      = NewTimerDef(\"history_event_notification_queueing_latency\")\n-\tHistoryEventNotificationFanoutLatency        = NewTimerDef(\"history_event_notification_fanout_latency\")\n-\tHistoryEventNotificationInFlightMessageGauge = NewGaugeDef(\"history_event_notification_inflight_message_gauge\")\n-\tHistoryEventNotificationFailDeliveryCount    = NewCounterDef(\"history_event_notification_fail_delivery_count\")\n-\tHistoryHostHealthGauge                       = NewGaugeDef(\"host_health\")\n+\tCacheRequests                                  = NewCounterDef(\"cache_requests\")\n+\tCacheFailures                                  = NewCounterDef(\"cache_errors\")\n+\tCacheLatency                                   = NewTimerDef(\"cache_latency\")\n+\tCacheMissCounter                               = NewCounterDef(\"cache_miss\")\n+\tCacheSize                                      = NewGaugeDef(\"cache_size\")\n+\tCacheUsage                                     = NewGaugeDef(\"cache_usage\")\n+\tCachePinnedUsage                               = NewGaugeDef(\"cache_pinned_usage\")\n+\tCacheTtl                                       = NewTimerDef(\"cache_ttl\")\n+\tCacheEntryAgeOnGet                             = NewTimerDef(\"cache_entry_age_on_get\")\n+\tCacheEntryAgeOnEviction                        = NewTimerDef(\"cache_entry_age_on_eviction\")\n+\tHistoryEventNotificationQueueingLatency        = NewTimerDef(\"history_event_notification_queueing_latency\")\n+\tHistoryEventNotificationFanoutLatency          = NewTimerDef(\"history_event_notification_fanout_latency\")\n+\tHistoryEventNotificationInFlightMessageGauge   = NewGaugeDef(\"history_event_notification_inflight_message_gauge\")\n+\tHistoryEventNotificationFailDeliveryCount      = NewCounterDef(\"history_event_notification_fail_delivery_count\")\n+\tChasmComponentNotificationQueueingLatency      = NewTimerDef(\"chasm_component_notification_queueing_latency\")\n+\tChasmComponentNotificationFanoutLatency        = NewTimerDef(\"chasm_component_notification_fanout_latency\")\n+\tChasmComponentNotificationInFlightMessageGauge = NewGaugeDef(\"chasm_component_notification_inflight_message_gauge\")","path":"common/metrics/metric_defs.go","commit_id":"e5d900bae4ca8bf7be4923a6aaa72467278da9b3","original_commit_id":"da6009564e796063faf853352077eecdc1473612","user":{"login":"bergundy","id":52304,"node_id":"MDQ6VXNlcjUyMzA0","avatar_url":"https://avatars.githubusercontent.com/u/52304?v=4","gravatar_id":"","url":"https://api.github.com/users/bergundy","html_url":"https://github.com/bergundy","followers_url":"https://api.github.com/users/bergundy/followers","following_url":"https://api.github.com/users/bergundy/following{/other_user}","gists_url":"https://api.github.com/users/bergundy/gists{/gist_id}","starred_url":"https://api.github.com/users/bergundy/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/bergundy/subscriptions","organizations_url":"https://api.github.com/users/bergundy/orgs","repos_url":"https://api.github.com/users/bergundy/repos","events_url":"https://api.github.com/users/bergundy/events{/privacy}","received_events_url":"https://api.github.com/users/bergundy/received_events","type":"User","user_view_type":"public","site_admin":false},"body":"Gauges only work well if you emit them periodically. Otherwise it's recommended to work with increment and decrement counters and deltas. Counters work better for aggregation too.","created_at":"2025-11-18T23:30:32Z","updated_at":"2025-11-19T01:17:28Z","html_url":"https://github.com/temporalio/temporal/pull/8563#discussion_r2539944243","pull_request_url":"https://api.github.com/repos/temporalio/temporal/pulls/8563","_links":{"self":{"href":"https://api.github.com/repos/temporalio/temporal/pulls/comments/2539944243"},"html":{"href":"https://github.com/temporalio/temporal/pull/8563#discussion_r2539944243"},"pull_request":{"href":"https://api.github.com/repos/temporalio/temporal/pulls/8563"}},"reactions":{"url":"https://api.github.com/repos/temporalio/temporal/pulls/comments/2539944243/reactions","total_count":0,"+1":0,"-1":0,"laugh":0,"hooray":0,"confused":0,"heart":0,"rocket":0,"eyes":0},"start_line":null,"original_start_line":null,"start_side":null,"line":null,"original_line":733,"side":"RIGHT","author_association":"MEMBER","original_position":44,"position":1,"subject_type":"line"},{"url":"https://api.github.com/repos/temporalio/temporal/pulls/comments/2539990577","pull_request_review_id":3479944087,"id":2539990577,"node_id":"PRRC_kwDODNqesM6XZS4x","diff_hunk":"@@ -241,14 +278,173 @@ func (e *ChasmEngine) ReadComponent(\n \treturn readFn(chasmContext, component)\n }\n \n+// PollComponent waits until the supplied predicate is satisfied when evaluated against the\n+// component identified by the supplied component reference. If it times out due to the\n+// server-imposed long-poll timeout then it returns (nil, nil). Otherwise if there is no error, it\n+// returns (ref, nil) where ref is a component reference identifying the state at which the\n+// predicate was satisfied. It is an error if entity transition history is (after reloading from\n+// persistence) behind the requested ref, or if the ref is not consistent with entity transition\n+// history. Thus when the predicate function is evaluated, it is guaranteed that the entity VT >=\n+// requestRef VT.\n func (e *ChasmEngine) PollComponent(\n \tctx context.Context,\n-\tentityRef chasm.ComponentRef,\n-\tpredicateFn func(chasm.Context, chasm.Component) (any, bool, error),\n-\toperationFn func(chasm.MutableContext, chasm.Component, any) error,\n-\topts ...chasm.TransitionOption,\n-) (newEntityRef []byte, retError error) {\n-\treturn nil, serviceerror.NewUnimplemented(\"PollComponent is not yet supported\")\n+\trequestRef chasm.ComponentRef,\n+\tpredicateFn func(chasm.Context, chasm.Component) (bool, error),\n+) ([]byte, error) {\n+\t// 1. Acquire lock\n+\t// 2. Error if shard entity VT < requestRef VT ('stale state')\n+\t// 3. If predicate satisfied, release lock and return\n+\t// 4. Subscribe to notifications for this entity\n+\t// 5. Release lock\n+\t// 6. On notification repeat (1) and (2)\n+\n+\tshardContext, executionLease, err := e.getExecutionLease(ctx, requestRef)\n+\tif err != nil {\n+\t\t// E.g. requestRef VT inconsistent with shard VT ('stale reference')\n+\t\treturn nil, err\n+\t}\n+\n+\t// hold lock until return or subscription established\n+\treleased := false\n+\tdefer func() {\n+\t\tif !released {\n+\t\t\t// read-only operation; don't pass error\n+\t\t\texecutionLease.GetReleaseFn()(nil)\n+\t\t}\n+\t}()\n+\n+\t// At this point it's possible that shard VT < requestRef VT (getExecutionLease does not\n+\t// guarantee that returned shard state is non-stale w.r.t. requestRef).\n+\tcurrentRef, err := e.checkPredicate(ctx, requestRef, executionLease, predicateFn)\n+\tif err != nil {\n+\t\treturn nil, err\n+\t}\n+\t// shard VT >= requestRef VT (enforced by checkPredicate)\n+\n+\tif currentRef != nil {\n+\t\t// wait condition was satisfied\n+\t\treturn currentRef, nil\n+\t}\n+\n+\t// Wait condition not satisfied; long-poll\n+\n+\tchannel, subscriberID, err := e.notifier.Subscribe(requestRef.EntityKey)\n+\tif err != nil {\n+\t\treturn nil, err\n+\t}\n+\tdefer func() {\n+\t\t_ = e.notifier.Unsubscribe(requestRef.EntityKey, subscriberID)\n+\t}()\n+\n+\t// Release the lock, now that we are subscribed\n+\texecutionLease.GetReleaseFn()(nil)\n+\treleased = true\n+\n+\tnamespaceRegistry, err := shardContext.GetNamespaceRegistry().GetNamespaceByID(\n+\t\tnamespace.ID(requestRef.EntityKey.NamespaceID),\n+\t)\n+\tif err != nil {\n+\t\treturn nil, err\n+\t}\n+\n+\t// Long-poll timeout semantics are the same as PollWorkflowExecutionUpdate: if the long-poll\n+\t// times out due to the server-imposed soft timeout, then return a non-error empty response\n+\t// indicating to a caller that they should continue long-polling.\n+\n+\t// TODO(dan): GetOrPollMutableState uses\n+\t// longPollInterval := shardContext.GetConfig().LongPollExpirationInterval(namespaceRegistry.Name().String())\n+\t// longPollCtx, cancel := contextutil.WithDeadlineBuffer(ctx, longPollInterval, longPollSoftTimeout)\n+\tsoftTimeout := shardContext.GetConfig().LongPollExpirationInterval(namespaceRegistry.Name().String())\n+\tstCtx, stCancel := context.WithTimeout(ctx, softTimeout)\n+\tdefer stCancel()","path":"service/history/chasm_engine.go","commit_id":"da6009564e796063faf853352077eecdc1473612","original_commit_id":"6a143cd1b107c501afb04b509304e46a9da03e6d","user":{"login":"bergundy","id":52304,"node_id":"MDQ6VXNlcjUyMzA0","avatar_url":"https://avatars.githubusercontent.com/u/52304?v=4","gravatar_id":"","url":"https://api.github.com/users/bergundy","html_url":"https://github.com/bergundy","followers_url":"https://api.github.com/users/bergundy/followers","following_url":"https://api.github.com/users/bergundy/following{/other_user}","gists_url":"https://api.github.com/users/bergundy/gists{/gist_id}","starred_url":"https://api.github.com/users/bergundy/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/bergundy/subscriptions","organizations_url":"https://api.github.com/users/bergundy/orgs","repos_url":"https://api.github.com/users/bergundy/repos","events_url":"https://api.github.com/users/bergundy/events{/privacy}","received_events_url":"https://api.github.com/users/bergundy/received_events","type":"User","user_view_type":"public","site_admin":false},"body":"What you put here LGTM.","created_at":"2025-11-18T23:58:22Z","updated_at":"2025-11-19T01:17:28Z","html_url":"https://github.com/temporalio/temporal/pull/8563#discussion_r2539990577","pull_request_url":"https://api.github.com/repos/temporalio/temporal/pulls/8563","_links":{"self":{"href":"https://api.github.com/repos/temporalio/temporal/pulls/comments/2539990577"},"html":{"href":"https://github.com/temporalio/temporal/pull/8563#discussion_r2539990577"},"pull_request":{"href":"https://api.github.com/repos/temporalio/temporal/pulls/8563"}},"reactions":{"url":"https://api.github.com/repos/temporalio/temporal/pulls/comments/2539990577/reactions","total_count":0,"+1":0,"-1":0,"laugh":0,"hooray":0,"confused":0,"heart":0,"rocket":0,"eyes":0},"start_line":null,"original_start_line":null,"start_side":null,"line":null,"original_line":358,"side":"RIGHT","in_reply_to_id":2524046642,"author_association":"MEMBER","original_position":180,"position":1,"subject_type":"line"},{"url":"https://api.github.com/repos/temporalio/temporal/pulls/comments/2539998404","pull_request_review_id":3479944087,"id":2539998404,"node_id":"PRRC_kwDODNqesM6XZUzE","diff_hunk":"@@ -241,14 +285,182 @@ func (e *ChasmEngine) ReadComponent(\n \treturn readFn(chasmContext, component)\n }\n \n+// PollComponent waits until the supplied predicate is satisfied when evaluated against the\n+// component identified by the supplied component reference. If it times out due to the\n+// server-imposed long-poll timeout then it returns (nil, nil). Otherwise if there is no error, it\n+// returns (ref, nil) where ref is a component reference identifying the state at which the\n+// predicate was satisfied. It is an error if execution transition history is (after reloading from\n+// persistence) behind the requested ref, or if the ref is inconsistent with execution transition\n+// history. Thus when the predicate function is evaluated, it is guaranteed that the execution VT >=\n+// requestRef VT.\n func (e *ChasmEngine) PollComponent(\n \tctx context.Context,\n-\tentityRef chasm.ComponentRef,\n-\tpredicateFn func(chasm.Context, chasm.Component) (any, bool, error),\n-\toperationFn func(chasm.MutableContext, chasm.Component, any) error,\n-\topts ...chasm.TransitionOption,\n-) (newEntityRef []byte, retError error) {\n-\treturn nil, serviceerror.NewUnimplemented(\"PollComponent is not yet supported\")\n+\trequestRef chasm.ComponentRef,\n+\tpredicateFn func(chasm.Context, chasm.Component) (bool, error),\n+) ([]byte, error) {\n+\t// 1. Acquire lock\n+\t// 2. Error if shard execution VT < requestRef VT ('stale state')\n+\t// 3. If predicate satisfied, release lock and return\n+\t// 4. Subscribe to notifications for this execution\n+\t// 5. Release lock\n+\t// 6. On notification repeat (1) and (2)\n+\n+\tshardContext, executionLease, err := e.getExecutionLease(ctx, requestRef)\n+\tif err != nil {\n+\t\t// E.g. requestRef VT inconsistent with shard VT ('stale reference')\n+\t\treturn nil, err\n+\t}\n+\n+\t// hold lock until return or subscription established\n+\treleased := false\n+\tdefer func() {\n+\t\tif !released {\n+\t\t\t// read-only operation; don't pass error\n+\t\t\texecutionLease.GetReleaseFn()(nil)\n+\t\t}\n+\t}()\n+\n+\t// At this point it's possible that shard VT < requestRef VT (getExecutionLease does not\n+\t// guarantee that returned shard state is non-stale w.r.t. requestRef).\n+\tcurrentRef, err := e.checkPredicate(ctx, requestRef, executionLease, predicateFn)\n+\tif err != nil {\n+\t\treturn nil, err\n+\t}\n+\t// shard VT >= requestRef VT (enforced by checkPredicate)\n+\n+\tif currentRef != nil {\n+\t\t// wait condition was satisfied\n+\t\treturn currentRef, nil\n+\t}\n+\n+\t// Wait condition not satisfied; long-poll\n+\n+\t// TODO(dan) For now, UpdateComponent emits execution-level notifications, and PollComponent\n+\t// subscribes to execution-level notifications. This means that PollComponent may be woken up\n+\t// unnecessarily, but it will not miss notifications. In the future we may want to change\n+\t// PollComponent to subscribe to component-level notifications, and change UpdateComponent so\n+\t// that notifications are emitted only for nodes that were mutated in the transaction.\n+\tchannel, subscriberID, err := e.notifier.Subscribe(requestRef.EntityKey)\n+\tif err != nil {\n+\t\treturn nil, err\n+\t}\n+\tdefer func() {\n+\t\t_ = e.notifier.Unsubscribe(requestRef.EntityKey, subscriberID)\n+\t}()\n+\n+\t// Release the lock, now that we are subscribed\n+\texecutionLease.GetReleaseFn()(nil)\n+\treleased = true\n+\n+\tnamespaceRegistry, err := shardContext.GetNamespaceRegistry().GetNamespaceByID(\n+\t\tnamespace.ID(requestRef.EntityKey.NamespaceID),\n+\t)\n+\tif err != nil {\n+\t\treturn nil, err\n+\t}\n+\n+\t// Long-poll timeout semantics are the same as PollWorkflowExecutionUpdate: if the long-poll\n+\t// times out due to the server-imposed soft timeout, then return a non-error empty response\n+\t// indicating to a caller that they should continue long-polling. Unlike\n+\t// PollWorkflowExecutionUpdate we reserve 1s buffer.\n+\tsoftTimeout := shardContext.GetConfig().LongPollExpirationInterval(namespaceRegistry.Name().String())\n+\tstCtx, stCancel := contextutil.WithDeadlineBuffer(ctx, softTimeout, time.Second)\n+\tdefer stCancel()\n+\n+\tfor {\n+\t\tselect {\n+\t\tcase notification := <-channel:\n+\t\t\tif notification == nil {\n+\t\t\t\treturn nil, serviceerror.NewInternal(\"nil component notification\")\n+\t\t\t}\n+\t\t\t// Received a notification. Re-acquire the lock and check the predicate.\n+\t\t\t_, executionLease, err := e.getExecutionLease(stCtx, requestRef)\n+\t\t\tif err != nil {\n+\t\t\t\tif ctx.Err() != nil && errors.Is(err, ctx.Err()) {\n+\t\t\t\t\treturn nil, ctx.Err()\n+\t\t\t\t}\n+\t\t\t\tif errors.Is(err, stCtx.Err()) {\n+\t\t\t\t\t// Server-imposed timeout; caller should continue long-polling.\n+\t\t\t\t\treturn nil, nil\n+\t\t\t\t}\n+\t\t\t\treturn nil, err\n+\t\t\t}","path":"service/history/chasm_engine.go","commit_id":"1d59e66d0ce5d91819f92c428ef5ab4c4efca1fb","original_commit_id":"da6009564e796063faf853352077eecdc1473612","user":{"login":"bergundy","id":52304,"node_id":"MDQ6VXNlcjUyMzA0","avatar_url":"https://avatars.githubusercontent.com/u/52304?v=4","gravatar_id":"","url":"https://api.github.com/users/bergundy","html_url":"https://github.com/bergundy","followers_url":"https://api.github.com/users/bergundy/followers","following_url":"https://api.github.com/users/bergundy/following{/other_user}","gists_url":"https://api.github.com/users/bergundy/gists{/gist_id}","starred_url":"https://api.github.com/users/bergundy/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/bergundy/subscriptions","organizations_url":"https://api.github.com/users/bergundy/orgs","repos_url":"https://api.github.com/users/bergundy/repos","events_url":"https://api.github.com/users/bergundy/events{/privacy}","received_events_url":"https://api.github.com/users/bergundy/received_events","type":"User","user_view_type":"public","site_admin":false},"body":"It's common to ignore the error returned check `ctx.Err() != nil` instead. This allows the implementor of the called function to propagate any error it wishes and doesn't bind it to returning the specific context deadline error as the contract.\n\nI also don't know what you'd gain from checking the original context's error, at that point, it's likely that the frontend will have timed out the request and whatever you return would be ignored.\n\nThe following code is much simpler to follow:\n\n```suggestion\n\t\t\tif errors.Is(err, stCtx.Err()) {\n\t\t\t\t// Server-imposed timeout; caller should continue long-polling.\n\t\t\t\treturn nil, nil\n\t\t\t}\n\t\t\treturn nil, err\n```\n\nYou can save some complexity by assigning the new context to the same `ctx` variable to remove the need to reason about which context should be referenced where.","created_at":"2025-11-19T00:03:58Z","updated_at":"2025-11-19T01:17:28Z","html_url":"https://github.com/temporalio/temporal/pull/8563#discussion_r2539998404","pull_request_url":"https://api.github.com/repos/temporalio/temporal/pulls/8563","_links":{"self":{"href":"https://api.github.com/repos/temporalio/temporal/pulls/comments/2539998404"},"html":{"href":"https://github.com/temporalio/temporal/pull/8563#discussion_r2539998404"},"pull_request":{"href":"https://api.github.com/repos/temporalio/temporal/pulls/8563"}},"reactions":{"url":"https://api.github.com/repos/temporalio/temporal/pulls/comments/2539998404/reactions","total_count":0,"+1":0,"-1":0,"laugh":0,"hooray":0,"confused":0,"heart":0,"rocket":0,"eyes":0},"start_line":318,"original_start_line":378,"start_side":"RIGHT","line":320,"original_line":387,"side":"RIGHT","author_association":"MEMBER","original_position":221,"position":132,"subject_type":"line"},{"url":"https://api.github.com/repos/temporalio/temporal/pulls/comments/2540009330","pull_request_review_id":3479944087,"id":2540009330,"node_id":"PRRC_kwDODNqesM6XZXdy","diff_hunk":"@@ -241,14 +285,182 @@ func (e *ChasmEngine) ReadComponent(\n \treturn readFn(chasmContext, component)\n }\n \n+// PollComponent waits until the supplied predicate is satisfied when evaluated against the\n+// component identified by the supplied component reference. If it times out due to the\n+// server-imposed long-poll timeout then it returns (nil, nil). Otherwise if there is no error, it\n+// returns (ref, nil) where ref is a component reference identifying the state at which the\n+// predicate was satisfied. It is an error if execution transition history is (after reloading from\n+// persistence) behind the requested ref, or if the ref is inconsistent with execution transition\n+// history. Thus when the predicate function is evaluated, it is guaranteed that the execution VT >=\n+// requestRef VT.\n func (e *ChasmEngine) PollComponent(\n \tctx context.Context,\n-\tentityRef chasm.ComponentRef,\n-\tpredicateFn func(chasm.Context, chasm.Component) (any, bool, error),\n-\toperationFn func(chasm.MutableContext, chasm.Component, any) error,\n-\topts ...chasm.TransitionOption,\n-) (newEntityRef []byte, retError error) {\n-\treturn nil, serviceerror.NewUnimplemented(\"PollComponent is not yet supported\")\n+\trequestRef chasm.ComponentRef,\n+\tpredicateFn func(chasm.Context, chasm.Component) (bool, error),\n+) ([]byte, error) {\n+\t// 1. Acquire lock\n+\t// 2. Error if shard execution VT < requestRef VT ('stale state')\n+\t// 3. If predicate satisfied, release lock and return\n+\t// 4. Subscribe to notifications for this execution\n+\t// 5. Release lock\n+\t// 6. On notification repeat (1) and (2)\n+\n+\tshardContext, executionLease, err := e.getExecutionLease(ctx, requestRef)\n+\tif err != nil {\n+\t\t// E.g. requestRef VT inconsistent with shard VT ('stale reference')\n+\t\treturn nil, err\n+\t}\n+\n+\t// hold lock until return or subscription established\n+\treleased := false\n+\tdefer func() {\n+\t\tif !released {\n+\t\t\t// read-only operation; don't pass error\n+\t\t\texecutionLease.GetReleaseFn()(nil)\n+\t\t}\n+\t}()\n+\n+\t// At this point it's possible that shard VT < requestRef VT (getExecutionLease does not\n+\t// guarantee that returned shard state is non-stale w.r.t. requestRef).\n+\tcurrentRef, err := e.checkPredicate(ctx, requestRef, executionLease, predicateFn)\n+\tif err != nil {\n+\t\treturn nil, err\n+\t}\n+\t// shard VT >= requestRef VT (enforced by checkPredicate)\n+\n+\tif currentRef != nil {\n+\t\t// wait condition was satisfied\n+\t\treturn currentRef, nil\n+\t}\n+\n+\t// Wait condition not satisfied; long-poll\n+\n+\t// TODO(dan) For now, UpdateComponent emits execution-level notifications, and PollComponent\n+\t// subscribes to execution-level notifications. This means that PollComponent may be woken up\n+\t// unnecessarily, but it will not miss notifications. In the future we may want to change\n+\t// PollComponent to subscribe to component-level notifications, and change UpdateComponent so\n+\t// that notifications are emitted only for nodes that were mutated in the transaction.\n+\tchannel, subscriberID, err := e.notifier.Subscribe(requestRef.EntityKey)\n+\tif err != nil {\n+\t\treturn nil, err\n+\t}\n+\tdefer func() {\n+\t\t_ = e.notifier.Unsubscribe(requestRef.EntityKey, subscriberID)\n+\t}()\n+\n+\t// Release the lock, now that we are subscribed\n+\texecutionLease.GetReleaseFn()(nil)\n+\treleased = true\n+\n+\tnamespaceRegistry, err := shardContext.GetNamespaceRegistry().GetNamespaceByID(\n+\t\tnamespace.ID(requestRef.EntityKey.NamespaceID),\n+\t)\n+\tif err != nil {\n+\t\treturn nil, err\n+\t}\n+\n+\t// Long-poll timeout semantics are the same as PollWorkflowExecutionUpdate: if the long-poll\n+\t// times out due to the server-imposed soft timeout, then return a non-error empty response\n+\t// indicating to a caller that they should continue long-polling. Unlike\n+\t// PollWorkflowExecutionUpdate we reserve 1s buffer.\n+\tsoftTimeout := shardContext.GetConfig().LongPollExpirationInterval(namespaceRegistry.Name().String())\n+\tstCtx, stCancel := contextutil.WithDeadlineBuffer(ctx, softTimeout, time.Second)\n+\tdefer stCancel()\n+\n+\tfor {\n+\t\tselect {\n+\t\tcase notification := <-channel:\n+\t\t\tif notification == nil {\n+\t\t\t\treturn nil, serviceerror.NewInternal(\"nil component notification\")\n+\t\t\t}\n+\t\t\t// Received a notification. Re-acquire the lock and check the predicate.\n+\t\t\t_, executionLease, err := e.getExecutionLease(stCtx, requestRef)\n+\t\t\tif err != nil {\n+\t\t\t\tif ctx.Err() != nil && errors.Is(err, ctx.Err()) {\n+\t\t\t\t\treturn nil, ctx.Err()\n+\t\t\t\t}\n+\t\t\t\tif errors.Is(err, stCtx.Err()) {\n+\t\t\t\t\t// Server-imposed timeout; caller should continue long-polling.\n+\t\t\t\t\treturn nil, nil\n+\t\t\t\t}\n+\t\t\t\treturn nil, err\n+\t\t\t}\n+\n+\t\t\tnewRef, err := e.checkPredicate(stCtx, requestRef, executionLease, predicateFn)\n+\t\t\texecutionLease.GetReleaseFn()(nil)","path":"service/history/chasm_engine.go","commit_id":"da6009564e796063faf853352077eecdc1473612","original_commit_id":"da6009564e796063faf853352077eecdc1473612","user":{"login":"bergundy","id":52304,"node_id":"MDQ6VXNlcjUyMzA0","avatar_url":"https://avatars.githubusercontent.com/u/52304?v=4","gravatar_id":"","url":"https://api.github.com/users/bergundy","html_url":"https://github.com/bergundy","followers_url":"https://api.github.com/users/bergundy/followers","following_url":"https://api.github.com/users/bergundy/following{/other_user}","gists_url":"https://api.github.com/users/bergundy/gists{/gist_id}","starred_url":"https://api.github.com/users/bergundy/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/bergundy/subscriptions","organizations_url":"https://api.github.com/users/bergundy/orgs","repos_url":"https://api.github.com/users/bergundy/repos","events_url":"https://api.github.com/users/bergundy/events{/privacy}","received_events_url":"https://api.github.com/users/bergundy/received_events","type":"User","user_view_type":"public","site_admin":false},"body":"It'd be better to put this in a defer statement just in case `checkPredicate` panics.","created_at":"2025-11-19T00:10:42Z","updated_at":"2025-11-19T01:17:28Z","html_url":"https://github.com/temporalio/temporal/pull/8563#discussion_r2540009330","pull_request_url":"https://api.github.com/repos/temporalio/temporal/pulls/8563","_links":{"self":{"href":"https://api.github.com/repos/temporalio/temporal/pulls/comments/2540009330"},"html":{"href":"https://github.com/temporalio/temporal/pull/8563#discussion_r2540009330"},"pull_request":{"href":"https://api.github.com/repos/temporalio/temporal/pulls/8563"}},"reactions":{"url":"https://api.github.com/repos/temporalio/temporal/pulls/comments/2540009330/reactions","total_count":0,"+1":0,"-1":0,"laugh":0,"hooray":0,"confused":0,"heart":0,"rocket":0,"eyes":0},"start_line":null,"original_start_line":null,"start_side":null,"line":null,"original_line":390,"side":"RIGHT","author_association":"MEMBER","original_position":224,"position":1,"subject_type":"line"},{"url":"https://api.github.com/repos/temporalio/temporal/pulls/comments/2540011133","pull_request_review_id":3479944087,"id":2540011133,"node_id":"PRRC_kwDODNqesM6XZX59","diff_hunk":"@@ -241,14 +285,182 @@ func (e *ChasmEngine) ReadComponent(\n \treturn readFn(chasmContext, component)\n }\n \n+// PollComponent waits until the supplied predicate is satisfied when evaluated against the\n+// component identified by the supplied component reference. If it times out due to the\n+// server-imposed long-poll timeout then it returns (nil, nil). Otherwise if there is no error, it\n+// returns (ref, nil) where ref is a component reference identifying the state at which the\n+// predicate was satisfied. It is an error if execution transition history is (after reloading from\n+// persistence) behind the requested ref, or if the ref is inconsistent with execution transition\n+// history. Thus when the predicate function is evaluated, it is guaranteed that the execution VT >=\n+// requestRef VT.\n func (e *ChasmEngine) PollComponent(\n \tctx context.Context,\n-\tentityRef chasm.ComponentRef,\n-\tpredicateFn func(chasm.Context, chasm.Component) (any, bool, error),\n-\toperationFn func(chasm.MutableContext, chasm.Component, any) error,\n-\topts ...chasm.TransitionOption,\n-) (newEntityRef []byte, retError error) {\n-\treturn nil, serviceerror.NewUnimplemented(\"PollComponent is not yet supported\")\n+\trequestRef chasm.ComponentRef,\n+\tpredicateFn func(chasm.Context, chasm.Component) (bool, error),\n+) ([]byte, error) {\n+\t// 1. Acquire lock\n+\t// 2. Error if shard execution VT < requestRef VT ('stale state')\n+\t// 3. If predicate satisfied, release lock and return\n+\t// 4. Subscribe to notifications for this execution\n+\t// 5. Release lock\n+\t// 6. On notification repeat (1) and (2)\n+\n+\tshardContext, executionLease, err := e.getExecutionLease(ctx, requestRef)\n+\tif err != nil {\n+\t\t// E.g. requestRef VT inconsistent with shard VT ('stale reference')\n+\t\treturn nil, err\n+\t}\n+\n+\t// hold lock until return or subscription established\n+\treleased := false\n+\tdefer func() {\n+\t\tif !released {\n+\t\t\t// read-only operation; don't pass error\n+\t\t\texecutionLease.GetReleaseFn()(nil)\n+\t\t}\n+\t}()\n+\n+\t// At this point it's possible that shard VT < requestRef VT (getExecutionLease does not\n+\t// guarantee that returned shard state is non-stale w.r.t. requestRef).\n+\tcurrentRef, err := e.checkPredicate(ctx, requestRef, executionLease, predicateFn)\n+\tif err != nil {\n+\t\treturn nil, err\n+\t}\n+\t// shard VT >= requestRef VT (enforced by checkPredicate)\n+\n+\tif currentRef != nil {\n+\t\t// wait condition was satisfied\n+\t\treturn currentRef, nil\n+\t}\n+\n+\t// Wait condition not satisfied; long-poll\n+\n+\t// TODO(dan) For now, UpdateComponent emits execution-level notifications, and PollComponent\n+\t// subscribes to execution-level notifications. This means that PollComponent may be woken up\n+\t// unnecessarily, but it will not miss notifications. In the future we may want to change\n+\t// PollComponent to subscribe to component-level notifications, and change UpdateComponent so\n+\t// that notifications are emitted only for nodes that were mutated in the transaction.\n+\tchannel, subscriberID, err := e.notifier.Subscribe(requestRef.EntityKey)\n+\tif err != nil {\n+\t\treturn nil, err\n+\t}\n+\tdefer func() {\n+\t\t_ = e.notifier.Unsubscribe(requestRef.EntityKey, subscriberID)\n+\t}()\n+\n+\t// Release the lock, now that we are subscribed\n+\texecutionLease.GetReleaseFn()(nil)\n+\treleased = true\n+\n+\tnamespaceRegistry, err := shardContext.GetNamespaceRegistry().GetNamespaceByID(\n+\t\tnamespace.ID(requestRef.EntityKey.NamespaceID),\n+\t)\n+\tif err != nil {\n+\t\treturn nil, err\n+\t}\n+\n+\t// Long-poll timeout semantics are the same as PollWorkflowExecutionUpdate: if the long-poll\n+\t// times out due to the server-imposed soft timeout, then return a non-error empty response\n+\t// indicating to a caller that they should continue long-polling. Unlike\n+\t// PollWorkflowExecutionUpdate we reserve 1s buffer.\n+\tsoftTimeout := shardContext.GetConfig().LongPollExpirationInterval(namespaceRegistry.Name().String())\n+\tstCtx, stCancel := contextutil.WithDeadlineBuffer(ctx, softTimeout, time.Second)\n+\tdefer stCancel()\n+\n+\tfor {\n+\t\tselect {\n+\t\tcase notification := <-channel:\n+\t\t\tif notification == nil {\n+\t\t\t\treturn nil, serviceerror.NewInternal(\"nil component notification\")\n+\t\t\t}\n+\t\t\t// Received a notification. Re-acquire the lock and check the predicate.\n+\t\t\t_, executionLease, err := e.getExecutionLease(stCtx, requestRef)\n+\t\t\tif err != nil {\n+\t\t\t\tif ctx.Err() != nil && errors.Is(err, ctx.Err()) {\n+\t\t\t\t\treturn nil, ctx.Err()\n+\t\t\t\t}\n+\t\t\t\tif errors.Is(err, stCtx.Err()) {\n+\t\t\t\t\t// Server-imposed timeout; caller should continue long-polling.\n+\t\t\t\t\treturn nil, nil\n+\t\t\t\t}\n+\t\t\t\treturn nil, err\n+\t\t\t}\n+\n+\t\t\tnewRef, err := e.checkPredicate(stCtx, requestRef, executionLease, predicateFn)\n+\t\t\texecutionLease.GetReleaseFn()(nil)\n+\t\t\tif err != nil {\n+\t\t\t\tif ctx.Err() != nil && errors.Is(err, ctx.Err()) {\n+\t\t\t\t\treturn nil, ctx.Err()\n+\t\t\t\t}\n+\t\t\t\tif errors.Is(err, stCtx.Err()) {\n+\t\t\t\t\t// Server-imposed timeout; caller should continue long-polling.\n+\t\t\t\t\treturn nil, nil\n+\t\t\t\t}\n+\t\t\t\treturn nil, err\n+\t\t\t}\n+\t\t\tif newRef != nil {\n+\t\t\t\t// Wait condition was satisfied.\n+\t\t\t\treturn newRef, nil\n+\t\t\t}","path":"service/history/chasm_engine.go","commit_id":"da6009564e796063faf853352077eecdc1473612","original_commit_id":"da6009564e796063faf853352077eecdc1473612","user":{"login":"bergundy","id":52304,"node_id":"MDQ6VXNlcjUyMzA0","avatar_url":"https://avatars.githubusercontent.com/u/52304?v=4","gravatar_id":"","url":"https://api.github.com/users/bergundy","html_url":"https://github.com/bergundy","followers_url":"https://api.github.com/users/bergundy/followers","following_url":"https://api.github.com/users/bergundy/following{/other_user}","gists_url":"https://api.github.com/users/bergundy/gists{/gist_id}","starred_url":"https://api.github.com/users/bergundy/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/bergundy/subscriptions","organizations_url":"https://api.github.com/users/bergundy/orgs","repos_url":"https://api.github.com/users/bergundy/repos","events_url":"https://api.github.com/users/bergundy/events{/privacy}","received_events_url":"https://api.github.com/users/bergundy/received_events","type":"User","user_view_type":"public","site_admin":false},"body":"Same here:\n\n```suggestion\n\t\t\tif stCtx.Err() != nil {\n\t\t\t\t// Server-imposed timeout; caller should continue long-polling.\n\t\t\t\treturn nil, nil\n\t\t\t}\n\t\t\treturn newRef, err\n```","created_at":"2025-11-19T00:11:58Z","updated_at":"2025-11-19T01:17:28Z","html_url":"https://github.com/temporalio/temporal/pull/8563#discussion_r2540011133","pull_request_url":"https://api.github.com/repos/temporalio/temporal/pulls/8563","_links":{"self":{"href":"https://api.github.com/repos/temporalio/temporal/pulls/comments/2540011133"},"html":{"href":"https://github.com/temporalio/temporal/pull/8563#discussion_r2540011133"},"pull_request":{"href":"https://api.github.com/repos/temporalio/temporal/pulls/8563"}},"reactions":{"url":"https://api.github.com/repos/temporalio/temporal/pulls/comments/2540011133/reactions","total_count":0,"+1":0,"-1":0,"laugh":0,"hooray":0,"confused":0,"heart":0,"rocket":0,"eyes":0},"start_line":318,"original_start_line":391,"start_side":"RIGHT","line":323,"original_line":404,"side":"RIGHT","author_association":"MEMBER","original_position":238,"position":1,"subject_type":"line"},{"url":"https://api.github.com/repos/temporalio/temporal/pulls/comments/2540011358","pull_request_review_id":3479944087,"id":2540011358,"node_id":"PRRC_kwDODNqesM6XZX9e","diff_hunk":"@@ -241,14 +285,182 @@ func (e *ChasmEngine) ReadComponent(\n \treturn readFn(chasmContext, component)\n }\n \n+// PollComponent waits until the supplied predicate is satisfied when evaluated against the\n+// component identified by the supplied component reference. If it times out due to the\n+// server-imposed long-poll timeout then it returns (nil, nil). Otherwise if there is no error, it\n+// returns (ref, nil) where ref is a component reference identifying the state at which the\n+// predicate was satisfied. It is an error if execution transition history is (after reloading from\n+// persistence) behind the requested ref, or if the ref is inconsistent with execution transition\n+// history. Thus when the predicate function is evaluated, it is guaranteed that the execution VT >=\n+// requestRef VT.\n func (e *ChasmEngine) PollComponent(\n \tctx context.Context,\n-\tentityRef chasm.ComponentRef,\n-\tpredicateFn func(chasm.Context, chasm.Component) (any, bool, error),\n-\toperationFn func(chasm.MutableContext, chasm.Component, any) error,\n-\topts ...chasm.TransitionOption,\n-) (newEntityRef []byte, retError error) {\n-\treturn nil, serviceerror.NewUnimplemented(\"PollComponent is not yet supported\")\n+\trequestRef chasm.ComponentRef,\n+\tpredicateFn func(chasm.Context, chasm.Component) (bool, error),\n+) ([]byte, error) {\n+\t// 1. Acquire lock\n+\t// 2. Error if shard execution VT < requestRef VT ('stale state')\n+\t// 3. If predicate satisfied, release lock and return\n+\t// 4. Subscribe to notifications for this execution\n+\t// 5. Release lock\n+\t// 6. On notification repeat (1) and (2)\n+\n+\tshardContext, executionLease, err := e.getExecutionLease(ctx, requestRef)\n+\tif err != nil {\n+\t\t// E.g. requestRef VT inconsistent with shard VT ('stale reference')\n+\t\treturn nil, err\n+\t}\n+\n+\t// hold lock until return or subscription established\n+\treleased := false\n+\tdefer func() {\n+\t\tif !released {\n+\t\t\t// read-only operation; don't pass error\n+\t\t\texecutionLease.GetReleaseFn()(nil)\n+\t\t}\n+\t}()\n+\n+\t// At this point it's possible that shard VT < requestRef VT (getExecutionLease does not\n+\t// guarantee that returned shard state is non-stale w.r.t. requestRef).\n+\tcurrentRef, err := e.checkPredicate(ctx, requestRef, executionLease, predicateFn)\n+\tif err != nil {\n+\t\treturn nil, err\n+\t}\n+\t// shard VT >= requestRef VT (enforced by checkPredicate)\n+\n+\tif currentRef != nil {\n+\t\t// wait condition was satisfied\n+\t\treturn currentRef, nil\n+\t}\n+\n+\t// Wait condition not satisfied; long-poll\n+\n+\t// TODO(dan) For now, UpdateComponent emits execution-level notifications, and PollComponent\n+\t// subscribes to execution-level notifications. This means that PollComponent may be woken up\n+\t// unnecessarily, but it will not miss notifications. In the future we may want to change\n+\t// PollComponent to subscribe to component-level notifications, and change UpdateComponent so\n+\t// that notifications are emitted only for nodes that were mutated in the transaction.\n+\tchannel, subscriberID, err := e.notifier.Subscribe(requestRef.EntityKey)\n+\tif err != nil {\n+\t\treturn nil, err\n+\t}\n+\tdefer func() {\n+\t\t_ = e.notifier.Unsubscribe(requestRef.EntityKey, subscriberID)\n+\t}()\n+\n+\t// Release the lock, now that we are subscribed\n+\texecutionLease.GetReleaseFn()(nil)\n+\treleased = true\n+\n+\tnamespaceRegistry, err := shardContext.GetNamespaceRegistry().GetNamespaceByID(\n+\t\tnamespace.ID(requestRef.EntityKey.NamespaceID),\n+\t)\n+\tif err != nil {\n+\t\treturn nil, err\n+\t}\n+\n+\t// Long-poll timeout semantics are the same as PollWorkflowExecutionUpdate: if the long-poll\n+\t// times out due to the server-imposed soft timeout, then return a non-error empty response\n+\t// indicating to a caller that they should continue long-polling. Unlike\n+\t// PollWorkflowExecutionUpdate we reserve 1s buffer.\n+\tsoftTimeout := shardContext.GetConfig().LongPollExpirationInterval(namespaceRegistry.Name().String())\n+\tstCtx, stCancel := contextutil.WithDeadlineBuffer(ctx, softTimeout, time.Second)\n+\tdefer stCancel()\n+\n+\tfor {\n+\t\tselect {\n+\t\tcase notification := <-channel:\n+\t\t\tif notification == nil {\n+\t\t\t\treturn nil, serviceerror.NewInternal(\"nil component notification\")\n+\t\t\t}\n+\t\t\t// Received a notification. Re-acquire the lock and check the predicate.\n+\t\t\t_, executionLease, err := e.getExecutionLease(stCtx, requestRef)\n+\t\t\tif err != nil {\n+\t\t\t\tif ctx.Err() != nil && errors.Is(err, ctx.Err()) {\n+\t\t\t\t\treturn nil, ctx.Err()\n+\t\t\t\t}\n+\t\t\t\tif errors.Is(err, stCtx.Err()) {\n+\t\t\t\t\t// Server-imposed timeout; caller should continue long-polling.\n+\t\t\t\t\treturn nil, nil\n+\t\t\t\t}\n+\t\t\t\treturn nil, err\n+\t\t\t}\n+\n+\t\t\tnewRef, err := e.checkPredicate(stCtx, requestRef, executionLease, predicateFn)\n+\t\t\texecutionLease.GetReleaseFn()(nil)\n+\t\t\tif err != nil {\n+\t\t\t\tif ctx.Err() != nil && errors.Is(err, ctx.Err()) {\n+\t\t\t\t\treturn nil, ctx.Err()\n+\t\t\t\t}\n+\t\t\t\tif errors.Is(err, stCtx.Err()) {\n+\t\t\t\t\t// Server-imposed timeout; caller should continue long-polling.\n+\t\t\t\t\treturn nil, nil\n+\t\t\t\t}\n+\t\t\t\treturn nil, err\n+\t\t\t}\n+\t\t\tif newRef != nil {\n+\t\t\t\t// Wait condition was satisfied.\n+\t\t\t\treturn newRef, nil\n+\t\t\t}\n+\t\tcase <-stCtx.Done():\n+\t\t\tif ctx.Err() != nil {\n+\t\t\t\treturn nil, ctx.Err()\n+\t\t\t}","path":"service/history/chasm_engine.go","commit_id":"da6009564e796063faf853352077eecdc1473612","original_commit_id":"da6009564e796063faf853352077eecdc1473612","user":{"login":"bergundy","id":52304,"node_id":"MDQ6VXNlcjUyMzA0","avatar_url":"https://avatars.githubusercontent.com/u/52304?v=4","gravatar_id":"","url":"https://api.github.com/users/bergundy","html_url":"https://github.com/bergundy","followers_url":"https://api.github.com/users/bergundy/followers","following_url":"https://api.github.com/users/bergundy/following{/other_user}","gists_url":"https://api.github.com/users/bergundy/gists{/gist_id}","starred_url":"https://api.github.com/users/bergundy/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/bergundy/subscriptions","organizations_url":"https://api.github.com/users/bergundy/orgs","repos_url":"https://api.github.com/users/bergundy/repos","events_url":"https://api.github.com/users/bergundy/events{/privacy}","received_events_url":"https://api.github.com/users/bergundy/received_events","type":"User","user_view_type":"public","site_admin":false},"body":"```suggestion\n```","created_at":"2025-11-19T00:12:06Z","updated_at":"2025-11-19T01:17:28Z","html_url":"https://github.com/temporalio/temporal/pull/8563#discussion_r2540011358","pull_request_url":"https://api.github.com/repos/temporalio/temporal/pulls/8563","_links":{"self":{"href":"https://api.github.com/repos/temporalio/temporal/pulls/comments/2540011358"},"html":{"href":"https://github.com/temporalio/temporal/pull/8563#discussion_r2540011358"},"pull_request":{"href":"https://api.github.com/repos/temporalio/temporal/pulls/8563"}},"reactions":{"url":"https://api.github.com/repos/temporalio/temporal/pulls/comments/2540011358/reactions","total_count":1,"+1":1,"-1":0,"laugh":0,"hooray":0,"confused":0,"heart":0,"rocket":0,"eyes":0},"start_line":null,"original_start_line":406,"start_side":"RIGHT","line":null,"original_line":408,"side":"RIGHT","author_association":"MEMBER","original_position":242,"position":1,"subject_type":"line"},{"url":"https://api.github.com/repos/temporalio/temporal/pulls/comments/2540016674","pull_request_review_id":3479944087,"id":2540016674,"node_id":"PRRC_kwDODNqesM6XZZQi","diff_hunk":"@@ -0,0 +1,178 @@\n+// This file implements ChasmNotifier, which allows subscribers to subscribe to notifications\n+// relating to components in a specified CHASM execution. It is based on the events.Notifier\n+// implementation.\n+package history\n+\n+import (\n+\t\"sync/atomic\"\n+\t\"time\"\n+\n+\t\"github.com/dgryski/go-farm\"\n+\t\"github.com/google/uuid\"\n+\t\"go.temporal.io/api/serviceerror\"\n+\t\"go.temporal.io/server/chasm\"\n+\t\"go.temporal.io/server/common\"\n+\t\"go.temporal.io/server/common/clock\"\n+\t\"go.temporal.io/server/common/collection\"\n+\t\"go.temporal.io/server/common/metrics\"\n+\t\"go.temporal.io/server/service/history/configs\"\n+)\n+\n+type (\n+\t// ChasmNotifier allows subscribers to subscribe to notifications relating to components in a\n+\t// specified CHASM execution.\n+\tChasmNotifier struct {\n+\t\ttimeSource      clock.TimeSource\n+\t\tmetricsHandler  metrics.Handler\n+\t\tstatus          int32","path":"service/history/chasm_notifier.go","commit_id":"9f8d762f3279f3b16d2217ae254bb3f85df69b44","original_commit_id":"da6009564e796063faf853352077eecdc1473612","user":{"login":"bergundy","id":52304,"node_id":"MDQ6VXNlcjUyMzA0","avatar_url":"https://avatars.githubusercontent.com/u/52304?v=4","gravatar_id":"","url":"https://api.github.com/users/bergundy","html_url":"https://github.com/bergundy","followers_url":"https://api.github.com/users/bergundy/followers","following_url":"https://api.github.com/users/bergundy/following{/other_user}","gists_url":"https://api.github.com/users/bergundy/gists{/gist_id}","starred_url":"https://api.github.com/users/bergundy/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/bergundy/subscriptions","organizations_url":"https://api.github.com/users/bergundy/orgs","repos_url":"https://api.github.com/users/bergundy/repos","events_url":"https://api.github.com/users/bergundy/events{/privacy}","received_events_url":"https://api.github.com/users/bergundy/received_events","type":"User","user_view_type":"public","site_admin":false},"body":"Use the more modern https://pkg.go.dev/sync/atomic#Int32 instead.","created_at":"2025-11-19T00:15:11Z","updated_at":"2025-11-19T01:17:28Z","html_url":"https://github.com/temporalio/temporal/pull/8563#discussion_r2540016674","pull_request_url":"https://api.github.com/repos/temporalio/temporal/pulls/8563","_links":{"self":{"href":"https://api.github.com/repos/temporalio/temporal/pulls/comments/2540016674"},"html":{"href":"https://github.com/temporalio/temporal/pull/8563#discussion_r2540016674"},"pull_request":{"href":"https://api.github.com/repos/temporalio/temporal/pulls/8563"}},"reactions":{"url":"https://api.github.com/repos/temporalio/temporal/pulls/comments/2540016674/reactions","total_count":0,"+1":0,"-1":0,"laugh":0,"hooray":0,"confused":0,"heart":0,"rocket":0,"eyes":0},"start_line":null,"original_start_line":null,"start_side":null,"line":null,"original_line":27,"side":"RIGHT","author_association":"MEMBER","original_position":27,"position":1,"subject_type":"line"},{"url":"https://api.github.com/repos/temporalio/temporal/pulls/comments/2540019207","pull_request_review_id":3479944087,"id":2540019207,"node_id":"PRRC_kwDODNqesM6XZZ4H","diff_hunk":"@@ -0,0 +1,178 @@\n+// This file implements ChasmNotifier, which allows subscribers to subscribe to notifications\n+// relating to components in a specified CHASM execution. It is based on the events.Notifier\n+// implementation.\n+package history\n+\n+import (\n+\t\"sync/atomic\"\n+\t\"time\"\n+\n+\t\"github.com/dgryski/go-farm\"\n+\t\"github.com/google/uuid\"\n+\t\"go.temporal.io/api/serviceerror\"\n+\t\"go.temporal.io/server/chasm\"\n+\t\"go.temporal.io/server/common\"\n+\t\"go.temporal.io/server/common/clock\"\n+\t\"go.temporal.io/server/common/collection\"\n+\t\"go.temporal.io/server/common/metrics\"\n+\t\"go.temporal.io/server/service/history/configs\"\n+)\n+\n+type (\n+\t// ChasmNotifier allows subscribers to subscribe to notifications relating to components in a\n+\t// specified CHASM execution.\n+\tChasmNotifier struct {\n+\t\ttimeSource      clock.TimeSource\n+\t\tmetricsHandler  metrics.Handler\n+\t\tstatus          int32\n+\t\tnotificationsCh chan *ChasmComponentNotification\n+\t\tstopCh          chan bool\n+\t\tsubscribers     collection.ConcurrentTxMap\n+\t}\n+\n+\t// ChasmComponentNotification is a notification relating to a CHASM component.\n+\tChasmComponentNotification struct {\n+\t\t// TODO(dan): confirm that we want Key in addition to the key in serialized ref\n+\t\tKey       chasm.EntityKey\n+\t\tRef       []byte\n+\t\ttimestamp time.Time\n+\t}\n+)\n+\n+// NewChasmNotifier creates a new instance of ChasmNotifier allowing subscribers to subscribe to\n+// notifications relating to components in a specified CHASM execution.\n+func NewChasmNotifier(\n+\ttimeSource clock.TimeSource,\n+\tmetricsHandler metrics.Handler,\n+\tconfig *configs.Config,\n+) *ChasmNotifier {\n+\treturn &ChasmNotifier{\n+\t\ttimeSource:      timeSource,\n+\t\tmetricsHandler:  metricsHandler.WithTags(metrics.OperationTag(metrics.ChasmComponentNotificationScope)),\n+\t\tstatus:          common.DaemonStatusInitialized,\n+\t\tstopCh:          make(chan bool),","path":"service/history/chasm_notifier.go","commit_id":"9f8d762f3279f3b16d2217ae254bb3f85df69b44","original_commit_id":"da6009564e796063faf853352077eecdc1473612","user":{"login":"bergundy","id":52304,"node_id":"MDQ6VXNlcjUyMzA0","avatar_url":"https://avatars.githubusercontent.com/u/52304?v=4","gravatar_id":"","url":"https://api.github.com/users/bergundy","html_url":"https://github.com/bergundy","followers_url":"https://api.github.com/users/bergundy/followers","following_url":"https://api.github.com/users/bergundy/following{/other_user}","gists_url":"https://api.github.com/users/bergundy/gists{/gist_id}","starred_url":"https://api.github.com/users/bergundy/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/bergundy/subscriptions","organizations_url":"https://api.github.com/users/bergundy/orgs","repos_url":"https://api.github.com/users/bergundy/repos","events_url":"https://api.github.com/users/bergundy/events{/privacy}","received_events_url":"https://api.github.com/users/bergundy/received_events","type":"User","user_view_type":"public","site_admin":false},"body":"```suggestion\n\t\tstopCh:          make(chan struct{}),\n```","created_at":"2025-11-19T00:16:43Z","updated_at":"2025-11-19T01:17:28Z","html_url":"https://github.com/temporalio/temporal/pull/8563#discussion_r2540019207","pull_request_url":"https://api.github.com/repos/temporalio/temporal/pulls/8563","_links":{"self":{"href":"https://api.github.com/repos/temporalio/temporal/pulls/comments/2540019207"},"html":{"href":"https://github.com/temporalio/temporal/pull/8563#discussion_r2540019207"},"pull_request":{"href":"https://api.github.com/repos/temporalio/temporal/pulls/8563"}},"reactions":{"url":"https://api.github.com/repos/temporalio/temporal/pulls/comments/2540019207/reactions","total_count":0,"+1":0,"-1":0,"laugh":0,"hooray":0,"confused":0,"heart":0,"rocket":0,"eyes":0},"start_line":null,"original_start_line":null,"start_side":null,"line":null,"original_line":53,"side":"RIGHT","author_association":"MEMBER","original_position":53,"position":1,"subject_type":"line"},{"url":"https://api.github.com/repos/temporalio/temporal/pulls/comments/2540019430","pull_request_review_id":3479944087,"id":2540019430,"node_id":"PRRC_kwDODNqesM6XZZ7m","diff_hunk":"@@ -0,0 +1,178 @@\n+// This file implements ChasmNotifier, which allows subscribers to subscribe to notifications\n+// relating to components in a specified CHASM execution. It is based on the events.Notifier\n+// implementation.\n+package history\n+\n+import (\n+\t\"sync/atomic\"\n+\t\"time\"\n+\n+\t\"github.com/dgryski/go-farm\"\n+\t\"github.com/google/uuid\"\n+\t\"go.temporal.io/api/serviceerror\"\n+\t\"go.temporal.io/server/chasm\"\n+\t\"go.temporal.io/server/common\"\n+\t\"go.temporal.io/server/common/clock\"\n+\t\"go.temporal.io/server/common/collection\"\n+\t\"go.temporal.io/server/common/metrics\"\n+\t\"go.temporal.io/server/service/history/configs\"\n+)\n+\n+type (\n+\t// ChasmNotifier allows subscribers to subscribe to notifications relating to components in a\n+\t// specified CHASM execution.\n+\tChasmNotifier struct {\n+\t\ttimeSource      clock.TimeSource\n+\t\tmetricsHandler  metrics.Handler\n+\t\tstatus          int32\n+\t\tnotificationsCh chan *ChasmComponentNotification\n+\t\tstopCh          chan bool\n+\t\tsubscribers     collection.ConcurrentTxMap\n+\t}\n+\n+\t// ChasmComponentNotification is a notification relating to a CHASM component.\n+\tChasmComponentNotification struct {\n+\t\t// TODO(dan): confirm that we want Key in addition to the key in serialized ref\n+\t\tKey       chasm.EntityKey\n+\t\tRef       []byte\n+\t\ttimestamp time.Time\n+\t}\n+)\n+\n+// NewChasmNotifier creates a new instance of ChasmNotifier allowing subscribers to subscribe to\n+// notifications relating to components in a specified CHASM execution.\n+func NewChasmNotifier(\n+\ttimeSource clock.TimeSource,\n+\tmetricsHandler metrics.Handler,\n+\tconfig *configs.Config,\n+) *ChasmNotifier {\n+\treturn &ChasmNotifier{\n+\t\ttimeSource:      timeSource,\n+\t\tmetricsHandler:  metricsHandler.WithTags(metrics.OperationTag(metrics.ChasmComponentNotificationScope)),\n+\t\tstatus:          common.DaemonStatusInitialized,\n+\t\tstopCh:          make(chan bool),\n+\t\tnotificationsCh: make(chan *ChasmComponentNotification, 1000),","path":"service/history/chasm_notifier.go","commit_id":"da6009564e796063faf853352077eecdc1473612","original_commit_id":"da6009564e796063faf853352077eecdc1473612","user":{"login":"bergundy","id":52304,"node_id":"MDQ6VXNlcjUyMzA0","avatar_url":"https://avatars.githubusercontent.com/u/52304?v=4","gravatar_id":"","url":"https://api.github.com/users/bergundy","html_url":"https://github.com/bergundy","followers_url":"https://api.github.com/users/bergundy/followers","following_url":"https://api.github.com/users/bergundy/following{/other_user}","gists_url":"https://api.github.com/users/bergundy/gists{/gist_id}","starred_url":"https://api.github.com/users/bergundy/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/bergundy/subscriptions","organizations_url":"https://api.github.com/users/bergundy/orgs","repos_url":"https://api.github.com/users/bergundy/repos","events_url":"https://api.github.com/users/bergundy/events{/privacy}","received_events_url":"https://api.github.com/users/bergundy/received_events","type":"User","user_view_type":"public","site_admin":false},"body":"Why 1000?","created_at":"2025-11-19T00:16:51Z","updated_at":"2025-11-19T01:17:28Z","html_url":"https://github.com/temporalio/temporal/pull/8563#discussion_r2540019430","pull_request_url":"https://api.github.com/repos/temporalio/temporal/pulls/8563","_links":{"self":{"href":"https://api.github.com/repos/temporalio/temporal/pulls/comments/2540019430"},"html":{"href":"https://github.com/temporalio/temporal/pull/8563#discussion_r2540019430"},"pull_request":{"href":"https://api.github.com/repos/temporalio/temporal/pulls/8563"}},"reactions":{"url":"https://api.github.com/repos/temporalio/temporal/pulls/comments/2540019430/reactions","total_count":0,"+1":0,"-1":0,"laugh":0,"hooray":0,"confused":0,"heart":0,"rocket":0,"eyes":0},"start_line":null,"original_start_line":null,"start_side":null,"line":null,"original_line":54,"side":"RIGHT","author_association":"MEMBER","original_position":54,"position":1,"subject_type":"line"},{"url":"https://api.github.com/repos/temporalio/temporal/pulls/comments/2540025103","pull_request_review_id":3479944087,"id":2540025103,"node_id":"PRRC_kwDODNqesM6XZbUP","diff_hunk":"@@ -0,0 +1,178 @@\n+// This file implements ChasmNotifier, which allows subscribers to subscribe to notifications\n+// relating to components in a specified CHASM execution. It is based on the events.Notifier\n+// implementation.\n+package history\n+\n+import (\n+\t\"sync/atomic\"\n+\t\"time\"\n+\n+\t\"github.com/dgryski/go-farm\"\n+\t\"github.com/google/uuid\"\n+\t\"go.temporal.io/api/serviceerror\"\n+\t\"go.temporal.io/server/chasm\"\n+\t\"go.temporal.io/server/common\"\n+\t\"go.temporal.io/server/common/clock\"\n+\t\"go.temporal.io/server/common/collection\"\n+\t\"go.temporal.io/server/common/metrics\"\n+\t\"go.temporal.io/server/service/history/configs\"\n+)\n+\n+type (\n+\t// ChasmNotifier allows subscribers to subscribe to notifications relating to components in a\n+\t// specified CHASM execution.\n+\tChasmNotifier struct {\n+\t\ttimeSource      clock.TimeSource\n+\t\tmetricsHandler  metrics.Handler\n+\t\tstatus          int32\n+\t\tnotificationsCh chan *ChasmComponentNotification\n+\t\tstopCh          chan bool\n+\t\tsubscribers     collection.ConcurrentTxMap\n+\t}\n+\n+\t// ChasmComponentNotification is a notification relating to a CHASM component.\n+\tChasmComponentNotification struct {\n+\t\t// TODO(dan): confirm that we want Key in addition to the key in serialized ref\n+\t\tKey       chasm.EntityKey\n+\t\tRef       []byte\n+\t\ttimestamp time.Time\n+\t}\n+)\n+\n+// NewChasmNotifier creates a new instance of ChasmNotifier allowing subscribers to subscribe to\n+// notifications relating to components in a specified CHASM execution.\n+func NewChasmNotifier(\n+\ttimeSource clock.TimeSource,\n+\tmetricsHandler metrics.Handler,\n+\tconfig *configs.Config,\n+) *ChasmNotifier {\n+\treturn &ChasmNotifier{\n+\t\ttimeSource:      timeSource,\n+\t\tmetricsHandler:  metricsHandler.WithTags(metrics.OperationTag(metrics.ChasmComponentNotificationScope)),\n+\t\tstatus:          common.DaemonStatusInitialized,\n+\t\tstopCh:          make(chan bool),\n+\t\tnotificationsCh: make(chan *ChasmComponentNotification, 1000),\n+\t\tsubscribers: collection.NewShardedConcurrentTxMap(1024, func(key any) uint32 {\n+\t\t\texecutionKey, ok := key.(chasm.EntityKey)\n+\t\t\tif !ok {\n+\t\t\t\treturn 0\n+\t\t\t}\n+\t\t\treturn farm.Fingerprint32([]byte(executionKey.NamespaceID + \"_\" + executionKey.BusinessID))","path":"service/history/chasm_notifier.go","commit_id":"9f8d762f3279f3b16d2217ae254bb3f85df69b44","original_commit_id":"da6009564e796063faf853352077eecdc1473612","user":{"login":"bergundy","id":52304,"node_id":"MDQ6VXNlcjUyMzA0","avatar_url":"https://avatars.githubusercontent.com/u/52304?v=4","gravatar_id":"","url":"https://api.github.com/users/bergundy","html_url":"https://github.com/bergundy","followers_url":"https://api.github.com/users/bergundy/followers","following_url":"https://api.github.com/users/bergundy/following{/other_user}","gists_url":"https://api.github.com/users/bergundy/gists{/gist_id}","starred_url":"https://api.github.com/users/bergundy/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/bergundy/subscriptions","organizations_url":"https://api.github.com/users/bergundy/orgs","repos_url":"https://api.github.com/users/bergundy/repos","events_url":"https://api.github.com/users/bergundy/events{/privacy}","received_events_url":"https://api.github.com/users/bergundy/received_events","type":"User","user_view_type":"public","site_admin":false},"body":"You should be able to use the standard Go library implementation's hash function. There's no need to have a deterministic hash function here.\nhttps://pkg.go.dev/hash/maphash@go1.25.4.","created_at":"2025-11-19T00:19:16Z","updated_at":"2025-11-19T01:17:28Z","html_url":"https://github.com/temporalio/temporal/pull/8563#discussion_r2540025103","pull_request_url":"https://api.github.com/repos/temporalio/temporal/pulls/8563","_links":{"self":{"href":"https://api.github.com/repos/temporalio/temporal/pulls/comments/2540025103"},"html":{"href":"https://github.com/temporalio/temporal/pull/8563#discussion_r2540025103"},"pull_request":{"href":"https://api.github.com/repos/temporalio/temporal/pulls/8563"}},"reactions":{"url":"https://api.github.com/repos/temporalio/temporal/pulls/comments/2540025103/reactions","total_count":0,"+1":0,"-1":0,"laugh":0,"hooray":0,"confused":0,"heart":0,"rocket":0,"eyes":0},"start_line":null,"original_start_line":null,"start_side":null,"line":null,"original_line":60,"side":"RIGHT","author_association":"MEMBER","original_position":60,"position":1,"subject_type":"line"},{"url":"https://api.github.com/repos/temporalio/temporal/pulls/comments/2540027863","pull_request_review_id":3479944087,"id":2540027863,"node_id":"PRRC_kwDODNqesM6XZb_X","diff_hunk":"@@ -0,0 +1,178 @@\n+// This file implements ChasmNotifier, which allows subscribers to subscribe to notifications\n+// relating to components in a specified CHASM execution. It is based on the events.Notifier\n+// implementation.\n+package history\n+\n+import (\n+\t\"sync/atomic\"\n+\t\"time\"\n+\n+\t\"github.com/dgryski/go-farm\"\n+\t\"github.com/google/uuid\"\n+\t\"go.temporal.io/api/serviceerror\"\n+\t\"go.temporal.io/server/chasm\"\n+\t\"go.temporal.io/server/common\"\n+\t\"go.temporal.io/server/common/clock\"\n+\t\"go.temporal.io/server/common/collection\"\n+\t\"go.temporal.io/server/common/metrics\"\n+\t\"go.temporal.io/server/service/history/configs\"\n+)\n+\n+type (\n+\t// ChasmNotifier allows subscribers to subscribe to notifications relating to components in a\n+\t// specified CHASM execution.\n+\tChasmNotifier struct {\n+\t\ttimeSource      clock.TimeSource\n+\t\tmetricsHandler  metrics.Handler\n+\t\tstatus          int32\n+\t\tnotificationsCh chan *ChasmComponentNotification\n+\t\tstopCh          chan bool\n+\t\tsubscribers     collection.ConcurrentTxMap\n+\t}\n+\n+\t// ChasmComponentNotification is a notification relating to a CHASM component.\n+\tChasmComponentNotification struct {\n+\t\t// TODO(dan): confirm that we want Key in addition to the key in serialized ref\n+\t\tKey       chasm.EntityKey\n+\t\tRef       []byte\n+\t\ttimestamp time.Time\n+\t}\n+)\n+\n+// NewChasmNotifier creates a new instance of ChasmNotifier allowing subscribers to subscribe to\n+// notifications relating to components in a specified CHASM execution.\n+func NewChasmNotifier(\n+\ttimeSource clock.TimeSource,\n+\tmetricsHandler metrics.Handler,\n+\tconfig *configs.Config,\n+) *ChasmNotifier {\n+\treturn &ChasmNotifier{\n+\t\ttimeSource:      timeSource,\n+\t\tmetricsHandler:  metricsHandler.WithTags(metrics.OperationTag(metrics.ChasmComponentNotificationScope)),\n+\t\tstatus:          common.DaemonStatusInitialized,\n+\t\tstopCh:          make(chan bool),\n+\t\tnotificationsCh: make(chan *ChasmComponentNotification, 1000),\n+\t\tsubscribers: collection.NewShardedConcurrentTxMap(1024, func(key any) uint32 {\n+\t\t\texecutionKey, ok := key.(chasm.EntityKey)\n+\t\t\tif !ok {\n+\t\t\t\treturn 0\n+\t\t\t}\n+\t\t\treturn farm.Fingerprint32([]byte(executionKey.NamespaceID + \"_\" + executionKey.BusinessID))\n+\t\t}),\n+\t}\n+}\n+\n+// Start starts the ChasmNotifier.\n+func (n *ChasmNotifier) Start() {\n+\tif !atomic.CompareAndSwapInt32(&n.status, common.DaemonStatusInitialized, common.DaemonStatusStarted) {\n+\t\treturn\n+\t}\n+\tgo n.dequeueLoop()\n+}\n+\n+// Stop stops the ChasmNotifier.\n+func (n *ChasmNotifier) Stop() {\n+\tif !atomic.CompareAndSwapInt32(&n.status, common.DaemonStatusStarted, common.DaemonStatusStopped) {\n+\t\treturn\n+\t}\n+\tclose(n.stopCh)\n+}\n+\n+// Notify sends a notification about a CHASM component.\n+func (n *ChasmNotifier) Notify(notification *ChasmComponentNotification) {\n+\tn.enqueue(notification)\n+}\n+\n+// Subscribe returns a channel that will receive notifications relating to the execution, along with\n+// a subscriber ID that can be passed to UnsubscribeNotification.\n+//\n+// TODO(dan): support subscribing to notifications for a specific component only?\n+func (n *ChasmNotifier) Subscribe(key chasm.EntityKey) (chan *ChasmComponentNotification, string, error) {\n+\tchannel := make(chan *ChasmComponentNotification, 1)\n+\tsubscriberID := uuid.NewString()","path":"service/history/chasm_notifier.go","commit_id":"9f8d762f3279f3b16d2217ae254bb3f85df69b44","original_commit_id":"da6009564e796063faf853352077eecdc1473612","user":{"login":"bergundy","id":52304,"node_id":"MDQ6VXNlcjUyMzA0","avatar_url":"https://avatars.githubusercontent.com/u/52304?v=4","gravatar_id":"","url":"https://api.github.com/users/bergundy","html_url":"https://github.com/bergundy","followers_url":"https://api.github.com/users/bergundy/followers","following_url":"https://api.github.com/users/bergundy/following{/other_user}","gists_url":"https://api.github.com/users/bergundy/gists{/gist_id}","starred_url":"https://api.github.com/users/bergundy/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/bergundy/subscriptions","organizations_url":"https://api.github.com/users/bergundy/orgs","repos_url":"https://api.github.com/users/bergundy/repos","events_url":"https://api.github.com/users/bergundy/events{/privacy}","received_events_url":"https://api.github.com/users/bergundy/received_events","type":"User","user_view_type":"public","site_admin":false},"body":"nit: We can use an atomic int64 counter here and be slightly more efficient.","created_at":"2025-11-19T00:21:10Z","updated_at":"2025-11-19T01:17:28Z","html_url":"https://github.com/temporalio/temporal/pull/8563#discussion_r2540027863","pull_request_url":"https://api.github.com/repos/temporalio/temporal/pulls/8563","_links":{"self":{"href":"https://api.github.com/repos/temporalio/temporal/pulls/comments/2540027863"},"html":{"href":"https://github.com/temporalio/temporal/pull/8563#discussion_r2540027863"},"pull_request":{"href":"https://api.github.com/repos/temporalio/temporal/pulls/8563"}},"reactions":{"url":"https://api.github.com/repos/temporalio/temporal/pulls/comments/2540027863/reactions","total_count":0,"+1":0,"-1":0,"laugh":0,"hooray":0,"confused":0,"heart":0,"rocket":0,"eyes":0},"start_line":null,"original_start_line":null,"start_side":null,"line":null,"original_line":92,"side":"RIGHT","author_association":"MEMBER","original_position":92,"position":1,"subject_type":"line"},{"url":"https://api.github.com/repos/temporalio/temporal/pulls/comments/2540038631","pull_request_review_id":3479944087,"id":2540038631,"node_id":"PRRC_kwDODNqesM6XZenn","diff_hunk":"@@ -0,0 +1,178 @@\n+// This file implements ChasmNotifier, which allows subscribers to subscribe to notifications\n+// relating to components in a specified CHASM execution. It is based on the events.Notifier\n+// implementation.\n+package history\n+\n+import (\n+\t\"sync/atomic\"\n+\t\"time\"\n+\n+\t\"github.com/dgryski/go-farm\"\n+\t\"github.com/google/uuid\"\n+\t\"go.temporal.io/api/serviceerror\"\n+\t\"go.temporal.io/server/chasm\"\n+\t\"go.temporal.io/server/common\"\n+\t\"go.temporal.io/server/common/clock\"\n+\t\"go.temporal.io/server/common/collection\"\n+\t\"go.temporal.io/server/common/metrics\"\n+\t\"go.temporal.io/server/service/history/configs\"\n+)\n+\n+type (\n+\t// ChasmNotifier allows subscribers to subscribe to notifications relating to components in a\n+\t// specified CHASM execution.\n+\tChasmNotifier struct {\n+\t\ttimeSource      clock.TimeSource\n+\t\tmetricsHandler  metrics.Handler\n+\t\tstatus          int32\n+\t\tnotificationsCh chan *ChasmComponentNotification\n+\t\tstopCh          chan bool\n+\t\tsubscribers     collection.ConcurrentTxMap\n+\t}\n+\n+\t// ChasmComponentNotification is a notification relating to a CHASM component.\n+\tChasmComponentNotification struct {\n+\t\t// TODO(dan): confirm that we want Key in addition to the key in serialized ref\n+\t\tKey       chasm.EntityKey\n+\t\tRef       []byte\n+\t\ttimestamp time.Time\n+\t}\n+)\n+\n+// NewChasmNotifier creates a new instance of ChasmNotifier allowing subscribers to subscribe to\n+// notifications relating to components in a specified CHASM execution.\n+func NewChasmNotifier(\n+\ttimeSource clock.TimeSource,\n+\tmetricsHandler metrics.Handler,\n+\tconfig *configs.Config,\n+) *ChasmNotifier {\n+\treturn &ChasmNotifier{\n+\t\ttimeSource:      timeSource,\n+\t\tmetricsHandler:  metricsHandler.WithTags(metrics.OperationTag(metrics.ChasmComponentNotificationScope)),\n+\t\tstatus:          common.DaemonStatusInitialized,\n+\t\tstopCh:          make(chan bool),\n+\t\tnotificationsCh: make(chan *ChasmComponentNotification, 1000),\n+\t\tsubscribers: collection.NewShardedConcurrentTxMap(1024, func(key any) uint32 {\n+\t\t\texecutionKey, ok := key.(chasm.EntityKey)\n+\t\t\tif !ok {\n+\t\t\t\treturn 0\n+\t\t\t}\n+\t\t\treturn farm.Fingerprint32([]byte(executionKey.NamespaceID + \"_\" + executionKey.BusinessID))\n+\t\t}),\n+\t}\n+}\n+\n+// Start starts the ChasmNotifier.\n+func (n *ChasmNotifier) Start() {\n+\tif !atomic.CompareAndSwapInt32(&n.status, common.DaemonStatusInitialized, common.DaemonStatusStarted) {\n+\t\treturn\n+\t}\n+\tgo n.dequeueLoop()\n+}\n+\n+// Stop stops the ChasmNotifier.\n+func (n *ChasmNotifier) Stop() {\n+\tif !atomic.CompareAndSwapInt32(&n.status, common.DaemonStatusStarted, common.DaemonStatusStopped) {\n+\t\treturn\n+\t}\n+\tclose(n.stopCh)\n+}\n+\n+// Notify sends a notification about a CHASM component.\n+func (n *ChasmNotifier) Notify(notification *ChasmComponentNotification) {\n+\tn.enqueue(notification)\n+}\n+\n+// Subscribe returns a channel that will receive notifications relating to the execution, along with\n+// a subscriber ID that can be passed to UnsubscribeNotification.\n+//\n+// TODO(dan): support subscribing to notifications for a specific component only?\n+func (n *ChasmNotifier) Subscribe(key chasm.EntityKey) (chan *ChasmComponentNotification, string, error) {\n+\tchannel := make(chan *ChasmComponentNotification, 1)\n+\tsubscriberID := uuid.NewString()\n+\n+\t// TODO(dan): This allocates a value that will not be used if key already has subscribers (code\n+\t// copied from events.Notifier)\n+\tsubscribers := map[string]chan *ChasmComponentNotification{\n+\t\tsubscriberID: channel,\n+\t}\n+\n+\t// If key exists then add new subscriber to that second-level map. Otherwise, add a new\n+\t// second-level map containing the new subscriber.\n+\t_, _, err := n.subscribers.PutOrDo(key, subscribers, func(key any, value any) error {\n+\t\tsubscribers := value.(map[string]chan *ChasmComponentNotification)\n+\t\tif _, ok := subscribers[subscriberID]; ok {\n+\t\t\t// uuid collision\n+\t\t\treturn serviceerror.NewUnavailable(\"Unable to watch component.\")\n+\t\t}\n+\t\tsubscribers[subscriberID] = channel\n+\t\treturn nil\n+\t})\n+\tif err != nil {\n+\t\treturn nil, \"\", err\n+\t}\n+\treturn channel, subscriberID, nil\n+}\n+\n+// Unsubscribe unsubscribes the subscriber from notifications relating to the execution.\n+func (n *ChasmNotifier) Unsubscribe(key chasm.EntityKey, subscriberID string) error {\n+\tsuccess := true\n+\tn.subscribers.RemoveIf(key, func(key any, value any) bool {\n+\t\tsubscribers := value.(map[string]chan *ChasmComponentNotification)\n+\t\tif _, ok := subscribers[subscriberID]; !ok {\n+\t\t\tsuccess = false\n+\t\t} else {\n+\t\t\tdelete(subscribers, subscriberID)\n+\t\t}\n+\t\treturn len(subscribers) == 0\n+\t})\n+\tif !success {\n+\t\t// This indicates a bug\n+\t\treturn serviceerror.NewInternal(\"Unable to unwatch component.\")\n+\t}\n+\treturn nil\n+}\n+\n+func (n *ChasmNotifier) enqueue(notification *ChasmComponentNotification) {","path":"service/history/chasm_notifier.go","commit_id":"da6009564e796063faf853352077eecdc1473612","original_commit_id":"da6009564e796063faf853352077eecdc1473612","user":{"login":"bergundy","id":52304,"node_id":"MDQ6VXNlcjUyMzA0","avatar_url":"https://avatars.githubusercontent.com/u/52304?v=4","gravatar_id":"","url":"https://api.github.com/users/bergundy","html_url":"https://github.com/bergundy","followers_url":"https://api.github.com/users/bergundy/followers","following_url":"https://api.github.com/users/bergundy/following{/other_user}","gists_url":"https://api.github.com/users/bergundy/gists{/gist_id}","starred_url":"https://api.github.com/users/bergundy/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/bergundy/subscriptions","organizations_url":"https://api.github.com/users/bergundy/orgs","repos_url":"https://api.github.com/users/bergundy/repos","events_url":"https://api.github.com/users/bergundy/events{/privacy}","received_events_url":"https://api.github.com/users/bergundy/received_events","type":"User","user_view_type":"public","site_admin":false},"body":"This implementation is problematic and would cause requests to time out unnecessarily if the buffer is full. At minimum, you will want to block on the channel.\nI would consider a sync send approach and limiting the number of waiters per key. You can return a resource exhausted error if the limit is exceeded. The limit could be configurable.","created_at":"2025-11-19T00:28:32Z","updated_at":"2025-11-19T01:17:28Z","html_url":"https://github.com/temporalio/temporal/pull/8563#discussion_r2540038631","pull_request_url":"https://api.github.com/repos/temporalio/temporal/pulls/8563","_links":{"self":{"href":"https://api.github.com/repos/temporalio/temporal/pulls/comments/2540038631"},"html":{"href":"https://github.com/temporalio/temporal/pull/8563#discussion_r2540038631"},"pull_request":{"href":"https://api.github.com/repos/temporalio/temporal/pulls/8563"}},"reactions":{"url":"https://api.github.com/repos/temporalio/temporal/pulls/comments/2540038631/reactions","total_count":0,"+1":0,"-1":0,"laugh":0,"hooray":0,"confused":0,"heart":0,"rocket":0,"eyes":0},"start_line":null,"original_start_line":null,"start_side":null,"line":null,"original_line":136,"side":"RIGHT","author_association":"MEMBER","original_position":136,"position":1,"subject_type":"line"},{"url":"https://api.github.com/repos/temporalio/temporal/pulls/comments/2540042787","pull_request_review_id":3479944087,"id":2540042787,"node_id":"PRRC_kwDODNqesM6XZfoj","diff_hunk":"@@ -0,0 +1,178 @@\n+// This file implements ChasmNotifier, which allows subscribers to subscribe to notifications\n+// relating to components in a specified CHASM execution. It is based on the events.Notifier\n+// implementation.\n+package history\n+\n+import (\n+\t\"sync/atomic\"\n+\t\"time\"\n+\n+\t\"github.com/dgryski/go-farm\"\n+\t\"github.com/google/uuid\"\n+\t\"go.temporal.io/api/serviceerror\"\n+\t\"go.temporal.io/server/chasm\"\n+\t\"go.temporal.io/server/common\"\n+\t\"go.temporal.io/server/common/clock\"\n+\t\"go.temporal.io/server/common/collection\"\n+\t\"go.temporal.io/server/common/metrics\"\n+\t\"go.temporal.io/server/service/history/configs\"\n+)\n+\n+type (\n+\t// ChasmNotifier allows subscribers to subscribe to notifications relating to components in a\n+\t// specified CHASM execution.\n+\tChasmNotifier struct {\n+\t\ttimeSource      clock.TimeSource\n+\t\tmetricsHandler  metrics.Handler\n+\t\tstatus          int32\n+\t\tnotificationsCh chan *ChasmComponentNotification\n+\t\tstopCh          chan bool\n+\t\tsubscribers     collection.ConcurrentTxMap\n+\t}\n+\n+\t// ChasmComponentNotification is a notification relating to a CHASM component.\n+\tChasmComponentNotification struct {\n+\t\t// TODO(dan): confirm that we want Key in addition to the key in serialized ref\n+\t\tKey       chasm.EntityKey\n+\t\tRef       []byte\n+\t\ttimestamp time.Time\n+\t}\n+)\n+\n+// NewChasmNotifier creates a new instance of ChasmNotifier allowing subscribers to subscribe to\n+// notifications relating to components in a specified CHASM execution.\n+func NewChasmNotifier(\n+\ttimeSource clock.TimeSource,\n+\tmetricsHandler metrics.Handler,\n+\tconfig *configs.Config,\n+) *ChasmNotifier {\n+\treturn &ChasmNotifier{\n+\t\ttimeSource:      timeSource,\n+\t\tmetricsHandler:  metricsHandler.WithTags(metrics.OperationTag(metrics.ChasmComponentNotificationScope)),\n+\t\tstatus:          common.DaemonStatusInitialized,\n+\t\tstopCh:          make(chan bool),\n+\t\tnotificationsCh: make(chan *ChasmComponentNotification, 1000),\n+\t\tsubscribers: collection.NewShardedConcurrentTxMap(1024, func(key any) uint32 {\n+\t\t\texecutionKey, ok := key.(chasm.EntityKey)\n+\t\t\tif !ok {\n+\t\t\t\treturn 0\n+\t\t\t}\n+\t\t\treturn farm.Fingerprint32([]byte(executionKey.NamespaceID + \"_\" + executionKey.BusinessID))\n+\t\t}),\n+\t}\n+}\n+\n+// Start starts the ChasmNotifier.\n+func (n *ChasmNotifier) Start() {\n+\tif !atomic.CompareAndSwapInt32(&n.status, common.DaemonStatusInitialized, common.DaemonStatusStarted) {\n+\t\treturn\n+\t}\n+\tgo n.dequeueLoop()\n+}\n+\n+// Stop stops the ChasmNotifier.\n+func (n *ChasmNotifier) Stop() {\n+\tif !atomic.CompareAndSwapInt32(&n.status, common.DaemonStatusStarted, common.DaemonStatusStopped) {\n+\t\treturn\n+\t}\n+\tclose(n.stopCh)\n+}\n+\n+// Notify sends a notification about a CHASM component.\n+func (n *ChasmNotifier) Notify(notification *ChasmComponentNotification) {\n+\tn.enqueue(notification)\n+}\n+\n+// Subscribe returns a channel that will receive notifications relating to the execution, along with\n+// a subscriber ID that can be passed to UnsubscribeNotification.\n+//\n+// TODO(dan): support subscribing to notifications for a specific component only?\n+func (n *ChasmNotifier) Subscribe(key chasm.EntityKey) (chan *ChasmComponentNotification, string, error) {\n+\tchannel := make(chan *ChasmComponentNotification, 1)\n+\tsubscriberID := uuid.NewString()\n+\n+\t// TODO(dan): This allocates a value that will not be used if key already has subscribers (code\n+\t// copied from events.Notifier)\n+\tsubscribers := map[string]chan *ChasmComponentNotification{\n+\t\tsubscriberID: channel,\n+\t}\n+\n+\t// If key exists then add new subscriber to that second-level map. Otherwise, add a new\n+\t// second-level map containing the new subscriber.\n+\t_, _, err := n.subscribers.PutOrDo(key, subscribers, func(key any, value any) error {\n+\t\tsubscribers := value.(map[string]chan *ChasmComponentNotification)\n+\t\tif _, ok := subscribers[subscriberID]; ok {\n+\t\t\t// uuid collision\n+\t\t\treturn serviceerror.NewUnavailable(\"Unable to watch component.\")\n+\t\t}\n+\t\tsubscribers[subscriberID] = channel\n+\t\treturn nil\n+\t})\n+\tif err != nil {\n+\t\treturn nil, \"\", err\n+\t}\n+\treturn channel, subscriberID, nil\n+}\n+\n+// Unsubscribe unsubscribes the subscriber from notifications relating to the execution.\n+func (n *ChasmNotifier) Unsubscribe(key chasm.EntityKey, subscriberID string) error {\n+\tsuccess := true\n+\tn.subscribers.RemoveIf(key, func(key any, value any) bool {\n+\t\tsubscribers := value.(map[string]chan *ChasmComponentNotification)\n+\t\tif _, ok := subscribers[subscriberID]; !ok {\n+\t\t\tsuccess = false\n+\t\t} else {\n+\t\t\tdelete(subscribers, subscriberID)\n+\t\t}\n+\t\treturn len(subscribers) == 0\n+\t})\n+\tif !success {\n+\t\t// This indicates a bug\n+\t\treturn serviceerror.NewInternal(\"Unable to unwatch component.\")\n+\t}\n+\treturn nil\n+}\n+\n+func (n *ChasmNotifier) enqueue(notification *ChasmComponentNotification) {\n+\t// TODO(dan) This enqueues to an intermediate channel which might fill up, thus dropping\n+\t// notifications for all subscribers. Consider broadcasting synchronously on enqueue instead.\n+\tnotification.timestamp = n.timeSource.Now()\n+\tselect {\n+\tcase n.notificationsCh <- notification:\n+\tdefault:\n+\t\tmetrics.ChasmComponentNotificationFailDeliveryCount.With(n.metricsHandler).Record(1)\n+\t}\n+}\n+\n+func (n *ChasmNotifier) dequeueLoop() {","path":"service/history/chasm_notifier.go","commit_id":"9f8d762f3279f3b16d2217ae254bb3f85df69b44","original_commit_id":"da6009564e796063faf853352077eecdc1473612","user":{"login":"bergundy","id":52304,"node_id":"MDQ6VXNlcjUyMzA0","avatar_url":"https://avatars.githubusercontent.com/u/52304?v=4","gravatar_id":"","url":"https://api.github.com/users/bergundy","html_url":"https://github.com/bergundy","followers_url":"https://api.github.com/users/bergundy/followers","following_url":"https://api.github.com/users/bergundy/following{/other_user}","gists_url":"https://api.github.com/users/bergundy/gists{/gist_id}","starred_url":"https://api.github.com/users/bergundy/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/bergundy/subscriptions","organizations_url":"https://api.github.com/users/bergundy/orgs","repos_url":"https://api.github.com/users/bergundy/repos","events_url":"https://api.github.com/users/bergundy/events{/privacy}","received_events_url":"https://api.github.com/users/bergundy/received_events","type":"User","user_view_type":"public","site_admin":false},"body":"This is also problematic because on stop you will stop sending notifications.","created_at":"2025-11-19T00:31:23Z","updated_at":"2025-11-19T01:17:28Z","html_url":"https://github.com/temporalio/temporal/pull/8563#discussion_r2540042787","pull_request_url":"https://api.github.com/repos/temporalio/temporal/pulls/8563","_links":{"self":{"href":"https://api.github.com/repos/temporalio/temporal/pulls/comments/2540042787"},"html":{"href":"https://github.com/temporalio/temporal/pull/8563#discussion_r2540042787"},"pull_request":{"href":"https://api.github.com/repos/temporalio/temporal/pulls/8563"}},"reactions":{"url":"https://api.github.com/repos/temporalio/temporal/pulls/comments/2540042787/reactions","total_count":1,"+1":1,"-1":0,"laugh":0,"hooray":0,"confused":0,"heart":0,"rocket":0,"eyes":0},"start_line":null,"original_start_line":null,"start_side":null,"line":null,"original_line":147,"side":"RIGHT","author_association":"MEMBER","original_position":147,"position":1,"subject_type":"line"},{"url":"https://api.github.com/repos/temporalio/temporal/pulls/comments/2540069266","pull_request_review_id":3479944087,"id":2540069266,"node_id":"PRRC_kwDODNqesM6XZmGS","diff_hunk":"@@ -0,0 +1,178 @@\n+// This file implements ChasmNotifier, which allows subscribers to subscribe to notifications\n+// relating to components in a specified CHASM execution. It is based on the events.Notifier\n+// implementation.\n+package history\n+\n+import (\n+\t\"sync/atomic\"\n+\t\"time\"\n+\n+\t\"github.com/dgryski/go-farm\"\n+\t\"github.com/google/uuid\"\n+\t\"go.temporal.io/api/serviceerror\"\n+\t\"go.temporal.io/server/chasm\"\n+\t\"go.temporal.io/server/common\"\n+\t\"go.temporal.io/server/common/clock\"\n+\t\"go.temporal.io/server/common/collection\"\n+\t\"go.temporal.io/server/common/metrics\"\n+\t\"go.temporal.io/server/service/history/configs\"\n+)\n+\n+type (\n+\t// ChasmNotifier allows subscribers to subscribe to notifications relating to components in a\n+\t// specified CHASM execution.\n+\tChasmNotifier struct {\n+\t\ttimeSource      clock.TimeSource\n+\t\tmetricsHandler  metrics.Handler\n+\t\tstatus          int32\n+\t\tnotificationsCh chan *ChasmComponentNotification\n+\t\tstopCh          chan bool\n+\t\tsubscribers     collection.ConcurrentTxMap\n+\t}\n+\n+\t// ChasmComponentNotification is a notification relating to a CHASM component.\n+\tChasmComponentNotification struct {\n+\t\t// TODO(dan): confirm that we want Key in addition to the key in serialized ref\n+\t\tKey       chasm.EntityKey\n+\t\tRef       []byte\n+\t\ttimestamp time.Time\n+\t}\n+)\n+\n+// NewChasmNotifier creates a new instance of ChasmNotifier allowing subscribers to subscribe to\n+// notifications relating to components in a specified CHASM execution.\n+func NewChasmNotifier(\n+\ttimeSource clock.TimeSource,\n+\tmetricsHandler metrics.Handler,\n+\tconfig *configs.Config,\n+) *ChasmNotifier {\n+\treturn &ChasmNotifier{\n+\t\ttimeSource:      timeSource,\n+\t\tmetricsHandler:  metricsHandler.WithTags(metrics.OperationTag(metrics.ChasmComponentNotificationScope)),\n+\t\tstatus:          common.DaemonStatusInitialized,\n+\t\tstopCh:          make(chan bool),\n+\t\tnotificationsCh: make(chan *ChasmComponentNotification, 1000),\n+\t\tsubscribers: collection.NewShardedConcurrentTxMap(1024, func(key any) uint32 {\n+\t\t\texecutionKey, ok := key.(chasm.EntityKey)\n+\t\t\tif !ok {\n+\t\t\t\treturn 0\n+\t\t\t}\n+\t\t\treturn farm.Fingerprint32([]byte(executionKey.NamespaceID + \"_\" + executionKey.BusinessID))\n+\t\t}),\n+\t}\n+}\n+\n+// Start starts the ChasmNotifier.\n+func (n *ChasmNotifier) Start() {\n+\tif !atomic.CompareAndSwapInt32(&n.status, common.DaemonStatusInitialized, common.DaemonStatusStarted) {\n+\t\treturn\n+\t}\n+\tgo n.dequeueLoop()\n+}\n+\n+// Stop stops the ChasmNotifier.\n+func (n *ChasmNotifier) Stop() {\n+\tif !atomic.CompareAndSwapInt32(&n.status, common.DaemonStatusStarted, common.DaemonStatusStopped) {\n+\t\treturn\n+\t}\n+\tclose(n.stopCh)\n+}\n+\n+// Notify sends a notification about a CHASM component.\n+func (n *ChasmNotifier) Notify(notification *ChasmComponentNotification) {\n+\tn.enqueue(notification)\n+}\n+\n+// Subscribe returns a channel that will receive notifications relating to the execution, along with\n+// a subscriber ID that can be passed to UnsubscribeNotification.\n+//\n+// TODO(dan): support subscribing to notifications for a specific component only?\n+func (n *ChasmNotifier) Subscribe(key chasm.EntityKey) (chan *ChasmComponentNotification, string, error) {\n+\tchannel := make(chan *ChasmComponentNotification, 1)\n+\tsubscriberID := uuid.NewString()\n+\n+\t// TODO(dan): This allocates a value that will not be used if key already has subscribers (code\n+\t// copied from events.Notifier)\n+\tsubscribers := map[string]chan *ChasmComponentNotification{\n+\t\tsubscriberID: channel,\n+\t}\n+\n+\t// If key exists then add new subscriber to that second-level map. Otherwise, add a new\n+\t// second-level map containing the new subscriber.\n+\t_, _, err := n.subscribers.PutOrDo(key, subscribers, func(key any, value any) error {\n+\t\tsubscribers := value.(map[string]chan *ChasmComponentNotification)\n+\t\tif _, ok := subscribers[subscriberID]; ok {\n+\t\t\t// uuid collision\n+\t\t\treturn serviceerror.NewUnavailable(\"Unable to watch component.\")\n+\t\t}\n+\t\tsubscribers[subscriberID] = channel\n+\t\treturn nil\n+\t})\n+\tif err != nil {\n+\t\treturn nil, \"\", err\n+\t}\n+\treturn channel, subscriberID, nil\n+}\n+\n+// Unsubscribe unsubscribes the subscriber from notifications relating to the execution.\n+func (n *ChasmNotifier) Unsubscribe(key chasm.EntityKey, subscriberID string) error {\n+\tsuccess := true\n+\tn.subscribers.RemoveIf(key, func(key any, value any) bool {\n+\t\tsubscribers := value.(map[string]chan *ChasmComponentNotification)\n+\t\tif _, ok := subscribers[subscriberID]; !ok {\n+\t\t\tsuccess = false\n+\t\t} else {\n+\t\t\tdelete(subscribers, subscriberID)\n+\t\t}\n+\t\treturn len(subscribers) == 0\n+\t})\n+\tif !success {\n+\t\t// This indicates a bug\n+\t\treturn serviceerror.NewInternal(\"Unable to unwatch component.\")\n+\t}\n+\treturn nil\n+}\n+\n+func (n *ChasmNotifier) enqueue(notification *ChasmComponentNotification) {\n+\t// TODO(dan) This enqueues to an intermediate channel which might fill up, thus dropping\n+\t// notifications for all subscribers. Consider broadcasting synchronously on enqueue instead.\n+\tnotification.timestamp = n.timeSource.Now()\n+\tselect {\n+\tcase n.notificationsCh <- notification:\n+\tdefault:\n+\t\tmetrics.ChasmComponentNotificationFailDeliveryCount.With(n.metricsHandler).Record(1)\n+\t}\n+}\n+\n+func (n *ChasmNotifier) dequeueLoop() {\n+\tfor {\n+\t\tmetrics.ChasmComponentNotificationInFlightMessageGauge.With(n.metricsHandler).Record(float64(len(n.notificationsCh)))\n+\t\tselect {\n+\t\tcase notification := <-n.notificationsCh:\n+\t\t\tmetrics.ChasmComponentNotificationQueueingLatency.With(n.metricsHandler).Record(time.Since(notification.timestamp))\n+\t\t\tn.broadcast(notification)\n+\t\tcase <-n.stopCh:\n+\t\t\treturn\n+\t\t}\n+\t}\n+}\n+\n+func (n *ChasmNotifier) broadcast(notification *ChasmComponentNotification) {\n+\tstartTime := time.Now().UTC()\n+\tdefer func() {\n+\t\t// TODO(dan): retaining \"Fanout\" name for consistency with events.Notifier for now\n+\t\tmetrics.ChasmComponentNotificationFanoutLatency.With(n.metricsHandler).Record(time.Since(startTime))\n+\t}()\n+\t_, _, _ = n.subscribers.GetAndDo(notification.Key, func(key any, value any) error {\n+\t\tsubscribers := value.(map[string]chan *ChasmComponentNotification)\n+\t\tfor _, ch := range subscribers {\n+\t\t\tselect {\n+\t\t\tcase ch <- notification:","path":"service/history/chasm_notifier.go","commit_id":"9f8d762f3279f3b16d2217ae254bb3f85df69b44","original_commit_id":"da6009564e796063faf853352077eecdc1473612","user":{"login":"bergundy","id":52304,"node_id":"MDQ6VXNlcjUyMzA0","avatar_url":"https://avatars.githubusercontent.com/u/52304?v=4","gravatar_id":"","url":"https://api.github.com/users/bergundy","html_url":"https://github.com/bergundy","followers_url":"https://api.github.com/users/bergundy/followers","following_url":"https://api.github.com/users/bergundy/following{/other_user}","gists_url":"https://api.github.com/users/bergundy/gists{/gist_id}","starred_url":"https://api.github.com/users/bergundy/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/bergundy/subscriptions","organizations_url":"https://api.github.com/users/bergundy/orgs","repos_url":"https://api.github.com/users/bergundy/repos","events_url":"https://api.github.com/users/bergundy/events{/privacy}","received_events_url":"https://api.github.com/users/bergundy/received_events","type":"User","user_view_type":"public","site_admin":false},"body":"You should block here instead of missing notifications.","created_at":"2025-11-19T00:45:57Z","updated_at":"2025-11-19T01:17:28Z","html_url":"https://github.com/temporalio/temporal/pull/8563#discussion_r2540069266","pull_request_url":"https://api.github.com/repos/temporalio/temporal/pulls/8563","_links":{"self":{"href":"https://api.github.com/repos/temporalio/temporal/pulls/comments/2540069266"},"html":{"href":"https://github.com/temporalio/temporal/pull/8563#discussion_r2540069266"},"pull_request":{"href":"https://api.github.com/repos/temporalio/temporal/pulls/8563"}},"reactions":{"url":"https://api.github.com/repos/temporalio/temporal/pulls/comments/2540069266/reactions","total_count":1,"+1":1,"-1":0,"laugh":0,"hooray":0,"confused":0,"heart":0,"rocket":0,"eyes":0},"start_line":null,"original_start_line":null,"start_side":null,"line":null,"original_line":170,"side":"RIGHT","author_association":"MEMBER","original_position":170,"position":1,"subject_type":"line"},{"url":"https://api.github.com/repos/temporalio/temporal/pulls/comments/2540076142","pull_request_review_id":3479944087,"id":2540076142,"node_id":"PRRC_kwDODNqesM6XZnxu","diff_hunk":"","path":"service/history/chasm_notifier.go","commit_id":"1d59e66d0ce5d91819f92c428ef5ab4c4efca1fb","original_commit_id":"da6009564e796063faf853352077eecdc1473612","user":{"login":"bergundy","id":52304,"node_id":"MDQ6VXNlcjUyMzA0","avatar_url":"https://avatars.githubusercontent.com/u/52304?v=4","gravatar_id":"","url":"https://api.github.com/users/bergundy","html_url":"https://github.com/bergundy","followers_url":"https://api.github.com/users/bergundy/followers","following_url":"https://api.github.com/users/bergundy/following{/other_user}","gists_url":"https://api.github.com/users/bergundy/gists{/gist_id}","starred_url":"https://api.github.com/users/bergundy/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/bergundy/subscriptions","organizations_url":"https://api.github.com/users/bergundy/orgs","repos_url":"https://api.github.com/users/bergundy/repos","events_url":"https://api.github.com/users/bergundy/events{/privacy}","received_events_url":"https://api.github.com/users/bergundy/received_events","type":"User","user_view_type":"public","site_admin":false},"body":"I reviewed this implementation but after giving it more thought, I realized this is not the correct way to fanout in Go. You can see what we did with task queue user data and the nexus registry as reference where we keep a single channel per key and return that channel to all subscribers. When you want to publish a notification, you check if a channel exists for the given key, and close the channel. Go will then notify all waiters of that channel.","created_at":"2025-11-19T00:50:36Z","updated_at":"2025-11-19T01:17:28Z","html_url":"https://github.com/temporalio/temporal/pull/8563#discussion_r2540076142","pull_request_url":"https://api.github.com/repos/temporalio/temporal/pulls/8563","_links":{"self":{"href":"https://api.github.com/repos/temporalio/temporal/pulls/comments/2540076142"},"html":{"href":"https://github.com/temporalio/temporal/pull/8563#discussion_r2540076142"},"pull_request":{"href":"https://api.github.com/repos/temporalio/temporal/pulls/8563"}},"reactions":{"url":"https://api.github.com/repos/temporalio/temporal/pulls/comments/2540076142/reactions","total_count":0,"+1":0,"-1":0,"laugh":0,"hooray":0,"confused":0,"heart":0,"rocket":0,"eyes":0},"start_line":null,"original_start_line":null,"start_side":null,"line":1,"original_line":1,"side":"RIGHT","author_association":"MEMBER","original_position":1,"position":1,"subject_type":"file"},{"url":"https://api.github.com/repos/temporalio/temporal/pulls/comments/2540083814","pull_request_review_id":3479944087,"id":2540083814,"node_id":"PRRC_kwDODNqesM6XZppm","diff_hunk":"@@ -13,30 +13,42 @@ import (\n \tenumspb \"go.temporal.io/api/enums/v1\"\n \ttaskqueuepb \"go.temporal.io/api/taskqueue/v1\"\n \t\"go.temporal.io/api/workflowservice/v1\"\n+\tpersistencespb \"go.temporal.io/server/api/persistence/v1\"\n+\t\"go.temporal.io/server/chasm\"\n+\t\"go.temporal.io/server/chasm/lib/activity\"\n \t\"go.temporal.io/server/common/dynamicconfig\"\n+\t\"go.temporal.io/server/common/payload\"\n \t\"go.temporal.io/server/tests/testcore\"\n \t\"google.golang.org/protobuf/proto\"\n \t\"google.golang.org/protobuf/types/known/durationpb\"\n )\n \n type standaloneActivityTestSuite struct {\n \ttestcore.FunctionalTestBase\n+\tchasmEngine chasm.Engine","path":"tests/standalone_activity_test.go","commit_id":"a7fd2457a72d9621d986fb36eee14bc23ed5820d","original_commit_id":"da6009564e796063faf853352077eecdc1473612","user":{"login":"bergundy","id":52304,"node_id":"MDQ6VXNlcjUyMzA0","avatar_url":"https://avatars.githubusercontent.com/u/52304?v=4","gravatar_id":"","url":"https://api.github.com/users/bergundy","html_url":"https://github.com/bergundy","followers_url":"https://api.github.com/users/bergundy/followers","following_url":"https://api.github.com/users/bergundy/following{/other_user}","gists_url":"https://api.github.com/users/bergundy/gists{/gist_id}","starred_url":"https://api.github.com/users/bergundy/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/bergundy/subscriptions","organizations_url":"https://api.github.com/users/bergundy/orgs","repos_url":"https://api.github.com/users/bergundy/repos","events_url":"https://api.github.com/users/bergundy/events{/privacy}","received_events_url":"https://api.github.com/users/bergundy/received_events","type":"User","user_view_type":"public","site_admin":false},"body":"CHASM engine is an internal implementation detail and does not belong in functional tests.","created_at":"2025-11-19T00:55:31Z","updated_at":"2025-11-19T01:17:28Z","html_url":"https://github.com/temporalio/temporal/pull/8563#discussion_r2540083814","pull_request_url":"https://api.github.com/repos/temporalio/temporal/pulls/8563","_links":{"self":{"href":"https://api.github.com/repos/temporalio/temporal/pulls/comments/2540083814"},"html":{"href":"https://github.com/temporalio/temporal/pull/8563#discussion_r2540083814"},"pull_request":{"href":"https://api.github.com/repos/temporalio/temporal/pulls/8563"}},"reactions":{"url":"https://api.github.com/repos/temporalio/temporal/pulls/comments/2540083814/reactions","total_count":0,"+1":0,"-1":0,"laugh":0,"hooray":0,"confused":0,"heart":0,"rocket":0,"eyes":0},"start_line":null,"original_start_line":null,"start_side":null,"line":null,"original_line":28,"side":"RIGHT","author_association":"MEMBER","original_position":16,"position":1,"subject_type":"line"},{"url":"https://api.github.com/repos/temporalio/temporal/pulls/comments/2540085010","pull_request_review_id":3479944087,"id":2540085010,"node_id":"PRRC_kwDODNqesM6XZp8S","diff_hunk":"@@ -105,3 +117,377 @@ func createDefaultInput() *commonpb.Payloads {\n \t\t},\n \t}\n }\n+\n+func (s *standaloneActivityTestSuite) Test_PollActivityExecution_NoWait() {\n+\t// Long poll for any state change. PollActivityTaskQueue is used to cause a state change.\n+\tt := s.T()\n+\tctx, cancel := context.WithTimeout(t.Context(), 10*time.Second)\n+\tdefer cancel()\n+\tactivityID := testcore.RandomizeStr(t.Name())\n+\ttaskQueue := uuid.New().String()\n+\n+\tstartResp, err := s.startActivity(ctx, activityID, taskQueue)\n+\trequire.NoError(t, err)\n+\n+\tpollResp, err := s.FrontendClient().PollActivityExecution(ctx, &workflowservice.PollActivityExecutionRequest{\n+\t\tNamespace:    s.Namespace().String(),\n+\t\tActivityId:   activityID,\n+\t\tRunId:        startResp.RunId,","path":"tests/standalone_activity_test.go","commit_id":"cd288dc5f2393c7e2771319f23fd89d46c958bab","original_commit_id":"da6009564e796063faf853352077eecdc1473612","user":{"login":"bergundy","id":52304,"node_id":"MDQ6VXNlcjUyMzA0","avatar_url":"https://avatars.githubusercontent.com/u/52304?v=4","gravatar_id":"","url":"https://api.github.com/users/bergundy","html_url":"https://github.com/bergundy","followers_url":"https://api.github.com/users/bergundy/followers","following_url":"https://api.github.com/users/bergundy/following{/other_user}","gists_url":"https://api.github.com/users/bergundy/gists{/gist_id}","starred_url":"https://api.github.com/users/bergundy/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/bergundy/subscriptions","organizations_url":"https://api.github.com/users/bergundy/orgs","repos_url":"https://api.github.com/users/bergundy/repos","events_url":"https://api.github.com/users/bergundy/events{/privacy}","received_events_url":"https://api.github.com/users/bergundy/received_events","type":"User","user_view_type":"public","site_admin":false},"body":"Check that this defaults to the current run ID too please.","created_at":"2025-11-19T00:56:10Z","updated_at":"2025-11-19T01:17:28Z","html_url":"https://github.com/temporalio/temporal/pull/8563#discussion_r2540085010","pull_request_url":"https://api.github.com/repos/temporalio/temporal/pulls/8563","_links":{"self":{"href":"https://api.github.com/repos/temporalio/temporal/pulls/comments/2540085010"},"html":{"href":"https://github.com/temporalio/temporal/pull/8563#discussion_r2540085010"},"pull_request":{"href":"https://api.github.com/repos/temporalio/temporal/pulls/8563"}},"reactions":{"url":"https://api.github.com/repos/temporalio/temporal/pulls/comments/2540085010/reactions","total_count":0,"+1":0,"-1":0,"laugh":0,"hooray":0,"confused":0,"heart":0,"rocket":0,"eyes":0},"start_line":null,"original_start_line":null,"start_side":null,"line":null,"original_line":135,"side":"RIGHT","author_association":"MEMBER","original_position":67,"position":1,"subject_type":"line"},{"url":"https://api.github.com/repos/temporalio/temporal/pulls/comments/2540086736","pull_request_review_id":3479944087,"id":2540086736,"node_id":"PRRC_kwDODNqesM6XZqXQ","diff_hunk":"@@ -105,3 +117,377 @@ func createDefaultInput() *commonpb.Payloads {\n \t\t},\n \t}\n }\n+\n+func (s *standaloneActivityTestSuite) Test_PollActivityExecution_NoWait() {\n+\t// Long poll for any state change. PollActivityTaskQueue is used to cause a state change.\n+\tt := s.T()\n+\tctx, cancel := context.WithTimeout(t.Context(), 10*time.Second)\n+\tdefer cancel()\n+\tactivityID := testcore.RandomizeStr(t.Name())\n+\ttaskQueue := uuid.New().String()","path":"tests/standalone_activity_test.go","commit_id":"ee79ea9d2857dc0da255fec35a8ec05b24ecc8c6","original_commit_id":"da6009564e796063faf853352077eecdc1473612","user":{"login":"bergundy","id":52304,"node_id":"MDQ6VXNlcjUyMzA0","avatar_url":"https://avatars.githubusercontent.com/u/52304?v=4","gravatar_id":"","url":"https://api.github.com/users/bergundy","html_url":"https://github.com/bergundy","followers_url":"https://api.github.com/users/bergundy/followers","following_url":"https://api.github.com/users/bergundy/following{/other_user}","gists_url":"https://api.github.com/users/bergundy/gists{/gist_id}","starred_url":"https://api.github.com/users/bergundy/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/bergundy/subscriptions","organizations_url":"https://api.github.com/users/bergundy/orgs","repos_url":"https://api.github.com/users/bergundy/repos","events_url":"https://api.github.com/users/bergundy/events{/privacy}","received_events_url":"https://api.github.com/users/bergundy/received_events","type":"User","user_view_type":"public","site_admin":false},"body":"Prefer `testcore.RandomizeStr(t.Name())`. This helps debug tests when looking at run logs.","created_at":"2025-11-19T00:57:16Z","updated_at":"2025-11-19T01:17:28Z","html_url":"https://github.com/temporalio/temporal/pull/8563#discussion_r2540086736","pull_request_url":"https://api.github.com/repos/temporalio/temporal/pulls/8563","_links":{"self":{"href":"https://api.github.com/repos/temporalio/temporal/pulls/comments/2540086736"},"html":{"href":"https://github.com/temporalio/temporal/pull/8563#discussion_r2540086736"},"pull_request":{"href":"https://api.github.com/repos/temporalio/temporal/pulls/8563"}},"reactions":{"url":"https://api.github.com/repos/temporalio/temporal/pulls/comments/2540086736/reactions","total_count":0,"+1":0,"-1":0,"laugh":0,"hooray":0,"confused":0,"heart":0,"rocket":0,"eyes":0},"start_line":null,"original_start_line":null,"start_side":null,"line":null,"original_line":127,"side":"RIGHT","author_association":"MEMBER","original_position":59,"position":1,"subject_type":"line"},{"url":"https://api.github.com/repos/temporalio/temporal/pulls/comments/2540091023","pull_request_review_id":3479944087,"id":2540091023,"node_id":"PRRC_kwDODNqesM6XZraP","diff_hunk":"@@ -13,30 +13,42 @@ import (\n \tenumspb \"go.temporal.io/api/enums/v1\"\n \ttaskqueuepb \"go.temporal.io/api/taskqueue/v1\"\n \t\"go.temporal.io/api/workflowservice/v1\"\n+\tpersistencespb \"go.temporal.io/server/api/persistence/v1\"\n+\t\"go.temporal.io/server/chasm\"\n+\t\"go.temporal.io/server/chasm/lib/activity\"\n \t\"go.temporal.io/server/common/dynamicconfig\"\n+\t\"go.temporal.io/server/common/payload\"\n \t\"go.temporal.io/server/tests/testcore\"\n \t\"google.golang.org/protobuf/proto\"\n \t\"google.golang.org/protobuf/types/known/durationpb\"\n )\n \n type standaloneActivityTestSuite struct {\n \ttestcore.FunctionalTestBase\n+\tchasmEngine chasm.Engine\n }\n \n func TestStandaloneActivityTestSuite(t *testing.T) {\n \tt.Parallel()\n \tsuite.Run(t, new(standaloneActivityTestSuite))\n }\n \n-func (s *standaloneActivityTestSuite) TestStartActivityExecution() {\n-\tt := s.T()\n-\tctx, cancel := context.WithTimeout(t.Context(), 10*time.Second)\n-\tdefer cancel()\n-\n+func (s *standaloneActivityTestSuite) SetupSuite() {\n+\ts.FunctionalTestBase.SetupSuite()\n \ts.OverrideDynamicConfig(","path":"tests/standalone_activity_test.go","commit_id":"1d59e66d0ce5d91819f92c428ef5ab4c4efca1fb","original_commit_id":"da6009564e796063faf853352077eecdc1473612","user":{"login":"bergundy","id":52304,"node_id":"MDQ6VXNlcjUyMzA0","avatar_url":"https://avatars.githubusercontent.com/u/52304?v=4","gravatar_id":"","url":"https://api.github.com/users/bergundy","html_url":"https://github.com/bergundy","followers_url":"https://api.github.com/users/bergundy/followers","following_url":"https://api.github.com/users/bergundy/following{/other_user}","gists_url":"https://api.github.com/users/bergundy/gists{/gist_id}","starred_url":"https://api.github.com/users/bergundy/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/bergundy/subscriptions","organizations_url":"https://api.github.com/users/bergundy/orgs","repos_url":"https://api.github.com/users/bergundy/repos","events_url":"https://api.github.com/users/bergundy/events{/privacy}","received_events_url":"https://api.github.com/users/bergundy/received_events","type":"User","user_view_type":"public","site_admin":false},"body":"Unrelated to this PR, let's not forget to add a dynamic config to enable standalone activities per namespace. We will need this for the feature rollout.","created_at":"2025-11-19T01:00:03Z","updated_at":"2025-11-19T01:17:28Z","html_url":"https://github.com/temporalio/temporal/pull/8563#discussion_r2540091023","pull_request_url":"https://api.github.com/repos/temporalio/temporal/pulls/8563","_links":{"self":{"href":"https://api.github.com/repos/temporalio/temporal/pulls/comments/2540091023"},"html":{"href":"https://github.com/temporalio/temporal/pull/8563#discussion_r2540091023"},"pull_request":{"href":"https://api.github.com/repos/temporalio/temporal/pulls/8563"}},"reactions":{"url":"https://api.github.com/repos/temporalio/temporal/pulls/comments/2540091023/reactions","total_count":0,"+1":0,"-1":0,"laugh":0,"hooray":0,"confused":0,"heart":0,"rocket":0,"eyes":0},"start_line":null,"original_start_line":null,"start_side":null,"line":38,"original_line":38,"side":"RIGHT","author_association":"MEMBER","original_position":31,"position":40,"subject_type":"line"},{"url":"https://api.github.com/repos/temporalio/temporal/pulls/comments/2540092026","pull_request_review_id":3479944087,"id":2540092026,"node_id":"PRRC_kwDODNqesM6XZrp6","diff_hunk":"@@ -85,6 +85,24 @@ func (h *frontendHandler) StartActivityExecution(ctx context.Context, req *workf\n \treturn resp.GetFrontendResponse(), err\n }\n \n+// PollActivityExecution handles PollActivityExecutionRequest. This method supports querying current\n+// activity state, optionally as a long-poll that waits for certain state changes. It is used by\n+// clients to poll for activity state and/or result.\n+func (h *frontendHandler) PollActivityExecution(","path":"chasm/lib/activity/frontend.go","commit_id":"1d59e66d0ce5d91819f92c428ef5ab4c4efca1fb","original_commit_id":"da6009564e796063faf853352077eecdc1473612","user":{"login":"bergundy","id":52304,"node_id":"MDQ6VXNlcjUyMzA0","avatar_url":"https://avatars.githubusercontent.com/u/52304?v=4","gravatar_id":"","url":"https://api.github.com/users/bergundy","html_url":"https://github.com/bergundy","followers_url":"https://api.github.com/users/bergundy/followers","following_url":"https://api.github.com/users/bergundy/following{/other_user}","gists_url":"https://api.github.com/users/bergundy/gists{/gist_id}","starred_url":"https://api.github.com/users/bergundy/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/bergundy/subscriptions","organizations_url":"https://api.github.com/users/bergundy/orgs","repos_url":"https://api.github.com/users/bergundy/repos","events_url":"https://api.github.com/users/bergundy/events{/privacy}","received_events_url":"https://api.github.com/users/bergundy/received_events","type":"User","user_view_type":"public","site_admin":false},"body":"Are there flag combinations that are invalid maybe?","created_at":"2025-11-19T01:00:43Z","updated_at":"2025-11-19T01:17:28Z","html_url":"https://github.com/temporalio/temporal/pull/8563#discussion_r2540092026","pull_request_url":"https://api.github.com/repos/temporalio/temporal/pulls/8563","_links":{"self":{"href":"https://api.github.com/repos/temporalio/temporal/pulls/comments/2540092026"},"html":{"href":"https://github.com/temporalio/temporal/pull/8563#discussion_r2540092026"},"pull_request":{"href":"https://api.github.com/repos/temporalio/temporal/pulls/8563"}},"reactions":{"url":"https://api.github.com/repos/temporalio/temporal/pulls/comments/2540092026/reactions","total_count":0,"+1":0,"-1":0,"laugh":0,"hooray":0,"confused":0,"heart":0,"rocket":0,"eyes":0},"start_line":null,"original_start_line":null,"start_side":null,"line":91,"original_line":91,"side":"RIGHT","in_reply_to_id":2539914786,"author_association":"MEMBER","original_position":7,"position":7,"subject_type":"line"},{"url":"https://api.github.com/repos/temporalio/temporal/pulls/comments/2540099296","pull_request_review_id":3479944087,"id":2540099296,"node_id":"PRRC_kwDODNqesM6XZtbg","diff_hunk":"@@ -105,3 +117,377 @@ func createDefaultInput() *commonpb.Payloads {\n \t\t},\n \t}\n }\n+\n+func (s *standaloneActivityTestSuite) Test_PollActivityExecution_NoWait() {\n+\t// Long poll for any state change. PollActivityTaskQueue is used to cause a state change.\n+\tt := s.T()\n+\tctx, cancel := context.WithTimeout(t.Context(), 10*time.Second)\n+\tdefer cancel()\n+\tactivityID := testcore.RandomizeStr(t.Name())\n+\ttaskQueue := uuid.New().String()\n+\n+\tstartResp, err := s.startActivity(ctx, activityID, taskQueue)\n+\trequire.NoError(t, err)\n+\n+\tpollResp, err := s.FrontendClient().PollActivityExecution(ctx, &workflowservice.PollActivityExecutionRequest{\n+\t\tNamespace:    s.Namespace().String(),\n+\t\tActivityId:   activityID,\n+\t\tRunId:        startResp.RunId,\n+\t\tIncludeInfo:  true,\n+\t\tIncludeInput: true,\n+\t})\n+\trequire.NoError(t, err)\n+\trequire.NotNil(t, pollResp.StateChangeLongPollToken)\n+\trequire.NotNil(t, pollResp.Info)\n+\ts.assertActivityExecutionInfo(\n+\t\tt,\n+\t\tpollResp.Info,\n+\t\tactivityID,\n+\t\tstartResp.RunId,\n+\t\tenumspb.PENDING_ACTIVITY_STATE_SCHEDULED,\n+\t)\n+\trequire.NotNil(t, pollResp.Input)\n+\trequire.Equal(t, \"test-activity-input\", string(pollResp.Input.Payloads[0].Data))\n+\t// TODO(dan): test IncludeOutcome\n+}\n+\n+func (s *standaloneActivityTestSuite) Test_PollActivityExecution_WaitAnyStateChange() {\n+\t// Long poll for any state change. PollActivityTaskQueue is used to cause a state change.\n+\tt := s.T()\n+\tctx, cancel := context.WithTimeout(t.Context(), 10*time.Second)\n+\tdefer cancel()\n+\tactivityID := testcore.RandomizeStr(t.Name())\n+\ttaskQueue := uuid.New().String()\n+\n+\tstartResp, err := s.startActivity(ctx, activityID, taskQueue)\n+\trequire.NoError(t, err)\n+\n+\t// First poll lacks token and therefore responds immediately, returning a token\n+\tfirstPollResp, err := s.FrontendClient().PollActivityExecution(ctx, &workflowservice.PollActivityExecutionRequest{\n+\t\tNamespace:  s.Namespace().String(),\n+\t\tActivityId: activityID,\n+\t\tRunId:      startResp.RunId,\n+\t\tWaitPolicy: &workflowservice.PollActivityExecutionRequest_WaitAnyStateChange{\n+\t\t\tWaitAnyStateChange: &workflowservice.PollActivityExecutionRequest_StateChangeWaitOptions{},\n+\t\t},\n+\t\tIncludeInfo:  true,\n+\t\tIncludeInput: true,\n+\t})\n+\trequire.NoError(t, err)\n+\trequire.NotNil(t, firstPollResp.StateChangeLongPollToken)\n+\trequire.NotNil(t, firstPollResp.Info)\n+\ts.assertActivityExecutionInfo(\n+\t\tt,\n+\t\tfirstPollResp.Info,\n+\t\tactivityID,\n+\t\tstartResp.RunId,\n+\t\tenumspb.PENDING_ACTIVITY_STATE_SCHEDULED,\n+\t)\n+\n+\ttaskQueuePollErr := make(chan error, 1)\n+\tactivityPollDone := make(chan struct{})\n+\tvar activityPollResp *workflowservice.PollActivityExecutionResponse\n+\tvar activityPollErr error\n+\n+\tgo func() {\n+\t\tdefer close(activityPollDone)\n+\t\t// Second poll uses token and therefore waits for a state transition\n+\t\tactivityPollResp, activityPollErr = s.FrontendClient().PollActivityExecution(ctx, &workflowservice.PollActivityExecutionRequest{\n+\t\t\tNamespace:    s.Namespace().String(),\n+\t\t\tActivityId:   activityID,\n+\t\t\tRunId:        startResp.RunId,\n+\t\t\tIncludeInfo:  true,\n+\t\t\tIncludeInput: true,\n+\t\t\tWaitPolicy: &workflowservice.PollActivityExecutionRequest_WaitAnyStateChange{\n+\t\t\t\tWaitAnyStateChange: &workflowservice.PollActivityExecutionRequest_StateChangeWaitOptions{\n+\t\t\t\t\tLongPollToken: firstPollResp.StateChangeLongPollToken,\n+\t\t\t\t},\n+\t\t\t},\n+\t\t})\n+\t}()\n+\n+\t// TODO(dan): race here: subscription might not be established yet\n+\n+\t// Worker picks up activity task, triggering transition (via RecordActivityTaskStarted)\n+\tgo func() {\n+\t\t_, err := s.pollActivityTaskQueue(ctx, taskQueue)\n+\t\ttaskQueuePollErr <- err\n+\t}()\n+\n+\tselect {\n+\tcase <-activityPollDone:\n+\t\trequire.NoError(t, activityPollErr)\n+\t\trequire.NotNil(t, activityPollResp)\n+\t\trequire.NotNil(t, activityPollResp.Info)\n+\t\ts.assertActivityExecutionInfo(\n+\t\t\tt,\n+\t\t\tactivityPollResp.Info,\n+\t\t\tactivityID,\n+\t\t\tstartResp.RunId,\n+\t\t\tenumspb.PENDING_ACTIVITY_STATE_STARTED,\n+\t\t)\n+\t\trequire.NotNil(t, activityPollResp.Input)\n+\t\trequire.Equal(t, \"test-activity-input\", string(activityPollResp.Input.Payloads[0].Data))\n+\n+\tcase <-ctx.Done():\n+\t\tt.Fatal(\"PollActivityExecution timed out\")\n+\t}\n+\n+\terr = <-taskQueuePollErr\n+\trequire.NoError(t, err)\n+\n+\t// Manipulate the token to verify token staleness checks (simulate ErrStaleReference). To do so\n+\t// we make use of the internal implementation detail that the bytes are a serialized ref.\n+\ttoken := firstPollResp.StateChangeLongPollToken","path":"tests/standalone_activity_test.go","commit_id":"cd288dc5f2393c7e2771319f23fd89d46c958bab","original_commit_id":"da6009564e796063faf853352077eecdc1473612","user":{"login":"bergundy","id":52304,"node_id":"MDQ6VXNlcjUyMzA0","avatar_url":"https://avatars.githubusercontent.com/u/52304?v=4","gravatar_id":"","url":"https://api.github.com/users/bergundy","html_url":"https://github.com/bergundy","followers_url":"https://api.github.com/users/bergundy/followers","following_url":"https://api.github.com/users/bergundy/following{/other_user}","gists_url":"https://api.github.com/users/bergundy/gists{/gist_id}","starred_url":"https://api.github.com/users/bergundy/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/bergundy/subscriptions","organizations_url":"https://api.github.com/users/bergundy/orgs","repos_url":"https://api.github.com/users/bergundy/repos","events_url":"https://api.github.com/users/bergundy/events{/privacy}","received_events_url":"https://api.github.com/users/bergundy/received_events","type":"User","user_view_type":"public","site_admin":false},"body":"This is a chasm framework level _unit_ test, not part of standalone activities.","created_at":"2025-11-19T01:05:51Z","updated_at":"2025-11-19T01:17:28Z","html_url":"https://github.com/temporalio/temporal/pull/8563#discussion_r2540099296","pull_request_url":"https://api.github.com/repos/temporalio/temporal/pulls/8563","_links":{"self":{"href":"https://api.github.com/repos/temporalio/temporal/pulls/comments/2540099296"},"html":{"href":"https://github.com/temporalio/temporal/pull/8563#discussion_r2540099296"},"pull_request":{"href":"https://api.github.com/repos/temporalio/temporal/pulls/8563"}},"reactions":{"url":"https://api.github.com/repos/temporalio/temporal/pulls/comments/2540099296/reactions","total_count":0,"+1":0,"-1":0,"laugh":0,"hooray":0,"confused":0,"heart":0,"rocket":0,"eyes":0},"start_line":null,"original_start_line":null,"start_side":null,"line":null,"original_line":241,"side":"RIGHT","author_association":"MEMBER","original_position":173,"position":1,"subject_type":"line"},{"url":"https://api.github.com/repos/temporalio/temporal/pulls/comments/2540101065","pull_request_review_id":3479944087,"id":2540101065,"node_id":"PRRC_kwDODNqesM6XZt3J","diff_hunk":"@@ -105,3 +117,377 @@ func createDefaultInput() *commonpb.Payloads {\n \t\t},\n \t}\n }\n+\n+func (s *standaloneActivityTestSuite) Test_PollActivityExecution_NoWait() {\n+\t// Long poll for any state change. PollActivityTaskQueue is used to cause a state change.\n+\tt := s.T()\n+\tctx, cancel := context.WithTimeout(t.Context(), 10*time.Second)\n+\tdefer cancel()\n+\tactivityID := testcore.RandomizeStr(t.Name())\n+\ttaskQueue := uuid.New().String()\n+\n+\tstartResp, err := s.startActivity(ctx, activityID, taskQueue)\n+\trequire.NoError(t, err)\n+\n+\tpollResp, err := s.FrontendClient().PollActivityExecution(ctx, &workflowservice.PollActivityExecutionRequest{\n+\t\tNamespace:    s.Namespace().String(),\n+\t\tActivityId:   activityID,\n+\t\tRunId:        startResp.RunId,\n+\t\tIncludeInfo:  true,\n+\t\tIncludeInput: true,\n+\t})\n+\trequire.NoError(t, err)\n+\trequire.NotNil(t, pollResp.StateChangeLongPollToken)\n+\trequire.NotNil(t, pollResp.Info)\n+\ts.assertActivityExecutionInfo(\n+\t\tt,\n+\t\tpollResp.Info,\n+\t\tactivityID,\n+\t\tstartResp.RunId,\n+\t\tenumspb.PENDING_ACTIVITY_STATE_SCHEDULED,\n+\t)\n+\trequire.NotNil(t, pollResp.Input)\n+\trequire.Equal(t, \"test-activity-input\", string(pollResp.Input.Payloads[0].Data))\n+\t// TODO(dan): test IncludeOutcome\n+}\n+\n+func (s *standaloneActivityTestSuite) Test_PollActivityExecution_WaitAnyStateChange() {\n+\t// Long poll for any state change. PollActivityTaskQueue is used to cause a state change.\n+\tt := s.T()\n+\tctx, cancel := context.WithTimeout(t.Context(), 10*time.Second)\n+\tdefer cancel()\n+\tactivityID := testcore.RandomizeStr(t.Name())\n+\ttaskQueue := uuid.New().String()\n+\n+\tstartResp, err := s.startActivity(ctx, activityID, taskQueue)\n+\trequire.NoError(t, err)\n+\n+\t// First poll lacks token and therefore responds immediately, returning a token\n+\tfirstPollResp, err := s.FrontendClient().PollActivityExecution(ctx, &workflowservice.PollActivityExecutionRequest{\n+\t\tNamespace:  s.Namespace().String(),\n+\t\tActivityId: activityID,\n+\t\tRunId:      startResp.RunId,\n+\t\tWaitPolicy: &workflowservice.PollActivityExecutionRequest_WaitAnyStateChange{\n+\t\t\tWaitAnyStateChange: &workflowservice.PollActivityExecutionRequest_StateChangeWaitOptions{},\n+\t\t},\n+\t\tIncludeInfo:  true,\n+\t\tIncludeInput: true,\n+\t})\n+\trequire.NoError(t, err)\n+\trequire.NotNil(t, firstPollResp.StateChangeLongPollToken)\n+\trequire.NotNil(t, firstPollResp.Info)\n+\ts.assertActivityExecutionInfo(\n+\t\tt,\n+\t\tfirstPollResp.Info,\n+\t\tactivityID,\n+\t\tstartResp.RunId,\n+\t\tenumspb.PENDING_ACTIVITY_STATE_SCHEDULED,\n+\t)\n+\n+\ttaskQueuePollErr := make(chan error, 1)\n+\tactivityPollDone := make(chan struct{})\n+\tvar activityPollResp *workflowservice.PollActivityExecutionResponse\n+\tvar activityPollErr error\n+\n+\tgo func() {\n+\t\tdefer close(activityPollDone)\n+\t\t// Second poll uses token and therefore waits for a state transition\n+\t\tactivityPollResp, activityPollErr = s.FrontendClient().PollActivityExecution(ctx, &workflowservice.PollActivityExecutionRequest{\n+\t\t\tNamespace:    s.Namespace().String(),\n+\t\t\tActivityId:   activityID,\n+\t\t\tRunId:        startResp.RunId,\n+\t\t\tIncludeInfo:  true,\n+\t\t\tIncludeInput: true,\n+\t\t\tWaitPolicy: &workflowservice.PollActivityExecutionRequest_WaitAnyStateChange{\n+\t\t\t\tWaitAnyStateChange: &workflowservice.PollActivityExecutionRequest_StateChangeWaitOptions{\n+\t\t\t\t\tLongPollToken: firstPollResp.StateChangeLongPollToken,\n+\t\t\t\t},\n+\t\t\t},\n+\t\t})\n+\t}()\n+\n+\t// TODO(dan): race here: subscription might not be established yet\n+\n+\t// Worker picks up activity task, triggering transition (via RecordActivityTaskStarted)\n+\tgo func() {\n+\t\t_, err := s.pollActivityTaskQueue(ctx, taskQueue)\n+\t\ttaskQueuePollErr <- err\n+\t}()\n+\n+\tselect {\n+\tcase <-activityPollDone:\n+\t\trequire.NoError(t, activityPollErr)\n+\t\trequire.NotNil(t, activityPollResp)\n+\t\trequire.NotNil(t, activityPollResp.Info)\n+\t\ts.assertActivityExecutionInfo(\n+\t\t\tt,\n+\t\t\tactivityPollResp.Info,\n+\t\t\tactivityID,\n+\t\t\tstartResp.RunId,\n+\t\t\tenumspb.PENDING_ACTIVITY_STATE_STARTED,\n+\t\t)\n+\t\trequire.NotNil(t, activityPollResp.Input)\n+\t\trequire.Equal(t, \"test-activity-input\", string(activityPollResp.Input.Payloads[0].Data))\n+\n+\tcase <-ctx.Done():\n+\t\tt.Fatal(\"PollActivityExecution timed out\")\n+\t}\n+\n+\terr = <-taskQueuePollErr\n+\trequire.NoError(t, err)\n+\n+\t// Manipulate the token to verify token staleness checks (simulate ErrStaleReference). To do so\n+\t// we make use of the internal implementation detail that the bytes are a serialized ref.\n+\ttoken := firstPollResp.StateChangeLongPollToken\n+\tvar pRef persistencespb.ChasmComponentRef\n+\terr = pRef.Unmarshal(token)\n+\trequire.NoError(t, err)\n+\tif pRef.EntityVersionedTransition != nil {\n+\t\tpRef.EntityVersionedTransition.NamespaceFailoverVersion += 1\n+\t}\n+\ttoken, err = pRef.Marshal()\n+\trequire.NoError(t, err)\n+\n+\t_, err = s.FrontendClient().PollActivityExecution(ctx, &workflowservice.PollActivityExecutionRequest{\n+\t\tNamespace:  s.Namespace().String(),\n+\t\tActivityId: activityID,\n+\t\tRunId:      startResp.RunId,\n+\t\tWaitPolicy: &workflowservice.PollActivityExecutionRequest_WaitAnyStateChange{\n+\t\t\tWaitAnyStateChange: &workflowservice.PollActivityExecutionRequest_StateChangeWaitOptions{\n+\t\t\t\tLongPollToken: token,\n+\t\t\t},\n+\t\t},\n+\t})\n+\trequire.Error(t, err)","path":"tests/standalone_activity_test.go","commit_id":"e95ab0ad0ba0c42c1e0e125042367ada0583ea76","original_commit_id":"da6009564e796063faf853352077eecdc1473612","user":{"login":"bergundy","id":52304,"node_id":"MDQ6VXNlcjUyMzA0","avatar_url":"https://avatars.githubusercontent.com/u/52304?v=4","gravatar_id":"","url":"https://api.github.com/users/bergundy","html_url":"https://github.com/bergundy","followers_url":"https://api.github.com/users/bergundy/followers","following_url":"https://api.github.com/users/bergundy/following{/other_user}","gists_url":"https://api.github.com/users/bergundy/gists{/gist_id}","starred_url":"https://api.github.com/users/bergundy/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/bergundy/subscriptions","organizations_url":"https://api.github.com/users/bergundy/orgs","repos_url":"https://api.github.com/users/bergundy/repos","events_url":"https://api.github.com/users/bergundy/events{/privacy}","received_events_url":"https://api.github.com/users/bergundy/received_events","type":"User","user_view_type":"public","site_admin":false},"body":"Use `require.ErrorAs` to ensure you get the expected response code.","created_at":"2025-11-19T01:07:12Z","updated_at":"2025-11-19T01:17:28Z","html_url":"https://github.com/temporalio/temporal/pull/8563#discussion_r2540101065","pull_request_url":"https://api.github.com/repos/temporalio/temporal/pulls/8563","_links":{"self":{"href":"https://api.github.com/repos/temporalio/temporal/pulls/comments/2540101065"},"html":{"href":"https://github.com/temporalio/temporal/pull/8563#discussion_r2540101065"},"pull_request":{"href":"https://api.github.com/repos/temporalio/temporal/pulls/8563"}},"reactions":{"url":"https://api.github.com/repos/temporalio/temporal/pulls/comments/2540101065/reactions","total_count":0,"+1":0,"-1":0,"laugh":0,"hooray":0,"confused":0,"heart":0,"rocket":0,"eyes":0},"start_line":null,"original_start_line":null,"start_side":null,"line":null,"original_line":261,"side":"RIGHT","author_association":"MEMBER","original_position":193,"position":1,"subject_type":"line"},{"url":"https://api.github.com/repos/temporalio/temporal/pulls/comments/2540101660","pull_request_review_id":3479944087,"id":2540101660,"node_id":"PRRC_kwDODNqesM6XZuAc","diff_hunk":"@@ -105,3 +117,377 @@ func createDefaultInput() *commonpb.Payloads {\n \t\t},\n \t}\n }\n+\n+func (s *standaloneActivityTestSuite) Test_PollActivityExecution_NoWait() {\n+\t// Long poll for any state change. PollActivityTaskQueue is used to cause a state change.\n+\tt := s.T()\n+\tctx, cancel := context.WithTimeout(t.Context(), 10*time.Second)\n+\tdefer cancel()\n+\tactivityID := testcore.RandomizeStr(t.Name())\n+\ttaskQueue := uuid.New().String()\n+\n+\tstartResp, err := s.startActivity(ctx, activityID, taskQueue)\n+\trequire.NoError(t, err)\n+\n+\tpollResp, err := s.FrontendClient().PollActivityExecution(ctx, &workflowservice.PollActivityExecutionRequest{\n+\t\tNamespace:    s.Namespace().String(),\n+\t\tActivityId:   activityID,\n+\t\tRunId:        startResp.RunId,\n+\t\tIncludeInfo:  true,\n+\t\tIncludeInput: true,\n+\t})\n+\trequire.NoError(t, err)\n+\trequire.NotNil(t, pollResp.StateChangeLongPollToken)\n+\trequire.NotNil(t, pollResp.Info)\n+\ts.assertActivityExecutionInfo(\n+\t\tt,\n+\t\tpollResp.Info,\n+\t\tactivityID,\n+\t\tstartResp.RunId,\n+\t\tenumspb.PENDING_ACTIVITY_STATE_SCHEDULED,\n+\t)\n+\trequire.NotNil(t, pollResp.Input)\n+\trequire.Equal(t, \"test-activity-input\", string(pollResp.Input.Payloads[0].Data))\n+\t// TODO(dan): test IncludeOutcome\n+}\n+\n+func (s *standaloneActivityTestSuite) Test_PollActivityExecution_WaitAnyStateChange() {\n+\t// Long poll for any state change. PollActivityTaskQueue is used to cause a state change.\n+\tt := s.T()\n+\tctx, cancel := context.WithTimeout(t.Context(), 10*time.Second)\n+\tdefer cancel()\n+\tactivityID := testcore.RandomizeStr(t.Name())\n+\ttaskQueue := uuid.New().String()\n+\n+\tstartResp, err := s.startActivity(ctx, activityID, taskQueue)\n+\trequire.NoError(t, err)\n+\n+\t// First poll lacks token and therefore responds immediately, returning a token\n+\tfirstPollResp, err := s.FrontendClient().PollActivityExecution(ctx, &workflowservice.PollActivityExecutionRequest{\n+\t\tNamespace:  s.Namespace().String(),\n+\t\tActivityId: activityID,\n+\t\tRunId:      startResp.RunId,\n+\t\tWaitPolicy: &workflowservice.PollActivityExecutionRequest_WaitAnyStateChange{\n+\t\t\tWaitAnyStateChange: &workflowservice.PollActivityExecutionRequest_StateChangeWaitOptions{},\n+\t\t},\n+\t\tIncludeInfo:  true,\n+\t\tIncludeInput: true,\n+\t})\n+\trequire.NoError(t, err)\n+\trequire.NotNil(t, firstPollResp.StateChangeLongPollToken)\n+\trequire.NotNil(t, firstPollResp.Info)\n+\ts.assertActivityExecutionInfo(\n+\t\tt,\n+\t\tfirstPollResp.Info,\n+\t\tactivityID,\n+\t\tstartResp.RunId,\n+\t\tenumspb.PENDING_ACTIVITY_STATE_SCHEDULED,\n+\t)\n+\n+\ttaskQueuePollErr := make(chan error, 1)\n+\tactivityPollDone := make(chan struct{})\n+\tvar activityPollResp *workflowservice.PollActivityExecutionResponse\n+\tvar activityPollErr error\n+\n+\tgo func() {\n+\t\tdefer close(activityPollDone)\n+\t\t// Second poll uses token and therefore waits for a state transition\n+\t\tactivityPollResp, activityPollErr = s.FrontendClient().PollActivityExecution(ctx, &workflowservice.PollActivityExecutionRequest{\n+\t\t\tNamespace:    s.Namespace().String(),\n+\t\t\tActivityId:   activityID,\n+\t\t\tRunId:        startResp.RunId,\n+\t\t\tIncludeInfo:  true,\n+\t\t\tIncludeInput: true,\n+\t\t\tWaitPolicy: &workflowservice.PollActivityExecutionRequest_WaitAnyStateChange{\n+\t\t\t\tWaitAnyStateChange: &workflowservice.PollActivityExecutionRequest_StateChangeWaitOptions{\n+\t\t\t\t\tLongPollToken: firstPollResp.StateChangeLongPollToken,\n+\t\t\t\t},\n+\t\t\t},\n+\t\t})\n+\t}()\n+\n+\t// TODO(dan): race here: subscription might not be established yet\n+\n+\t// Worker picks up activity task, triggering transition (via RecordActivityTaskStarted)\n+\tgo func() {\n+\t\t_, err := s.pollActivityTaskQueue(ctx, taskQueue)\n+\t\ttaskQueuePollErr <- err\n+\t}()\n+\n+\tselect {\n+\tcase <-activityPollDone:\n+\t\trequire.NoError(t, activityPollErr)\n+\t\trequire.NotNil(t, activityPollResp)\n+\t\trequire.NotNil(t, activityPollResp.Info)\n+\t\ts.assertActivityExecutionInfo(\n+\t\t\tt,\n+\t\t\tactivityPollResp.Info,\n+\t\t\tactivityID,\n+\t\t\tstartResp.RunId,\n+\t\t\tenumspb.PENDING_ACTIVITY_STATE_STARTED,\n+\t\t)\n+\t\trequire.NotNil(t, activityPollResp.Input)\n+\t\trequire.Equal(t, \"test-activity-input\", string(activityPollResp.Input.Payloads[0].Data))\n+\n+\tcase <-ctx.Done():\n+\t\tt.Fatal(\"PollActivityExecution timed out\")\n+\t}\n+\n+\terr = <-taskQueuePollErr\n+\trequire.NoError(t, err)\n+\n+\t// Manipulate the token to verify token staleness checks (simulate ErrStaleReference). To do so\n+\t// we make use of the internal implementation detail that the bytes are a serialized ref.\n+\ttoken := firstPollResp.StateChangeLongPollToken\n+\tvar pRef persistencespb.ChasmComponentRef\n+\terr = pRef.Unmarshal(token)\n+\trequire.NoError(t, err)\n+\tif pRef.EntityVersionedTransition != nil {\n+\t\tpRef.EntityVersionedTransition.NamespaceFailoverVersion += 1\n+\t}\n+\ttoken, err = pRef.Marshal()\n+\trequire.NoError(t, err)\n+\n+\t_, err = s.FrontendClient().PollActivityExecution(ctx, &workflowservice.PollActivityExecutionRequest{\n+\t\tNamespace:  s.Namespace().String(),\n+\t\tActivityId: activityID,\n+\t\tRunId:      startResp.RunId,\n+\t\tWaitPolicy: &workflowservice.PollActivityExecutionRequest_WaitAnyStateChange{\n+\t\t\tWaitAnyStateChange: &workflowservice.PollActivityExecutionRequest_StateChangeWaitOptions{\n+\t\t\t\tLongPollToken: token,\n+\t\t\t},\n+\t\t},\n+\t})\n+\trequire.Error(t, err)\n+\trequire.ErrorContains(t, err, \"cached mutable state could potentially be stale\")","path":"tests/standalone_activity_test.go","commit_id":"ee79ea9d2857dc0da255fec35a8ec05b24ecc8c6","original_commit_id":"da6009564e796063faf853352077eecdc1473612","user":{"login":"bergundy","id":52304,"node_id":"MDQ6VXNlcjUyMzA0","avatar_url":"https://avatars.githubusercontent.com/u/52304?v=4","gravatar_id":"","url":"https://api.github.com/users/bergundy","html_url":"https://github.com/bergundy","followers_url":"https://api.github.com/users/bergundy/followers","following_url":"https://api.github.com/users/bergundy/following{/other_user}","gists_url":"https://api.github.com/users/bergundy/gists{/gist_id}","starred_url":"https://api.github.com/users/bergundy/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/bergundy/subscriptions","organizations_url":"https://api.github.com/users/bergundy/orgs","repos_url":"https://api.github.com/users/bergundy/repos","events_url":"https://api.github.com/users/bergundy/events{/privacy}","received_events_url":"https://api.github.com/users/bergundy/received_events","type":"User","user_view_type":"public","site_admin":false},"body":"This should not be a user facing error. I would be scared as a user to see this come back.","created_at":"2025-11-19T01:07:38Z","updated_at":"2025-11-19T01:17:28Z","html_url":"https://github.com/temporalio/temporal/pull/8563#discussion_r2540101660","pull_request_url":"https://api.github.com/repos/temporalio/temporal/pulls/8563","_links":{"self":{"href":"https://api.github.com/repos/temporalio/temporal/pulls/comments/2540101660"},"html":{"href":"https://github.com/temporalio/temporal/pull/8563#discussion_r2540101660"},"pull_request":{"href":"https://api.github.com/repos/temporalio/temporal/pulls/8563"}},"reactions":{"url":"https://api.github.com/repos/temporalio/temporal/pulls/comments/2540101660/reactions","total_count":0,"+1":0,"-1":0,"laugh":0,"hooray":0,"confused":0,"heart":0,"rocket":0,"eyes":0},"start_line":null,"original_start_line":null,"start_side":null,"line":null,"original_line":262,"side":"RIGHT","author_association":"MEMBER","original_position":194,"position":1,"subject_type":"line"},{"url":"https://api.github.com/repos/temporalio/temporal/pulls/comments/2540109782","pull_request_review_id":3479944087,"id":2540109782,"node_id":"PRRC_kwDODNqesM6XZv_W","diff_hunk":"@@ -105,3 +117,377 @@ func createDefaultInput() *commonpb.Payloads {\n \t\t},\n \t}\n }\n+\n+func (s *standaloneActivityTestSuite) Test_PollActivityExecution_NoWait() {\n+\t// Long poll for any state change. PollActivityTaskQueue is used to cause a state change.\n+\tt := s.T()\n+\tctx, cancel := context.WithTimeout(t.Context(), 10*time.Second)\n+\tdefer cancel()\n+\tactivityID := testcore.RandomizeStr(t.Name())\n+\ttaskQueue := uuid.New().String()\n+\n+\tstartResp, err := s.startActivity(ctx, activityID, taskQueue)\n+\trequire.NoError(t, err)\n+\n+\tpollResp, err := s.FrontendClient().PollActivityExecution(ctx, &workflowservice.PollActivityExecutionRequest{\n+\t\tNamespace:    s.Namespace().String(),\n+\t\tActivityId:   activityID,\n+\t\tRunId:        startResp.RunId,\n+\t\tIncludeInfo:  true,\n+\t\tIncludeInput: true,\n+\t})\n+\trequire.NoError(t, err)\n+\trequire.NotNil(t, pollResp.StateChangeLongPollToken)\n+\trequire.NotNil(t, pollResp.Info)\n+\ts.assertActivityExecutionInfo(\n+\t\tt,\n+\t\tpollResp.Info,\n+\t\tactivityID,\n+\t\tstartResp.RunId,\n+\t\tenumspb.PENDING_ACTIVITY_STATE_SCHEDULED,\n+\t)\n+\trequire.NotNil(t, pollResp.Input)\n+\trequire.Equal(t, \"test-activity-input\", string(pollResp.Input.Payloads[0].Data))\n+\t// TODO(dan): test IncludeOutcome\n+}\n+\n+func (s *standaloneActivityTestSuite) Test_PollActivityExecution_WaitAnyStateChange() {\n+\t// Long poll for any state change. PollActivityTaskQueue is used to cause a state change.\n+\tt := s.T()\n+\tctx, cancel := context.WithTimeout(t.Context(), 10*time.Second)\n+\tdefer cancel()\n+\tactivityID := testcore.RandomizeStr(t.Name())\n+\ttaskQueue := uuid.New().String()\n+\n+\tstartResp, err := s.startActivity(ctx, activityID, taskQueue)\n+\trequire.NoError(t, err)\n+\n+\t// First poll lacks token and therefore responds immediately, returning a token\n+\tfirstPollResp, err := s.FrontendClient().PollActivityExecution(ctx, &workflowservice.PollActivityExecutionRequest{\n+\t\tNamespace:  s.Namespace().String(),\n+\t\tActivityId: activityID,\n+\t\tRunId:      startResp.RunId,\n+\t\tWaitPolicy: &workflowservice.PollActivityExecutionRequest_WaitAnyStateChange{\n+\t\t\tWaitAnyStateChange: &workflowservice.PollActivityExecutionRequest_StateChangeWaitOptions{},\n+\t\t},\n+\t\tIncludeInfo:  true,\n+\t\tIncludeInput: true,\n+\t})\n+\trequire.NoError(t, err)\n+\trequire.NotNil(t, firstPollResp.StateChangeLongPollToken)\n+\trequire.NotNil(t, firstPollResp.Info)\n+\ts.assertActivityExecutionInfo(\n+\t\tt,\n+\t\tfirstPollResp.Info,\n+\t\tactivityID,\n+\t\tstartResp.RunId,\n+\t\tenumspb.PENDING_ACTIVITY_STATE_SCHEDULED,\n+\t)\n+\n+\ttaskQueuePollErr := make(chan error, 1)\n+\tactivityPollDone := make(chan struct{})\n+\tvar activityPollResp *workflowservice.PollActivityExecutionResponse\n+\tvar activityPollErr error\n+\n+\tgo func() {\n+\t\tdefer close(activityPollDone)\n+\t\t// Second poll uses token and therefore waits for a state transition\n+\t\tactivityPollResp, activityPollErr = s.FrontendClient().PollActivityExecution(ctx, &workflowservice.PollActivityExecutionRequest{\n+\t\t\tNamespace:    s.Namespace().String(),\n+\t\t\tActivityId:   activityID,\n+\t\t\tRunId:        startResp.RunId,\n+\t\t\tIncludeInfo:  true,\n+\t\t\tIncludeInput: true,\n+\t\t\tWaitPolicy: &workflowservice.PollActivityExecutionRequest_WaitAnyStateChange{\n+\t\t\t\tWaitAnyStateChange: &workflowservice.PollActivityExecutionRequest_StateChangeWaitOptions{\n+\t\t\t\t\tLongPollToken: firstPollResp.StateChangeLongPollToken,\n+\t\t\t\t},\n+\t\t\t},\n+\t\t})\n+\t}()\n+\n+\t// TODO(dan): race here: subscription might not be established yet\n+\n+\t// Worker picks up activity task, triggering transition (via RecordActivityTaskStarted)\n+\tgo func() {\n+\t\t_, err := s.pollActivityTaskQueue(ctx, taskQueue)\n+\t\ttaskQueuePollErr <- err\n+\t}()\n+\n+\tselect {\n+\tcase <-activityPollDone:\n+\t\trequire.NoError(t, activityPollErr)\n+\t\trequire.NotNil(t, activityPollResp)\n+\t\trequire.NotNil(t, activityPollResp.Info)\n+\t\ts.assertActivityExecutionInfo(\n+\t\t\tt,\n+\t\t\tactivityPollResp.Info,\n+\t\t\tactivityID,\n+\t\t\tstartResp.RunId,\n+\t\t\tenumspb.PENDING_ACTIVITY_STATE_STARTED,\n+\t\t)\n+\t\trequire.NotNil(t, activityPollResp.Input)\n+\t\trequire.Equal(t, \"test-activity-input\", string(activityPollResp.Input.Payloads[0].Data))\n+\n+\tcase <-ctx.Done():\n+\t\tt.Fatal(\"PollActivityExecution timed out\")\n+\t}\n+\n+\terr = <-taskQueuePollErr\n+\trequire.NoError(t, err)\n+\n+\t// Manipulate the token to verify token staleness checks (simulate ErrStaleReference). To do so\n+\t// we make use of the internal implementation detail that the bytes are a serialized ref.\n+\ttoken := firstPollResp.StateChangeLongPollToken\n+\tvar pRef persistencespb.ChasmComponentRef\n+\terr = pRef.Unmarshal(token)\n+\trequire.NoError(t, err)\n+\tif pRef.EntityVersionedTransition != nil {\n+\t\tpRef.EntityVersionedTransition.NamespaceFailoverVersion += 1\n+\t}\n+\ttoken, err = pRef.Marshal()\n+\trequire.NoError(t, err)\n+\n+\t_, err = s.FrontendClient().PollActivityExecution(ctx, &workflowservice.PollActivityExecutionRequest{\n+\t\tNamespace:  s.Namespace().String(),\n+\t\tActivityId: activityID,\n+\t\tRunId:      startResp.RunId,\n+\t\tWaitPolicy: &workflowservice.PollActivityExecutionRequest_WaitAnyStateChange{\n+\t\t\tWaitAnyStateChange: &workflowservice.PollActivityExecutionRequest_StateChangeWaitOptions{\n+\t\t\t\tLongPollToken: token,\n+\t\t\t},\n+\t\t},\n+\t})\n+\trequire.Error(t, err)\n+\trequire.ErrorContains(t, err, \"cached mutable state could potentially be stale\")","path":"tests/standalone_activity_test.go","commit_id":"ee79ea9d2857dc0da255fec35a8ec05b24ecc8c6","original_commit_id":"da6009564e796063faf853352077eecdc1473612","user":{"login":"bergundy","id":52304,"node_id":"MDQ6VXNlcjUyMzA0","avatar_url":"https://avatars.githubusercontent.com/u/52304?v=4","gravatar_id":"","url":"https://api.github.com/users/bergundy","html_url":"https://github.com/bergundy","followers_url":"https://api.github.com/users/bergundy/followers","following_url":"https://api.github.com/users/bergundy/following{/other_user}","gists_url":"https://api.github.com/users/bergundy/gists{/gist_id}","starred_url":"https://api.github.com/users/bergundy/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/bergundy/subscriptions","organizations_url":"https://api.github.com/users/bergundy/orgs","repos_url":"https://api.github.com/users/bergundy/repos","events_url":"https://api.github.com/users/bergundy/events{/privacy}","received_events_url":"https://api.github.com/users/bergundy/received_events","type":"User","user_view_type":"public","site_admin":false},"body":"You should return some form of retryable error, probably one of our errors that map to an unavailable grpc status code. This can happen when a namespace fails over and replication hasn't caught up yet. The user's request should be allowed to retry as long as they are willing to.","created_at":"2025-11-19T01:13:31Z","updated_at":"2025-11-19T01:17:28Z","html_url":"https://github.com/temporalio/temporal/pull/8563#discussion_r2540109782","pull_request_url":"https://api.github.com/repos/temporalio/temporal/pulls/8563","_links":{"self":{"href":"https://api.github.com/repos/temporalio/temporal/pulls/comments/2540109782"},"html":{"href":"https://github.com/temporalio/temporal/pull/8563#discussion_r2540109782"},"pull_request":{"href":"https://api.github.com/repos/temporalio/temporal/pulls/8563"}},"reactions":{"url":"https://api.github.com/repos/temporalio/temporal/pulls/comments/2540109782/reactions","total_count":0,"+1":0,"-1":0,"laugh":0,"hooray":0,"confused":0,"heart":0,"rocket":0,"eyes":0},"start_line":null,"original_start_line":null,"start_side":null,"line":null,"original_line":262,"side":"RIGHT","in_reply_to_id":2540101660,"author_association":"MEMBER","original_position":194,"position":1,"subject_type":"line"},{"url":"https://api.github.com/repos/temporalio/temporal/pulls/comments/2540110627","pull_request_review_id":3479944087,"id":2540110627,"node_id":"PRRC_kwDODNqesM6XZwMj","diff_hunk":"@@ -105,3 +117,377 @@ func createDefaultInput() *commonpb.Payloads {\n \t\t},\n \t}\n }\n+\n+func (s *standaloneActivityTestSuite) Test_PollActivityExecution_NoWait() {\n+\t// Long poll for any state change. PollActivityTaskQueue is used to cause a state change.\n+\tt := s.T()\n+\tctx, cancel := context.WithTimeout(t.Context(), 10*time.Second)\n+\tdefer cancel()\n+\tactivityID := testcore.RandomizeStr(t.Name())\n+\ttaskQueue := uuid.New().String()\n+\n+\tstartResp, err := s.startActivity(ctx, activityID, taskQueue)\n+\trequire.NoError(t, err)\n+\n+\tpollResp, err := s.FrontendClient().PollActivityExecution(ctx, &workflowservice.PollActivityExecutionRequest{\n+\t\tNamespace:    s.Namespace().String(),\n+\t\tActivityId:   activityID,\n+\t\tRunId:        startResp.RunId,\n+\t\tIncludeInfo:  true,\n+\t\tIncludeInput: true,\n+\t})\n+\trequire.NoError(t, err)\n+\trequire.NotNil(t, pollResp.StateChangeLongPollToken)\n+\trequire.NotNil(t, pollResp.Info)\n+\ts.assertActivityExecutionInfo(\n+\t\tt,\n+\t\tpollResp.Info,\n+\t\tactivityID,\n+\t\tstartResp.RunId,\n+\t\tenumspb.PENDING_ACTIVITY_STATE_SCHEDULED,\n+\t)\n+\trequire.NotNil(t, pollResp.Input)\n+\trequire.Equal(t, \"test-activity-input\", string(pollResp.Input.Payloads[0].Data))\n+\t// TODO(dan): test IncludeOutcome\n+}\n+\n+func (s *standaloneActivityTestSuite) Test_PollActivityExecution_WaitAnyStateChange() {\n+\t// Long poll for any state change. PollActivityTaskQueue is used to cause a state change.\n+\tt := s.T()\n+\tctx, cancel := context.WithTimeout(t.Context(), 10*time.Second)\n+\tdefer cancel()\n+\tactivityID := testcore.RandomizeStr(t.Name())\n+\ttaskQueue := uuid.New().String()\n+\n+\tstartResp, err := s.startActivity(ctx, activityID, taskQueue)\n+\trequire.NoError(t, err)\n+\n+\t// First poll lacks token and therefore responds immediately, returning a token\n+\tfirstPollResp, err := s.FrontendClient().PollActivityExecution(ctx, &workflowservice.PollActivityExecutionRequest{\n+\t\tNamespace:  s.Namespace().String(),\n+\t\tActivityId: activityID,\n+\t\tRunId:      startResp.RunId,\n+\t\tWaitPolicy: &workflowservice.PollActivityExecutionRequest_WaitAnyStateChange{\n+\t\t\tWaitAnyStateChange: &workflowservice.PollActivityExecutionRequest_StateChangeWaitOptions{},\n+\t\t},\n+\t\tIncludeInfo:  true,\n+\t\tIncludeInput: true,\n+\t})\n+\trequire.NoError(t, err)\n+\trequire.NotNil(t, firstPollResp.StateChangeLongPollToken)\n+\trequire.NotNil(t, firstPollResp.Info)\n+\ts.assertActivityExecutionInfo(\n+\t\tt,\n+\t\tfirstPollResp.Info,\n+\t\tactivityID,\n+\t\tstartResp.RunId,\n+\t\tenumspb.PENDING_ACTIVITY_STATE_SCHEDULED,\n+\t)\n+\n+\ttaskQueuePollErr := make(chan error, 1)\n+\tactivityPollDone := make(chan struct{})\n+\tvar activityPollResp *workflowservice.PollActivityExecutionResponse\n+\tvar activityPollErr error\n+\n+\tgo func() {\n+\t\tdefer close(activityPollDone)\n+\t\t// Second poll uses token and therefore waits for a state transition\n+\t\tactivityPollResp, activityPollErr = s.FrontendClient().PollActivityExecution(ctx, &workflowservice.PollActivityExecutionRequest{\n+\t\t\tNamespace:    s.Namespace().String(),\n+\t\t\tActivityId:   activityID,\n+\t\t\tRunId:        startResp.RunId,\n+\t\t\tIncludeInfo:  true,\n+\t\t\tIncludeInput: true,\n+\t\t\tWaitPolicy: &workflowservice.PollActivityExecutionRequest_WaitAnyStateChange{\n+\t\t\t\tWaitAnyStateChange: &workflowservice.PollActivityExecutionRequest_StateChangeWaitOptions{\n+\t\t\t\t\tLongPollToken: firstPollResp.StateChangeLongPollToken,\n+\t\t\t\t},\n+\t\t\t},\n+\t\t})\n+\t}()\n+\n+\t// TODO(dan): race here: subscription might not be established yet\n+\n+\t// Worker picks up activity task, triggering transition (via RecordActivityTaskStarted)\n+\tgo func() {\n+\t\t_, err := s.pollActivityTaskQueue(ctx, taskQueue)\n+\t\ttaskQueuePollErr <- err\n+\t}()\n+\n+\tselect {\n+\tcase <-activityPollDone:\n+\t\trequire.NoError(t, activityPollErr)\n+\t\trequire.NotNil(t, activityPollResp)\n+\t\trequire.NotNil(t, activityPollResp.Info)\n+\t\ts.assertActivityExecutionInfo(\n+\t\t\tt,\n+\t\t\tactivityPollResp.Info,\n+\t\t\tactivityID,\n+\t\t\tstartResp.RunId,\n+\t\t\tenumspb.PENDING_ACTIVITY_STATE_STARTED,\n+\t\t)\n+\t\trequire.NotNil(t, activityPollResp.Input)\n+\t\trequire.Equal(t, \"test-activity-input\", string(activityPollResp.Input.Payloads[0].Data))\n+\n+\tcase <-ctx.Done():\n+\t\tt.Fatal(\"PollActivityExecution timed out\")\n+\t}\n+\n+\terr = <-taskQueuePollErr\n+\trequire.NoError(t, err)\n+\n+\t// Manipulate the token to verify token staleness checks (simulate ErrStaleReference). To do so\n+\t// we make use of the internal implementation detail that the bytes are a serialized ref.\n+\ttoken := firstPollResp.StateChangeLongPollToken\n+\tvar pRef persistencespb.ChasmComponentRef\n+\terr = pRef.Unmarshal(token)\n+\trequire.NoError(t, err)\n+\tif pRef.EntityVersionedTransition != nil {\n+\t\tpRef.EntityVersionedTransition.NamespaceFailoverVersion += 1\n+\t}\n+\ttoken, err = pRef.Marshal()\n+\trequire.NoError(t, err)\n+\n+\t_, err = s.FrontendClient().PollActivityExecution(ctx, &workflowservice.PollActivityExecutionRequest{\n+\t\tNamespace:  s.Namespace().String(),\n+\t\tActivityId: activityID,\n+\t\tRunId:      startResp.RunId,\n+\t\tWaitPolicy: &workflowservice.PollActivityExecutionRequest_WaitAnyStateChange{\n+\t\t\tWaitAnyStateChange: &workflowservice.PollActivityExecutionRequest_StateChangeWaitOptions{\n+\t\t\t\tLongPollToken: token,\n+\t\t\t},\n+\t\t},\n+\t})\n+\trequire.Error(t, err)\n+\trequire.ErrorContains(t, err, \"cached mutable state could potentially be stale\")","path":"tests/standalone_activity_test.go","commit_id":"ee79ea9d2857dc0da255fec35a8ec05b24ecc8c6","original_commit_id":"da6009564e796063faf853352077eecdc1473612","user":{"login":"bergundy","id":52304,"node_id":"MDQ6VXNlcjUyMzA0","avatar_url":"https://avatars.githubusercontent.com/u/52304?v=4","gravatar_id":"","url":"https://api.github.com/users/bergundy","html_url":"https://github.com/bergundy","followers_url":"https://api.github.com/users/bergundy/followers","following_url":"https://api.github.com/users/bergundy/following{/other_user}","gists_url":"https://api.github.com/users/bergundy/gists{/gist_id}","starred_url":"https://api.github.com/users/bergundy/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/bergundy/subscriptions","organizations_url":"https://api.github.com/users/bergundy/orgs","repos_url":"https://api.github.com/users/bergundy/repos","events_url":"https://api.github.com/users/bergundy/events{/privacy}","received_events_url":"https://api.github.com/users/bergundy/received_events","type":"User","user_view_type":"public","site_admin":false},"body":"Just note that this counts as an SLA violation in Temporal cloud but I think that's expected.","created_at":"2025-11-19T01:14:06Z","updated_at":"2025-11-19T01:17:28Z","html_url":"https://github.com/temporalio/temporal/pull/8563#discussion_r2540110627","pull_request_url":"https://api.github.com/repos/temporalio/temporal/pulls/8563","_links":{"self":{"href":"https://api.github.com/repos/temporalio/temporal/pulls/comments/2540110627"},"html":{"href":"https://github.com/temporalio/temporal/pull/8563#discussion_r2540110627"},"pull_request":{"href":"https://api.github.com/repos/temporalio/temporal/pulls/8563"}},"reactions":{"url":"https://api.github.com/repos/temporalio/temporal/pulls/comments/2540110627/reactions","total_count":0,"+1":0,"-1":0,"laugh":0,"hooray":0,"confused":0,"heart":0,"rocket":0,"eyes":0},"start_line":null,"original_start_line":null,"start_side":null,"line":null,"original_line":262,"side":"RIGHT","in_reply_to_id":2540101660,"author_association":"MEMBER","original_position":194,"position":1,"subject_type":"line"},{"url":"https://api.github.com/repos/temporalio/temporal/pulls/comments/2540111898","pull_request_review_id":3479944087,"id":2540111898,"node_id":"PRRC_kwDODNqesM6XZwga","diff_hunk":"@@ -105,3 +117,377 @@ func createDefaultInput() *commonpb.Payloads {\n \t\t},\n \t}\n }\n+\n+func (s *standaloneActivityTestSuite) Test_PollActivityExecution_NoWait() {\n+\t// Long poll for any state change. PollActivityTaskQueue is used to cause a state change.\n+\tt := s.T()\n+\tctx, cancel := context.WithTimeout(t.Context(), 10*time.Second)\n+\tdefer cancel()\n+\tactivityID := testcore.RandomizeStr(t.Name())\n+\ttaskQueue := uuid.New().String()\n+\n+\tstartResp, err := s.startActivity(ctx, activityID, taskQueue)\n+\trequire.NoError(t, err)\n+\n+\tpollResp, err := s.FrontendClient().PollActivityExecution(ctx, &workflowservice.PollActivityExecutionRequest{\n+\t\tNamespace:    s.Namespace().String(),\n+\t\tActivityId:   activityID,\n+\t\tRunId:        startResp.RunId,\n+\t\tIncludeInfo:  true,\n+\t\tIncludeInput: true,\n+\t})\n+\trequire.NoError(t, err)\n+\trequire.NotNil(t, pollResp.StateChangeLongPollToken)\n+\trequire.NotNil(t, pollResp.Info)\n+\ts.assertActivityExecutionInfo(\n+\t\tt,\n+\t\tpollResp.Info,\n+\t\tactivityID,\n+\t\tstartResp.RunId,\n+\t\tenumspb.PENDING_ACTIVITY_STATE_SCHEDULED,\n+\t)\n+\trequire.NotNil(t, pollResp.Input)\n+\trequire.Equal(t, \"test-activity-input\", string(pollResp.Input.Payloads[0].Data))\n+\t// TODO(dan): test IncludeOutcome\n+}\n+\n+func (s *standaloneActivityTestSuite) Test_PollActivityExecution_WaitAnyStateChange() {\n+\t// Long poll for any state change. PollActivityTaskQueue is used to cause a state change.\n+\tt := s.T()\n+\tctx, cancel := context.WithTimeout(t.Context(), 10*time.Second)\n+\tdefer cancel()\n+\tactivityID := testcore.RandomizeStr(t.Name())\n+\ttaskQueue := uuid.New().String()\n+\n+\tstartResp, err := s.startActivity(ctx, activityID, taskQueue)\n+\trequire.NoError(t, err)\n+\n+\t// First poll lacks token and therefore responds immediately, returning a token\n+\tfirstPollResp, err := s.FrontendClient().PollActivityExecution(ctx, &workflowservice.PollActivityExecutionRequest{\n+\t\tNamespace:  s.Namespace().String(),\n+\t\tActivityId: activityID,\n+\t\tRunId:      startResp.RunId,\n+\t\tWaitPolicy: &workflowservice.PollActivityExecutionRequest_WaitAnyStateChange{\n+\t\t\tWaitAnyStateChange: &workflowservice.PollActivityExecutionRequest_StateChangeWaitOptions{},\n+\t\t},\n+\t\tIncludeInfo:  true,\n+\t\tIncludeInput: true,\n+\t})\n+\trequire.NoError(t, err)\n+\trequire.NotNil(t, firstPollResp.StateChangeLongPollToken)\n+\trequire.NotNil(t, firstPollResp.Info)\n+\ts.assertActivityExecutionInfo(\n+\t\tt,\n+\t\tfirstPollResp.Info,\n+\t\tactivityID,\n+\t\tstartResp.RunId,\n+\t\tenumspb.PENDING_ACTIVITY_STATE_SCHEDULED,\n+\t)\n+\n+\ttaskQueuePollErr := make(chan error, 1)\n+\tactivityPollDone := make(chan struct{})\n+\tvar activityPollResp *workflowservice.PollActivityExecutionResponse\n+\tvar activityPollErr error\n+\n+\tgo func() {\n+\t\tdefer close(activityPollDone)\n+\t\t// Second poll uses token and therefore waits for a state transition\n+\t\tactivityPollResp, activityPollErr = s.FrontendClient().PollActivityExecution(ctx, &workflowservice.PollActivityExecutionRequest{\n+\t\t\tNamespace:    s.Namespace().String(),\n+\t\t\tActivityId:   activityID,\n+\t\t\tRunId:        startResp.RunId,\n+\t\t\tIncludeInfo:  true,\n+\t\t\tIncludeInput: true,\n+\t\t\tWaitPolicy: &workflowservice.PollActivityExecutionRequest_WaitAnyStateChange{\n+\t\t\t\tWaitAnyStateChange: &workflowservice.PollActivityExecutionRequest_StateChangeWaitOptions{\n+\t\t\t\t\tLongPollToken: firstPollResp.StateChangeLongPollToken,\n+\t\t\t\t},\n+\t\t\t},\n+\t\t})\n+\t}()\n+\n+\t// TODO(dan): race here: subscription might not be established yet\n+\n+\t// Worker picks up activity task, triggering transition (via RecordActivityTaskStarted)\n+\tgo func() {\n+\t\t_, err := s.pollActivityTaskQueue(ctx, taskQueue)\n+\t\ttaskQueuePollErr <- err\n+\t}()\n+\n+\tselect {\n+\tcase <-activityPollDone:\n+\t\trequire.NoError(t, activityPollErr)\n+\t\trequire.NotNil(t, activityPollResp)\n+\t\trequire.NotNil(t, activityPollResp.Info)\n+\t\ts.assertActivityExecutionInfo(\n+\t\t\tt,\n+\t\t\tactivityPollResp.Info,\n+\t\t\tactivityID,\n+\t\t\tstartResp.RunId,\n+\t\t\tenumspb.PENDING_ACTIVITY_STATE_STARTED,\n+\t\t)\n+\t\trequire.NotNil(t, activityPollResp.Input)\n+\t\trequire.Equal(t, \"test-activity-input\", string(activityPollResp.Input.Payloads[0].Data))\n+\n+\tcase <-ctx.Done():\n+\t\tt.Fatal(\"PollActivityExecution timed out\")\n+\t}\n+\n+\terr = <-taskQueuePollErr\n+\trequire.NoError(t, err)\n+\n+\t// Manipulate the token to verify token staleness checks (simulate ErrStaleReference). To do so\n+\t// we make use of the internal implementation detail that the bytes are a serialized ref.\n+\ttoken := firstPollResp.StateChangeLongPollToken\n+\tvar pRef persistencespb.ChasmComponentRef\n+\terr = pRef.Unmarshal(token)\n+\trequire.NoError(t, err)\n+\tif pRef.EntityVersionedTransition != nil {\n+\t\tpRef.EntityVersionedTransition.NamespaceFailoverVersion += 1\n+\t}\n+\ttoken, err = pRef.Marshal()\n+\trequire.NoError(t, err)\n+\n+\t_, err = s.FrontendClient().PollActivityExecution(ctx, &workflowservice.PollActivityExecutionRequest{\n+\t\tNamespace:  s.Namespace().String(),\n+\t\tActivityId: activityID,\n+\t\tRunId:      startResp.RunId,\n+\t\tWaitPolicy: &workflowservice.PollActivityExecutionRequest_WaitAnyStateChange{\n+\t\t\tWaitAnyStateChange: &workflowservice.PollActivityExecutionRequest_StateChangeWaitOptions{\n+\t\t\t\tLongPollToken: token,\n+\t\t\t},\n+\t\t},\n+\t})\n+\trequire.Error(t, err)\n+\trequire.ErrorContains(t, err, \"cached mutable state could potentially be stale\")\n+}\n+\n+func (s *standaloneActivityTestSuite) Test_PollActivityExecution_WaitCompletion() {\n+\tt := s.T()\n+\tt.Skip(\"TODO(dan): implement test when RecordActivityTaskCompleted is implemented\")\n+}\n+\n+func (s *standaloneActivityTestSuite) Test_PollActivityExecution_WaitAnyStateChange_Success_UpdateComponent() {\n+\tt := s.T()\n+\tctx, cancel := context.WithTimeout(t.Context(), 10*time.Second)\n+\tdefer cancel()\n+\tctx = chasm.NewEngineContext(ctx, s.chasmEngine)\n+\n+\tactivityID := testcore.RandomizeStr(t.Name())\n+\ttaskQueue := uuid.New().String()\n+\n+\tstartResp, err := s.startActivity(ctx, activityID, taskQueue)\n+\trequire.NoError(t, err)\n+\tentityKey := chasm.EntityKey{\n+\t\tNamespaceID: s.NamespaceID().String(),\n+\t\tBusinessID:  activityID,\n+\t\tEntityID:    startResp.RunId,\n+\t}\n+\n+\t// Test PollActivityExecution(WaitAnyStateChange) without a long-poll token.\n+\tpollResp, err := s.FrontendClient().PollActivityExecution(ctx, &workflowservice.PollActivityExecutionRequest{\n+\t\tNamespace:  s.Namespace().String(),\n+\t\tActivityId: activityID,\n+\t\tRunId:      startResp.RunId,\n+\t\tWaitPolicy: &workflowservice.PollActivityExecutionRequest_WaitAnyStateChange{\n+\t\t\tWaitAnyStateChange: &workflowservice.PollActivityExecutionRequest_StateChangeWaitOptions{},\n+\t\t},\n+\t})\n+\trequire.NoError(t, err)\n+\trequire.NotNil(t, pollResp.GetStateChangeLongPollToken())\n+\trequire.Equal(t, startResp.GetRunId(), pollResp.GetRunId())\n+\n+\t_, _, err = chasm.UpdateComponent(","path":"tests/standalone_activity_test.go","commit_id":"ee79ea9d2857dc0da255fec35a8ec05b24ecc8c6","original_commit_id":"da6009564e796063faf853352077eecdc1473612","user":{"login":"bergundy","id":52304,"node_id":"MDQ6VXNlcjUyMzA0","avatar_url":"https://avatars.githubusercontent.com/u/52304?v=4","gravatar_id":"","url":"https://api.github.com/users/bergundy","html_url":"https://github.com/bergundy","followers_url":"https://api.github.com/users/bergundy/followers","following_url":"https://api.github.com/users/bergundy/following{/other_user}","gists_url":"https://api.github.com/users/bergundy/gists{/gist_id}","starred_url":"https://api.github.com/users/bergundy/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/bergundy/subscriptions","organizations_url":"https://api.github.com/users/bergundy/orgs","repos_url":"https://api.github.com/users/bergundy/repos","events_url":"https://api.github.com/users/bergundy/events{/privacy}","received_events_url":"https://api.github.com/users/bergundy/received_events","type":"User","user_view_type":"public","site_admin":false},"body":"Don't do this in functional tests. I don't see how this is related to standalone activity tests.","created_at":"2025-11-19T01:15:05Z","updated_at":"2025-11-19T01:17:28Z","html_url":"https://github.com/temporalio/temporal/pull/8563#discussion_r2540111898","pull_request_url":"https://api.github.com/repos/temporalio/temporal/pulls/8563","_links":{"self":{"href":"https://api.github.com/repos/temporalio/temporal/pulls/comments/2540111898"},"html":{"href":"https://github.com/temporalio/temporal/pull/8563#discussion_r2540111898"},"pull_request":{"href":"https://api.github.com/repos/temporalio/temporal/pulls/8563"}},"reactions":{"url":"https://api.github.com/repos/temporalio/temporal/pulls/comments/2540111898/reactions","total_count":0,"+1":0,"-1":0,"laugh":0,"hooray":0,"confused":0,"heart":0,"rocket":0,"eyes":0},"start_line":null,"original_start_line":null,"start_side":null,"line":null,"original_line":300,"side":"RIGHT","author_association":"MEMBER","original_position":232,"position":1,"subject_type":"line"},{"url":"https://api.github.com/repos/temporalio/temporal/pulls/comments/2540112768","pull_request_review_id":3479944087,"id":2540112768,"node_id":"PRRC_kwDODNqesM6XZwuA","diff_hunk":"@@ -105,3 +117,377 @@ func createDefaultInput() *commonpb.Payloads {\n \t\t},\n \t}\n }\n+\n+func (s *standaloneActivityTestSuite) Test_PollActivityExecution_NoWait() {\n+\t// Long poll for any state change. PollActivityTaskQueue is used to cause a state change.\n+\tt := s.T()\n+\tctx, cancel := context.WithTimeout(t.Context(), 10*time.Second)\n+\tdefer cancel()\n+\tactivityID := testcore.RandomizeStr(t.Name())\n+\ttaskQueue := uuid.New().String()\n+\n+\tstartResp, err := s.startActivity(ctx, activityID, taskQueue)\n+\trequire.NoError(t, err)\n+\n+\tpollResp, err := s.FrontendClient().PollActivityExecution(ctx, &workflowservice.PollActivityExecutionRequest{\n+\t\tNamespace:    s.Namespace().String(),\n+\t\tActivityId:   activityID,\n+\t\tRunId:        startResp.RunId,\n+\t\tIncludeInfo:  true,\n+\t\tIncludeInput: true,\n+\t})\n+\trequire.NoError(t, err)\n+\trequire.NotNil(t, pollResp.StateChangeLongPollToken)\n+\trequire.NotNil(t, pollResp.Info)\n+\ts.assertActivityExecutionInfo(\n+\t\tt,\n+\t\tpollResp.Info,\n+\t\tactivityID,\n+\t\tstartResp.RunId,\n+\t\tenumspb.PENDING_ACTIVITY_STATE_SCHEDULED,\n+\t)\n+\trequire.NotNil(t, pollResp.Input)\n+\trequire.Equal(t, \"test-activity-input\", string(pollResp.Input.Payloads[0].Data))\n+\t// TODO(dan): test IncludeOutcome\n+}\n+\n+func (s *standaloneActivityTestSuite) Test_PollActivityExecution_WaitAnyStateChange() {\n+\t// Long poll for any state change. PollActivityTaskQueue is used to cause a state change.\n+\tt := s.T()\n+\tctx, cancel := context.WithTimeout(t.Context(), 10*time.Second)\n+\tdefer cancel()\n+\tactivityID := testcore.RandomizeStr(t.Name())\n+\ttaskQueue := uuid.New().String()\n+\n+\tstartResp, err := s.startActivity(ctx, activityID, taskQueue)\n+\trequire.NoError(t, err)\n+\n+\t// First poll lacks token and therefore responds immediately, returning a token\n+\tfirstPollResp, err := s.FrontendClient().PollActivityExecution(ctx, &workflowservice.PollActivityExecutionRequest{\n+\t\tNamespace:  s.Namespace().String(),\n+\t\tActivityId: activityID,\n+\t\tRunId:      startResp.RunId,\n+\t\tWaitPolicy: &workflowservice.PollActivityExecutionRequest_WaitAnyStateChange{\n+\t\t\tWaitAnyStateChange: &workflowservice.PollActivityExecutionRequest_StateChangeWaitOptions{},\n+\t\t},\n+\t\tIncludeInfo:  true,\n+\t\tIncludeInput: true,\n+\t})\n+\trequire.NoError(t, err)\n+\trequire.NotNil(t, firstPollResp.StateChangeLongPollToken)\n+\trequire.NotNil(t, firstPollResp.Info)\n+\ts.assertActivityExecutionInfo(\n+\t\tt,\n+\t\tfirstPollResp.Info,\n+\t\tactivityID,\n+\t\tstartResp.RunId,\n+\t\tenumspb.PENDING_ACTIVITY_STATE_SCHEDULED,\n+\t)\n+\n+\ttaskQueuePollErr := make(chan error, 1)\n+\tactivityPollDone := make(chan struct{})\n+\tvar activityPollResp *workflowservice.PollActivityExecutionResponse\n+\tvar activityPollErr error\n+\n+\tgo func() {\n+\t\tdefer close(activityPollDone)\n+\t\t// Second poll uses token and therefore waits for a state transition\n+\t\tactivityPollResp, activityPollErr = s.FrontendClient().PollActivityExecution(ctx, &workflowservice.PollActivityExecutionRequest{\n+\t\t\tNamespace:    s.Namespace().String(),\n+\t\t\tActivityId:   activityID,\n+\t\t\tRunId:        startResp.RunId,\n+\t\t\tIncludeInfo:  true,\n+\t\t\tIncludeInput: true,\n+\t\t\tWaitPolicy: &workflowservice.PollActivityExecutionRequest_WaitAnyStateChange{\n+\t\t\t\tWaitAnyStateChange: &workflowservice.PollActivityExecutionRequest_StateChangeWaitOptions{\n+\t\t\t\t\tLongPollToken: firstPollResp.StateChangeLongPollToken,\n+\t\t\t\t},\n+\t\t\t},\n+\t\t})\n+\t}()\n+\n+\t// TODO(dan): race here: subscription might not be established yet\n+\n+\t// Worker picks up activity task, triggering transition (via RecordActivityTaskStarted)\n+\tgo func() {\n+\t\t_, err := s.pollActivityTaskQueue(ctx, taskQueue)\n+\t\ttaskQueuePollErr <- err\n+\t}()\n+\n+\tselect {\n+\tcase <-activityPollDone:\n+\t\trequire.NoError(t, activityPollErr)\n+\t\trequire.NotNil(t, activityPollResp)\n+\t\trequire.NotNil(t, activityPollResp.Info)\n+\t\ts.assertActivityExecutionInfo(\n+\t\t\tt,\n+\t\t\tactivityPollResp.Info,\n+\t\t\tactivityID,\n+\t\t\tstartResp.RunId,\n+\t\t\tenumspb.PENDING_ACTIVITY_STATE_STARTED,\n+\t\t)\n+\t\trequire.NotNil(t, activityPollResp.Input)\n+\t\trequire.Equal(t, \"test-activity-input\", string(activityPollResp.Input.Payloads[0].Data))\n+\n+\tcase <-ctx.Done():\n+\t\tt.Fatal(\"PollActivityExecution timed out\")\n+\t}\n+\n+\terr = <-taskQueuePollErr\n+\trequire.NoError(t, err)\n+\n+\t// Manipulate the token to verify token staleness checks (simulate ErrStaleReference). To do so\n+\t// we make use of the internal implementation detail that the bytes are a serialized ref.\n+\ttoken := firstPollResp.StateChangeLongPollToken\n+\tvar pRef persistencespb.ChasmComponentRef\n+\terr = pRef.Unmarshal(token)\n+\trequire.NoError(t, err)\n+\tif pRef.EntityVersionedTransition != nil {\n+\t\tpRef.EntityVersionedTransition.NamespaceFailoverVersion += 1\n+\t}\n+\ttoken, err = pRef.Marshal()\n+\trequire.NoError(t, err)\n+\n+\t_, err = s.FrontendClient().PollActivityExecution(ctx, &workflowservice.PollActivityExecutionRequest{\n+\t\tNamespace:  s.Namespace().String(),\n+\t\tActivityId: activityID,\n+\t\tRunId:      startResp.RunId,\n+\t\tWaitPolicy: &workflowservice.PollActivityExecutionRequest_WaitAnyStateChange{\n+\t\t\tWaitAnyStateChange: &workflowservice.PollActivityExecutionRequest_StateChangeWaitOptions{\n+\t\t\t\tLongPollToken: token,\n+\t\t\t},\n+\t\t},\n+\t})\n+\trequire.Error(t, err)\n+\trequire.ErrorContains(t, err, \"cached mutable state could potentially be stale\")\n+}\n+\n+func (s *standaloneActivityTestSuite) Test_PollActivityExecution_WaitCompletion() {\n+\tt := s.T()\n+\tt.Skip(\"TODO(dan): implement test when RecordActivityTaskCompleted is implemented\")\n+}\n+\n+func (s *standaloneActivityTestSuite) Test_PollActivityExecution_WaitAnyStateChange_Success_UpdateComponent() {\n+\tt := s.T()\n+\tctx, cancel := context.WithTimeout(t.Context(), 10*time.Second)\n+\tdefer cancel()\n+\tctx = chasm.NewEngineContext(ctx, s.chasmEngine)\n+\n+\tactivityID := testcore.RandomizeStr(t.Name())\n+\ttaskQueue := uuid.New().String()\n+\n+\tstartResp, err := s.startActivity(ctx, activityID, taskQueue)\n+\trequire.NoError(t, err)\n+\tentityKey := chasm.EntityKey{\n+\t\tNamespaceID: s.NamespaceID().String(),\n+\t\tBusinessID:  activityID,\n+\t\tEntityID:    startResp.RunId,\n+\t}\n+\n+\t// Test PollActivityExecution(WaitAnyStateChange) without a long-poll token.\n+\tpollResp, err := s.FrontendClient().PollActivityExecution(ctx, &workflowservice.PollActivityExecutionRequest{\n+\t\tNamespace:  s.Namespace().String(),\n+\t\tActivityId: activityID,\n+\t\tRunId:      startResp.RunId,\n+\t\tWaitPolicy: &workflowservice.PollActivityExecutionRequest_WaitAnyStateChange{\n+\t\t\tWaitAnyStateChange: &workflowservice.PollActivityExecutionRequest_StateChangeWaitOptions{},\n+\t\t},\n+\t})\n+\trequire.NoError(t, err)\n+\trequire.NotNil(t, pollResp.GetStateChangeLongPollToken())\n+\trequire.Equal(t, startResp.GetRunId(), pollResp.GetRunId())\n+\n+\t_, _, err = chasm.UpdateComponent(\n+\t\tctx,\n+\t\tchasm.NewComponentRef[*activity.Activity](entityKey),\n+\t\tfunc(a *activity.Activity, ctx chasm.MutableContext, _ any) (any, error) {\n+\t\t\t// Don't actually mutate; just trigger the notification\n+\t\t\treturn nil, nil\n+\t\t}, nil)\n+\trequire.NoError(t, err)\n+\n+\t// Test PollActivityExecution(WaitAnyStateChange) with a long-poll token.\n+\tsecondPollResp, err := s.FrontendClient().PollActivityExecution(ctx, &workflowservice.PollActivityExecutionRequest{\n+\t\tNamespace:  s.Namespace().String(),\n+\t\tActivityId: activityID,\n+\t\tRunId:      startResp.RunId,\n+\t\tWaitPolicy: &workflowservice.PollActivityExecutionRequest_WaitAnyStateChange{\n+\t\t\tWaitAnyStateChange: &workflowservice.PollActivityExecutionRequest_StateChangeWaitOptions{\n+\t\t\t\tLongPollToken: pollResp.GetStateChangeLongPollToken(),\n+\t\t\t},\n+\t\t},\n+\t})\n+\trequire.NoError(t, err)\n+\trequire.NotNil(t, secondPollResp.StateChangeLongPollToken)\n+}\n+\n+// Test_PollVisibility_UpdateFromParent tests that polling for visibility component is woken up when\n+// the parent activity is updated and modifies the visibility.\n+// TODO(dan): this test uses chasm APIs (ReadComponent, UpdateComponent, PollComponent) directly. Is\n+// this illegitimate in tests/?\n+func (s *standaloneActivityTestSuite) Test_PollVisibility_UpdateFromParent() {","path":"tests/standalone_activity_test.go","commit_id":"ee79ea9d2857dc0da255fec35a8ec05b24ecc8c6","original_commit_id":"da6009564e796063faf853352077eecdc1473612","user":{"login":"bergundy","id":52304,"node_id":"MDQ6VXNlcjUyMzA0","avatar_url":"https://avatars.githubusercontent.com/u/52304?v=4","gravatar_id":"","url":"https://api.github.com/users/bergundy","html_url":"https://github.com/bergundy","followers_url":"https://api.github.com/users/bergundy/followers","following_url":"https://api.github.com/users/bergundy/following{/other_user}","gists_url":"https://api.github.com/users/bergundy/gists{/gist_id}","starred_url":"https://api.github.com/users/bergundy/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/bergundy/subscriptions","organizations_url":"https://api.github.com/users/bergundy/orgs","repos_url":"https://api.github.com/users/bergundy/repos","events_url":"https://api.github.com/users/bergundy/events{/privacy}","received_events_url":"https://api.github.com/users/bergundy/received_events","type":"User","user_view_type":"public","site_admin":false},"body":"Also doesn't belong here and should be a unit test in the chasm framework.","created_at":"2025-11-19T01:15:38Z","updated_at":"2025-11-19T01:17:28Z","html_url":"https://github.com/temporalio/temporal/pull/8563#discussion_r2540112768","pull_request_url":"https://api.github.com/repos/temporalio/temporal/pulls/8563","_links":{"self":{"href":"https://api.github.com/repos/temporalio/temporal/pulls/comments/2540112768"},"html":{"href":"https://github.com/temporalio/temporal/pull/8563#discussion_r2540112768"},"pull_request":{"href":"https://api.github.com/repos/temporalio/temporal/pulls/8563"}},"reactions":{"url":"https://api.github.com/repos/temporalio/temporal/pulls/comments/2540112768/reactions","total_count":0,"+1":0,"-1":0,"laugh":0,"hooray":0,"confused":0,"heart":0,"rocket":0,"eyes":0},"start_line":null,"original_start_line":null,"start_side":null,"line":null,"original_line":328,"side":"RIGHT","author_association":"MEMBER","original_position":260,"position":1,"subject_type":"line"},{"url":"https://api.github.com/repos/temporalio/temporal/pulls/comments/2540114706","pull_request_review_id":3479944087,"id":2540114706,"node_id":"PRRC_kwDODNqesM6XZxMS","diff_hunk":"@@ -105,3 +117,377 @@ func createDefaultInput() *commonpb.Payloads {\n \t\t},\n \t}\n }\n+\n+func (s *standaloneActivityTestSuite) Test_PollActivityExecution_NoWait() {\n+\t// Long poll for any state change. PollActivityTaskQueue is used to cause a state change.\n+\tt := s.T()\n+\tctx, cancel := context.WithTimeout(t.Context(), 10*time.Second)\n+\tdefer cancel()\n+\tactivityID := testcore.RandomizeStr(t.Name())\n+\ttaskQueue := uuid.New().String()\n+\n+\tstartResp, err := s.startActivity(ctx, activityID, taskQueue)\n+\trequire.NoError(t, err)\n+\n+\tpollResp, err := s.FrontendClient().PollActivityExecution(ctx, &workflowservice.PollActivityExecutionRequest{\n+\t\tNamespace:    s.Namespace().String(),\n+\t\tActivityId:   activityID,\n+\t\tRunId:        startResp.RunId,\n+\t\tIncludeInfo:  true,\n+\t\tIncludeInput: true,\n+\t})\n+\trequire.NoError(t, err)\n+\trequire.NotNil(t, pollResp.StateChangeLongPollToken)\n+\trequire.NotNil(t, pollResp.Info)\n+\ts.assertActivityExecutionInfo(\n+\t\tt,\n+\t\tpollResp.Info,\n+\t\tactivityID,\n+\t\tstartResp.RunId,\n+\t\tenumspb.PENDING_ACTIVITY_STATE_SCHEDULED,\n+\t)\n+\trequire.NotNil(t, pollResp.Input)\n+\trequire.Equal(t, \"test-activity-input\", string(pollResp.Input.Payloads[0].Data))\n+\t// TODO(dan): test IncludeOutcome\n+}\n+\n+func (s *standaloneActivityTestSuite) Test_PollActivityExecution_WaitAnyStateChange() {\n+\t// Long poll for any state change. PollActivityTaskQueue is used to cause a state change.\n+\tt := s.T()\n+\tctx, cancel := context.WithTimeout(t.Context(), 10*time.Second)\n+\tdefer cancel()\n+\tactivityID := testcore.RandomizeStr(t.Name())\n+\ttaskQueue := uuid.New().String()\n+\n+\tstartResp, err := s.startActivity(ctx, activityID, taskQueue)\n+\trequire.NoError(t, err)\n+\n+\t// First poll lacks token and therefore responds immediately, returning a token\n+\tfirstPollResp, err := s.FrontendClient().PollActivityExecution(ctx, &workflowservice.PollActivityExecutionRequest{\n+\t\tNamespace:  s.Namespace().String(),\n+\t\tActivityId: activityID,\n+\t\tRunId:      startResp.RunId,\n+\t\tWaitPolicy: &workflowservice.PollActivityExecutionRequest_WaitAnyStateChange{\n+\t\t\tWaitAnyStateChange: &workflowservice.PollActivityExecutionRequest_StateChangeWaitOptions{},\n+\t\t},\n+\t\tIncludeInfo:  true,\n+\t\tIncludeInput: true,\n+\t})\n+\trequire.NoError(t, err)\n+\trequire.NotNil(t, firstPollResp.StateChangeLongPollToken)\n+\trequire.NotNil(t, firstPollResp.Info)\n+\ts.assertActivityExecutionInfo(\n+\t\tt,\n+\t\tfirstPollResp.Info,\n+\t\tactivityID,\n+\t\tstartResp.RunId,\n+\t\tenumspb.PENDING_ACTIVITY_STATE_SCHEDULED,\n+\t)\n+\n+\ttaskQueuePollErr := make(chan error, 1)\n+\tactivityPollDone := make(chan struct{})\n+\tvar activityPollResp *workflowservice.PollActivityExecutionResponse\n+\tvar activityPollErr error\n+\n+\tgo func() {\n+\t\tdefer close(activityPollDone)\n+\t\t// Second poll uses token and therefore waits for a state transition\n+\t\tactivityPollResp, activityPollErr = s.FrontendClient().PollActivityExecution(ctx, &workflowservice.PollActivityExecutionRequest{\n+\t\t\tNamespace:    s.Namespace().String(),\n+\t\t\tActivityId:   activityID,\n+\t\t\tRunId:        startResp.RunId,\n+\t\t\tIncludeInfo:  true,\n+\t\t\tIncludeInput: true,\n+\t\t\tWaitPolicy: &workflowservice.PollActivityExecutionRequest_WaitAnyStateChange{\n+\t\t\t\tWaitAnyStateChange: &workflowservice.PollActivityExecutionRequest_StateChangeWaitOptions{\n+\t\t\t\t\tLongPollToken: firstPollResp.StateChangeLongPollToken,\n+\t\t\t\t},\n+\t\t\t},\n+\t\t})\n+\t}()\n+\n+\t// TODO(dan): race here: subscription might not be established yet\n+\n+\t// Worker picks up activity task, triggering transition (via RecordActivityTaskStarted)\n+\tgo func() {\n+\t\t_, err := s.pollActivityTaskQueue(ctx, taskQueue)\n+\t\ttaskQueuePollErr <- err\n+\t}()\n+\n+\tselect {\n+\tcase <-activityPollDone:\n+\t\trequire.NoError(t, activityPollErr)\n+\t\trequire.NotNil(t, activityPollResp)\n+\t\trequire.NotNil(t, activityPollResp.Info)\n+\t\ts.assertActivityExecutionInfo(\n+\t\t\tt,\n+\t\t\tactivityPollResp.Info,\n+\t\t\tactivityID,\n+\t\t\tstartResp.RunId,\n+\t\t\tenumspb.PENDING_ACTIVITY_STATE_STARTED,\n+\t\t)\n+\t\trequire.NotNil(t, activityPollResp.Input)\n+\t\trequire.Equal(t, \"test-activity-input\", string(activityPollResp.Input.Payloads[0].Data))\n+\n+\tcase <-ctx.Done():\n+\t\tt.Fatal(\"PollActivityExecution timed out\")\n+\t}\n+\n+\terr = <-taskQueuePollErr\n+\trequire.NoError(t, err)\n+\n+\t// Manipulate the token to verify token staleness checks (simulate ErrStaleReference). To do so\n+\t// we make use of the internal implementation detail that the bytes are a serialized ref.\n+\ttoken := firstPollResp.StateChangeLongPollToken\n+\tvar pRef persistencespb.ChasmComponentRef\n+\terr = pRef.Unmarshal(token)\n+\trequire.NoError(t, err)\n+\tif pRef.EntityVersionedTransition != nil {\n+\t\tpRef.EntityVersionedTransition.NamespaceFailoverVersion += 1\n+\t}\n+\ttoken, err = pRef.Marshal()\n+\trequire.NoError(t, err)\n+\n+\t_, err = s.FrontendClient().PollActivityExecution(ctx, &workflowservice.PollActivityExecutionRequest{\n+\t\tNamespace:  s.Namespace().String(),\n+\t\tActivityId: activityID,\n+\t\tRunId:      startResp.RunId,\n+\t\tWaitPolicy: &workflowservice.PollActivityExecutionRequest_WaitAnyStateChange{\n+\t\t\tWaitAnyStateChange: &workflowservice.PollActivityExecutionRequest_StateChangeWaitOptions{\n+\t\t\t\tLongPollToken: token,\n+\t\t\t},\n+\t\t},\n+\t})\n+\trequire.Error(t, err)\n+\trequire.ErrorContains(t, err, \"cached mutable state could potentially be stale\")\n+}\n+\n+func (s *standaloneActivityTestSuite) Test_PollActivityExecution_WaitCompletion() {\n+\tt := s.T()\n+\tt.Skip(\"TODO(dan): implement test when RecordActivityTaskCompleted is implemented\")\n+}\n+\n+func (s *standaloneActivityTestSuite) Test_PollActivityExecution_WaitAnyStateChange_Success_UpdateComponent() {\n+\tt := s.T()\n+\tctx, cancel := context.WithTimeout(t.Context(), 10*time.Second)\n+\tdefer cancel()\n+\tctx = chasm.NewEngineContext(ctx, s.chasmEngine)\n+\n+\tactivityID := testcore.RandomizeStr(t.Name())\n+\ttaskQueue := uuid.New().String()\n+\n+\tstartResp, err := s.startActivity(ctx, activityID, taskQueue)\n+\trequire.NoError(t, err)\n+\tentityKey := chasm.EntityKey{\n+\t\tNamespaceID: s.NamespaceID().String(),\n+\t\tBusinessID:  activityID,\n+\t\tEntityID:    startResp.RunId,\n+\t}\n+\n+\t// Test PollActivityExecution(WaitAnyStateChange) without a long-poll token.\n+\tpollResp, err := s.FrontendClient().PollActivityExecution(ctx, &workflowservice.PollActivityExecutionRequest{\n+\t\tNamespace:  s.Namespace().String(),\n+\t\tActivityId: activityID,\n+\t\tRunId:      startResp.RunId,\n+\t\tWaitPolicy: &workflowservice.PollActivityExecutionRequest_WaitAnyStateChange{\n+\t\t\tWaitAnyStateChange: &workflowservice.PollActivityExecutionRequest_StateChangeWaitOptions{},\n+\t\t},\n+\t})\n+\trequire.NoError(t, err)\n+\trequire.NotNil(t, pollResp.GetStateChangeLongPollToken())\n+\trequire.Equal(t, startResp.GetRunId(), pollResp.GetRunId())\n+\n+\t_, _, err = chasm.UpdateComponent(\n+\t\tctx,\n+\t\tchasm.NewComponentRef[*activity.Activity](entityKey),\n+\t\tfunc(a *activity.Activity, ctx chasm.MutableContext, _ any) (any, error) {\n+\t\t\t// Don't actually mutate; just trigger the notification\n+\t\t\treturn nil, nil\n+\t\t}, nil)\n+\trequire.NoError(t, err)\n+\n+\t// Test PollActivityExecution(WaitAnyStateChange) with a long-poll token.\n+\tsecondPollResp, err := s.FrontendClient().PollActivityExecution(ctx, &workflowservice.PollActivityExecutionRequest{\n+\t\tNamespace:  s.Namespace().String(),\n+\t\tActivityId: activityID,\n+\t\tRunId:      startResp.RunId,\n+\t\tWaitPolicy: &workflowservice.PollActivityExecutionRequest_WaitAnyStateChange{\n+\t\t\tWaitAnyStateChange: &workflowservice.PollActivityExecutionRequest_StateChangeWaitOptions{\n+\t\t\t\tLongPollToken: pollResp.GetStateChangeLongPollToken(),\n+\t\t\t},\n+\t\t},\n+\t})\n+\trequire.NoError(t, err)\n+\trequire.NotNil(t, secondPollResp.StateChangeLongPollToken)\n+}\n+\n+// Test_PollVisibility_UpdateFromParent tests that polling for visibility component is woken up when\n+// the parent activity is updated and modifies the visibility.\n+// TODO(dan): this test uses chasm APIs (ReadComponent, UpdateComponent, PollComponent) directly. Is\n+// this illegitimate in tests/?\n+func (s *standaloneActivityTestSuite) Test_PollVisibility_UpdateFromParent() {\n+\tt := s.T()\n+\tctx, cancel := context.WithTimeout(t.Context(), 10*time.Second)\n+\tdefer cancel()\n+\tctx = chasm.NewEngineContext(ctx, s.chasmEngine)\n+\n+\tactivityID := testcore.RandomizeStr(t.Name())\n+\ttaskQueue := uuid.New().String()\n+\n+\tstartResp, err := s.startActivity(ctx, activityID, taskQueue)\n+\trequire.NoError(t, err)\n+\tentityKey := chasm.EntityKey{\n+\t\tNamespaceID: s.NamespaceID().String(),\n+\t\tBusinessID:  activityID,\n+\t\tEntityID:    startResp.RunId,\n+\t}\n+\n+\tvisibilityRef, err := chasm.ReadComponent(\n+\t\tctx,\n+\t\tchasm.NewComponentRef[*activity.Activity](entityKey),\n+\t\tfunc(a *activity.Activity, ctx chasm.Context, _ any) ([]byte, error) {\n+\t\t\tvisibility, err := a.Visibility.Get(ctx)\n+\t\t\tif err != nil {\n+\t\t\t\treturn nil, err\n+\t\t\t}\n+\t\t\treturn ctx.Ref(visibility)\n+\t\t},\n+\t\tnil,\n+\t)\n+\trequire.NoError(t, err)\n+\trequire.NotNil(t, visibilityRef)\n+\n+\tpollStarted := make(chan struct{})\n+\tpollCompleted := make(chan []byte, 1)\n+\tpollError := make(chan error, 1)\n+\n+\tgo func() {\n+\t\tclose(pollStarted)\n+\n+\t\t_, ref, err := chasm.PollComponent(\n+\t\t\tctx,\n+\t\t\tvisibilityRef,\n+\t\t\tfunc(v *chasm.Visibility, ctx chasm.Context, _ any) (any, bool, error) {\n+\t\t\t\tsa, err := v.SA.Get(ctx)\n+\t\t\t\tif err != nil {\n+\t\t\t\t\treturn nil, false, err\n+\t\t\t\t}\n+\t\t\t\tif sa != nil && len(sa.IndexedFields) > 0 {\n+\t\t\t\t\t// State has changed, stop waiting\n+\t\t\t\t\treturn nil, true, nil\n+\t\t\t\t}\n+\t\t\t\t// State hasn't changed yet, keep waiting\n+\t\t\t\treturn nil, false, nil\n+\t\t\t},\n+\t\t\tnil,\n+\t\t)\n+\t\tif err != nil {\n+\t\t\tpollError <- err\n+\t\t} else {\n+\t\t\tpollCompleted <- ref\n+\t\t}\n+\t}()\n+\n+\t<-pollStarted\n+\t// Hope that subscription has been established after an arbitrary amount of time\n+\t// TODO(dan)\n+\ttime.Sleep(100 * time.Millisecond)\n+\n+\t// Modify the visibility component via an update targeting its parent activity component\n+\t_, _, err = chasm.UpdateComponent(\n+\t\tctx,\n+\t\tchasm.NewComponentRef[*activity.Activity](entityKey),\n+\t\tfunc(a *activity.Activity, ctx chasm.MutableContext, _ any) (any, error) {\n+\t\t\tvisibility, err := a.Visibility.Get(ctx)\n+\t\t\tif err != nil {\n+\t\t\t\treturn nil, err\n+\t\t\t}\n+\t\t\tvisibility.SA = chasm.NewDataField(ctx, &commonpb.SearchAttributes{\n+\t\t\t\tIndexedFields: map[string]*commonpb.Payload{\n+\t\t\t\t\t\"TestField\": payload.EncodeString(\"updated from parent\"),\n+\t\t\t\t},\n+\t\t\t})\n+\t\t\treturn nil, nil\n+\t\t}, nil)\n+\trequire.NoError(t, err)\n+\n+\tselect {\n+\tcase ref := <-pollCompleted:\n+\t\trequire.NotNil(t, ref)\n+\tcase err := <-pollError:\n+\t\tt.Fatalf(\"Poll failed with error: %v\", err)\n+\tcase <-time.After(5 * time.Second):\n+\t\tt.Fatal(\"Poll did not complete within timeout\")\n+\t}\n+}\n+\n+func (s *standaloneActivityTestSuite) assertActivityExecutionInfo(","path":"tests/standalone_activity_test.go","commit_id":"1d59e66d0ce5d91819f92c428ef5ab4c4efca1fb","original_commit_id":"da6009564e796063faf853352077eecdc1473612","user":{"login":"bergundy","id":52304,"node_id":"MDQ6VXNlcjUyMzA0","avatar_url":"https://avatars.githubusercontent.com/u/52304?v=4","gravatar_id":"","url":"https://api.github.com/users/bergundy","html_url":"https://github.com/bergundy","followers_url":"https://api.github.com/users/bergundy/followers","following_url":"https://api.github.com/users/bergundy/following{/other_user}","gists_url":"https://api.github.com/users/bergundy/gists{/gist_id}","starred_url":"https://api.github.com/users/bergundy/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/bergundy/subscriptions","organizations_url":"https://api.github.com/users/bergundy/orgs","repos_url":"https://api.github.com/users/bergundy/repos","events_url":"https://api.github.com/users/bergundy/events{/privacy}","received_events_url":"https://api.github.com/users/bergundy/received_events","type":"User","user_view_type":"public","site_admin":false},"body":"I am not a fan of this type of test helper. It makes it harder to understand what a test is actually asserting. Tests can (and I'd argue) should be verbose and as easy to read and debug as possible.","created_at":"2025-11-19T01:17:01Z","updated_at":"2025-11-19T01:17:28Z","html_url":"https://github.com/temporalio/temporal/pull/8563#discussion_r2540114706","pull_request_url":"https://api.github.com/repos/temporalio/temporal/pulls/8563","_links":{"self":{"href":"https://api.github.com/repos/temporalio/temporal/pulls/comments/2540114706"},"html":{"href":"https://github.com/temporalio/temporal/pull/8563#discussion_r2540114706"},"pull_request":{"href":"https://api.github.com/repos/temporalio/temporal/pulls/8563"}},"reactions":{"url":"https://api.github.com/repos/temporalio/temporal/pulls/comments/2540114706/reactions","total_count":0,"+1":0,"-1":0,"laugh":0,"hooray":0,"confused":0,"heart":0,"rocket":0,"eyes":0},"start_line":null,"original_start_line":null,"start_side":null,"line":689,"original_line":424,"side":"RIGHT","author_association":"MEMBER","original_position":356,"position":680,"subject_type":"line"},{"url":"https://api.github.com/repos/temporalio/temporal/pulls/comments/2540118562","pull_request_review_id":3480312648,"id":2540118562,"node_id":"PRRC_kwDODNqesM6XZyIi","diff_hunk":"@@ -204,9 +235,17 @@ func (e *ChasmEngine) UpdateComponent(\n \t\treturn nil, serviceerror.NewInternalf(\"componentRef: %+v: %s\", ref, err)\n \t}\n \n+\te.notifier.Notify(&ChasmComponentNotification{\n+\t\tKey: ref.EntityKey,\n+\t\tRef: newSerializedRef,\n+\t})","path":"service/history/chasm_engine.go","commit_id":"da6009564e796063faf853352077eecdc1473612","original_commit_id":"eb1ded5ef804505544b0ab631d660b43072ee6f6","user":{"login":"dandavison","id":52205,"node_id":"MDQ6VXNlcjUyMjA1","avatar_url":"https://avatars.githubusercontent.com/u/52205?v=4","gravatar_id":"","url":"https://api.github.com/users/dandavison","html_url":"https://github.com/dandavison","followers_url":"https://api.github.com/users/dandavison/followers","following_url":"https://api.github.com/users/dandavison/following{/other_user}","gists_url":"https://api.github.com/users/dandavison/gists{/gist_id}","starred_url":"https://api.github.com/users/dandavison/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/dandavison/subscriptions","organizations_url":"https://api.github.com/users/dandavison/orgs","repos_url":"https://api.github.com/users/dandavison/repos","events_url":"https://api.github.com/users/dandavison/events{/privacy}","received_events_url":"https://api.github.com/users/dandavison/received_events","type":"User","user_view_type":"public","site_admin":false},"body":"Offline @yycptt pointed out that the current implementation in this PR will not notify when an execution is updated by a pure task. I'm looking into doing this from `transactionImpl`.","created_at":"2025-11-19T01:19:28Z","updated_at":"2025-11-19T01:19:28Z","html_url":"https://github.com/temporalio/temporal/pull/8563#discussion_r2540118562","pull_request_url":"https://api.github.com/repos/temporalio/temporal/pulls/8563","_links":{"self":{"href":"https://api.github.com/repos/temporalio/temporal/pulls/comments/2540118562"},"html":{"href":"https://github.com/temporalio/temporal/pull/8563#discussion_r2540118562"},"pull_request":{"href":"https://api.github.com/repos/temporalio/temporal/pulls/8563"}},"reactions":{"url":"https://api.github.com/repos/temporalio/temporal/pulls/comments/2540118562/reactions","total_count":0,"+1":0,"-1":0,"laugh":0,"hooray":0,"confused":0,"heart":0,"rocket":0,"eyes":0},"start_line":null,"original_start_line":null,"start_side":null,"line":null,"original_line":241,"side":"RIGHT","in_reply_to_id":2519344176,"author_association":"MEMBER","original_position":96,"position":1,"subject_type":"line"},{"url":"https://api.github.com/repos/temporalio/temporal/pulls/comments/2546978804","pull_request_review_id":3489038133,"id":2546978804,"node_id":"PRRC_kwDODNqesM6Xz8_0","diff_hunk":"@@ -155,7 +155,9 @@ func (e *startToCloseTimeoutTaskExecutor) Execute(\n ) error {\n \tretryPolicy := activity.RetryPolicy\n \n-\tenoughAttempts := retryPolicy.GetMaximumAttempts() == 0 || task.GetAttempt() < retryPolicy.GetMaximumAttempts()\n+\t// Only retry if MaximumAttempts is explicitly set to > 1 (0 means no retries for start-to-close timeouts)\n+\t// Note: MaximumAttempts == 0 should mean no retries, not unlimited retries for timeouts\n+\tenoughAttempts := retryPolicy.GetMaximumAttempts() > 1 && task.GetAttempt() < retryPolicy.GetMaximumAttempts()","path":"chasm/lib/activity/activity_tasks.go","commit_id":"7fdded5aec1efc28fa9cb0ae9c3697188b1834df","original_commit_id":"109a90fe02cb145ef9d0481242c354b066ca027d","user":{"login":"cursor[bot]","id":206951365,"node_id":"BOT_kgDODFXTxQ","avatar_url":"https://avatars.githubusercontent.com/in/1210556?v=4","gravatar_id":"","url":"https://api.github.com/users/cursor%5Bbot%5D","html_url":"https://github.com/apps/cursor","followers_url":"https://api.github.com/users/cursor%5Bbot%5D/followers","following_url":"https://api.github.com/users/cursor%5Bbot%5D/following{/other_user}","gists_url":"https://api.github.com/users/cursor%5Bbot%5D/gists{/gist_id}","starred_url":"https://api.github.com/users/cursor%5Bbot%5D/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/cursor%5Bbot%5D/subscriptions","organizations_url":"https://api.github.com/users/cursor%5Bbot%5D/orgs","repos_url":"https://api.github.com/users/cursor%5Bbot%5D/repos","events_url":"https://api.github.com/users/cursor%5Bbot%5D/events{/privacy}","received_events_url":"https://api.github.com/users/cursor%5Bbot%5D/received_events","type":"Bot","user_view_type":"public","site_admin":false},"body":"### Bug: Incorrect retry logic for start-to-close timeout\n\n<!-- **Medium Severity** -->\n\n<!-- DESCRIPTION START -->\nThe retry logic for start-to-close timeouts incorrectly treats `MaximumAttempts == 0` as \"no retries\" when it should mean \"unlimited retries\" according to Temporal's retry policy semantics. The condition `retryPolicy.GetMaximumAttempts() > 1` prevents retries when `MaximumAttempts` is 0 (the default for unlimited retries) or 1 (no retries). The original logic `MaximumAttempts == 0 || attempt < MaximumAttempts` correctly handled unlimited retries when the value is 0. This breaks the standard Temporal retry behavior where 0 means unlimited attempts.\n<!-- DESCRIPTION END -->\n\n<!-- LOCATIONS START\nchasm/lib/activity/activity_tasks.go#L157-L160\nLOCATIONS END -->\n<a href=\"https://cursor.com/open?data=eyJhbGciOiJSUzI1NiIsInR5cCI6IkpXVCIsImtpZCI6ImJ1Z2JvdC12MSJ9.eyJ2ZXJzaW9uIjoxLCJ0eXBlIjoiQlVHQk9UX0ZJWF9JTl9DVVJTT1IiLCJkYXRhIjp7InJlZGlzS2V5IjoiYnVnYm90OmU2YjVhZDRjLTI0ODYtNDE2MC05MzdmLWFhMzg4OWU5NGYxZiIsImVuY3J5cHRpb25LZXkiOiJrQ3VtOGFJZG82VWoxSTJSeG1paHl4UEEzN2JqZEhQZkxRV0ZKd1lnNzJnIiwiYnJhbmNoIjoicG9sbC1jb21wb25lbnQifSwiaWF0IjoxNzYzNjU5NTc2LCJleHAiOjE3NjQyNjQzNzZ9.HFO-czH3xAwgPt7v5ZyORLLV-rQnkTk5MUTNa40I8jQHejyHa6rt-X0b4LJIh_jH85UWLEYoKW5IrDGsBolPV3xrFi1jVbXPj-cHJW7N0HNgtHUkJqp4kgcOV4HiPCdujvsJPfZ7wAuMtC3l4qIeDgp4avqAsgnY3nVY5yroNxafyGMb0QhtiG4WXm_2w5LU0vA4ApV9-fmEEcG9C1nfzAhKEMcB8RE1E8w6_LGRl251dpg5mEn8B61mfBqrKIYlETtMxvp3HVsZxpmYhmq0MFA8zXWv5ofW3tmoHG-5mUP029J72-coj2YJsEqHDjLzsSqgvn5tse5szrxLe1fDog\"><picture><source media=\"(prefers-color-scheme: dark)\" srcset=\"https://cursor.com/fix-in-cursor-dark.svg\"><source media=\"(prefers-color-scheme: light)\" srcset=\"https://cursor.com/fix-in-cursor-light.svg\"><img alt=\"Fix in Cursor\" src=\"https://cursor.com/fix-in-cursor.svg\"></picture></a>&nbsp;<a href=\"https://cursor.com/agents?data=eyJhbGciOiJSUzI1NiIsInR5cCI6IkpXVCIsImtpZCI6ImJ1Z2JvdC12MSJ9.eyJ2ZXJzaW9uIjoxLCJ0eXBlIjoiQlVHQk9UX0ZJWF9JTl9XRUIiLCJkYXRhIjp7InJlZGlzS2V5IjoiYnVnYm90OmU2YjVhZDRjLTI0ODYtNDE2MC05MzdmLWFhMzg4OWU5NGYxZiIsImVuY3J5cHRpb25LZXkiOiJrQ3VtOGFJZG82VWoxSTJSeG1paHl4UEEzN2JqZEhQZkxRV0ZKd1lnNzJnIiwiYnJhbmNoIjoicG9sbC1jb21wb25lbnQiLCJyZXBvT3duZXIiOiJ0ZW1wb3JhbGlvIiwicmVwb05hbWUiOiJ0ZW1wb3JhbCIsInByTnVtYmVyIjo4NTYzLCJjb21taXRTaGEiOiIxMDlhOTBmZTAyY2IxNDVlZjlkMDQ4MTI0MmMzNTRiMDY2Y2EwMjdkIn0sImlhdCI6MTc2MzY1OTU3NiwiZXhwIjoxNzY0MjY0Mzc2fQ.VLGifyLIMKV4H0GxdTJi7A4K-t2meu4KgJ2iXjIlpCK_7dPpEjZ0v0co7gHKH4yil9-3hfi88-qbJ37gyW2jnqvAOkzhNRfzjqEjpOs6Kzzu0-JWKqugtq0HOT4z7TVBeTwNe74uRA9S2lifcdS5BvYWd7aDupUqoDk-IkqU3dS3kS5CZfVeyqCuflHyUG7L9N8D5R0Oa5kTSEuVZ92VAkXnBFTRLU9jnwl2yV7th38V5y6fM4eubszwp2g0s3ebtTJCZTHbnMH9nB9bmlaRI4krtLs2JVW2vRmuySPqvnOzTTvrXd32hpWh6AdAFrMySEo6l4H9nRaAJIG52KCLAg\"><picture><source media=\"(prefers-color-scheme: dark)\" srcset=\"https://cursor.com/fix-in-web-dark.svg\"><source media=\"(prefers-color-scheme: light)\" srcset=\"https://cursor.com/fix-in-web-light.svg\"><img alt=\"Fix in Web\" src=\"https://cursor.com/fix-in-web.svg\"></picture></a>\n\n","created_at":"2025-11-20T17:26:17Z","updated_at":"2025-11-20T17:26:17Z","html_url":"https://github.com/temporalio/temporal/pull/8563#discussion_r2546978804","pull_request_url":"https://api.github.com/repos/temporalio/temporal/pulls/8563","_links":{"self":{"href":"https://api.github.com/repos/temporalio/temporal/pulls/comments/2546978804"},"html":{"href":"https://github.com/temporalio/temporal/pull/8563#discussion_r2546978804"},"pull_request":{"href":"https://api.github.com/repos/temporalio/temporal/pulls/8563"}},"reactions":{"url":"https://api.github.com/repos/temporalio/temporal/pulls/comments/2546978804/reactions","total_count":0,"+1":0,"-1":0,"laugh":0,"hooray":0,"confused":0,"heart":0,"rocket":0,"eyes":0},"start_line":null,"original_start_line":null,"start_side":null,"line":null,"original_line":160,"side":"RIGHT","author_association":"NONE","original_position":7,"position":1,"subject_type":"line"},{"url":"https://api.github.com/repos/temporalio/temporal/pulls/comments/2546978812","pull_request_review_id":3489038133,"id":2546978812,"node_id":"PRRC_kwDODNqesM6Xz8_8","diff_hunk":"@@ -241,14 +278,196 @@ func (e *ChasmEngine) ReadComponent(\n \treturn readFn(chasmContext, component)\n }\n \n+// PollComponent waits until the supplied predicate is satisfied when evaluated against the\n+// component identified by the supplied component reference. If it times out due to the\n+// server-imposed long-poll timeout then it returns (nil, nil). Otherwise if there is no error, it\n+// returns (ref, nil) where ref is a component reference identifying the state at which the\n+// predicate was satisfied. It is an error if execution transition history is (after reloading from\n+// persistence) behind the requested ref, or if the ref is inconsistent with execution transition\n+// history. Thus when the predicate function is evaluated, it is guaranteed that the execution VT >=\n+// requestRef VT.\n func (e *ChasmEngine) PollComponent(\n \tctx context.Context,\n-\tentityRef chasm.ComponentRef,\n-\tpredicateFn func(chasm.Context, chasm.Component) (any, bool, error),\n-\toperationFn func(chasm.MutableContext, chasm.Component, any) error,\n-\topts ...chasm.TransitionOption,\n-) (newEntityRef []byte, retError error) {\n-\treturn nil, serviceerror.NewUnimplemented(\"PollComponent is not yet supported\")\n+\trequestRef chasm.ComponentRef,\n+\tpredicateFn func(chasm.Context, chasm.Component) (bool, error),\n+) (retRef []byte, retError error) {\n+\t// 1. Acquire lock\n+\t// 2. Error if shard execution VT < requestRef VT ('stale state')\n+\t// 3. If predicate satisfied, release lock and return\n+\t// 4. Subscribe to notifications for this execution\n+\t// 5. Release lock\n+\t// 6. On notification repeat (1) and (2)\n+\n+\tdefer func() {\n+\t\tif retError != nil {\n+\t\t\tfmt.Println(\" PollComponent: returning with error\", retError)\n+\t\t} else {\n+\t\t\tfmt.Println(\" PollComponent: returning successfully\")\n+\t\t}\n+\t}()\n+\n+\tshardContext, executionLease, err := e.getExecutionLease(ctx, requestRef)\n+\tif err != nil {\n+\t\t// E.g. requestRef VT inconsistent with shard VT ('stale reference')\n+\t\treturn nil, err\n+\t}\n+\n+\t// hold lock until return or subscription established\n+\treleased := false\n+\tdefer func() {\n+\t\tif !released {\n+\t\t\t// read-only operation; don't pass error\n+\t\t\texecutionLease.GetReleaseFn()(nil)\n+\t\t}\n+\t}()\n+\n+\t// At this point it's possible that shard VT < requestRef VT (getExecutionLease does not\n+\t// guarantee that returned shard state is non-stale w.r.t. requestRef).\n+\tsatisfiedRef, err := e.predicateSatisfied(ctx, requestRef, executionLease, predicateFn)\n+\tif err != nil {\n+\t\treturn nil, err\n+\t}\n+\t// shard VT >= requestRef VT (enforced by checkPredicate)\n+\n+\tif satisfiedRef != nil {\n+\t\t// wait condition was satisfied\n+\t\treturn satisfiedRef, nil\n+\t}\n+\n+\t// Wait condition not satisfied; long-poll\n+\n+\t// TODO(dan) For now, UpdateComponent emits execution-level notifications, and PollComponent\n+\t// subscribes to execution-level notifications. This means that PollComponent may be woken up\n+\t// unnecessarily, but it will not miss notifications. In the future we may want to change\n+\t// PollComponent to subscribe to component-level notifications, and change UpdateComponent so\n+\t// that notifications are emitted only for nodes that were mutated in the transaction.\n+\tchannel, subscriberID, err := e.notifier.Subscribe(requestRef.EntityKey)\n+\tif err != nil {\n+\t\treturn nil, err\n+\t}\n+\tdefer func() {\n+\t\t_ = e.notifier.Unsubscribe(requestRef.EntityKey, subscriberID)\n+\t}()\n+\n+\t// Release the lock, now that we are subscribed\n+\texecutionLease.GetReleaseFn()(nil)\n+\treleased = true\n+\n+\tnamespaceRegistry, err := shardContext.GetNamespaceRegistry().GetNamespaceByID(\n+\t\tnamespace.ID(requestRef.EntityKey.NamespaceID),\n+\t)\n+\tif err != nil {\n+\t\treturn nil, err\n+\t}\n+\n+\t// If the long-poll times out due to the internally-imposed long-poll timeout, then we want the\n+\t// initiator of the long-poll to receive a non-error empty response indicating that they should\n+\t// continue long-polling. To achieve this, we return nil on all canceled context errors below.\n+\t// We assume that the parent will check for a canceled context independently (without relying on\n+\t// any error value we return), so that if the cancelation was due to the parent deadline rather\n+\t// than the internally-imposed long-poll timeout then the initiator of the long-poll will get a\n+\t// deadline exceeded error.\n+\n+\tif deadline, ok := ctx.Deadline(); ok {\n+\t\tfmt.Println(\"  PollComponent: parent has deadline\", time.Until(deadline))\n+\t}\n+\n+\tinternalLongPollTimeout := shardContext.GetConfig().LongPollExpirationInterval(namespaceRegistry.Name().String())\n+\n+\tfmt.Println(\"  PollComponent: internal long poll timeout\", internalLongPollTimeout)\n+\n+\tctx, cancel := context.WithTimeout(ctx, internalLongPollTimeout)\n+\tdefer cancel()\n+\tif stDeadline, ok := ctx.Deadline(); ok {\n+\t\tfmt.Println(\"  PollComponent: after applying internal long poll timeout has deadline\", time.Until(stDeadline))\n+\t}\n+\tfor {\n+\t\tselect {\n+\t\tcase notification := <-channel:\n+\t\t\tif notification == nil {\n+\t\t\t\treturn nil, serviceerror.NewInternal(\"nil component notification\")\n+\t\t\t}\n+\t\t\t_, executionLease, err := e.getExecutionLease(ctx, requestRef)\n+\t\t\tif err != nil {\n+\t\t\t\tif errors.Is(err, ctx.Err()) {\n+\t\t\t\t\tfmt.Println(\" PollComponent: server-imposed timeout I\")\n+\t\t\t\t\treturn nil, nil\n+\t\t\t\t}\n+\t\t\t\treturn nil, err\n+\t\t\t}\n+\t\t\tfunc() {\n+\t\t\t\tdefer executionLease.GetReleaseFn()(nil)\n+\t\t\t\tsatisfiedRef, err = e.predicateSatisfied(ctx, requestRef, executionLease, predicateFn)\n+\t\t\t}()\n+\t\t\tif err != nil {\n+\t\t\t\tif errors.Is(err, ctx.Err()) {\n+\t\t\t\t\tfmt.Println(\" PollComponent: server-imposed timeout II\")\n+\t\t\t\t\treturn nil, nil\n+\t\t\t\t}\n+\t\t\t\treturn nil, err\n+\t\t\t}\n+\t\t\tif satisfiedRef != nil {\n+\t\t\t\treturn satisfiedRef, nil\n+\t\t\t}\n+\t\tcase <-ctx.Done():\n+\t\t\tfmt.Println(\" PollComponent: server-imposed timeout III\")","path":"service/history/chasm_engine.go","commit_id":"9f8d762f3279f3b16d2217ae254bb3f85df69b44","original_commit_id":"109a90fe02cb145ef9d0481242c354b066ca027d","user":{"login":"cursor[bot]","id":206951365,"node_id":"BOT_kgDODFXTxQ","avatar_url":"https://avatars.githubusercontent.com/in/1210556?v=4","gravatar_id":"","url":"https://api.github.com/users/cursor%5Bbot%5D","html_url":"https://github.com/apps/cursor","followers_url":"https://api.github.com/users/cursor%5Bbot%5D/followers","following_url":"https://api.github.com/users/cursor%5Bbot%5D/following{/other_user}","gists_url":"https://api.github.com/users/cursor%5Bbot%5D/gists{/gist_id}","starred_url":"https://api.github.com/users/cursor%5Bbot%5D/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/cursor%5Bbot%5D/subscriptions","organizations_url":"https://api.github.com/users/cursor%5Bbot%5D/orgs","repos_url":"https://api.github.com/users/cursor%5Bbot%5D/repos","events_url":"https://api.github.com/users/cursor%5Bbot%5D/events{/privacy}","received_events_url":"https://api.github.com/users/cursor%5Bbot%5D/received_events","type":"Bot","user_view_type":"public","site_admin":false},"body":"### Bug: Debug print statements in production code\n\n<!-- **Low Severity** -->\n\n<!-- DESCRIPTION START -->\nMultiple debug `fmt.Println` statements with emoji markers are present in the `PollComponent` and `predicateSatisfied` methods. These debugging statements print internal state information like \" PollComponent: returning with error\", \" PollComponent: parent has deadline\", \" PollComponent: server-imposed timeout\", and \" checkPredicate\". These should be removed before merging to production as they pollute logs and expose internal implementation details.\n<!-- DESCRIPTION END -->\n\n<!-- LOCATIONS START\nservice/history/chasm_engine.go#L302-L413\nLOCATIONS END -->\n<a href=\"https://cursor.com/open?data=eyJhbGciOiJSUzI1NiIsInR5cCI6IkpXVCIsImtpZCI6ImJ1Z2JvdC12MSJ9.eyJ2ZXJzaW9uIjoxLCJ0eXBlIjoiQlVHQk9UX0ZJWF9JTl9DVVJTT1IiLCJkYXRhIjp7InJlZGlzS2V5IjoiYnVnYm90OjNhMzMzZmFjLTI0OGQtNDE1MS05YzU4LWMyNGE0MzhmMmQ4NCIsImVuY3J5cHRpb25LZXkiOiI3X2xXRUNRajVlZTYzQW5jQWtCMWJhc3hVOWs5dUdoYmZjeUQxSkRVZURvIiwiYnJhbmNoIjoicG9sbC1jb21wb25lbnQifSwiaWF0IjoxNzYzNjU5NTc2LCJleHAiOjE3NjQyNjQzNzZ9.PNCIMUm7CU1nhjvFYQNpx1bIzO2cIh9Oy33Etc_nRGmK6pdJ4gXth0hbdinYnEjJEnkD1W2wFJR7w1-SrLO41mlPIMXxHcxz1Y5K6Qwn6my0AyUi9DfDrc6mvYu7NFA4zzXCV6m4BxqhQ9rlIguYr0auwjsLXog9OxoNYojzGYVfRisuqVM0Gw3nPVibEnfKkNCWk_0WtZGBMQZVYp6BpdUS4qeMV4Tt2NNONjMOlgHssXXT5Gf-JgSzvmvvpcIcvGeW_d0mrd9iQe_P4aMMtPDvsRnXW2383n583fz4o1LQPapJUrODj05XxKk6Ma7PmVkDwWDla2EFcDuietv8cQ\"><picture><source media=\"(prefers-color-scheme: dark)\" srcset=\"https://cursor.com/fix-in-cursor-dark.svg\"><source media=\"(prefers-color-scheme: light)\" srcset=\"https://cursor.com/fix-in-cursor-light.svg\"><img alt=\"Fix in Cursor\" src=\"https://cursor.com/fix-in-cursor.svg\"></picture></a>&nbsp;<a href=\"https://cursor.com/agents?data=eyJhbGciOiJSUzI1NiIsInR5cCI6IkpXVCIsImtpZCI6ImJ1Z2JvdC12MSJ9.eyJ2ZXJzaW9uIjoxLCJ0eXBlIjoiQlVHQk9UX0ZJWF9JTl9XRUIiLCJkYXRhIjp7InJlZGlzS2V5IjoiYnVnYm90OjNhMzMzZmFjLTI0OGQtNDE1MS05YzU4LWMyNGE0MzhmMmQ4NCIsImVuY3J5cHRpb25LZXkiOiI3X2xXRUNRajVlZTYzQW5jQWtCMWJhc3hVOWs5dUdoYmZjeUQxSkRVZURvIiwiYnJhbmNoIjoicG9sbC1jb21wb25lbnQiLCJyZXBvT3duZXIiOiJ0ZW1wb3JhbGlvIiwicmVwb05hbWUiOiJ0ZW1wb3JhbCIsInByTnVtYmVyIjo4NTYzLCJjb21taXRTaGEiOiIxMDlhOTBmZTAyY2IxNDVlZjlkMDQ4MTI0MmMzNTRiMDY2Y2EwMjdkIn0sImlhdCI6MTc2MzY1OTU3NiwiZXhwIjoxNzY0MjY0Mzc2fQ.h_8Cm3MTknWuyBML6q7zbfJqoWZ13SN4VgCZZAcr-uGZusONyqNtiJtvub8bOFDtJPSdOCzX01xslDYp4V5pIe7hcdHojN0gp3H5AvbGLR1jnfZBI-BzuXnxpvA15TlanVYB1PR2ANLWKGy779yBX_eHilTHhql9PPYSUpRDMlLy3OjUd_3gal8K_bVxRNhN4cmAR-AutR3of4AwW0tScZEUuTKVoDxk7rLhPCbXASmBBlbgJkVjMjCGE3Q0A5nWxlNj8RSPbYJYRRJ8LYQBAS1ceasF1TNwM7Wgv63eKFg5K8updLajeJrwKRe6JwblSpAzGl52v8LX8eteKTmRNQ\"><picture><source media=\"(prefers-color-scheme: dark)\" srcset=\"https://cursor.com/fix-in-web-dark.svg\"><source media=\"(prefers-color-scheme: light)\" srcset=\"https://cursor.com/fix-in-web-light.svg\"><img alt=\"Fix in Web\" src=\"https://cursor.com/fix-in-web.svg\"></picture></a>\n\n","created_at":"2025-11-20T17:26:17Z","updated_at":"2025-11-20T17:26:17Z","html_url":"https://github.com/temporalio/temporal/pull/8563#discussion_r2546978812","pull_request_url":"https://api.github.com/repos/temporalio/temporal/pulls/8563","_links":{"self":{"href":"https://api.github.com/repos/temporalio/temporal/pulls/comments/2546978812"},"html":{"href":"https://github.com/temporalio/temporal/pull/8563#discussion_r2546978812"},"pull_request":{"href":"https://api.github.com/repos/temporalio/temporal/pulls/8563"}},"reactions":{"url":"https://api.github.com/repos/temporalio/temporal/pulls/comments/2546978812/reactions","total_count":0,"+1":0,"-1":0,"laugh":0,"hooray":0,"confused":0,"heart":0,"rocket":0,"eyes":0},"start_line":null,"original_start_line":null,"start_side":null,"line":null,"original_line":413,"side":"RIGHT","author_association":"NONE","original_position":238,"position":1,"subject_type":"line"},{"url":"https://api.github.com/repos/temporalio/temporal/pulls/comments/2547528847","pull_request_review_id":3489746627,"id":2547528847,"node_id":"PRRC_kwDODNqesM6X2DSP","diff_hunk":"@@ -314,3 +315,123 @@ func (a *Activity) RecordHeartbeat(ctx chasm.MutableContext, details *commonpb.P\n \t})\n \treturn nil, nil\n }\n+\n+func (a *Activity) buildActivityExecutionInfo(ctx chasm.Context) (*activity.ActivityExecutionInfo, error) {\n+\tif a.ActivityState == nil {\n+\t\treturn nil, errors.New(\"activity state is nil\")\n+\t}\n+\n+\t// TODO(dan): support pause states\n+\tvar status enumspb.ActivityExecutionStatus\n+\tvar runState enumspb.PendingActivityState\n+\tswitch a.GetStatus() {\n+\tcase activitypb.ACTIVITY_EXECUTION_STATUS_UNSPECIFIED:\n+\t\tstatus = enumspb.ACTIVITY_EXECUTION_STATUS_UNSPECIFIED\n+\t\trunState = enumspb.PENDING_ACTIVITY_STATE_UNSPECIFIED\n+\tcase activitypb.ACTIVITY_EXECUTION_STATUS_SCHEDULED:\n+\t\tstatus = enumspb.ACTIVITY_EXECUTION_STATUS_RUNNING\n+\t\trunState = enumspb.PENDING_ACTIVITY_STATE_SCHEDULED\n+\tcase activitypb.ACTIVITY_EXECUTION_STATUS_STARTED:\n+\t\tstatus = enumspb.ACTIVITY_EXECUTION_STATUS_RUNNING\n+\t\trunState = enumspb.PENDING_ACTIVITY_STATE_STARTED\n+\tcase activitypb.ACTIVITY_EXECUTION_STATUS_CANCEL_REQUESTED:\n+\t\tstatus = enumspb.ACTIVITY_EXECUTION_STATUS_RUNNING\n+\t\trunState = enumspb.PENDING_ACTIVITY_STATE_CANCEL_REQUESTED\n+\tcase activitypb.ACTIVITY_EXECUTION_STATUS_COMPLETED:\n+\t\tstatus = enumspb.ACTIVITY_EXECUTION_STATUS_COMPLETED\n+\t\trunState = enumspb.PENDING_ACTIVITY_STATE_UNSPECIFIED\n+\tcase activitypb.ACTIVITY_EXECUTION_STATUS_FAILED:\n+\t\tstatus = enumspb.ACTIVITY_EXECUTION_STATUS_FAILED\n+\t\trunState = enumspb.PENDING_ACTIVITY_STATE_UNSPECIFIED\n+\tcase activitypb.ACTIVITY_EXECUTION_STATUS_CANCELED:\n+\t\tstatus = enumspb.ACTIVITY_EXECUTION_STATUS_CANCELED\n+\t\trunState = enumspb.PENDING_ACTIVITY_STATE_UNSPECIFIED\n+\tcase activitypb.ACTIVITY_EXECUTION_STATUS_TERMINATED:\n+\t\tstatus = enumspb.ACTIVITY_EXECUTION_STATUS_TERMINATED\n+\t\trunState = enumspb.PENDING_ACTIVITY_STATE_UNSPECIFIED\n+\tcase activitypb.ACTIVITY_EXECUTION_STATUS_TIMED_OUT:\n+\t\tstatus = enumspb.ACTIVITY_EXECUTION_STATUS_TIMED_OUT\n+\t\trunState = enumspb.PENDING_ACTIVITY_STATE_UNSPECIFIED\n+\tdefault:\n+\t\treturn nil, serviceerror.NewInternalf(\"unknown activity execution status: %s\", a.GetStatus())\n+\t}\n+\n+\trequestData, err := a.RequestData.Get(ctx)\n+\tif err != nil {\n+\t\treturn nil, err\n+\t}\n+\n+\tkey := ctx.ExecutionKey()\n+\n+\tinfo := &activity.ActivityExecutionInfo{\n+\t\tActivityId:    key.BusinessID,\n+\t\tRunId:         key.EntityID,\n+\t\tActivityType:  a.GetActivityType(),\n+\t\tStatus:        status,\n+\t\tRunState:      runState,\n+\t\tScheduledTime: a.GetScheduledTime(),\n+\t\tPriority:      a.GetPriority(),\n+\t\tHeader:        requestData.GetHeader(),\n+\t\t// TODO(dan): populate remaining fields\n+\t}\n+\n+\treturn info, nil\n+}\n+\n+func (a *Activity) buildPollActivityExecutionResponse(\n+\tctx chasm.Context,\n+\treq *activitypb.PollActivityExecutionRequest,","path":"chasm/lib/activity/activity.go","commit_id":"1d59e66d0ce5d91819f92c428ef5ab4c4efca1fb","original_commit_id":"da6009564e796063faf853352077eecdc1473612","user":{"login":"dandavison","id":52205,"node_id":"MDQ6VXNlcjUyMjA1","avatar_url":"https://avatars.githubusercontent.com/u/52205?v=4","gravatar_id":"","url":"https://api.github.com/users/dandavison","html_url":"https://github.com/dandavison","followers_url":"https://api.github.com/users/dandavison/followers","following_url":"https://api.github.com/users/dandavison/following{/other_user}","gists_url":"https://api.github.com/users/dandavison/gists{/gist_id}","starred_url":"https://api.github.com/users/dandavison/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/dandavison/subscriptions","organizations_url":"https://api.github.com/users/dandavison/orgs","repos_url":"https://api.github.com/users/dandavison/repos","events_url":"https://api.github.com/users/dandavison/events{/privacy}","received_events_url":"https://api.github.com/users/dandavison/received_events","type":"User","user_view_type":"public","site_admin":false},"body":"I get the thinking but I'm not sure it's an improvement:\r\n\r\n(1) It feels more correct for a `chasm/lib/activity` function to have `activitypb` input and output\r\n\r\n(2) The change you're proposing would turn this:\r\n\r\n```go\r\n\tif waitPolicy == nil {\r\n\t\treturn chasm.ReadComponent(ctx, ref, (*Activity).buildPollActivityExecutionResponse, req, nil)\r\n\t}\r\n```\r\ninto this:\r\n```go\r\n\tif waitPolicy == nil {\r\n\t\tresponse, err := chasm.ReadComponent(ctx, ref, (*Activity).buildPollActivityExecutionResponse, req.GetFrontendRequest(), nil)\r\n\t\tif err != nil {\r\n\t\t\treturn nil, err\r\n\t\t}\r\n\t\treturn &activitypb.PollActivityExecutionResponse{\r\n\t\t\tFrontendResponse: response,\r\n\t\t}, nil\r\n\t}\r\n```","created_at":"2025-11-20T20:10:44Z","updated_at":"2025-12-01T18:46:27Z","html_url":"https://github.com/temporalio/temporal/pull/8563#discussion_r2547528847","pull_request_url":"https://api.github.com/repos/temporalio/temporal/pulls/8563","_links":{"self":{"href":"https://api.github.com/repos/temporalio/temporal/pulls/comments/2547528847"},"html":{"href":"https://github.com/temporalio/temporal/pull/8563#discussion_r2547528847"},"pull_request":{"href":"https://api.github.com/repos/temporalio/temporal/pulls/8563"}},"reactions":{"url":"https://api.github.com/repos/temporalio/temporal/pulls/comments/2547528847/reactions","total_count":0,"+1":0,"-1":0,"laugh":0,"hooray":0,"confused":0,"heart":0,"rocket":0,"eyes":0},"start_line":null,"original_start_line":null,"start_side":null,"line":383,"original_line":383,"side":"RIGHT","in_reply_to_id":2539839248,"author_association":"MEMBER","original_position":103,"position":99,"subject_type":"line"},{"url":"https://api.github.com/repos/temporalio/temporal/pulls/comments/2547886079","pull_request_review_id":3490238098,"id":2547886079,"node_id":"PRRC_kwDODNqesM6X3af_","diff_hunk":"@@ -155,7 +155,9 @@ func (e *startToCloseTimeoutTaskExecutor) Execute(\n ) error {\n \tretryPolicy := activity.RetryPolicy\n \n-\tenoughAttempts := retryPolicy.GetMaximumAttempts() == 0 || task.GetAttempt() < retryPolicy.GetMaximumAttempts()\n+\t// Only retry if MaximumAttempts is explicitly set to > 1 (0 means no retries for start-to-close timeouts)\n+\t// Note: MaximumAttempts == 0 should mean no retries, not unlimited retries for timeouts\n+\tenoughAttempts := retryPolicy.GetMaximumAttempts() > 1 && task.GetAttempt() < retryPolicy.GetMaximumAttempts()","path":"chasm/lib/activity/activity_tasks.go","commit_id":"7fdded5aec1efc28fa9cb0ae9c3697188b1834df","original_commit_id":"7fdded5aec1efc28fa9cb0ae9c3697188b1834df","user":{"login":"cursor[bot]","id":206951365,"node_id":"BOT_kgDODFXTxQ","avatar_url":"https://avatars.githubusercontent.com/in/1210556?v=4","gravatar_id":"","url":"https://api.github.com/users/cursor%5Bbot%5D","html_url":"https://github.com/apps/cursor","followers_url":"https://api.github.com/users/cursor%5Bbot%5D/followers","following_url":"https://api.github.com/users/cursor%5Bbot%5D/following{/other_user}","gists_url":"https://api.github.com/users/cursor%5Bbot%5D/gists{/gist_id}","starred_url":"https://api.github.com/users/cursor%5Bbot%5D/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/cursor%5Bbot%5D/subscriptions","organizations_url":"https://api.github.com/users/cursor%5Bbot%5D/orgs","repos_url":"https://api.github.com/users/cursor%5Bbot%5D/repos","events_url":"https://api.github.com/users/cursor%5Bbot%5D/events{/privacy}","received_events_url":"https://api.github.com/users/cursor%5Bbot%5D/received_events","type":"Bot","user_view_type":"public","site_admin":false},"body":"### Bug: Incorrect retry logic for MaximumAttempts\n\n<!-- **Medium Severity** -->\n\n<!-- DESCRIPTION START -->\nThe retry logic incorrectly interprets `MaximumAttempts`. In Temporal, `MaximumAttempts == 0` means unlimited retries (the default), not zero retries. The condition `retryPolicy.GetMaximumAttempts() > 1` prevents retries when `MaximumAttempts` is 0 or 1, breaking the standard Temporal retry behavior. The correct check should allow retries when `MaximumAttempts` is 0 (unlimited) or when the current attempt is less than `MaximumAttempts`.\n<!-- DESCRIPTION END -->\n\n<!-- LOCATIONS START\nchasm/lib/activity/activity_tasks.go#L157-L160\nLOCATIONS END -->\n<a href=\"https://cursor.com/open?data=eyJhbGciOiJSUzI1NiIsInR5cCI6IkpXVCIsImtpZCI6ImJ1Z2JvdC12MSJ9.eyJ2ZXJzaW9uIjoxLCJ0eXBlIjoiQlVHQk9UX0ZJWF9JTl9DVVJTT1IiLCJkYXRhIjp7InJlZGlzS2V5IjoiYnVnYm90Ojk3MDI4ZDI5LWVjMjgtNDQwMy1iMmQyLTcwYjRiNWEwMWEzOCIsImVuY3J5cHRpb25LZXkiOiJ5WkJuV0pqdWVSNFZfUWN1UGhraXN4X0hramtjeFlESHJVeThPcVN1aUtnIiwiYnJhbmNoIjoicG9sbC1jb21wb25lbnQifSwiaWF0IjoxNzYzNjc3NTUxLCJleHAiOjE3NjQyODIzNTF9.nKCzNoNUkFa_7idGclzMFT8af-aFFjpBlsgK1h5_cT2Y7BaBwYUA9S0b8Lt9VOdp1iIJdAeh23QBjix212xvhUX4YlOPLCArwloHm5HtBz7O_rKUpDxf7iCRv5nMxr77WnzC1JEqxKC4ZjQS5_Fh3cdLfYyDAXI6Iorh-NFGPyOmz_BEtuF8A5ylu-K8JyQfaCiGdVrBmi2rDrTiPJFaolSYGKDRVGH4YoHuKYtke40Vc64YjuTbJwWRa8WsnmB2gzUBJkf9S3giXR-vwvTtZtANb9xAsborrBwxCS53cl03HJwWggL161ChCM8HXA9Ks4CjGNye88boPiWmqJoGiA\"><picture><source media=\"(prefers-color-scheme: dark)\" srcset=\"https://cursor.com/fix-in-cursor-dark.svg\"><source media=\"(prefers-color-scheme: light)\" srcset=\"https://cursor.com/fix-in-cursor-light.svg\"><img alt=\"Fix in Cursor\" src=\"https://cursor.com/fix-in-cursor.svg\"></picture></a>&nbsp;<a href=\"https://cursor.com/agents?data=eyJhbGciOiJSUzI1NiIsInR5cCI6IkpXVCIsImtpZCI6ImJ1Z2JvdC12MSJ9.eyJ2ZXJzaW9uIjoxLCJ0eXBlIjoiQlVHQk9UX0ZJWF9JTl9XRUIiLCJkYXRhIjp7InJlZGlzS2V5IjoiYnVnYm90Ojk3MDI4ZDI5LWVjMjgtNDQwMy1iMmQyLTcwYjRiNWEwMWEzOCIsImVuY3J5cHRpb25LZXkiOiJ5WkJuV0pqdWVSNFZfUWN1UGhraXN4X0hramtjeFlESHJVeThPcVN1aUtnIiwiYnJhbmNoIjoicG9sbC1jb21wb25lbnQiLCJyZXBvT3duZXIiOiJ0ZW1wb3JhbGlvIiwicmVwb05hbWUiOiJ0ZW1wb3JhbCIsInByTnVtYmVyIjo4NTYzLCJjb21taXRTaGEiOiI3ZmRkZWQ1YWVjMWVmYzI4ZmE5Y2IwYWU5YzM2OTcxODhiMTgzNGRmIn0sImlhdCI6MTc2MzY3NzU1MSwiZXhwIjoxNzY0MjgyMzUxfQ.Uh3QuytNhGh5LhmRtFF6gzF7z6HZtW-F7RqFx9WAeI4QYiLRBgEiGV07AwjqmHxmNzLP-oShuk628PR-AT0npjaSTkR2wEzgjehi1ApV1x9OKhHrGT69uAI9Je8oF62uYlj9Cj-C6ZkYBJ0FRhwreQhe0dV8FTuh4buUSIHs5M-JV0DDIMx5DC2XNeeOH-R-H17MTnoJ92aW-S8uiW4swdWa8ZlW2R2xo7BE_Y8nkzwzONoKeWb0AxuBc0eWGHz0yHPuaqFnaB4068v08SbiGKt1a-KbM0mvlaw_8ZqXm5TBT3XOe8N6q9sYk-70ikyskbeNUpPZb2MxMs9liYyq4Q\"><picture><source media=\"(prefers-color-scheme: dark)\" srcset=\"https://cursor.com/fix-in-web-dark.svg\"><source media=\"(prefers-color-scheme: light)\" srcset=\"https://cursor.com/fix-in-web-light.svg\"><img alt=\"Fix in Web\" src=\"https://cursor.com/fix-in-web.svg\"></picture></a>\n\n","created_at":"2025-11-20T22:25:51Z","updated_at":"2025-11-20T22:25:51Z","html_url":"https://github.com/temporalio/temporal/pull/8563#discussion_r2547886079","pull_request_url":"https://api.github.com/repos/temporalio/temporal/pulls/8563","_links":{"self":{"href":"https://api.github.com/repos/temporalio/temporal/pulls/comments/2547886079"},"html":{"href":"https://github.com/temporalio/temporal/pull/8563#discussion_r2547886079"},"pull_request":{"href":"https://api.github.com/repos/temporalio/temporal/pulls/8563"}},"reactions":{"url":"https://api.github.com/repos/temporalio/temporal/pulls/comments/2547886079/reactions","total_count":0,"+1":0,"-1":0,"laugh":0,"hooray":0,"confused":0,"heart":0,"rocket":0,"eyes":0},"start_line":null,"original_start_line":null,"start_side":null,"line":null,"original_line":160,"side":"RIGHT","author_association":"NONE","original_position":7,"position":1,"subject_type":"line"},{"url":"https://api.github.com/repos/temporalio/temporal/pulls/comments/2547886083","pull_request_review_id":3490238098,"id":2547886083,"node_id":"PRRC_kwDODNqesM6X3agD","diff_hunk":"@@ -241,14 +278,196 @@ func (e *ChasmEngine) ReadComponent(\n \treturn readFn(chasmContext, component)\n }\n \n+// PollComponent waits until the supplied predicate is satisfied when evaluated against the\n+// component identified by the supplied component reference. If it times out due to the\n+// server-imposed long-poll timeout then it returns (nil, nil). Otherwise if there is no error, it\n+// returns (ref, nil) where ref is a component reference identifying the state at which the\n+// predicate was satisfied. It is an error if execution transition history is (after reloading from\n+// persistence) behind the requested ref, or if the ref is inconsistent with execution transition\n+// history. Thus when the predicate function is evaluated, it is guaranteed that the execution VT >=\n+// requestRef VT.\n func (e *ChasmEngine) PollComponent(\n \tctx context.Context,\n-\tentityRef chasm.ComponentRef,\n-\tpredicateFn func(chasm.Context, chasm.Component) (any, bool, error),\n-\toperationFn func(chasm.MutableContext, chasm.Component, any) error,\n-\topts ...chasm.TransitionOption,\n-) (newEntityRef []byte, retError error) {\n-\treturn nil, serviceerror.NewUnimplemented(\"PollComponent is not yet supported\")\n+\trequestRef chasm.ComponentRef,\n+\tpredicateFn func(chasm.Context, chasm.Component) (bool, error),\n+) (retRef []byte, retError error) {\n+\t// 1. Acquire lock\n+\t// 2. Error if shard execution VT < requestRef VT ('stale state')\n+\t// 3. If predicate satisfied, release lock and return\n+\t// 4. Subscribe to notifications for this execution\n+\t// 5. Release lock\n+\t// 6. On notification repeat (1) and (2)\n+\n+\tdefer func() {\n+\t\tif retError != nil {\n+\t\t\tfmt.Println(\" PollComponent: returning with error\", retError)\n+\t\t} else {\n+\t\t\tfmt.Println(\" PollComponent: returning successfully\")\n+\t\t}\n+\t}()\n+\n+\tshardContext, executionLease, err := e.getExecutionLease(ctx, requestRef)\n+\tif err != nil {\n+\t\t// E.g. requestRef VT inconsistent with shard VT ('stale reference')\n+\t\treturn nil, err\n+\t}\n+\n+\t// hold lock until return or subscription established\n+\treleased := false\n+\tdefer func() {\n+\t\tif !released {\n+\t\t\t// read-only operation; don't pass error\n+\t\t\texecutionLease.GetReleaseFn()(nil)\n+\t\t}\n+\t}()\n+\n+\t// At this point it's possible that shard VT < requestRef VT (getExecutionLease does not\n+\t// guarantee that returned shard state is non-stale w.r.t. requestRef).\n+\tsatisfiedRef, err := e.predicateSatisfied(ctx, requestRef, executionLease, predicateFn)\n+\tif err != nil {\n+\t\treturn nil, err\n+\t}\n+\t// shard VT >= requestRef VT (enforced by checkPredicate)\n+\n+\tif satisfiedRef != nil {\n+\t\t// wait condition was satisfied\n+\t\treturn satisfiedRef, nil\n+\t}\n+\n+\t// Wait condition not satisfied; long-poll\n+\n+\t// TODO(dan) For now, UpdateComponent emits execution-level notifications, and PollComponent\n+\t// subscribes to execution-level notifications. This means that PollComponent may be woken up\n+\t// unnecessarily, but it will not miss notifications. In the future we may want to change\n+\t// PollComponent to subscribe to component-level notifications, and change UpdateComponent so\n+\t// that notifications are emitted only for nodes that were mutated in the transaction.\n+\tchannel, subscriberID, err := e.notifier.Subscribe(requestRef.EntityKey)\n+\tif err != nil {\n+\t\treturn nil, err\n+\t}\n+\tdefer func() {\n+\t\t_ = e.notifier.Unsubscribe(requestRef.EntityKey, subscriberID)\n+\t}()\n+\n+\t// Release the lock, now that we are subscribed\n+\texecutionLease.GetReleaseFn()(nil)\n+\treleased = true\n+\n+\tnamespaceRegistry, err := shardContext.GetNamespaceRegistry().GetNamespaceByID(\n+\t\tnamespace.ID(requestRef.EntityKey.NamespaceID),\n+\t)\n+\tif err != nil {\n+\t\treturn nil, err\n+\t}\n+\n+\t// If the long-poll times out due to the internally-imposed long-poll timeout, then we want the\n+\t// initiator of the long-poll to receive a non-error empty response indicating that they should\n+\t// continue long-polling. To achieve this, we return nil on all canceled context errors below.\n+\t// We assume that the parent will check for a canceled context independently (without relying on\n+\t// any error value we return), so that if the cancelation was due to the parent deadline rather\n+\t// than the internally-imposed long-poll timeout then the initiator of the long-poll will get a\n+\t// deadline exceeded error.\n+\n+\tif deadline, ok := ctx.Deadline(); ok {\n+\t\tfmt.Println(\"  PollComponent: parent has deadline\", time.Until(deadline))\n+\t}\n+\n+\tinternalLongPollTimeout := shardContext.GetConfig().LongPollExpirationInterval(namespaceRegistry.Name().String())\n+\n+\tfmt.Println(\"  PollComponent: internal long poll timeout\", internalLongPollTimeout)","path":"service/history/chasm_engine.go","commit_id":"9f8d762f3279f3b16d2217ae254bb3f85df69b44","original_commit_id":"7fdded5aec1efc28fa9cb0ae9c3697188b1834df","user":{"login":"cursor[bot]","id":206951365,"node_id":"BOT_kgDODFXTxQ","avatar_url":"https://avatars.githubusercontent.com/in/1210556?v=4","gravatar_id":"","url":"https://api.github.com/users/cursor%5Bbot%5D","html_url":"https://github.com/apps/cursor","followers_url":"https://api.github.com/users/cursor%5Bbot%5D/followers","following_url":"https://api.github.com/users/cursor%5Bbot%5D/following{/other_user}","gists_url":"https://api.github.com/users/cursor%5Bbot%5D/gists{/gist_id}","starred_url":"https://api.github.com/users/cursor%5Bbot%5D/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/cursor%5Bbot%5D/subscriptions","organizations_url":"https://api.github.com/users/cursor%5Bbot%5D/orgs","repos_url":"https://api.github.com/users/cursor%5Bbot%5D/repos","events_url":"https://api.github.com/users/cursor%5Bbot%5D/events{/privacy}","received_events_url":"https://api.github.com/users/cursor%5Bbot%5D/received_events","type":"Bot","user_view_type":"public","site_admin":false},"body":"### Bug: Debug print statements in production code\n\n<!-- **Medium Severity** -->\n\n<!-- DESCRIPTION START -->\nMultiple `fmt.Println` debug statements are present in the `PollComponent` method and `predicateSatisfied` helper function. These include emoji-prefixed debug messages like \" PollComponent: returning with error\", \" PollComponent: parent has deadline\", \" checkPredicate\", etc. Debug print statements pollute production logs and reduce performance, and were likely intended only for development.\n<!-- DESCRIPTION END -->\n\n<!-- LOCATIONS START\nservice/history/chasm_engine.go#L317-L377\nLOCATIONS END -->\n<a href=\"https://cursor.com/open?data=eyJhbGciOiJSUzI1NiIsInR5cCI6IkpXVCIsImtpZCI6ImJ1Z2JvdC12MSJ9.eyJ2ZXJzaW9uIjoxLCJ0eXBlIjoiQlVHQk9UX0ZJWF9JTl9DVVJTT1IiLCJkYXRhIjp7InJlZGlzS2V5IjoiYnVnYm90OmUxNTdmYThiLTFkYTUtNDMxYy04ODE1LWE4MWRlNTUyOThkZSIsImVuY3J5cHRpb25LZXkiOiJtTHFkLTdBOUI5ZzQ5V3BqTGN4NEFpUEN0Wk9mVjBzZk82TFFQRE9RWlhFIiwiYnJhbmNoIjoicG9sbC1jb21wb25lbnQifSwiaWF0IjoxNzYzNjc3NTUxLCJleHAiOjE3NjQyODIzNTF9.JEh6peqtuOhp4SxqYNJ7WrdIYPIU7mG6RU9gJGNEosuWcULWt_bHYZBkznX4f5EzMAAkkfA_1Gcsj0_09njXPk1hyhmNVsHmA7U1T5bRje7U4C1X1gPdxByLuOfVZ2rvefeWJub6-O_J-UXp5LcY8K629CKZO5Qh8WytbxQyTCzQuqTfVtnpVSxOxwRcvUbW9CABexOOYQzhx_kI9XTfTzkBFZ90tYbqQAs4jjybJxlBMUoa6i7-YxF3eVUXEFH7EE2bX7M7DaDJtkU7-WQ6SWfFyNlKgAKxEwFUu-fbvEtZtIwJKRnwS9qzn1Uxa82FGfXUEMBL2vGZ3rxXCZDYXw\"><picture><source media=\"(prefers-color-scheme: dark)\" srcset=\"https://cursor.com/fix-in-cursor-dark.svg\"><source media=\"(prefers-color-scheme: light)\" srcset=\"https://cursor.com/fix-in-cursor-light.svg\"><img alt=\"Fix in Cursor\" src=\"https://cursor.com/fix-in-cursor.svg\"></picture></a>&nbsp;<a href=\"https://cursor.com/agents?data=eyJhbGciOiJSUzI1NiIsInR5cCI6IkpXVCIsImtpZCI6ImJ1Z2JvdC12MSJ9.eyJ2ZXJzaW9uIjoxLCJ0eXBlIjoiQlVHQk9UX0ZJWF9JTl9XRUIiLCJkYXRhIjp7InJlZGlzS2V5IjoiYnVnYm90OmUxNTdmYThiLTFkYTUtNDMxYy04ODE1LWE4MWRlNTUyOThkZSIsImVuY3J5cHRpb25LZXkiOiJtTHFkLTdBOUI5ZzQ5V3BqTGN4NEFpUEN0Wk9mVjBzZk82TFFQRE9RWlhFIiwiYnJhbmNoIjoicG9sbC1jb21wb25lbnQiLCJyZXBvT3duZXIiOiJ0ZW1wb3JhbGlvIiwicmVwb05hbWUiOiJ0ZW1wb3JhbCIsInByTnVtYmVyIjo4NTYzLCJjb21taXRTaGEiOiI3ZmRkZWQ1YWVjMWVmYzI4ZmE5Y2IwYWU5YzM2OTcxODhiMTgzNGRmIn0sImlhdCI6MTc2MzY3NzU1MSwiZXhwIjoxNzY0MjgyMzUxfQ.Y4RIl4AqKDz_JY9qYmqcJJ-iWcxX5OYZBmNCrty2a0B4W1JN7YuvAJ6W5Cfs5qrUPRM-7e1pkDW1OKp1NH79PQkadUtfMujx1GEf2_mITRVMj6w8vs3FUPyOP1WXyVdDOHYuoH-ViqQX2pFtXnR9ld1nMBiQOg0EFjMA9bXzWFhMkEhkrQwKE0MVf7Nx3REM0CyHPHsLd8aj4anfQJ636EE1V-bxlK-C9MA7QS3B9I3F1TAwIB9H0V4L8m4vZC9a1GbSjRM_sQkihAnLRoAScLyV8QGdOVGVfpwbsQRa_DbXe-EQQMv5qiQc7zMRk5ah8zUYG_WDIriuDU87OIPdDg\"><picture><source media=\"(prefers-color-scheme: dark)\" srcset=\"https://cursor.com/fix-in-web-dark.svg\"><source media=\"(prefers-color-scheme: light)\" srcset=\"https://cursor.com/fix-in-web-light.svg\"><img alt=\"Fix in Web\" src=\"https://cursor.com/fix-in-web.svg\"></picture></a>\n\n","created_at":"2025-11-20T22:25:51Z","updated_at":"2025-11-20T22:25:51Z","html_url":"https://github.com/temporalio/temporal/pull/8563#discussion_r2547886083","pull_request_url":"https://api.github.com/repos/temporalio/temporal/pulls/8563","_links":{"self":{"href":"https://api.github.com/repos/temporalio/temporal/pulls/comments/2547886083"},"html":{"href":"https://github.com/temporalio/temporal/pull/8563#discussion_r2547886083"},"pull_request":{"href":"https://api.github.com/repos/temporalio/temporal/pulls/8563"}},"reactions":{"url":"https://api.github.com/repos/temporalio/temporal/pulls/comments/2547886083/reactions","total_count":0,"+1":0,"-1":0,"laugh":0,"hooray":0,"confused":0,"heart":0,"rocket":0,"eyes":0},"start_line":null,"original_start_line":null,"start_side":null,"line":null,"original_line":377,"side":"RIGHT","author_association":"NONE","original_position":202,"position":1,"subject_type":"line"},{"url":"https://api.github.com/repos/temporalio/temporal/pulls/comments/2550256022","pull_request_review_id":3493427342,"id":2550256022,"node_id":"PRRC_kwDODNqesM6YAdGW","diff_hunk":"@@ -282,10 +283,14 @@ func (a *Activity) recordStartToCloseTimedOut(ctx chasm.MutableContext, retryInt\n \t}\n \tattempt.LastAttemptCompleteTime = currentTime\n \n-\t// If the activity has exhausted retries, mark the outcome failure as well but don't store duplicate failure info.\n+\t// If the activity has exhausted retries, mark the outcome failure as well.\n \t// Also reset the retry interval as there won't be any more retries.\n \tif noRetriesLeft {\n-\t\toutcome.Variant = &activitypb.ActivityOutcome_Failed_{}\n+\t\toutcome.Variant = &activitypb.ActivityOutcome_Failed_{","path":"chasm/lib/activity/activity.go","commit_id":"ee79ea9d2857dc0da255fec35a8ec05b24ecc8c6","original_commit_id":"9f8d762f3279f3b16d2217ae254bb3f85df69b44","user":{"login":"fretz12","id":41805201,"node_id":"MDQ6VXNlcjQxODA1MjAx","avatar_url":"https://avatars.githubusercontent.com/u/41805201?v=4","gravatar_id":"","url":"https://api.github.com/users/fretz12","html_url":"https://github.com/fretz12","followers_url":"https://api.github.com/users/fretz12/followers","following_url":"https://api.github.com/users/fretz12/following{/other_user}","gists_url":"https://api.github.com/users/fretz12/gists{/gist_id}","starred_url":"https://api.github.com/users/fretz12/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/fretz12/subscriptions","organizations_url":"https://api.github.com/users/fretz12/orgs","repos_url":"https://api.github.com/users/fretz12/repos","events_url":"https://api.github.com/users/fretz12/events{/privacy}","received_events_url":"https://api.github.com/users/fretz12/received_events","type":"User","user_view_type":"public","site_admin":false},"body":"This shouldn't be changed to fill in the failure. Any attempted run, such as start-to-close, should always keep the failure in only in attempt.LastFailureDetails so as not to duplicate data. We have to put an empty failure outcome after the last try as to indicate this is a failure. \r\nWhen pollactivity happens, it should dynamically fill out the outcome failure from attempt.LastFailureDetails.\r\nThe behavior is a bit complex but worth it for not duplicating potentially large data. We can maybe document this better.","created_at":"2025-11-21T16:05:47Z","updated_at":"2025-11-21T16:05:47Z","html_url":"https://github.com/temporalio/temporal/pull/8563#discussion_r2550256022","pull_request_url":"https://api.github.com/repos/temporalio/temporal/pulls/8563","_links":{"self":{"href":"https://api.github.com/repos/temporalio/temporal/pulls/comments/2550256022"},"html":{"href":"https://github.com/temporalio/temporal/pull/8563#discussion_r2550256022"},"pull_request":{"href":"https://api.github.com/repos/temporalio/temporal/pulls/8563"}},"reactions":{"url":"https://api.github.com/repos/temporalio/temporal/pulls/comments/2550256022/reactions","total_count":0,"+1":0,"-1":0,"laugh":0,"hooray":0,"confused":0,"heart":0,"rocket":0,"eyes":0},"start_line":null,"original_start_line":null,"start_side":null,"line":null,"original_line":289,"side":"RIGHT","author_association":"MEMBER","original_position":43,"position":1,"subject_type":"line"},{"url":"https://api.github.com/repos/temporalio/temporal/pulls/comments/2550649578","pull_request_review_id":3493950068,"id":2550649578,"node_id":"PRRC_kwDODNqesM6YB9Lq","diff_hunk":"@@ -241,14 +256,161 @@ func (e *ChasmEngine) ReadComponent(\n \treturn readFn(chasmContext, component)\n }\n \n+// PollComponent waits until the supplied predicate is satisfied when evaluated against the\n+// component identified by the supplied component reference. If it times out due to the\n+// server-imposed long-poll timeout then it returns (nil, nil). Otherwise if there is no error, it\n+// returns (ref, nil) where ref is a component reference identifying the state at which the\n+// predicate was satisfied. It is an error if execution transition history is (after reloading from\n+// persistence) behind the requested ref, or if the ref is inconsistent with execution transition\n+// history. Thus when the predicate function is evaluated, it is guaranteed that the execution VT >=\n+// requestRef VT.\n func (e *ChasmEngine) PollComponent(\n \tctx context.Context,\n-\tentityRef chasm.ComponentRef,\n-\tpredicateFn func(chasm.Context, chasm.Component) (any, bool, error),\n-\toperationFn func(chasm.MutableContext, chasm.Component, any) error,\n-\topts ...chasm.TransitionOption,\n-) (newEntityRef []byte, retError error) {\n-\treturn nil, serviceerror.NewUnimplemented(\"PollComponent is not yet supported\")\n+\trequestRef chasm.ComponentRef,\n+\tpredicateFn func(chasm.Context, chasm.Component) (bool, error),\n+) (retRef []byte, retError error) {\n+\t// 1. Acquire lock\n+\t// 2. Error if shard execution VT < requestRef VT ('stale state')\n+\t// 3. If predicate satisfied, release lock and return\n+\t// 4. Subscribe to notifications for this execution\n+\t// 5. Release lock\n+\t// 6. On notification repeat (1) and (2)\n+\n+\tshardContext, executionLease, err := e.getExecutionLease(ctx, requestRef)\n+\tif err != nil {\n+\t\t// E.g. requestRef VT inconsistent with shard VT ('stale reference')\n+\t\treturn nil, err\n+\t}\n+\n+\t// hold lock until return or subscription established\n+\t// TODO(dan): this will probably be called when its already been release; ok?\n+\tdefer executionLease.GetReleaseFn()(nil)\n+\n+\t// At this point it's possible that shard VT < requestRef VT (getExecutionLease does not\n+\t// guarantee that returned shard state is non-stale w.r.t. requestRef).\n+\tsatisfiedRef, err := e.predicateSatisfied(ctx, requestRef, executionLease, predicateFn)\n+\tif err != nil {\n+\t\treturn nil, err\n+\t}\n+\t// shard VT >= requestRef VT (enforced by checkPredicate)\n+\n+\tif satisfiedRef != nil {\n+\t\t// wait condition was satisfied\n+\t\treturn satisfiedRef, nil\n+\t}\n+\n+\t// Wait condition not satisfied; long-poll\n+\n+\tnamespaceRegistry, err := shardContext.GetNamespaceRegistry().GetNamespaceByID(\n+\t\tnamespace.ID(requestRef.EntityKey.NamespaceID),\n+\t)\n+\tif err != nil {\n+\t\treturn nil, err\n+\t}\n+\n+\t// If the long-poll times out due to the internally-imposed long-poll timeout, then we want the\n+\t// initiator of the long-poll to receive a non-error empty response indicating that they should\n+\t// continue long-polling. To achieve this, we return nil on all canceled context errors below.\n+\t// We assume that the parent will check for a canceled context independently (without relying on\n+\t// any error value we return), so that if the cancelation was due to the parent deadline rather\n+\t// than the internally-imposed long-poll timeout then the initiator of the long-poll will get a\n+\t// deadline exceeded error.\n+\n+\tinternalLongPollTimeout := shardContext.GetConfig().LongPollExpirationInterval(namespaceRegistry.Name().String())\n+\tctx, cancel := context.WithTimeout(ctx, internalLongPollTimeout)\n+\tdefer cancel()\n+\n+\t// For now, PollComponent subscribes to execution-level notifications. Suppose that an\n+\t// execution consists of one component A, and A has subcomponent B. Subscribers interested\n+\t// only in component B may be woken up unnecessarily due to changes in parts of A that do\n+\t// not also belong to B, but they will not miss notifications.\n+\tch, err := e.notifier.Subscribe(requestRef.EntityKey)\n+\tif err != nil {\n+\t\treturn nil, err\n+\t}\n+\texecutionLease.GetReleaseFn()(nil)\n+\n+\tfor {\n+\t\tselect {\n+\t\tcase <-ch:\n+\t\t\t_, executionLease, err := e.getExecutionLease(ctx, requestRef)\n+\t\t\tif err != nil {\n+\t\t\t\tif errors.Is(err, ctx.Err()) {\n+\t\t\t\t\treturn nil, nil\n+\t\t\t\t}\n+\t\t\t\treturn nil, err\n+\t\t\t}\n+\t\t\tfunc() {\n+\t\t\t\tdefer executionLease.GetReleaseFn()(nil)\n+\t\t\t\tsatisfiedRef, err = e.predicateSatisfied(ctx, requestRef, executionLease, predicateFn)\n+\t\t\t}()\n+\t\t\tif err != nil {\n+\t\t\t\tif errors.Is(err, ctx.Err()) {\n+\t\t\t\t\treturn nil, nil\n+\t\t\t\t}\n+\t\t\t\treturn nil, err\n+\t\t\t}\n+\t\t\tif satisfiedRef != nil {\n+\t\t\t\treturn satisfiedRef, nil\n+\t\t\t}\n+\t\tcase <-ctx.Done():\n+\t\t\treturn nil, nil\n+\t\t}\n+\t}\n+}\n+\n+// predicateSatisfied is a helper function for PollComponent. It returns (ref, err) where ref is non-nil\n+// iff there's no error and predicateFn evaluates to true.\n+func (e *ChasmEngine) predicateSatisfied(\n+\tctx context.Context,\n+\tref chasm.ComponentRef,\n+\texecutionLease api.WorkflowLease,\n+\tpredicateFn func(chasm.Context, chasm.Component) (bool, error),\n+) ([]byte, error) {\n+\tfmt.Println(\" checkPredicate\")\n+\n+\tchasmTree, ok := executionLease.GetMutableState().ChasmTree().(*chasm.Node)\n+\tif !ok {\n+\t\treturn nil, serviceerror.NewInternalf(\n+\t\t\t\"CHASM tree implementation not properly wired up, encountered type: %T, expected type: %T\",\n+\t\t\texecutionLease.GetMutableState().ChasmTree(),\n+\t\t\t&chasm.Node{},\n+\t\t)\n+\t}\n+\n+\t// It is not acceptable to declare the predicate to be satisfied against shard state that is\n+\t// behind the requested reference. However, getExecutionLease does not currently guarantee that\n+\t// shard VT >= ref VT, therefore we call IsStale() again here and return any error (which at\n+\t// this point must be ErrStaleState; ErrStaleReference has already been eliminated).\n+\terr := chasmTree.IsStale(ref)\n+\tif err != nil {\n+\t\t// ErrStaleState\n+\t\t// TODO(dan): this should be retryable if it is the failover version that is stale\n+\t\treturn nil, err\n+\t}\n+\t// We know now that shard VT >= ref VT\n+\n+\tchasmContext := chasm.NewContext(ctx, chasmTree)\n+\n+\tcomponent, err := chasmTree.Component(chasmContext, ref)\n+\tif err != nil {\n+\t\treturn nil, err\n+\t}\n+\tsatisfied, err := predicateFn(chasmContext, component)\n+\tif err != nil {\n+\t\treturn nil, err\n+\t}\n+\tif !satisfied {\n+\t\tfmt.Println(\"     checkPredicate: predicate not satisfied\")\n+\t\treturn nil, nil\n+\t}\n+\n+\tnewRef, err := chasmContext.Ref(component)\n+\tif err != nil {\n+\t\treturn nil, err\n+\t}\n+\tfmt.Println(\"     checkPredicate: predicate satisfied\")\n+\treturn newRef, nil","path":"service/history/chasm_engine.go","commit_id":"8f24888c6d1161340179426a776d5b962ffb53fe","original_commit_id":"e4c98ae2a6b8cfb7167f3a7ad36755ae3647200a","user":{"login":"cursor[bot]","id":206951365,"node_id":"BOT_kgDODFXTxQ","avatar_url":"https://avatars.githubusercontent.com/in/1210556?v=4","gravatar_id":"","url":"https://api.github.com/users/cursor%5Bbot%5D","html_url":"https://github.com/apps/cursor","followers_url":"https://api.github.com/users/cursor%5Bbot%5D/followers","following_url":"https://api.github.com/users/cursor%5Bbot%5D/following{/other_user}","gists_url":"https://api.github.com/users/cursor%5Bbot%5D/gists{/gist_id}","starred_url":"https://api.github.com/users/cursor%5Bbot%5D/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/cursor%5Bbot%5D/subscriptions","organizations_url":"https://api.github.com/users/cursor%5Bbot%5D/orgs","repos_url":"https://api.github.com/users/cursor%5Bbot%5D/repos","events_url":"https://api.github.com/users/cursor%5Bbot%5D/events{/privacy}","received_events_url":"https://api.github.com/users/cursor%5Bbot%5D/received_events","type":"Bot","user_view_type":"public","site_admin":false},"body":"### Bug: Debug statements left in production code\n\n<!-- **Low Severity** -->\n\n<!-- DESCRIPTION START -->\nThree `fmt.Println` debug statements with emoji were accidentally left in the `predicateSatisfied` function. These print to stdout and appear to be debugging code that was meant to be removed before committing. They will clutter production logs and aren't appropriate for production code.\n<!-- DESCRIPTION END -->\n\n<!-- LOCATIONS START\nservice/history/chasm_engine.go#L369-L413\nLOCATIONS END -->\n<a href=\"https://cursor.com/open?data=eyJhbGciOiJSUzI1NiIsInR5cCI6IkpXVCIsImtpZCI6ImJ1Z2JvdC12MSJ9.eyJ2ZXJzaW9uIjoxLCJ0eXBlIjoiQlVHQk9UX0ZJWF9JTl9DVVJTT1IiLCJkYXRhIjp7InJlZGlzS2V5IjoiYnVnYm90OjA1MmE2OWNjLTRkZjAtNDg2Ny1hOWYxLTRjNTA4ZDUzNWY3ZCIsImVuY3J5cHRpb25LZXkiOiJhT0xDSkxHX2taWjVTbXRBaC1McmQ4VkFfU0tLc2tmbFNWb0h6YnV0TjBRIiwiYnJhbmNoIjoicG9sbC1jb21wb25lbnQifSwiaWF0IjoxNzYzNzUwMjc0LCJleHAiOjE3NjQzNTUwNzR9.hV6iskiqpm-aB0gXK-cbkZVqApHsKwDZBRGyPD-Dgm9RaKlcA788RFqorObPgc_06mPxeTKKnO42GLvqMqAKXw5xaRt-uPc1eRwAvAD24VKnTRrom14PBWChIxfR-0jt0a9NpgUFq2dN1MNNfqQ_MKvIgwID4TyIZUc8V1z3T2ijNMKdgjGlRw2wJ-eNukD_gboyXqRXGgljd8XODesq37LptDAu8pTMwjX9F4XhzowFxumd2EtrizWPLOh4Sq_A8bqCUxWXHBja6XP7abjiNC9jAspsrg_4bofio0oTHwQEntMp6xs2DOFGmdor3raPLleqP61_Jr9uTK1KlhGWwg\"><picture><source media=\"(prefers-color-scheme: dark)\" srcset=\"https://cursor.com/fix-in-cursor-dark.svg\"><source media=\"(prefers-color-scheme: light)\" srcset=\"https://cursor.com/fix-in-cursor-light.svg\"><img alt=\"Fix in Cursor\" src=\"https://cursor.com/fix-in-cursor.svg\"></picture></a>&nbsp;<a href=\"https://cursor.com/agents?data=eyJhbGciOiJSUzI1NiIsInR5cCI6IkpXVCIsImtpZCI6ImJ1Z2JvdC12MSJ9.eyJ2ZXJzaW9uIjoxLCJ0eXBlIjoiQlVHQk9UX0ZJWF9JTl9XRUIiLCJkYXRhIjp7InJlZGlzS2V5IjoiYnVnYm90OjA1MmE2OWNjLTRkZjAtNDg2Ny1hOWYxLTRjNTA4ZDUzNWY3ZCIsImVuY3J5cHRpb25LZXkiOiJhT0xDSkxHX2taWjVTbXRBaC1McmQ4VkFfU0tLc2tmbFNWb0h6YnV0TjBRIiwiYnJhbmNoIjoicG9sbC1jb21wb25lbnQiLCJyZXBvT3duZXIiOiJ0ZW1wb3JhbGlvIiwicmVwb05hbWUiOiJ0ZW1wb3JhbCIsInByTnVtYmVyIjo4NTYzLCJjb21taXRTaGEiOiJlNGM5OGFlMmE2YjhjZmI3MTY3ZjNhN2FkMzY3NTVhZTM2NDcyMDBhIiwicHJvdmlkZXIiOiJnaXRodWIifSwiaWF0IjoxNzYzNzUwMjc0LCJleHAiOjE3NjQzNTUwNzR9.OuEM9gE9Vr-Ytr1RKMU1__e8AuVY9jOvA9BexGAHR87uyNW1wTNFi66c1wEesL4tqFTC79r-SmB5aWKAlAU2iVmeQwTmCC9OyR0Stxcd6LxFJ7K31diZPQJrU7gV8F4yALzTHbO9FmR_uphGp31arLDem1UzgoOMbL9NiCFvhrig13GYOKgWDNriEBhU6j60LeHJf1G3_nx5Z85CVg1O2R9gxWf_3k5hgWb2HS8-riyBLXVS-eFwW-FGUhb3Y08Ke1J-BMOoBszNU6ZQnSv9Ut4-T-rowbMsCEbCGKBnctnsmHx1XQ9GIzuBcrppC0eqP3ot5t75hFxa0dg-d3s5GA\"><picture><source media=\"(prefers-color-scheme: dark)\" srcset=\"https://cursor.com/fix-in-web-dark.svg\"><source media=\"(prefers-color-scheme: light)\" srcset=\"https://cursor.com/fix-in-web-light.svg\"><img alt=\"Fix in Web\" src=\"https://cursor.com/fix-in-web.svg\"></picture></a>\n\n","created_at":"2025-11-21T18:37:55Z","updated_at":"2025-11-21T18:37:55Z","html_url":"https://github.com/temporalio/temporal/pull/8563#discussion_r2550649578","pull_request_url":"https://api.github.com/repos/temporalio/temporal/pulls/8563","_links":{"self":{"href":"https://api.github.com/repos/temporalio/temporal/pulls/comments/2550649578"},"html":{"href":"https://github.com/temporalio/temporal/pull/8563#discussion_r2550649578"},"pull_request":{"href":"https://api.github.com/repos/temporalio/temporal/pulls/8563"}},"reactions":{"url":"https://api.github.com/repos/temporalio/temporal/pulls/comments/2550649578/reactions","total_count":0,"+1":0,"-1":0,"laugh":0,"hooray":0,"confused":0,"heart":0,"rocket":0,"eyes":0},"start_line":null,"original_start_line":null,"start_side":null,"line":null,"original_line":418,"side":"RIGHT","author_association":"NONE","original_position":230,"position":1,"subject_type":"line"},{"url":"https://api.github.com/repos/temporalio/temporal/pulls/comments/2550649584","pull_request_review_id":3493950068,"id":2550649584,"node_id":"PRRC_kwDODNqesM6YB9Lw","diff_hunk":"@@ -241,14 +256,161 @@ func (e *ChasmEngine) ReadComponent(\n \treturn readFn(chasmContext, component)\n }\n \n+// PollComponent waits until the supplied predicate is satisfied when evaluated against the\n+// component identified by the supplied component reference. If it times out due to the\n+// server-imposed long-poll timeout then it returns (nil, nil). Otherwise if there is no error, it\n+// returns (ref, nil) where ref is a component reference identifying the state at which the\n+// predicate was satisfied. It is an error if execution transition history is (after reloading from\n+// persistence) behind the requested ref, or if the ref is inconsistent with execution transition\n+// history. Thus when the predicate function is evaluated, it is guaranteed that the execution VT >=\n+// requestRef VT.\n func (e *ChasmEngine) PollComponent(\n \tctx context.Context,\n-\tentityRef chasm.ComponentRef,\n-\tpredicateFn func(chasm.Context, chasm.Component) (any, bool, error),\n-\toperationFn func(chasm.MutableContext, chasm.Component, any) error,\n-\topts ...chasm.TransitionOption,\n-) (newEntityRef []byte, retError error) {\n-\treturn nil, serviceerror.NewUnimplemented(\"PollComponent is not yet supported\")\n+\trequestRef chasm.ComponentRef,\n+\tpredicateFn func(chasm.Context, chasm.Component) (bool, error),\n+) (retRef []byte, retError error) {\n+\t// 1. Acquire lock\n+\t// 2. Error if shard execution VT < requestRef VT ('stale state')\n+\t// 3. If predicate satisfied, release lock and return\n+\t// 4. Subscribe to notifications for this execution\n+\t// 5. Release lock\n+\t// 6. On notification repeat (1) and (2)\n+\n+\tshardContext, executionLease, err := e.getExecutionLease(ctx, requestRef)\n+\tif err != nil {\n+\t\t// E.g. requestRef VT inconsistent with shard VT ('stale reference')\n+\t\treturn nil, err\n+\t}\n+\n+\t// hold lock until return or subscription established\n+\t// TODO(dan): this will probably be called when its already been release; ok?\n+\tdefer executionLease.GetReleaseFn()(nil)\n+\n+\t// At this point it's possible that shard VT < requestRef VT (getExecutionLease does not\n+\t// guarantee that returned shard state is non-stale w.r.t. requestRef).\n+\tsatisfiedRef, err := e.predicateSatisfied(ctx, requestRef, executionLease, predicateFn)\n+\tif err != nil {\n+\t\treturn nil, err\n+\t}\n+\t// shard VT >= requestRef VT (enforced by checkPredicate)\n+\n+\tif satisfiedRef != nil {\n+\t\t// wait condition was satisfied\n+\t\treturn satisfiedRef, nil\n+\t}\n+\n+\t// Wait condition not satisfied; long-poll\n+\n+\tnamespaceRegistry, err := shardContext.GetNamespaceRegistry().GetNamespaceByID(\n+\t\tnamespace.ID(requestRef.EntityKey.NamespaceID),\n+\t)\n+\tif err != nil {\n+\t\treturn nil, err\n+\t}\n+\n+\t// If the long-poll times out due to the internally-imposed long-poll timeout, then we want the\n+\t// initiator of the long-poll to receive a non-error empty response indicating that they should\n+\t// continue long-polling. To achieve this, we return nil on all canceled context errors below.\n+\t// We assume that the parent will check for a canceled context independently (without relying on\n+\t// any error value we return), so that if the cancelation was due to the parent deadline rather\n+\t// than the internally-imposed long-poll timeout then the initiator of the long-poll will get a\n+\t// deadline exceeded error.\n+\n+\tinternalLongPollTimeout := shardContext.GetConfig().LongPollExpirationInterval(namespaceRegistry.Name().String())\n+\tctx, cancel := context.WithTimeout(ctx, internalLongPollTimeout)\n+\tdefer cancel()\n+\n+\t// For now, PollComponent subscribes to execution-level notifications. Suppose that an\n+\t// execution consists of one component A, and A has subcomponent B. Subscribers interested\n+\t// only in component B may be woken up unnecessarily due to changes in parts of A that do\n+\t// not also belong to B, but they will not miss notifications.\n+\tch, err := e.notifier.Subscribe(requestRef.EntityKey)\n+\tif err != nil {\n+\t\treturn nil, err\n+\t}\n+\texecutionLease.GetReleaseFn()(nil)","path":"service/history/chasm_engine.go","commit_id":"372cc0a17931bd461ec03349b8509b57820e36c2","original_commit_id":"e4c98ae2a6b8cfb7167f3a7ad36755ae3647200a","user":{"login":"cursor[bot]","id":206951365,"node_id":"BOT_kgDODFXTxQ","avatar_url":"https://avatars.githubusercontent.com/in/1210556?v=4","gravatar_id":"","url":"https://api.github.com/users/cursor%5Bbot%5D","html_url":"https://github.com/apps/cursor","followers_url":"https://api.github.com/users/cursor%5Bbot%5D/followers","following_url":"https://api.github.com/users/cursor%5Bbot%5D/following{/other_user}","gists_url":"https://api.github.com/users/cursor%5Bbot%5D/gists{/gist_id}","starred_url":"https://api.github.com/users/cursor%5Bbot%5D/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/cursor%5Bbot%5D/subscriptions","organizations_url":"https://api.github.com/users/cursor%5Bbot%5D/orgs","repos_url":"https://api.github.com/users/cursor%5Bbot%5D/repos","events_url":"https://api.github.com/users/cursor%5Bbot%5D/events{/privacy}","received_events_url":"https://api.github.com/users/cursor%5Bbot%5D/received_events","type":"Bot","user_view_type":"public","site_admin":false},"body":"### Bug: Double release of execution lease in PollComponent\n\n<!-- **High Severity** -->\n\n<!-- DESCRIPTION START -->\nThe `PollComponent` function has a `defer executionLease.GetReleaseFn()(nil)` at line 287 that releases the execution lease when the function returns. However, at line 331, the code explicitly calls `executionLease.GetReleaseFn()(nil)` before entering the long-poll loop. This causes the release function to be invoked twice: once explicitly and once via the deferred call when the function returns. This double-release violates the lock contract and could lead to race conditions or undefined behavior in the lock management system.\n<!-- DESCRIPTION END -->\n\n<!-- LOCATIONS START\nservice/history/chasm_engine.go#L286-L331\nLOCATIONS END -->\n<a href=\"https://cursor.com/open?data=eyJhbGciOiJSUzI1NiIsInR5cCI6IkpXVCIsImtpZCI6ImJ1Z2JvdC12MSJ9.eyJ2ZXJzaW9uIjoxLCJ0eXBlIjoiQlVHQk9UX0ZJWF9JTl9DVVJTT1IiLCJkYXRhIjp7InJlZGlzS2V5IjoiYnVnYm90OjA2MjRkMGYyLTA0ODctNGRhZC04NzQ3LTU4NjcyYzlkMDZmOSIsImVuY3J5cHRpb25LZXkiOiJ0NUlWUHFQa0tsT0x3RDlVeXRWRHhBektHOGxPOUdqUzZObDAtWXo1WHJRIiwiYnJhbmNoIjoicG9sbC1jb21wb25lbnQifSwiaWF0IjoxNzYzNzUwMjc0LCJleHAiOjE3NjQzNTUwNzR9.f2MkB8my5nxQOjWu_aerYKCiWTlwOkVX3QLEhw-7yudtWHWXx5qFtn7lc1TYr4Ys5nlLIQgAmS5ApJqYjT48bBLA5jH6GHLWEJPrY1n9KzPcdH5Dirbnx8M0Zxk5YBILRybVrNdjro-iWTK00HmMXxFVrQpr1nO6cN3Guby4Q8BQoMy18YiS5MSSTPQJ6ueFxaf3RoB2ssGYqLkOWNk6-8CXUDfxPtXhvNGy1d2QAd5xvYyou_eLfhkUitqaS87bFU6gi9vhCP1n456gG7KRRr90tyf7U_q7UoKqCGyF1Q_Oe4CMaVUCwiWHQe3dkZsIvTf_zIvG70R_2_n5qWUSrw\"><picture><source media=\"(prefers-color-scheme: dark)\" srcset=\"https://cursor.com/fix-in-cursor-dark.svg\"><source media=\"(prefers-color-scheme: light)\" srcset=\"https://cursor.com/fix-in-cursor-light.svg\"><img alt=\"Fix in Cursor\" src=\"https://cursor.com/fix-in-cursor.svg\"></picture></a>&nbsp;<a href=\"https://cursor.com/agents?data=eyJhbGciOiJSUzI1NiIsInR5cCI6IkpXVCIsImtpZCI6ImJ1Z2JvdC12MSJ9.eyJ2ZXJzaW9uIjoxLCJ0eXBlIjoiQlVHQk9UX0ZJWF9JTl9XRUIiLCJkYXRhIjp7InJlZGlzS2V5IjoiYnVnYm90OjA2MjRkMGYyLTA0ODctNGRhZC04NzQ3LTU4NjcyYzlkMDZmOSIsImVuY3J5cHRpb25LZXkiOiJ0NUlWUHFQa0tsT0x3RDlVeXRWRHhBektHOGxPOUdqUzZObDAtWXo1WHJRIiwiYnJhbmNoIjoicG9sbC1jb21wb25lbnQiLCJyZXBvT3duZXIiOiJ0ZW1wb3JhbGlvIiwicmVwb05hbWUiOiJ0ZW1wb3JhbCIsInByTnVtYmVyIjo4NTYzLCJjb21taXRTaGEiOiJlNGM5OGFlMmE2YjhjZmI3MTY3ZjNhN2FkMzY3NTVhZTM2NDcyMDBhIiwicHJvdmlkZXIiOiJnaXRodWIifSwiaWF0IjoxNzYzNzUwMjc0LCJleHAiOjE3NjQzNTUwNzR9.W-ul9tyKF1XLr3KRSoZeGdg4s4rf5SGPN-dSvC593BLOLB-IqF6BAgmrtZr4G-gfev8rrcHpltnLt1lUzS9lvbcDh7QSq-WEJgx3sY5YGXoVEB3Gfck-TTnfV6xHIsgCmEi8nAllUxAB5y-QG1RrSOup804F42kaZGSXjfIwi_nGgt0gGdAOSrPx08CMWHWt84qVC4D02bkIuT3n6S_FMMAPNBOg95o7DthxU7pnQqtg6zfLCEoxq8-5a8gGdXV1GTgOwclamdfan942yzvJIwiaUHgMq5i9cshMeI9cwHYUQ6NqjxCDrhmVhg0rNnhETZPS9itV5B-INx1LQnToeQ\"><picture><source media=\"(prefers-color-scheme: dark)\" srcset=\"https://cursor.com/fix-in-web-dark.svg\"><source media=\"(prefers-color-scheme: light)\" srcset=\"https://cursor.com/fix-in-web-light.svg\"><img alt=\"Fix in Web\" src=\"https://cursor.com/fix-in-web.svg\"></picture></a>\n\n","created_at":"2025-11-21T18:37:55Z","updated_at":"2025-11-21T18:37:55Z","html_url":"https://github.com/temporalio/temporal/pull/8563#discussion_r2550649584","pull_request_url":"https://api.github.com/repos/temporalio/temporal/pulls/8563","_links":{"self":{"href":"https://api.github.com/repos/temporalio/temporal/pulls/comments/2550649584"},"html":{"href":"https://github.com/temporalio/temporal/pull/8563#discussion_r2550649584"},"pull_request":{"href":"https://api.github.com/repos/temporalio/temporal/pulls/8563"}},"reactions":{"url":"https://api.github.com/repos/temporalio/temporal/pulls/comments/2550649584/reactions","total_count":0,"+1":0,"-1":0,"laugh":0,"hooray":0,"confused":0,"heart":0,"rocket":0,"eyes":0},"start_line":null,"original_start_line":null,"start_side":null,"line":null,"original_line":336,"side":"RIGHT","author_association":"NONE","original_position":148,"position":1,"subject_type":"line"},{"url":"https://api.github.com/repos/temporalio/temporal/pulls/comments/2550664065","pull_request_review_id":3493968967,"id":2550664065,"node_id":"PRRC_kwDODNqesM6YCAuB","diff_hunk":"@@ -282,10 +283,14 @@ func (a *Activity) recordStartToCloseTimedOut(ctx chasm.MutableContext, retryInt\n \t}\n \tattempt.LastAttemptCompleteTime = currentTime\n \n-\t// If the activity has exhausted retries, mark the outcome failure as well but don't store duplicate failure info.\n+\t// If the activity has exhausted retries, mark the outcome failure as well.\n \t// Also reset the retry interval as there won't be any more retries.\n \tif noRetriesLeft {\n-\t\toutcome.Variant = &activitypb.ActivityOutcome_Failed_{}\n+\t\toutcome.Variant = &activitypb.ActivityOutcome_Failed_{","path":"chasm/lib/activity/activity.go","commit_id":"ee79ea9d2857dc0da255fec35a8ec05b24ecc8c6","original_commit_id":"9f8d762f3279f3b16d2217ae254bb3f85df69b44","user":{"login":"fretz12","id":41805201,"node_id":"MDQ6VXNlcjQxODA1MjAx","avatar_url":"https://avatars.githubusercontent.com/u/41805201?v=4","gravatar_id":"","url":"https://api.github.com/users/fretz12","html_url":"https://github.com/fretz12","followers_url":"https://api.github.com/users/fretz12/followers","following_url":"https://api.github.com/users/fretz12/following{/other_user}","gists_url":"https://api.github.com/users/fretz12/gists{/gist_id}","starred_url":"https://api.github.com/users/fretz12/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/fretz12/subscriptions","organizations_url":"https://api.github.com/users/fretz12/orgs","repos_url":"https://api.github.com/users/fretz12/repos","events_url":"https://api.github.com/users/fretz12/events{/privacy}","received_events_url":"https://api.github.com/users/fretz12/received_events","type":"User","user_view_type":"public","site_admin":false},"body":"I'll address this on my follow on PR as we discussed.","created_at":"2025-11-21T18:44:26Z","updated_at":"2025-11-21T18:44:27Z","html_url":"https://github.com/temporalio/temporal/pull/8563#discussion_r2550664065","pull_request_url":"https://api.github.com/repos/temporalio/temporal/pulls/8563","_links":{"self":{"href":"https://api.github.com/repos/temporalio/temporal/pulls/comments/2550664065"},"html":{"href":"https://github.com/temporalio/temporal/pull/8563#discussion_r2550664065"},"pull_request":{"href":"https://api.github.com/repos/temporalio/temporal/pulls/8563"}},"reactions":{"url":"https://api.github.com/repos/temporalio/temporal/pulls/comments/2550664065/reactions","total_count":0,"+1":0,"-1":0,"laugh":0,"hooray":0,"confused":0,"heart":0,"rocket":0,"eyes":0},"start_line":null,"original_start_line":null,"start_side":null,"line":null,"original_line":289,"side":"RIGHT","in_reply_to_id":2550256022,"author_association":"MEMBER","original_position":43,"position":1,"subject_type":"line"},{"url":"https://api.github.com/repos/temporalio/temporal/pulls/comments/2554404385","pull_request_review_id":3489746627,"id":2554404385,"node_id":"PRRC_kwDODNqesM6YQR4h","diff_hunk":"@@ -282,10 +283,14 @@ func (a *Activity) recordStartToCloseTimedOut(ctx chasm.MutableContext, retryInt\n \t}\n \tattempt.LastAttemptCompleteTime = currentTime\n \n-\t// If the activity has exhausted retries, mark the outcome failure as well but don't store duplicate failure info.\n+\t// If the activity has exhausted retries, mark the outcome failure as well.\n \t// Also reset the retry interval as there won't be any more retries.\n \tif noRetriesLeft {\n-\t\toutcome.Variant = &activitypb.ActivityOutcome_Failed_{}\n+\t\toutcome.Variant = &activitypb.ActivityOutcome_Failed_{","path":"chasm/lib/activity/activity.go","commit_id":"ee79ea9d2857dc0da255fec35a8ec05b24ecc8c6","original_commit_id":"9f8d762f3279f3b16d2217ae254bb3f85df69b44","user":{"login":"dandavison","id":52205,"node_id":"MDQ6VXNlcjUyMjA1","avatar_url":"https://avatars.githubusercontent.com/u/52205?v=4","gravatar_id":"","url":"https://api.github.com/users/dandavison","html_url":"https://github.com/dandavison","followers_url":"https://api.github.com/users/dandavison/followers","following_url":"https://api.github.com/users/dandavison/following{/other_user}","gists_url":"https://api.github.com/users/dandavison/gists{/gist_id}","starred_url":"https://api.github.com/users/dandavison/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/dandavison/subscriptions","organizations_url":"https://api.github.com/users/dandavison/orgs","repos_url":"https://api.github.com/users/dandavison/repos","events_url":"https://api.github.com/users/dandavison/events{/privacy}","received_events_url":"https://api.github.com/users/dandavison/received_events","type":"User","user_view_type":"public","site_admin":false},"body":"Thanks! I didn't intend to leave this in; the bug it was addressing was in the way I was computing outcome in the PollActivity response.","created_at":"2025-11-23T23:19:54Z","updated_at":"2025-11-27T03:19:06Z","html_url":"https://github.com/temporalio/temporal/pull/8563#discussion_r2554404385","pull_request_url":"https://api.github.com/repos/temporalio/temporal/pulls/8563","_links":{"self":{"href":"https://api.github.com/repos/temporalio/temporal/pulls/comments/2554404385"},"html":{"href":"https://github.com/temporalio/temporal/pull/8563#discussion_r2554404385"},"pull_request":{"href":"https://api.github.com/repos/temporalio/temporal/pulls/8563"}},"reactions":{"url":"https://api.github.com/repos/temporalio/temporal/pulls/comments/2554404385/reactions","total_count":0,"+1":0,"-1":0,"laugh":0,"hooray":0,"confused":0,"heart":0,"rocket":0,"eyes":0},"start_line":null,"original_start_line":null,"start_side":null,"line":null,"original_line":289,"side":"RIGHT","in_reply_to_id":2550256022,"author_association":"MEMBER","original_position":43,"position":1,"subject_type":"line"},{"url":"https://api.github.com/repos/temporalio/temporal/pulls/comments/2554447272","pull_request_review_id":3489746627,"id":2554447272,"node_id":"PRRC_kwDODNqesM6YQcWo","diff_hunk":"@@ -105,3 +117,377 @@ func createDefaultInput() *commonpb.Payloads {\n \t\t},\n \t}\n }\n+\n+func (s *standaloneActivityTestSuite) Test_PollActivityExecution_NoWait() {\n+\t// Long poll for any state change. PollActivityTaskQueue is used to cause a state change.\n+\tt := s.T()\n+\tctx, cancel := context.WithTimeout(t.Context(), 10*time.Second)\n+\tdefer cancel()\n+\tactivityID := testcore.RandomizeStr(t.Name())\n+\ttaskQueue := uuid.New().String()\n+\n+\tstartResp, err := s.startActivity(ctx, activityID, taskQueue)\n+\trequire.NoError(t, err)\n+\n+\tpollResp, err := s.FrontendClient().PollActivityExecution(ctx, &workflowservice.PollActivityExecutionRequest{\n+\t\tNamespace:    s.Namespace().String(),\n+\t\tActivityId:   activityID,\n+\t\tRunId:        startResp.RunId,\n+\t\tIncludeInfo:  true,\n+\t\tIncludeInput: true,\n+\t})\n+\trequire.NoError(t, err)\n+\trequire.NotNil(t, pollResp.StateChangeLongPollToken)\n+\trequire.NotNil(t, pollResp.Info)\n+\ts.assertActivityExecutionInfo(\n+\t\tt,\n+\t\tpollResp.Info,\n+\t\tactivityID,\n+\t\tstartResp.RunId,\n+\t\tenumspb.PENDING_ACTIVITY_STATE_SCHEDULED,\n+\t)\n+\trequire.NotNil(t, pollResp.Input)\n+\trequire.Equal(t, \"test-activity-input\", string(pollResp.Input.Payloads[0].Data))\n+\t// TODO(dan): test IncludeOutcome\n+}\n+\n+func (s *standaloneActivityTestSuite) Test_PollActivityExecution_WaitAnyStateChange() {\n+\t// Long poll for any state change. PollActivityTaskQueue is used to cause a state change.\n+\tt := s.T()\n+\tctx, cancel := context.WithTimeout(t.Context(), 10*time.Second)\n+\tdefer cancel()\n+\tactivityID := testcore.RandomizeStr(t.Name())\n+\ttaskQueue := uuid.New().String()\n+\n+\tstartResp, err := s.startActivity(ctx, activityID, taskQueue)\n+\trequire.NoError(t, err)\n+\n+\t// First poll lacks token and therefore responds immediately, returning a token\n+\tfirstPollResp, err := s.FrontendClient().PollActivityExecution(ctx, &workflowservice.PollActivityExecutionRequest{\n+\t\tNamespace:  s.Namespace().String(),\n+\t\tActivityId: activityID,\n+\t\tRunId:      startResp.RunId,\n+\t\tWaitPolicy: &workflowservice.PollActivityExecutionRequest_WaitAnyStateChange{\n+\t\t\tWaitAnyStateChange: &workflowservice.PollActivityExecutionRequest_StateChangeWaitOptions{},\n+\t\t},\n+\t\tIncludeInfo:  true,\n+\t\tIncludeInput: true,\n+\t})\n+\trequire.NoError(t, err)\n+\trequire.NotNil(t, firstPollResp.StateChangeLongPollToken)\n+\trequire.NotNil(t, firstPollResp.Info)\n+\ts.assertActivityExecutionInfo(\n+\t\tt,\n+\t\tfirstPollResp.Info,\n+\t\tactivityID,\n+\t\tstartResp.RunId,\n+\t\tenumspb.PENDING_ACTIVITY_STATE_SCHEDULED,\n+\t)\n+\n+\ttaskQueuePollErr := make(chan error, 1)\n+\tactivityPollDone := make(chan struct{})\n+\tvar activityPollResp *workflowservice.PollActivityExecutionResponse\n+\tvar activityPollErr error\n+\n+\tgo func() {\n+\t\tdefer close(activityPollDone)\n+\t\t// Second poll uses token and therefore waits for a state transition\n+\t\tactivityPollResp, activityPollErr = s.FrontendClient().PollActivityExecution(ctx, &workflowservice.PollActivityExecutionRequest{\n+\t\t\tNamespace:    s.Namespace().String(),\n+\t\t\tActivityId:   activityID,\n+\t\t\tRunId:        startResp.RunId,\n+\t\t\tIncludeInfo:  true,\n+\t\t\tIncludeInput: true,\n+\t\t\tWaitPolicy: &workflowservice.PollActivityExecutionRequest_WaitAnyStateChange{\n+\t\t\t\tWaitAnyStateChange: &workflowservice.PollActivityExecutionRequest_StateChangeWaitOptions{\n+\t\t\t\t\tLongPollToken: firstPollResp.StateChangeLongPollToken,\n+\t\t\t\t},\n+\t\t\t},\n+\t\t})\n+\t}()\n+\n+\t// TODO(dan): race here: subscription might not be established yet\n+\n+\t// Worker picks up activity task, triggering transition (via RecordActivityTaskStarted)\n+\tgo func() {\n+\t\t_, err := s.pollActivityTaskQueue(ctx, taskQueue)\n+\t\ttaskQueuePollErr <- err\n+\t}()\n+\n+\tselect {\n+\tcase <-activityPollDone:\n+\t\trequire.NoError(t, activityPollErr)\n+\t\trequire.NotNil(t, activityPollResp)\n+\t\trequire.NotNil(t, activityPollResp.Info)\n+\t\ts.assertActivityExecutionInfo(\n+\t\t\tt,\n+\t\t\tactivityPollResp.Info,\n+\t\t\tactivityID,\n+\t\t\tstartResp.RunId,\n+\t\t\tenumspb.PENDING_ACTIVITY_STATE_STARTED,\n+\t\t)\n+\t\trequire.NotNil(t, activityPollResp.Input)\n+\t\trequire.Equal(t, \"test-activity-input\", string(activityPollResp.Input.Payloads[0].Data))\n+\n+\tcase <-ctx.Done():\n+\t\tt.Fatal(\"PollActivityExecution timed out\")\n+\t}\n+\n+\terr = <-taskQueuePollErr\n+\trequire.NoError(t, err)\n+\n+\t// Manipulate the token to verify token staleness checks (simulate ErrStaleReference). To do so\n+\t// we make use of the internal implementation detail that the bytes are a serialized ref.\n+\ttoken := firstPollResp.StateChangeLongPollToken\n+\tvar pRef persistencespb.ChasmComponentRef\n+\terr = pRef.Unmarshal(token)\n+\trequire.NoError(t, err)\n+\tif pRef.EntityVersionedTransition != nil {\n+\t\tpRef.EntityVersionedTransition.NamespaceFailoverVersion += 1\n+\t}\n+\ttoken, err = pRef.Marshal()\n+\trequire.NoError(t, err)\n+\n+\t_, err = s.FrontendClient().PollActivityExecution(ctx, &workflowservice.PollActivityExecutionRequest{\n+\t\tNamespace:  s.Namespace().String(),\n+\t\tActivityId: activityID,\n+\t\tRunId:      startResp.RunId,\n+\t\tWaitPolicy: &workflowservice.PollActivityExecutionRequest_WaitAnyStateChange{\n+\t\t\tWaitAnyStateChange: &workflowservice.PollActivityExecutionRequest_StateChangeWaitOptions{\n+\t\t\t\tLongPollToken: token,\n+\t\t\t},\n+\t\t},\n+\t})\n+\trequire.Error(t, err)\n+\trequire.ErrorContains(t, err, \"cached mutable state could potentially be stale\")\n+}\n+\n+func (s *standaloneActivityTestSuite) Test_PollActivityExecution_WaitCompletion() {\n+\tt := s.T()\n+\tt.Skip(\"TODO(dan): implement test when RecordActivityTaskCompleted is implemented\")\n+}\n+\n+func (s *standaloneActivityTestSuite) Test_PollActivityExecution_WaitAnyStateChange_Success_UpdateComponent() {\n+\tt := s.T()\n+\tctx, cancel := context.WithTimeout(t.Context(), 10*time.Second)\n+\tdefer cancel()\n+\tctx = chasm.NewEngineContext(ctx, s.chasmEngine)\n+\n+\tactivityID := testcore.RandomizeStr(t.Name())\n+\ttaskQueue := uuid.New().String()\n+\n+\tstartResp, err := s.startActivity(ctx, activityID, taskQueue)\n+\trequire.NoError(t, err)\n+\tentityKey := chasm.EntityKey{\n+\t\tNamespaceID: s.NamespaceID().String(),\n+\t\tBusinessID:  activityID,\n+\t\tEntityID:    startResp.RunId,\n+\t}\n+\n+\t// Test PollActivityExecution(WaitAnyStateChange) without a long-poll token.\n+\tpollResp, err := s.FrontendClient().PollActivityExecution(ctx, &workflowservice.PollActivityExecutionRequest{\n+\t\tNamespace:  s.Namespace().String(),\n+\t\tActivityId: activityID,\n+\t\tRunId:      startResp.RunId,\n+\t\tWaitPolicy: &workflowservice.PollActivityExecutionRequest_WaitAnyStateChange{\n+\t\t\tWaitAnyStateChange: &workflowservice.PollActivityExecutionRequest_StateChangeWaitOptions{},\n+\t\t},\n+\t})\n+\trequire.NoError(t, err)\n+\trequire.NotNil(t, pollResp.GetStateChangeLongPollToken())\n+\trequire.Equal(t, startResp.GetRunId(), pollResp.GetRunId())\n+\n+\t_, _, err = chasm.UpdateComponent(","path":"tests/standalone_activity_test.go","commit_id":"ee79ea9d2857dc0da255fec35a8ec05b24ecc8c6","original_commit_id":"da6009564e796063faf853352077eecdc1473612","user":{"login":"dandavison","id":52205,"node_id":"MDQ6VXNlcjUyMjA1","avatar_url":"https://avatars.githubusercontent.com/u/52205?v=4","gravatar_id":"","url":"https://api.github.com/users/dandavison","html_url":"https://github.com/dandavison","followers_url":"https://api.github.com/users/dandavison/followers","following_url":"https://api.github.com/users/dandavison/following{/other_user}","gists_url":"https://api.github.com/users/dandavison/gists{/gist_id}","starred_url":"https://api.github.com/users/dandavison/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/dandavison/subscriptions","organizations_url":"https://api.github.com/users/dandavison/orgs","repos_url":"https://api.github.com/users/dandavison/repos","events_url":"https://api.github.com/users/dandavison/events{/privacy}","received_events_url":"https://api.github.com/users/dandavison/received_events","type":"User","user_view_type":"public","site_admin":false},"body":"Yes sorry, this state was temporary -- I wanted to make sure we had coverage but I should have made it clearer to reviewers. See the comment below:\r\n\r\n> This test uses chasm APIs (ReadComponent, UpdateComponent, PollComponent) directly. It's illegitimate to do this in tests/, correct? I do want something like this test.","created_at":"2025-11-24T00:37:26Z","updated_at":"2025-11-27T03:19:06Z","html_url":"https://github.com/temporalio/temporal/pull/8563#discussion_r2554447272","pull_request_url":"https://api.github.com/repos/temporalio/temporal/pulls/8563","_links":{"self":{"href":"https://api.github.com/repos/temporalio/temporal/pulls/comments/2554447272"},"html":{"href":"https://github.com/temporalio/temporal/pull/8563#discussion_r2554447272"},"pull_request":{"href":"https://api.github.com/repos/temporalio/temporal/pulls/8563"}},"reactions":{"url":"https://api.github.com/repos/temporalio/temporal/pulls/comments/2554447272/reactions","total_count":0,"+1":0,"-1":0,"laugh":0,"hooray":0,"confused":0,"heart":0,"rocket":0,"eyes":0},"start_line":null,"original_start_line":null,"start_side":null,"line":null,"original_line":300,"side":"RIGHT","in_reply_to_id":2540111898,"author_association":"MEMBER","original_position":232,"position":1,"subject_type":"line"},{"url":"https://api.github.com/repos/temporalio/temporal/pulls/comments/2554448253","pull_request_review_id":3489746627,"id":2554448253,"node_id":"PRRC_kwDODNqesM6YQcl9","diff_hunk":"@@ -105,3 +117,377 @@ func createDefaultInput() *commonpb.Payloads {\n \t\t},\n \t}\n }\n+\n+func (s *standaloneActivityTestSuite) Test_PollActivityExecution_NoWait() {\n+\t// Long poll for any state change. PollActivityTaskQueue is used to cause a state change.\n+\tt := s.T()\n+\tctx, cancel := context.WithTimeout(t.Context(), 10*time.Second)\n+\tdefer cancel()\n+\tactivityID := testcore.RandomizeStr(t.Name())\n+\ttaskQueue := uuid.New().String()\n+\n+\tstartResp, err := s.startActivity(ctx, activityID, taskQueue)\n+\trequire.NoError(t, err)\n+\n+\tpollResp, err := s.FrontendClient().PollActivityExecution(ctx, &workflowservice.PollActivityExecutionRequest{\n+\t\tNamespace:    s.Namespace().String(),\n+\t\tActivityId:   activityID,\n+\t\tRunId:        startResp.RunId,\n+\t\tIncludeInfo:  true,\n+\t\tIncludeInput: true,\n+\t})\n+\trequire.NoError(t, err)\n+\trequire.NotNil(t, pollResp.StateChangeLongPollToken)\n+\trequire.NotNil(t, pollResp.Info)\n+\ts.assertActivityExecutionInfo(\n+\t\tt,\n+\t\tpollResp.Info,\n+\t\tactivityID,\n+\t\tstartResp.RunId,\n+\t\tenumspb.PENDING_ACTIVITY_STATE_SCHEDULED,\n+\t)\n+\trequire.NotNil(t, pollResp.Input)\n+\trequire.Equal(t, \"test-activity-input\", string(pollResp.Input.Payloads[0].Data))\n+\t// TODO(dan): test IncludeOutcome\n+}\n+\n+func (s *standaloneActivityTestSuite) Test_PollActivityExecution_WaitAnyStateChange() {\n+\t// Long poll for any state change. PollActivityTaskQueue is used to cause a state change.\n+\tt := s.T()\n+\tctx, cancel := context.WithTimeout(t.Context(), 10*time.Second)\n+\tdefer cancel()\n+\tactivityID := testcore.RandomizeStr(t.Name())\n+\ttaskQueue := uuid.New().String()\n+\n+\tstartResp, err := s.startActivity(ctx, activityID, taskQueue)\n+\trequire.NoError(t, err)\n+\n+\t// First poll lacks token and therefore responds immediately, returning a token\n+\tfirstPollResp, err := s.FrontendClient().PollActivityExecution(ctx, &workflowservice.PollActivityExecutionRequest{\n+\t\tNamespace:  s.Namespace().String(),\n+\t\tActivityId: activityID,\n+\t\tRunId:      startResp.RunId,\n+\t\tWaitPolicy: &workflowservice.PollActivityExecutionRequest_WaitAnyStateChange{\n+\t\t\tWaitAnyStateChange: &workflowservice.PollActivityExecutionRequest_StateChangeWaitOptions{},\n+\t\t},\n+\t\tIncludeInfo:  true,\n+\t\tIncludeInput: true,\n+\t})\n+\trequire.NoError(t, err)\n+\trequire.NotNil(t, firstPollResp.StateChangeLongPollToken)\n+\trequire.NotNil(t, firstPollResp.Info)\n+\ts.assertActivityExecutionInfo(\n+\t\tt,\n+\t\tfirstPollResp.Info,\n+\t\tactivityID,\n+\t\tstartResp.RunId,\n+\t\tenumspb.PENDING_ACTIVITY_STATE_SCHEDULED,\n+\t)\n+\n+\ttaskQueuePollErr := make(chan error, 1)\n+\tactivityPollDone := make(chan struct{})\n+\tvar activityPollResp *workflowservice.PollActivityExecutionResponse\n+\tvar activityPollErr error\n+\n+\tgo func() {\n+\t\tdefer close(activityPollDone)\n+\t\t// Second poll uses token and therefore waits for a state transition\n+\t\tactivityPollResp, activityPollErr = s.FrontendClient().PollActivityExecution(ctx, &workflowservice.PollActivityExecutionRequest{\n+\t\t\tNamespace:    s.Namespace().String(),\n+\t\t\tActivityId:   activityID,\n+\t\t\tRunId:        startResp.RunId,\n+\t\t\tIncludeInfo:  true,\n+\t\t\tIncludeInput: true,\n+\t\t\tWaitPolicy: &workflowservice.PollActivityExecutionRequest_WaitAnyStateChange{\n+\t\t\t\tWaitAnyStateChange: &workflowservice.PollActivityExecutionRequest_StateChangeWaitOptions{\n+\t\t\t\t\tLongPollToken: firstPollResp.StateChangeLongPollToken,\n+\t\t\t\t},\n+\t\t\t},\n+\t\t})\n+\t}()\n+\n+\t// TODO(dan): race here: subscription might not be established yet\n+\n+\t// Worker picks up activity task, triggering transition (via RecordActivityTaskStarted)\n+\tgo func() {\n+\t\t_, err := s.pollActivityTaskQueue(ctx, taskQueue)\n+\t\ttaskQueuePollErr <- err\n+\t}()\n+\n+\tselect {\n+\tcase <-activityPollDone:\n+\t\trequire.NoError(t, activityPollErr)\n+\t\trequire.NotNil(t, activityPollResp)\n+\t\trequire.NotNil(t, activityPollResp.Info)\n+\t\ts.assertActivityExecutionInfo(\n+\t\t\tt,\n+\t\t\tactivityPollResp.Info,\n+\t\t\tactivityID,\n+\t\t\tstartResp.RunId,\n+\t\t\tenumspb.PENDING_ACTIVITY_STATE_STARTED,\n+\t\t)\n+\t\trequire.NotNil(t, activityPollResp.Input)\n+\t\trequire.Equal(t, \"test-activity-input\", string(activityPollResp.Input.Payloads[0].Data))\n+\n+\tcase <-ctx.Done():\n+\t\tt.Fatal(\"PollActivityExecution timed out\")\n+\t}\n+\n+\terr = <-taskQueuePollErr\n+\trequire.NoError(t, err)\n+\n+\t// Manipulate the token to verify token staleness checks (simulate ErrStaleReference). To do so\n+\t// we make use of the internal implementation detail that the bytes are a serialized ref.\n+\ttoken := firstPollResp.StateChangeLongPollToken\n+\tvar pRef persistencespb.ChasmComponentRef\n+\terr = pRef.Unmarshal(token)\n+\trequire.NoError(t, err)\n+\tif pRef.EntityVersionedTransition != nil {\n+\t\tpRef.EntityVersionedTransition.NamespaceFailoverVersion += 1\n+\t}\n+\ttoken, err = pRef.Marshal()\n+\trequire.NoError(t, err)\n+\n+\t_, err = s.FrontendClient().PollActivityExecution(ctx, &workflowservice.PollActivityExecutionRequest{\n+\t\tNamespace:  s.Namespace().String(),\n+\t\tActivityId: activityID,\n+\t\tRunId:      startResp.RunId,\n+\t\tWaitPolicy: &workflowservice.PollActivityExecutionRequest_WaitAnyStateChange{\n+\t\t\tWaitAnyStateChange: &workflowservice.PollActivityExecutionRequest_StateChangeWaitOptions{\n+\t\t\t\tLongPollToken: token,\n+\t\t\t},\n+\t\t},\n+\t})\n+\trequire.Error(t, err)\n+\trequire.ErrorContains(t, err, \"cached mutable state could potentially be stale\")\n+}\n+\n+func (s *standaloneActivityTestSuite) Test_PollActivityExecution_WaitCompletion() {\n+\tt := s.T()\n+\tt.Skip(\"TODO(dan): implement test when RecordActivityTaskCompleted is implemented\")\n+}\n+\n+func (s *standaloneActivityTestSuite) Test_PollActivityExecution_WaitAnyStateChange_Success_UpdateComponent() {\n+\tt := s.T()\n+\tctx, cancel := context.WithTimeout(t.Context(), 10*time.Second)\n+\tdefer cancel()\n+\tctx = chasm.NewEngineContext(ctx, s.chasmEngine)\n+\n+\tactivityID := testcore.RandomizeStr(t.Name())\n+\ttaskQueue := uuid.New().String()\n+\n+\tstartResp, err := s.startActivity(ctx, activityID, taskQueue)\n+\trequire.NoError(t, err)\n+\tentityKey := chasm.EntityKey{\n+\t\tNamespaceID: s.NamespaceID().String(),\n+\t\tBusinessID:  activityID,\n+\t\tEntityID:    startResp.RunId,\n+\t}\n+\n+\t// Test PollActivityExecution(WaitAnyStateChange) without a long-poll token.\n+\tpollResp, err := s.FrontendClient().PollActivityExecution(ctx, &workflowservice.PollActivityExecutionRequest{\n+\t\tNamespace:  s.Namespace().String(),\n+\t\tActivityId: activityID,\n+\t\tRunId:      startResp.RunId,\n+\t\tWaitPolicy: &workflowservice.PollActivityExecutionRequest_WaitAnyStateChange{\n+\t\t\tWaitAnyStateChange: &workflowservice.PollActivityExecutionRequest_StateChangeWaitOptions{},\n+\t\t},\n+\t})\n+\trequire.NoError(t, err)\n+\trequire.NotNil(t, pollResp.GetStateChangeLongPollToken())\n+\trequire.Equal(t, startResp.GetRunId(), pollResp.GetRunId())\n+\n+\t_, _, err = chasm.UpdateComponent(\n+\t\tctx,\n+\t\tchasm.NewComponentRef[*activity.Activity](entityKey),\n+\t\tfunc(a *activity.Activity, ctx chasm.MutableContext, _ any) (any, error) {\n+\t\t\t// Don't actually mutate; just trigger the notification\n+\t\t\treturn nil, nil\n+\t\t}, nil)\n+\trequire.NoError(t, err)\n+\n+\t// Test PollActivityExecution(WaitAnyStateChange) with a long-poll token.\n+\tsecondPollResp, err := s.FrontendClient().PollActivityExecution(ctx, &workflowservice.PollActivityExecutionRequest{\n+\t\tNamespace:  s.Namespace().String(),\n+\t\tActivityId: activityID,\n+\t\tRunId:      startResp.RunId,\n+\t\tWaitPolicy: &workflowservice.PollActivityExecutionRequest_WaitAnyStateChange{\n+\t\t\tWaitAnyStateChange: &workflowservice.PollActivityExecutionRequest_StateChangeWaitOptions{\n+\t\t\t\tLongPollToken: pollResp.GetStateChangeLongPollToken(),\n+\t\t\t},\n+\t\t},\n+\t})\n+\trequire.NoError(t, err)\n+\trequire.NotNil(t, secondPollResp.StateChangeLongPollToken)\n+}\n+\n+// Test_PollVisibility_UpdateFromParent tests that polling for visibility component is woken up when\n+// the parent activity is updated and modifies the visibility.\n+// TODO(dan): this test uses chasm APIs (ReadComponent, UpdateComponent, PollComponent) directly. Is\n+// this illegitimate in tests/?\n+func (s *standaloneActivityTestSuite) Test_PollVisibility_UpdateFromParent() {\n+\tt := s.T()\n+\tctx, cancel := context.WithTimeout(t.Context(), 10*time.Second)\n+\tdefer cancel()\n+\tctx = chasm.NewEngineContext(ctx, s.chasmEngine)\n+\n+\tactivityID := testcore.RandomizeStr(t.Name())\n+\ttaskQueue := uuid.New().String()\n+\n+\tstartResp, err := s.startActivity(ctx, activityID, taskQueue)\n+\trequire.NoError(t, err)\n+\tentityKey := chasm.EntityKey{\n+\t\tNamespaceID: s.NamespaceID().String(),\n+\t\tBusinessID:  activityID,\n+\t\tEntityID:    startResp.RunId,\n+\t}\n+\n+\tvisibilityRef, err := chasm.ReadComponent(\n+\t\tctx,\n+\t\tchasm.NewComponentRef[*activity.Activity](entityKey),\n+\t\tfunc(a *activity.Activity, ctx chasm.Context, _ any) ([]byte, error) {\n+\t\t\tvisibility, err := a.Visibility.Get(ctx)\n+\t\t\tif err != nil {\n+\t\t\t\treturn nil, err\n+\t\t\t}\n+\t\t\treturn ctx.Ref(visibility)\n+\t\t},\n+\t\tnil,\n+\t)\n+\trequire.NoError(t, err)\n+\trequire.NotNil(t, visibilityRef)\n+\n+\tpollStarted := make(chan struct{})\n+\tpollCompleted := make(chan []byte, 1)\n+\tpollError := make(chan error, 1)\n+\n+\tgo func() {\n+\t\tclose(pollStarted)\n+\n+\t\t_, ref, err := chasm.PollComponent(\n+\t\t\tctx,\n+\t\t\tvisibilityRef,\n+\t\t\tfunc(v *chasm.Visibility, ctx chasm.Context, _ any) (any, bool, error) {\n+\t\t\t\tsa, err := v.SA.Get(ctx)\n+\t\t\t\tif err != nil {\n+\t\t\t\t\treturn nil, false, err\n+\t\t\t\t}\n+\t\t\t\tif sa != nil && len(sa.IndexedFields) > 0 {\n+\t\t\t\t\t// State has changed, stop waiting\n+\t\t\t\t\treturn nil, true, nil\n+\t\t\t\t}\n+\t\t\t\t// State hasn't changed yet, keep waiting\n+\t\t\t\treturn nil, false, nil\n+\t\t\t},\n+\t\t\tnil,\n+\t\t)\n+\t\tif err != nil {\n+\t\t\tpollError <- err\n+\t\t} else {\n+\t\t\tpollCompleted <- ref\n+\t\t}\n+\t}()\n+\n+\t<-pollStarted\n+\t// Hope that subscription has been established after an arbitrary amount of time\n+\t// TODO(dan)\n+\ttime.Sleep(100 * time.Millisecond)\n+\n+\t// Modify the visibility component via an update targeting its parent activity component\n+\t_, _, err = chasm.UpdateComponent(\n+\t\tctx,\n+\t\tchasm.NewComponentRef[*activity.Activity](entityKey),\n+\t\tfunc(a *activity.Activity, ctx chasm.MutableContext, _ any) (any, error) {\n+\t\t\tvisibility, err := a.Visibility.Get(ctx)\n+\t\t\tif err != nil {\n+\t\t\t\treturn nil, err\n+\t\t\t}\n+\t\t\tvisibility.SA = chasm.NewDataField(ctx, &commonpb.SearchAttributes{\n+\t\t\t\tIndexedFields: map[string]*commonpb.Payload{\n+\t\t\t\t\t\"TestField\": payload.EncodeString(\"updated from parent\"),\n+\t\t\t\t},\n+\t\t\t})\n+\t\t\treturn nil, nil\n+\t\t}, nil)\n+\trequire.NoError(t, err)\n+\n+\tselect {\n+\tcase ref := <-pollCompleted:\n+\t\trequire.NotNil(t, ref)\n+\tcase err := <-pollError:\n+\t\tt.Fatalf(\"Poll failed with error: %v\", err)\n+\tcase <-time.After(5 * time.Second):\n+\t\tt.Fatal(\"Poll did not complete within timeout\")\n+\t}\n+}\n+\n+func (s *standaloneActivityTestSuite) assertActivityExecutionInfo(","path":"tests/standalone_activity_test.go","commit_id":"1d59e66d0ce5d91819f92c428ef5ab4c4efca1fb","original_commit_id":"da6009564e796063faf853352077eecdc1473612","user":{"login":"dandavison","id":52205,"node_id":"MDQ6VXNlcjUyMjA1","avatar_url":"https://avatars.githubusercontent.com/u/52205?v=4","gravatar_id":"","url":"https://api.github.com/users/dandavison","html_url":"https://github.com/dandavison","followers_url":"https://api.github.com/users/dandavison/followers","following_url":"https://api.github.com/users/dandavison/following{/other_user}","gists_url":"https://api.github.com/users/dandavison/gists{/gist_id}","starred_url":"https://api.github.com/users/dandavison/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/dandavison/subscriptions","organizations_url":"https://api.github.com/users/dandavison/orgs","repos_url":"https://api.github.com/users/dandavison/repos","events_url":"https://api.github.com/users/dandavison/events{/privacy}","received_events_url":"https://api.github.com/users/dandavison/received_events","type":"User","user_view_type":"public","site_admin":false},"body":"I understand that view but for now I would like to keep the assertions about the `Info` struct in one place. This is partly because the assertions themselves are evolving as we complete more of the API surface area; let's consider inlining them when that's stable.","created_at":"2025-11-24T00:39:19Z","updated_at":"2025-11-27T03:19:06Z","html_url":"https://github.com/temporalio/temporal/pull/8563#discussion_r2554448253","pull_request_url":"https://api.github.com/repos/temporalio/temporal/pulls/8563","_links":{"self":{"href":"https://api.github.com/repos/temporalio/temporal/pulls/comments/2554448253"},"html":{"href":"https://github.com/temporalio/temporal/pull/8563#discussion_r2554448253"},"pull_request":{"href":"https://api.github.com/repos/temporalio/temporal/pulls/8563"}},"reactions":{"url":"https://api.github.com/repos/temporalio/temporal/pulls/comments/2554448253/reactions","total_count":0,"+1":0,"-1":0,"laugh":0,"hooray":0,"confused":0,"heart":0,"rocket":0,"eyes":0},"start_line":null,"original_start_line":null,"start_side":null,"line":689,"original_line":424,"side":"RIGHT","in_reply_to_id":2540114706,"author_association":"MEMBER","original_position":356,"position":680,"subject_type":"line"},{"url":"https://api.github.com/repos/temporalio/temporal/pulls/comments/2554448486","pull_request_review_id":3489746627,"id":2554448486,"node_id":"PRRC_kwDODNqesM6YQcpm","diff_hunk":"@@ -105,3 +117,377 @@ func createDefaultInput() *commonpb.Payloads {\n \t\t},\n \t}\n }\n+\n+func (s *standaloneActivityTestSuite) Test_PollActivityExecution_NoWait() {\n+\t// Long poll for any state change. PollActivityTaskQueue is used to cause a state change.\n+\tt := s.T()\n+\tctx, cancel := context.WithTimeout(t.Context(), 10*time.Second)\n+\tdefer cancel()\n+\tactivityID := testcore.RandomizeStr(t.Name())\n+\ttaskQueue := uuid.New().String()\n+\n+\tstartResp, err := s.startActivity(ctx, activityID, taskQueue)\n+\trequire.NoError(t, err)\n+\n+\tpollResp, err := s.FrontendClient().PollActivityExecution(ctx, &workflowservice.PollActivityExecutionRequest{\n+\t\tNamespace:    s.Namespace().String(),\n+\t\tActivityId:   activityID,\n+\t\tRunId:        startResp.RunId,\n+\t\tIncludeInfo:  true,\n+\t\tIncludeInput: true,\n+\t})\n+\trequire.NoError(t, err)\n+\trequire.NotNil(t, pollResp.StateChangeLongPollToken)\n+\trequire.NotNil(t, pollResp.Info)\n+\ts.assertActivityExecutionInfo(\n+\t\tt,\n+\t\tpollResp.Info,\n+\t\tactivityID,\n+\t\tstartResp.RunId,\n+\t\tenumspb.PENDING_ACTIVITY_STATE_SCHEDULED,\n+\t)\n+\trequire.NotNil(t, pollResp.Input)\n+\trequire.Equal(t, \"test-activity-input\", string(pollResp.Input.Payloads[0].Data))\n+\t// TODO(dan): test IncludeOutcome\n+}\n+\n+func (s *standaloneActivityTestSuite) Test_PollActivityExecution_WaitAnyStateChange() {\n+\t// Long poll for any state change. PollActivityTaskQueue is used to cause a state change.\n+\tt := s.T()\n+\tctx, cancel := context.WithTimeout(t.Context(), 10*time.Second)\n+\tdefer cancel()\n+\tactivityID := testcore.RandomizeStr(t.Name())\n+\ttaskQueue := uuid.New().String()\n+\n+\tstartResp, err := s.startActivity(ctx, activityID, taskQueue)\n+\trequire.NoError(t, err)\n+\n+\t// First poll lacks token and therefore responds immediately, returning a token\n+\tfirstPollResp, err := s.FrontendClient().PollActivityExecution(ctx, &workflowservice.PollActivityExecutionRequest{\n+\t\tNamespace:  s.Namespace().String(),\n+\t\tActivityId: activityID,\n+\t\tRunId:      startResp.RunId,\n+\t\tWaitPolicy: &workflowservice.PollActivityExecutionRequest_WaitAnyStateChange{\n+\t\t\tWaitAnyStateChange: &workflowservice.PollActivityExecutionRequest_StateChangeWaitOptions{},\n+\t\t},\n+\t\tIncludeInfo:  true,\n+\t\tIncludeInput: true,\n+\t})\n+\trequire.NoError(t, err)\n+\trequire.NotNil(t, firstPollResp.StateChangeLongPollToken)\n+\trequire.NotNil(t, firstPollResp.Info)\n+\ts.assertActivityExecutionInfo(\n+\t\tt,\n+\t\tfirstPollResp.Info,\n+\t\tactivityID,\n+\t\tstartResp.RunId,\n+\t\tenumspb.PENDING_ACTIVITY_STATE_SCHEDULED,\n+\t)\n+\n+\ttaskQueuePollErr := make(chan error, 1)\n+\tactivityPollDone := make(chan struct{})\n+\tvar activityPollResp *workflowservice.PollActivityExecutionResponse\n+\tvar activityPollErr error\n+\n+\tgo func() {\n+\t\tdefer close(activityPollDone)\n+\t\t// Second poll uses token and therefore waits for a state transition\n+\t\tactivityPollResp, activityPollErr = s.FrontendClient().PollActivityExecution(ctx, &workflowservice.PollActivityExecutionRequest{\n+\t\t\tNamespace:    s.Namespace().String(),\n+\t\t\tActivityId:   activityID,\n+\t\t\tRunId:        startResp.RunId,\n+\t\t\tIncludeInfo:  true,\n+\t\t\tIncludeInput: true,\n+\t\t\tWaitPolicy: &workflowservice.PollActivityExecutionRequest_WaitAnyStateChange{\n+\t\t\t\tWaitAnyStateChange: &workflowservice.PollActivityExecutionRequest_StateChangeWaitOptions{\n+\t\t\t\t\tLongPollToken: firstPollResp.StateChangeLongPollToken,\n+\t\t\t\t},\n+\t\t\t},\n+\t\t})\n+\t}()\n+\n+\t// TODO(dan): race here: subscription might not be established yet\n+\n+\t// Worker picks up activity task, triggering transition (via RecordActivityTaskStarted)\n+\tgo func() {\n+\t\t_, err := s.pollActivityTaskQueue(ctx, taskQueue)\n+\t\ttaskQueuePollErr <- err\n+\t}()\n+\n+\tselect {\n+\tcase <-activityPollDone:\n+\t\trequire.NoError(t, activityPollErr)\n+\t\trequire.NotNil(t, activityPollResp)\n+\t\trequire.NotNil(t, activityPollResp.Info)\n+\t\ts.assertActivityExecutionInfo(\n+\t\t\tt,\n+\t\t\tactivityPollResp.Info,\n+\t\t\tactivityID,\n+\t\t\tstartResp.RunId,\n+\t\t\tenumspb.PENDING_ACTIVITY_STATE_STARTED,\n+\t\t)\n+\t\trequire.NotNil(t, activityPollResp.Input)\n+\t\trequire.Equal(t, \"test-activity-input\", string(activityPollResp.Input.Payloads[0].Data))\n+\n+\tcase <-ctx.Done():\n+\t\tt.Fatal(\"PollActivityExecution timed out\")\n+\t}\n+\n+\terr = <-taskQueuePollErr\n+\trequire.NoError(t, err)\n+\n+\t// Manipulate the token to verify token staleness checks (simulate ErrStaleReference). To do so\n+\t// we make use of the internal implementation detail that the bytes are a serialized ref.\n+\ttoken := firstPollResp.StateChangeLongPollToken\n+\tvar pRef persistencespb.ChasmComponentRef\n+\terr = pRef.Unmarshal(token)\n+\trequire.NoError(t, err)\n+\tif pRef.EntityVersionedTransition != nil {\n+\t\tpRef.EntityVersionedTransition.NamespaceFailoverVersion += 1\n+\t}\n+\ttoken, err = pRef.Marshal()\n+\trequire.NoError(t, err)\n+\n+\t_, err = s.FrontendClient().PollActivityExecution(ctx, &workflowservice.PollActivityExecutionRequest{\n+\t\tNamespace:  s.Namespace().String(),\n+\t\tActivityId: activityID,\n+\t\tRunId:      startResp.RunId,\n+\t\tWaitPolicy: &workflowservice.PollActivityExecutionRequest_WaitAnyStateChange{\n+\t\t\tWaitAnyStateChange: &workflowservice.PollActivityExecutionRequest_StateChangeWaitOptions{\n+\t\t\t\tLongPollToken: token,\n+\t\t\t},\n+\t\t},\n+\t})\n+\trequire.Error(t, err)\n+\trequire.ErrorContains(t, err, \"cached mutable state could potentially be stale\")\n+}\n+\n+func (s *standaloneActivityTestSuite) Test_PollActivityExecution_WaitCompletion() {\n+\tt := s.T()\n+\tt.Skip(\"TODO(dan): implement test when RecordActivityTaskCompleted is implemented\")\n+}\n+\n+func (s *standaloneActivityTestSuite) Test_PollActivityExecution_WaitAnyStateChange_Success_UpdateComponent() {\n+\tt := s.T()\n+\tctx, cancel := context.WithTimeout(t.Context(), 10*time.Second)\n+\tdefer cancel()\n+\tctx = chasm.NewEngineContext(ctx, s.chasmEngine)\n+\n+\tactivityID := testcore.RandomizeStr(t.Name())\n+\ttaskQueue := uuid.New().String()\n+\n+\tstartResp, err := s.startActivity(ctx, activityID, taskQueue)\n+\trequire.NoError(t, err)\n+\tentityKey := chasm.EntityKey{\n+\t\tNamespaceID: s.NamespaceID().String(),\n+\t\tBusinessID:  activityID,\n+\t\tEntityID:    startResp.RunId,\n+\t}\n+\n+\t// Test PollActivityExecution(WaitAnyStateChange) without a long-poll token.\n+\tpollResp, err := s.FrontendClient().PollActivityExecution(ctx, &workflowservice.PollActivityExecutionRequest{\n+\t\tNamespace:  s.Namespace().String(),\n+\t\tActivityId: activityID,\n+\t\tRunId:      startResp.RunId,\n+\t\tWaitPolicy: &workflowservice.PollActivityExecutionRequest_WaitAnyStateChange{\n+\t\t\tWaitAnyStateChange: &workflowservice.PollActivityExecutionRequest_StateChangeWaitOptions{},\n+\t\t},\n+\t})\n+\trequire.NoError(t, err)\n+\trequire.NotNil(t, pollResp.GetStateChangeLongPollToken())\n+\trequire.Equal(t, startResp.GetRunId(), pollResp.GetRunId())\n+\n+\t_, _, err = chasm.UpdateComponent(\n+\t\tctx,\n+\t\tchasm.NewComponentRef[*activity.Activity](entityKey),\n+\t\tfunc(a *activity.Activity, ctx chasm.MutableContext, _ any) (any, error) {\n+\t\t\t// Don't actually mutate; just trigger the notification\n+\t\t\treturn nil, nil\n+\t\t}, nil)\n+\trequire.NoError(t, err)\n+\n+\t// Test PollActivityExecution(WaitAnyStateChange) with a long-poll token.\n+\tsecondPollResp, err := s.FrontendClient().PollActivityExecution(ctx, &workflowservice.PollActivityExecutionRequest{\n+\t\tNamespace:  s.Namespace().String(),\n+\t\tActivityId: activityID,\n+\t\tRunId:      startResp.RunId,\n+\t\tWaitPolicy: &workflowservice.PollActivityExecutionRequest_WaitAnyStateChange{\n+\t\t\tWaitAnyStateChange: &workflowservice.PollActivityExecutionRequest_StateChangeWaitOptions{\n+\t\t\t\tLongPollToken: pollResp.GetStateChangeLongPollToken(),\n+\t\t\t},\n+\t\t},\n+\t})\n+\trequire.NoError(t, err)\n+\trequire.NotNil(t, secondPollResp.StateChangeLongPollToken)\n+}\n+\n+// Test_PollVisibility_UpdateFromParent tests that polling for visibility component is woken up when\n+// the parent activity is updated and modifies the visibility.\n+// TODO(dan): this test uses chasm APIs (ReadComponent, UpdateComponent, PollComponent) directly. Is\n+// this illegitimate in tests/?\n+func (s *standaloneActivityTestSuite) Test_PollVisibility_UpdateFromParent() {","path":"tests/standalone_activity_test.go","commit_id":"ee79ea9d2857dc0da255fec35a8ec05b24ecc8c6","original_commit_id":"da6009564e796063faf853352077eecdc1473612","user":{"login":"dandavison","id":52205,"node_id":"MDQ6VXNlcjUyMjA1","avatar_url":"https://avatars.githubusercontent.com/u/52205?v=4","gravatar_id":"","url":"https://api.github.com/users/dandavison","html_url":"https://github.com/dandavison","followers_url":"https://api.github.com/users/dandavison/followers","following_url":"https://api.github.com/users/dandavison/following{/other_user}","gists_url":"https://api.github.com/users/dandavison/gists{/gist_id}","starred_url":"https://api.github.com/users/dandavison/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/dandavison/subscriptions","organizations_url":"https://api.github.com/users/dandavison/orgs","repos_url":"https://api.github.com/users/dandavison/repos","events_url":"https://api.github.com/users/dandavison/events{/privacy}","received_events_url":"https://api.github.com/users/dandavison/received_events","type":"User","user_view_type":"public","site_admin":false},"body":"Yes, again that was deliberate. I didn't know how else to achieve this coverage:\r\n\r\n> This test uses chasm APIs (ReadComponent, UpdateComponent, PollComponent) directly. It's illegitimate to do this in tests/, correct? I do want something like this test.\r\n\r\nWe can't implement it as a CHASM unit test without a lot of disruption because the mocked CHASM execution that those tests use has one component only.\r\n\r\nI think we just have to drop this test coverage for now. However what I would like is for us to have coverage for\r\n\r\n- `PollComponent(child)` is woken up by update to parent component\r\n- `PollComponent(parent)` is woken up by update to child component\r\n- `PollComponent(sib)` is woken up by update to sibling component","created_at":"2025-11-24T00:39:47Z","updated_at":"2025-11-27T03:19:06Z","html_url":"https://github.com/temporalio/temporal/pull/8563#discussion_r2554448486","pull_request_url":"https://api.github.com/repos/temporalio/temporal/pulls/8563","_links":{"self":{"href":"https://api.github.com/repos/temporalio/temporal/pulls/comments/2554448486"},"html":{"href":"https://github.com/temporalio/temporal/pull/8563#discussion_r2554448486"},"pull_request":{"href":"https://api.github.com/repos/temporalio/temporal/pulls/8563"}},"reactions":{"url":"https://api.github.com/repos/temporalio/temporal/pulls/comments/2554448486/reactions","total_count":0,"+1":0,"-1":0,"laugh":0,"hooray":0,"confused":0,"heart":0,"rocket":0,"eyes":0},"start_line":null,"original_start_line":null,"start_side":null,"line":null,"original_line":328,"side":"RIGHT","in_reply_to_id":2540112768,"author_association":"MEMBER","original_position":260,"position":1,"subject_type":"line"},{"url":"https://api.github.com/repos/temporalio/temporal/pulls/comments/2554498634","pull_request_review_id":3489746627,"id":2554498634,"node_id":"PRRC_kwDODNqesM6YQo5K","diff_hunk":"@@ -13,30 +13,42 @@ import (\n \tenumspb \"go.temporal.io/api/enums/v1\"\n \ttaskqueuepb \"go.temporal.io/api/taskqueue/v1\"\n \t\"go.temporal.io/api/workflowservice/v1\"\n+\tpersistencespb \"go.temporal.io/server/api/persistence/v1\"\n+\t\"go.temporal.io/server/chasm\"\n+\t\"go.temporal.io/server/chasm/lib/activity\"\n \t\"go.temporal.io/server/common/dynamicconfig\"\n+\t\"go.temporal.io/server/common/payload\"\n \t\"go.temporal.io/server/tests/testcore\"\n \t\"google.golang.org/protobuf/proto\"\n \t\"google.golang.org/protobuf/types/known/durationpb\"\n )\n \n type standaloneActivityTestSuite struct {\n \ttestcore.FunctionalTestBase\n+\tchasmEngine chasm.Engine","path":"tests/standalone_activity_test.go","commit_id":"a7fd2457a72d9621d986fb36eee14bc23ed5820d","original_commit_id":"da6009564e796063faf853352077eecdc1473612","user":{"login":"dandavison","id":52205,"node_id":"MDQ6VXNlcjUyMjA1","avatar_url":"https://avatars.githubusercontent.com/u/52205?v=4","gravatar_id":"","url":"https://api.github.com/users/dandavison","html_url":"https://github.com/dandavison","followers_url":"https://api.github.com/users/dandavison/followers","following_url":"https://api.github.com/users/dandavison/following{/other_user}","gists_url":"https://api.github.com/users/dandavison/gists{/gist_id}","starred_url":"https://api.github.com/users/dandavison/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/dandavison/subscriptions","organizations_url":"https://api.github.com/users/dandavison/orgs","repos_url":"https://api.github.com/users/dandavison/repos","events_url":"https://api.github.com/users/dandavison/events{/privacy}","received_events_url":"https://api.github.com/users/dandavison/received_events","type":"User","user_view_type":"public","site_admin":false},"body":"Yes, sorry, this state was intentional and temporary because I wanted to test long-poll with updates to two different components, and the CHASM unit tests are currently not set up to perform tests against a multi-component execution.","created_at":"2025-11-24T02:03:43Z","updated_at":"2025-11-27T03:19:06Z","html_url":"https://github.com/temporalio/temporal/pull/8563#discussion_r2554498634","pull_request_url":"https://api.github.com/repos/temporalio/temporal/pulls/8563","_links":{"self":{"href":"https://api.github.com/repos/temporalio/temporal/pulls/comments/2554498634"},"html":{"href":"https://github.com/temporalio/temporal/pull/8563#discussion_r2554498634"},"pull_request":{"href":"https://api.github.com/repos/temporalio/temporal/pulls/8563"}},"reactions":{"url":"https://api.github.com/repos/temporalio/temporal/pulls/comments/2554498634/reactions","total_count":0,"+1":0,"-1":0,"laugh":0,"hooray":0,"confused":0,"heart":0,"rocket":0,"eyes":0},"start_line":null,"original_start_line":null,"start_side":null,"line":null,"original_line":28,"side":"RIGHT","in_reply_to_id":2540083814,"author_association":"MEMBER","original_position":16,"position":1,"subject_type":"line"},{"url":"https://api.github.com/repos/temporalio/temporal/pulls/comments/2554499554","pull_request_review_id":3489746627,"id":2554499554,"node_id":"PRRC_kwDODNqesM6YQpHi","diff_hunk":"@@ -105,3 +117,377 @@ func createDefaultInput() *commonpb.Payloads {\n \t\t},\n \t}\n }\n+\n+func (s *standaloneActivityTestSuite) Test_PollActivityExecution_NoWait() {\n+\t// Long poll for any state change. PollActivityTaskQueue is used to cause a state change.\n+\tt := s.T()\n+\tctx, cancel := context.WithTimeout(t.Context(), 10*time.Second)\n+\tdefer cancel()\n+\tactivityID := testcore.RandomizeStr(t.Name())\n+\ttaskQueue := uuid.New().String()","path":"tests/standalone_activity_test.go","commit_id":"ee79ea9d2857dc0da255fec35a8ec05b24ecc8c6","original_commit_id":"da6009564e796063faf853352077eecdc1473612","user":{"login":"dandavison","id":52205,"node_id":"MDQ6VXNlcjUyMjA1","avatar_url":"https://avatars.githubusercontent.com/u/52205?v=4","gravatar_id":"","url":"https://api.github.com/users/dandavison","html_url":"https://github.com/dandavison","followers_url":"https://api.github.com/users/dandavison/followers","following_url":"https://api.github.com/users/dandavison/following{/other_user}","gists_url":"https://api.github.com/users/dandavison/gists{/gist_id}","starred_url":"https://api.github.com/users/dandavison/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/dandavison/subscriptions","organizations_url":"https://api.github.com/users/dandavison/orgs","repos_url":"https://api.github.com/users/dandavison/repos","events_url":"https://api.github.com/users/dandavison/events{/privacy}","received_events_url":"https://api.github.com/users/dandavison/received_events","type":"User","user_view_type":"public","site_admin":false},"body":"Thanks, done","created_at":"2025-11-24T02:05:03Z","updated_at":"2025-11-27T03:19:06Z","html_url":"https://github.com/temporalio/temporal/pull/8563#discussion_r2554499554","pull_request_url":"https://api.github.com/repos/temporalio/temporal/pulls/8563","_links":{"self":{"href":"https://api.github.com/repos/temporalio/temporal/pulls/comments/2554499554"},"html":{"href":"https://github.com/temporalio/temporal/pull/8563#discussion_r2554499554"},"pull_request":{"href":"https://api.github.com/repos/temporalio/temporal/pulls/8563"}},"reactions":{"url":"https://api.github.com/repos/temporalio/temporal/pulls/comments/2554499554/reactions","total_count":0,"+1":0,"-1":0,"laugh":0,"hooray":0,"confused":0,"heart":0,"rocket":0,"eyes":0},"start_line":null,"original_start_line":null,"start_side":null,"line":null,"original_line":127,"side":"RIGHT","in_reply_to_id":2540086736,"author_association":"MEMBER","original_position":59,"position":1,"subject_type":"line"},{"url":"https://api.github.com/repos/temporalio/temporal/pulls/comments/2554501008","pull_request_review_id":3489746627,"id":2554501008,"node_id":"PRRC_kwDODNqesM6YQpeQ","diff_hunk":"@@ -105,3 +117,377 @@ func createDefaultInput() *commonpb.Payloads {\n \t\t},\n \t}\n }\n+\n+func (s *standaloneActivityTestSuite) Test_PollActivityExecution_NoWait() {\n+\t// Long poll for any state change. PollActivityTaskQueue is used to cause a state change.\n+\tt := s.T()\n+\tctx, cancel := context.WithTimeout(t.Context(), 10*time.Second)\n+\tdefer cancel()\n+\tactivityID := testcore.RandomizeStr(t.Name())\n+\ttaskQueue := uuid.New().String()\n+\n+\tstartResp, err := s.startActivity(ctx, activityID, taskQueue)\n+\trequire.NoError(t, err)\n+\n+\tpollResp, err := s.FrontendClient().PollActivityExecution(ctx, &workflowservice.PollActivityExecutionRequest{\n+\t\tNamespace:    s.Namespace().String(),\n+\t\tActivityId:   activityID,\n+\t\tRunId:        startResp.RunId,","path":"tests/standalone_activity_test.go","commit_id":"cd288dc5f2393c7e2771319f23fd89d46c958bab","original_commit_id":"da6009564e796063faf853352077eecdc1473612","user":{"login":"dandavison","id":52205,"node_id":"MDQ6VXNlcjUyMjA1","avatar_url":"https://avatars.githubusercontent.com/u/52205?v=4","gravatar_id":"","url":"https://api.github.com/users/dandavison","html_url":"https://github.com/dandavison","followers_url":"https://api.github.com/users/dandavison/followers","following_url":"https://api.github.com/users/dandavison/following{/other_user}","gists_url":"https://api.github.com/users/dandavison/gists{/gist_id}","starred_url":"https://api.github.com/users/dandavison/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/dandavison/subscriptions","organizations_url":"https://api.github.com/users/dandavison/orgs","repos_url":"https://api.github.com/users/dandavison/repos","events_url":"https://api.github.com/users/dandavison/events{/privacy}","received_events_url":"https://api.github.com/users/dandavison/received_events","type":"User","user_view_type":"public","site_admin":false},"body":"Good call, done.","created_at":"2025-11-24T02:07:06Z","updated_at":"2025-11-27T03:19:06Z","html_url":"https://github.com/temporalio/temporal/pull/8563#discussion_r2554501008","pull_request_url":"https://api.github.com/repos/temporalio/temporal/pulls/8563","_links":{"self":{"href":"https://api.github.com/repos/temporalio/temporal/pulls/comments/2554501008"},"html":{"href":"https://github.com/temporalio/temporal/pull/8563#discussion_r2554501008"},"pull_request":{"href":"https://api.github.com/repos/temporalio/temporal/pulls/8563"}},"reactions":{"url":"https://api.github.com/repos/temporalio/temporal/pulls/comments/2554501008/reactions","total_count":0,"+1":0,"-1":0,"laugh":0,"hooray":0,"confused":0,"heart":0,"rocket":0,"eyes":0},"start_line":null,"original_start_line":null,"start_side":null,"line":null,"original_line":135,"side":"RIGHT","in_reply_to_id":2540085010,"author_association":"MEMBER","original_position":67,"position":1,"subject_type":"line"},{"url":"https://api.github.com/repos/temporalio/temporal/pulls/comments/2554506057","pull_request_review_id":3489746627,"id":2554506057,"node_id":"PRRC_kwDODNqesM6YQqtJ","diff_hunk":"@@ -53,3 +52,90 @@ func (h *handler) StartActivityExecution(ctx context.Context, req *activitypb.St\n \t\tFrontendResponse: response,\n \t}, nil\n }\n+\n+// PollActivityExecution handles PollActivityExecutionRequest from frontend. This method supports\n+// querying current activity state, optionally as a long-poll that waits for certain state changes.\n+// It is used by clients to poll for activity state and/or result.\n+func (h *handler) PollActivityExecution(\n+\tctx context.Context,\n+\treq *activitypb.PollActivityExecutionRequest,\n+) (response *activitypb.PollActivityExecutionResponse, err error) {\n+\tref := chasm.NewComponentRef[*Activity](chasm.EntityKey{\n+\t\tNamespaceID: req.GetNamespaceId(),\n+\t\tBusinessID:  req.GetFrontendRequest().GetActivityId(),\n+\t\tEntityID:    req.GetFrontendRequest().GetRunId(),\n+\t})\n+\twaitPolicy := req.GetFrontendRequest().GetWaitPolicy()\n+\n+\tif waitPolicy == nil {\n+\t\treturn chasm.ReadComponent(ctx, ref, (*Activity).buildPollActivityExecutionResponse, req, nil)\n+\t}\n+\n+\tswitch waitPolicy.(type) {\n+\tcase *workflowservice.PollActivityExecutionRequest_WaitAnyStateChange:\n+\t\ttoken := req.GetFrontendRequest().\n+\t\t\tGetWaitPolicy().(*workflowservice.PollActivityExecutionRequest_WaitAnyStateChange).\n+\t\t\tWaitAnyStateChange.GetLongPollToken()\n+\t\tresponse, _, err = chasm.PollComponent(ctx, ref, func(\n+\t\t\ta *Activity,\n+\t\t\tctx chasm.Context,\n+\t\t\treq *activitypb.PollActivityExecutionRequest,\n+\t\t) (*activitypb.PollActivityExecutionResponse, bool, error) {\n+\t\t\t_, changed, err := chasm.ExecutionStateChanged(a, ctx, token)\n+\t\t\tif err != nil {\n+\t\t\t\treturn nil, false, err\n+\t\t\t}\n+\t\t\tif changed {\n+\t\t\t\t// TODO(dan): pass ref returned by HasStateAdvanced into this?\n+\t\t\t\tresponse, err := a.buildPollActivityExecutionResponse(ctx, req)\n+\t\t\t\tif err != nil {\n+\t\t\t\t\treturn nil, true, err\n+\t\t\t\t}\n+\t\t\t\treturn response, true, nil","path":"chasm/lib/activity/handler.go","commit_id":"ee79ea9d2857dc0da255fec35a8ec05b24ecc8c6","original_commit_id":"da6009564e796063faf853352077eecdc1473612","user":{"login":"dandavison","id":52205,"node_id":"MDQ6VXNlcjUyMjA1","avatar_url":"https://avatars.githubusercontent.com/u/52205?v=4","gravatar_id":"","url":"https://api.github.com/users/dandavison","html_url":"https://github.com/dandavison","followers_url":"https://api.github.com/users/dandavison/followers","following_url":"https://api.github.com/users/dandavison/following{/other_user}","gists_url":"https://api.github.com/users/dandavison/gists{/gist_id}","starred_url":"https://api.github.com/users/dandavison/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/dandavison/subscriptions","organizations_url":"https://api.github.com/users/dandavison/orgs","repos_url":"https://api.github.com/users/dandavison/repos","events_url":"https://api.github.com/users/dandavison/events{/privacy}","received_events_url":"https://api.github.com/users/dandavison/received_events","type":"User","user_view_type":"public","site_admin":false},"body":" ","created_at":"2025-11-24T02:14:26Z","updated_at":"2025-11-27T03:19:05Z","html_url":"https://github.com/temporalio/temporal/pull/8563#discussion_r2554506057","pull_request_url":"https://api.github.com/repos/temporalio/temporal/pulls/8563","_links":{"self":{"href":"https://api.github.com/repos/temporalio/temporal/pulls/comments/2554506057"},"html":{"href":"https://github.com/temporalio/temporal/pull/8563#discussion_r2554506057"},"pull_request":{"href":"https://api.github.com/repos/temporalio/temporal/pulls/8563"}},"reactions":{"url":"https://api.github.com/repos/temporalio/temporal/pulls/comments/2554506057/reactions","total_count":0,"+1":0,"-1":0,"laugh":0,"hooray":0,"confused":0,"heart":0,"rocket":0,"eyes":0},"start_line":null,"original_start_line":91,"start_side":"RIGHT","line":null,"original_line":94,"side":"RIGHT","in_reply_to_id":2539894829,"author_association":"MEMBER","original_position":62,"position":1,"subject_type":"line"},{"url":"https://api.github.com/repos/temporalio/temporal/pulls/comments/2557405619","pull_request_review_id":3501836960,"id":2557405619,"node_id":"PRRC_kwDODNqesM6Ybumz","diff_hunk":"@@ -187,9 +188,34 @@ func (t *TransactionImpl) UpdateWorkflowExecution(\n \t\t},\n \t\tisWorkflow,\n \t)\n+\n \tif persistence.OperationPossiblySucceeded(err) {\n \t\tNotifyWorkflowMutationTasks(engine, currentWorkflowMutation)\n \t\tNotifyWorkflowSnapshotTasks(engine, newWorkflowSnapshot)\n+\n+\t\tif persistence.OperationPossiblySucceeded(err) {\n+\t\t\tNotifyWorkflowMutationTasks(engine, currentWorkflowMutation)\n+\t\t\tNotifyWorkflowSnapshotTasks(engine, newWorkflowSnapshot)\n+\n+\t\t\t// Notify for current workflow if it has CHASM updates\n+\t\t\tif len(currentWorkflowMutation.UpsertChasmNodes) > 0 ||\n+\t\t\t\tlen(currentWorkflowMutation.DeleteChasmNodes) > 0 {\n+\t\t\t\tengine.NotifyChasmExecution(chasm.EntityKey{\n+\t\t\t\t\tNamespaceID: currentWorkflowMutation.ExecutionInfo.NamespaceId,\n+\t\t\t\t\tBusinessID:  currentWorkflowMutation.ExecutionInfo.WorkflowId,\n+\t\t\t\t\tEntityID:    currentWorkflowMutation.ExecutionState.RunId,\n+\t\t\t\t}, nil)\n+\t\t\t}\n+\n+\t\t\t// Notify for new workflow if it has CHASM nodes\n+\t\t\tif newWorkflowSnapshot != nil && len(newWorkflowSnapshot.ChasmNodes) > 0 {\n+\t\t\t\tengine.NotifyChasmExecution(chasm.EntityKey{\n+\t\t\t\t\tNamespaceID: newWorkflowSnapshot.ExecutionInfo.NamespaceId,\n+\t\t\t\t\tBusinessID:  newWorkflowSnapshot.ExecutionInfo.WorkflowId,\n+\t\t\t\t\tEntityID:    newWorkflowSnapshot.ExecutionState.RunId,\n+\t\t\t\t}, nil)\n+\t\t\t}\n+\t\t}","path":"service/history/workflow/transaction_impl.go","commit_id":"1d59e66d0ce5d91819f92c428ef5ab4c4efca1fb","original_commit_id":"e95ab0ad0ba0c42c1e0e125042367ada0583ea76","user":{"login":"cursor[bot]","id":206951365,"node_id":"BOT_kgDODFXTxQ","avatar_url":"https://avatars.githubusercontent.com/in/1210556?v=4","gravatar_id":"","url":"https://api.github.com/users/cursor%5Bbot%5D","html_url":"https://github.com/apps/cursor","followers_url":"https://api.github.com/users/cursor%5Bbot%5D/followers","following_url":"https://api.github.com/users/cursor%5Bbot%5D/following{/other_user}","gists_url":"https://api.github.com/users/cursor%5Bbot%5D/gists{/gist_id}","starred_url":"https://api.github.com/users/cursor%5Bbot%5D/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/cursor%5Bbot%5D/subscriptions","organizations_url":"https://api.github.com/users/cursor%5Bbot%5D/orgs","repos_url":"https://api.github.com/users/cursor%5Bbot%5D/repos","events_url":"https://api.github.com/users/cursor%5Bbot%5D/events{/privacy}","received_events_url":"https://api.github.com/users/cursor%5Bbot%5D/received_events","type":"Bot","user_view_type":"public","site_admin":false},"body":"### Bug: Duplicate notification logic in UpdateWorkflowExecution\n\n<!-- **Medium Severity** -->\n\n<!-- DESCRIPTION START -->\nThe notification logic in `UpdateWorkflowExecution` is duplicated inside a nested `if persistence.OperationPossiblySucceeded(err)` block. Lines 193-194 call `NotifyWorkflowMutationTasks` and `NotifyWorkflowSnapshotTasks`, then lines 197-198 duplicate the exact same calls. This redundancy causes workflow tasks and snapshot tasks to be notified twice, and CHASM execution notifications to execute when they shouldn't (since the nested block's condition is always true when the outer block executes). The nested block starting at line 196 should be removed entirely.\n<!-- DESCRIPTION END -->\n\n<!-- LOCATIONS START\nservice/history/workflow/transaction_impl.go#L191-L218\nLOCATIONS END -->\n<a href=\"https://cursor.com/open?data=eyJhbGciOiJSUzI1NiIsInR5cCI6IkpXVCIsImtpZCI6ImJ1Z2JvdC12MSJ9.eyJ2ZXJzaW9uIjoxLCJ0eXBlIjoiQlVHQk9UX0ZJWF9JTl9DVVJTT1IiLCJkYXRhIjp7InJlZGlzS2V5IjoiYnVnYm90OjY3YWM4NTkzLTRhNjYtNDZmZi05YWI3LTM0MjFhNzNkNmExMSIsImVuY3J5cHRpb25LZXkiOiJ6cUZpMmNZcFlQeXdtbGZVX21GaUxGRjZBTHpCWTdJOTJoRUF4bGpGZlJZIiwiYnJhbmNoIjoicG9sbC1jb21wb25lbnQifSwiaWF0IjoxNzY0MDExNDU1LCJleHAiOjE3NjQ2MTYyNTV9.aS3O2x9DyG9C7gYOpaVbC-KpAf2HTpKsY-HOe2pYICTUM39PPtUhXhhjRQ0t0QjVT3N3FPJgKguPxP6RDybXeHlInVKnqBW9SpAU4NlS9hY2DAIPuEeauqoyp6ZTjhIcULrQl_28ThwEiKUUFvbcBKTkEtFplNKuBD-Dl82A1WhJ-inQKNhXahuFbf97h4_QkxfF_0kouayQFaG1xTD98kbQnsmRcMasNnE92r679Pt_nbK3ECyBISWzsUSXq8QlmnoyapJr9qYjj-7QY5c-XU5s9_XXm1EcypmdkApqp3gnOB36EicZH05IjiG71j5XZf_rSkhihQgq-lvYLeXgOw\"><picture><source media=\"(prefers-color-scheme: dark)\" srcset=\"https://cursor.com/fix-in-cursor-dark.svg\"><source media=\"(prefers-color-scheme: light)\" srcset=\"https://cursor.com/fix-in-cursor-light.svg\"><img alt=\"Fix in Cursor\" src=\"https://cursor.com/fix-in-cursor.svg\"></picture></a>&nbsp;<a href=\"https://cursor.com/agents?data=eyJhbGciOiJSUzI1NiIsInR5cCI6IkpXVCIsImtpZCI6ImJ1Z2JvdC12MSJ9.eyJ2ZXJzaW9uIjoxLCJ0eXBlIjoiQlVHQk9UX0ZJWF9JTl9XRUIiLCJkYXRhIjp7InJlZGlzS2V5IjoiYnVnYm90OjY3YWM4NTkzLTRhNjYtNDZmZi05YWI3LTM0MjFhNzNkNmExMSIsImVuY3J5cHRpb25LZXkiOiJ6cUZpMmNZcFlQeXdtbGZVX21GaUxGRjZBTHpCWTdJOTJoRUF4bGpGZlJZIiwiYnJhbmNoIjoicG9sbC1jb21wb25lbnQiLCJyZXBvT3duZXIiOiJ0ZW1wb3JhbGlvIiwicmVwb05hbWUiOiJ0ZW1wb3JhbCIsInByTnVtYmVyIjo4NTYzLCJjb21taXRTaGEiOiJlOTVhYjBhZDBiYTBjNDJjMWUwZTEyNTA0MjM2N2FkYTA1ODNlYTc2IiwicHJvdmlkZXIiOiJnaXRodWIifSwiaWF0IjoxNzY0MDExNDU1LCJleHAiOjE3NjQ2MTYyNTV9.ihggaORIOknNwjagekZUge30QB25pLTc8XE1cnekorGRqdZkmj2fmuk9En3o0bLkZ8aM1gk99ViPTFl2cFkdtvRwynrQtqEbtQsuTzSxSac8Dk6gFwc0BH3qgU0s7T-hmJHVBB-G6JzoXwZQ9a_mFwQdekTd-fHFyBWJYIU9h9NOtMXilduDNOT4vs-cb0qFJrLAInaMQ9eB0kFm5Xuz_CJ4N5ynnK5mFQD7aWmM4_eNdvekhlLydN8IUvXUJhwig39H4yxJMf3BJ-khks4wYEX7rahur0vJc2RREPrnrD0eZy_9AzIceaKuWtTm-nGMQUS45QT0sZe-dPy0dWEdsw\"><picture><source media=\"(prefers-color-scheme: dark)\" srcset=\"https://cursor.com/fix-in-web-dark.svg\"><source media=\"(prefers-color-scheme: light)\" srcset=\"https://cursor.com/fix-in-web-light.svg\"><img alt=\"Fix in Web\" src=\"https://cursor.com/fix-in-web.svg\"></picture></a>\n\n","created_at":"2025-11-24T19:10:56Z","updated_at":"2025-11-24T19:10:56Z","html_url":"https://github.com/temporalio/temporal/pull/8563#discussion_r2557405619","pull_request_url":"https://api.github.com/repos/temporalio/temporal/pulls/8563","_links":{"self":{"href":"https://api.github.com/repos/temporalio/temporal/pulls/comments/2557405619"},"html":{"href":"https://github.com/temporalio/temporal/pull/8563#discussion_r2557405619"},"pull_request":{"href":"https://api.github.com/repos/temporalio/temporal/pulls/8563"}},"reactions":{"url":"https://api.github.com/repos/temporalio/temporal/pulls/comments/2557405619/reactions","total_count":0,"+1":0,"-1":0,"laugh":0,"hooray":0,"confused":0,"heart":0,"rocket":0,"eyes":0},"start_line":null,"original_start_line":null,"start_side":null,"line":214,"original_line":218,"side":"RIGHT","author_association":"NONE","original_position":39,"position":32,"subject_type":"line"},{"url":"https://api.github.com/repos/temporalio/temporal/pulls/comments/2557405633","pull_request_review_id":3501836960,"id":2557405633,"node_id":"PRRC_kwDODNqesM6YbunB","diff_hunk":"@@ -51,3 +54,93 @@ func (h *handler) StartActivityExecution(ctx context.Context, req *activitypb.St\n \t\tFrontendResponse: response,\n \t}, nil\n }\n+\n+// PollActivityExecution handles PollActivityExecutionRequest from frontend. This method supports\n+// querying current activity state, optionally as a long-poll that waits for certain state changes.\n+// It is used by clients to poll for activity state and/or result.\n+func (h *handler) PollActivityExecution(\n+\tctx context.Context,\n+\treq *activitypb.PollActivityExecutionRequest,\n+) (response *activitypb.PollActivityExecutionResponse, err error) {\n+\tref := chasm.NewComponentRef[*Activity](chasm.EntityKey{\n+\t\tNamespaceID: req.GetNamespaceId(),\n+\t\tBusinessID:  req.GetFrontendRequest().GetActivityId(),\n+\t\tEntityID:    req.GetFrontendRequest().GetRunId(),\n+\t})\n+\twaitPolicy := req.GetFrontendRequest().GetWaitPolicy()\n+\n+\tif waitPolicy == nil {\n+\t\treturn chasm.ReadComponent(ctx, ref, (*Activity).buildPollActivityExecutionResponse, req, nil)\n+\t}\n+\n+\t// Do not allow long-poll to use all remaining time\n+\tctx, cancel := context.WithTimeout(ctx, time.Second)","path":"chasm/lib/activity/handler.go","commit_id":"e95ab0ad0ba0c42c1e0e125042367ada0583ea76","original_commit_id":"e95ab0ad0ba0c42c1e0e125042367ada0583ea76","user":{"login":"cursor[bot]","id":206951365,"node_id":"BOT_kgDODFXTxQ","avatar_url":"https://avatars.githubusercontent.com/in/1210556?v=4","gravatar_id":"","url":"https://api.github.com/users/cursor%5Bbot%5D","html_url":"https://github.com/apps/cursor","followers_url":"https://api.github.com/users/cursor%5Bbot%5D/followers","following_url":"https://api.github.com/users/cursor%5Bbot%5D/following{/other_user}","gists_url":"https://api.github.com/users/cursor%5Bbot%5D/gists{/gist_id}","starred_url":"https://api.github.com/users/cursor%5Bbot%5D/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/cursor%5Bbot%5D/subscriptions","organizations_url":"https://api.github.com/users/cursor%5Bbot%5D/orgs","repos_url":"https://api.github.com/users/cursor%5Bbot%5D/repos","events_url":"https://api.github.com/users/cursor%5Bbot%5D/events{/privacy}","received_events_url":"https://api.github.com/users/cursor%5Bbot%5D/received_events","type":"Bot","user_view_type":"public","site_admin":false},"body":"### Bug: Hardcoded timeout overrides configured long-poll timeout\n\n<!-- **Medium Severity** -->\n\n<!-- DESCRIPTION START -->\nThe handler applies a hardcoded 1-second timeout to all long-poll requests, which overrides the server's configured `LongPollExpirationInterval` (default 20 seconds). This causes long-polls to timeout after only 1 second instead of the intended duration. The `PollComponent` implementation in the engine applies the proper configured timeout using `shardContext.GetConfig().LongPollExpirationInterval()`, but the hardcoded timeout in the handler prevents it from being effective, resulting in premature timeouts and inefficient polling behavior.\n<!-- DESCRIPTION END -->\n\n<!-- LOCATIONS START\nchasm/lib/activity/handler.go#L76-L77\nLOCATIONS END -->\n<a href=\"https://cursor.com/open?data=eyJhbGciOiJSUzI1NiIsInR5cCI6IkpXVCIsImtpZCI6ImJ1Z2JvdC12MSJ9.eyJ2ZXJzaW9uIjoxLCJ0eXBlIjoiQlVHQk9UX0ZJWF9JTl9DVVJTT1IiLCJkYXRhIjp7InJlZGlzS2V5IjoiYnVnYm90OjM3YmQ4ZjYxLTg5YzQtNDI5OS1hYzM4LWUxZWIzMTVkODEzMCIsImVuY3J5cHRpb25LZXkiOiJzUXI0cEc0LUdNc25NZ1FYNU9WMnd6TTRRMTBWY3FnODNUVTlMYWRTSnk4IiwiYnJhbmNoIjoicG9sbC1jb21wb25lbnQifSwiaWF0IjoxNzY0MDExNDU1LCJleHAiOjE3NjQ2MTYyNTV9.eTJtjgh9Fk4-7Bqw1PrMfTQqJrCUMIYyME4ZkpqnW23sLyOFWqF8IBOYglbvZH5Ccg4Kq4QADM0Mnrlo_xYGp_am2vGSI1t1T7vBcWqqSFlTBudo9_0Ny1CSfWL4d0mOoF7roysXsYSepF21xIWd8wcdyXOunfQLwazkb3htQXjHfqamWlmryhHzDBbx1PFBFdXhE7YU7VtCc6O2NgkMWbePzxfrCOOpF0iuc4PJFYIqexzv1MAQbgr2ZJ-YahqDGT4qwOChZ981x-I4kDXMYFTQVH788iTZj73eQFIXALkkBGijhfIXOT5eDNJ6hMTQgojqx7kE0FpLzSrTaKeG6w\"><picture><source media=\"(prefers-color-scheme: dark)\" srcset=\"https://cursor.com/fix-in-cursor-dark.svg\"><source media=\"(prefers-color-scheme: light)\" srcset=\"https://cursor.com/fix-in-cursor-light.svg\"><img alt=\"Fix in Cursor\" src=\"https://cursor.com/fix-in-cursor.svg\"></picture></a>&nbsp;<a href=\"https://cursor.com/agents?data=eyJhbGciOiJSUzI1NiIsInR5cCI6IkpXVCIsImtpZCI6ImJ1Z2JvdC12MSJ9.eyJ2ZXJzaW9uIjoxLCJ0eXBlIjoiQlVHQk9UX0ZJWF9JTl9XRUIiLCJkYXRhIjp7InJlZGlzS2V5IjoiYnVnYm90OjM3YmQ4ZjYxLTg5YzQtNDI5OS1hYzM4LWUxZWIzMTVkODEzMCIsImVuY3J5cHRpb25LZXkiOiJzUXI0cEc0LUdNc25NZ1FYNU9WMnd6TTRRMTBWY3FnODNUVTlMYWRTSnk4IiwiYnJhbmNoIjoicG9sbC1jb21wb25lbnQiLCJyZXBvT3duZXIiOiJ0ZW1wb3JhbGlvIiwicmVwb05hbWUiOiJ0ZW1wb3JhbCIsInByTnVtYmVyIjo4NTYzLCJjb21taXRTaGEiOiJlOTVhYjBhZDBiYTBjNDJjMWUwZTEyNTA0MjM2N2FkYTA1ODNlYTc2IiwicHJvdmlkZXIiOiJnaXRodWIifSwiaWF0IjoxNzY0MDExNDU1LCJleHAiOjE3NjQ2MTYyNTV9.LS69hj9DESUJM1yBd8w7DBUTCnLCmIceJTVMOVzb3eINXyjWj8npb-zjJr1jZ-k2ei624WjWLx-u6KEgWi85oAoGZrEIMIu3JwzJ52utq6gew_nQhwwpHKWX5gXQo6l0UBWSCasJwxYEl-fYe6PlW7DuDlZC2Kj7XKHqee0-08AstTxSCGUOANnmh7HfERJ3tnl6fPhKGhTonVXHXjRWgexyND2GA4_BgsQkRcO4oSDvxyx4erzbX_U9d6yw7twc-wUwIl8eJOOATdFWkt_wBj3jPmKZAM1iSDR5eVIFw3-GPR6w4bNGRmUOKQKfcKG9-fHpKpfzxch1qsApI45ztg\"><picture><source media=\"(prefers-color-scheme: dark)\" srcset=\"https://cursor.com/fix-in-web-dark.svg\"><source media=\"(prefers-color-scheme: light)\" srcset=\"https://cursor.com/fix-in-web-light.svg\"><img alt=\"Fix in Web\" src=\"https://cursor.com/fix-in-web.svg\"></picture></a>\n\n","created_at":"2025-11-24T19:10:56Z","updated_at":"2025-11-24T19:10:56Z","html_url":"https://github.com/temporalio/temporal/pull/8563#discussion_r2557405633","pull_request_url":"https://api.github.com/repos/temporalio/temporal/pulls/8563","_links":{"self":{"href":"https://api.github.com/repos/temporalio/temporal/pulls/comments/2557405633"},"html":{"href":"https://github.com/temporalio/temporal/pull/8563#discussion_r2557405633"},"pull_request":{"href":"https://api.github.com/repos/temporalio/temporal/pulls/8563"}},"reactions":{"url":"https://api.github.com/repos/temporalio/temporal/pulls/comments/2557405633/reactions","total_count":0,"+1":0,"-1":0,"laugh":0,"hooray":0,"confused":0,"heart":0,"rocket":0,"eyes":0},"start_line":null,"original_start_line":null,"start_side":null,"line":null,"original_line":77,"side":"RIGHT","author_association":"NONE","original_position":35,"position":1,"subject_type":"line"},{"url":"https://api.github.com/repos/temporalio/temporal/pulls/comments/2557405643","pull_request_review_id":3501836960,"id":2557405643,"node_id":"PRRC_kwDODNqesM6YbunL","diff_hunk":"@@ -51,3 +54,93 @@ func (h *handler) StartActivityExecution(ctx context.Context, req *activitypb.St\n \t\tFrontendResponse: response,\n \t}, nil\n }\n+\n+// PollActivityExecution handles PollActivityExecutionRequest from frontend. This method supports\n+// querying current activity state, optionally as a long-poll that waits for certain state changes.\n+// It is used by clients to poll for activity state and/or result.\n+func (h *handler) PollActivityExecution(\n+\tctx context.Context,\n+\treq *activitypb.PollActivityExecutionRequest,\n+) (response *activitypb.PollActivityExecutionResponse, err error) {\n+\tref := chasm.NewComponentRef[*Activity](chasm.EntityKey{\n+\t\tNamespaceID: req.GetNamespaceId(),\n+\t\tBusinessID:  req.GetFrontendRequest().GetActivityId(),\n+\t\tEntityID:    req.GetFrontendRequest().GetRunId(),\n+\t})\n+\twaitPolicy := req.GetFrontendRequest().GetWaitPolicy()\n+\n+\tif waitPolicy == nil {\n+\t\treturn chasm.ReadComponent(ctx, ref, (*Activity).buildPollActivityExecutionResponse, req, nil)\n+\t}\n+\n+\t// Do not allow long-poll to use all remaining time\n+\tctx, cancel := context.WithTimeout(ctx, time.Second)\n+\tdefer cancel()\n+\n+\tswitch waitPolicy.(type) {\n+\tcase *workflowservice.PollActivityExecutionRequest_WaitAnyStateChange:\n+\t\ttoken := req.GetFrontendRequest().\n+\t\t\tGetWaitPolicy().(*workflowservice.PollActivityExecutionRequest_WaitAnyStateChange).\n+\t\t\tWaitAnyStateChange.GetLongPollToken()\n+\t\tresponse, _, err = chasm.PollComponent(ctx, ref, func(\n+\t\t\ta *Activity,\n+\t\t\tctx chasm.Context,\n+\t\t\treq *activitypb.PollActivityExecutionRequest,\n+\t\t) (*activitypb.PollActivityExecutionResponse, bool, error) {\n+\t\t\t_, changed, err := chasm.ExecutionStateChanged(a, ctx, token)\n+\t\t\tif err != nil {\n+\t\t\t\treturn nil, false, err\n+\t\t\t}\n+\t\t\tif changed {\n+\t\t\t\tresponse, err := a.buildPollActivityExecutionResponse(ctx, req)\n+\t\t\t\treturn response, true, err\n+\t\t\t} else {\n+\t\t\t\treturn nil, false, nil\n+\t\t\t}\n+\t\t}, req)\n+\tcase *workflowservice.PollActivityExecutionRequest_WaitCompletion:\n+\t\t// TODO(dan): add functional test when RecordActivityTaskCompleted is implemented\n+\t\tresponse, _, err = chasm.PollComponent(ctx, ref, func(\n+\t\t\ta *Activity,\n+\t\t\tctx chasm.Context,\n+\t\t\treq *activitypb.PollActivityExecutionRequest,\n+\t\t) (*activitypb.PollActivityExecutionResponse, bool, error) {\n+\t\t\t// TODO(dan): check for terminal activity states\n+\t\t\tpanic(\"pollActivityExecutionWaitCompletion is not implemented\")\n+\t\t\tcompleted := false\n+\t\t\tif completed {\n+\t\t\t\tresponse, err := a.buildPollActivityExecutionResponse(ctx, req)\n+\t\t\t\tif err != nil {\n+\t\t\t\t\treturn nil, true, err\n+\t\t\t\t}\n+\t\t\t\treturn response, true, nil\n+\t\t\t}\n+\t\t\treturn nil, false, nil\n+\t\t}, req)\n+\tdefault:\n+\t\treturn nil, serviceerror.NewInvalidArgumentf(\"unexpected wait policy type: %T\", waitPolicy)\n+\t}\n+\tif err != nil {\n+\t\tfmt.Println(\" error received from PollComponent:\", err)\n+\t\treturn nil, err\n+\t} else {\n+\t\tfmt.Println(\" no error received from PollComponent\")","path":"chasm/lib/activity/handler.go","commit_id":"e95ab0ad0ba0c42c1e0e125042367ada0583ea76","original_commit_id":"e95ab0ad0ba0c42c1e0e125042367ada0583ea76","user":{"login":"cursor[bot]","id":206951365,"node_id":"BOT_kgDODFXTxQ","avatar_url":"https://avatars.githubusercontent.com/in/1210556?v=4","gravatar_id":"","url":"https://api.github.com/users/cursor%5Bbot%5D","html_url":"https://github.com/apps/cursor","followers_url":"https://api.github.com/users/cursor%5Bbot%5D/followers","following_url":"https://api.github.com/users/cursor%5Bbot%5D/following{/other_user}","gists_url":"https://api.github.com/users/cursor%5Bbot%5D/gists{/gist_id}","starred_url":"https://api.github.com/users/cursor%5Bbot%5D/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/cursor%5Bbot%5D/subscriptions","organizations_url":"https://api.github.com/users/cursor%5Bbot%5D/orgs","repos_url":"https://api.github.com/users/cursor%5Bbot%5D/repos","events_url":"https://api.github.com/users/cursor%5Bbot%5D/events{/privacy}","received_events_url":"https://api.github.com/users/cursor%5Bbot%5D/received_events","type":"Bot","user_view_type":"public","site_admin":false},"body":"### Bug: Debug print statements in production code\n\n<!-- **Low Severity** -->\n\n<!-- DESCRIPTION START -->\nDebug `fmt.Println` statements at lines 124 and 127 log error status to stdout using emoji. These appear to be temporary debugging code that should be removed before merging to production. Production code should use the proper logging framework instead of printing to stdout.\n<!-- DESCRIPTION END -->\n\n<!-- LOCATIONS START\nchasm/lib/activity/handler.go#L123-L127\nLOCATIONS END -->\n<a href=\"https://cursor.com/open?data=eyJhbGciOiJSUzI1NiIsInR5cCI6IkpXVCIsImtpZCI6ImJ1Z2JvdC12MSJ9.eyJ2ZXJzaW9uIjoxLCJ0eXBlIjoiQlVHQk9UX0ZJWF9JTl9DVVJTT1IiLCJkYXRhIjp7InJlZGlzS2V5IjoiYnVnYm90Ojc4MmVlOTY0LThjYWMtNDIxZi1iZTRmLWIwNjYyZWI2MGI5YSIsImVuY3J5cHRpb25LZXkiOiJYaDRuVHlRb0RuOGxlM2dILWxGc1dYSUN4MWZDSm1uZnRqQmFlSnlFdlVJIiwiYnJhbmNoIjoicG9sbC1jb21wb25lbnQifSwiaWF0IjoxNzY0MDExNDU1LCJleHAiOjE3NjQ2MTYyNTV9.USt-1Aozn3i4-pO1WpNQbuDfSXMaMsVzu_mBFpMlEC9wOsUMPAOwdIl95ZhzX535iVETmWowMgkByEOPDagS9V7SZlr0VcU-gp8cXWam7Qv2cYMCz74ew8fPzXMV3uKtsAEDxLV6jzpt5V22p7T8G9ZVQl-MX7IEpleStKpOZaPNI6nTMl1NfpN11DGu0f7dvrdzf6lhZU9GmYYY4U9yS0VnKvaRgtN8xKIs7QBU4LqvZYd-g74N9sJxyR5nJ7L6w0Fw3ZLlJ6yXXyB_narHC9QI2s0Nj7iJsf-6PE_Fk3_RceFPH-3xdp0CRsaqad_kydHC0TQrgCM0A9JwJ7mDMw\"><picture><source media=\"(prefers-color-scheme: dark)\" srcset=\"https://cursor.com/fix-in-cursor-dark.svg\"><source media=\"(prefers-color-scheme: light)\" srcset=\"https://cursor.com/fix-in-cursor-light.svg\"><img alt=\"Fix in Cursor\" src=\"https://cursor.com/fix-in-cursor.svg\"></picture></a>&nbsp;<a href=\"https://cursor.com/agents?data=eyJhbGciOiJSUzI1NiIsInR5cCI6IkpXVCIsImtpZCI6ImJ1Z2JvdC12MSJ9.eyJ2ZXJzaW9uIjoxLCJ0eXBlIjoiQlVHQk9UX0ZJWF9JTl9XRUIiLCJkYXRhIjp7InJlZGlzS2V5IjoiYnVnYm90Ojc4MmVlOTY0LThjYWMtNDIxZi1iZTRmLWIwNjYyZWI2MGI5YSIsImVuY3J5cHRpb25LZXkiOiJYaDRuVHlRb0RuOGxlM2dILWxGc1dYSUN4MWZDSm1uZnRqQmFlSnlFdlVJIiwiYnJhbmNoIjoicG9sbC1jb21wb25lbnQiLCJyZXBvT3duZXIiOiJ0ZW1wb3JhbGlvIiwicmVwb05hbWUiOiJ0ZW1wb3JhbCIsInByTnVtYmVyIjo4NTYzLCJjb21taXRTaGEiOiJlOTVhYjBhZDBiYTBjNDJjMWUwZTEyNTA0MjM2N2FkYTA1ODNlYTc2IiwicHJvdmlkZXIiOiJnaXRodWIifSwiaWF0IjoxNzY0MDExNDU1LCJleHAiOjE3NjQ2MTYyNTV9.B8tXhARFKS1mWQU23lkbS6nZF1XOQa08_gBMyOBXrq2NUZvuxWcLIoTL1n_FJunqMUd4j0phja-5Lj-V2A6tbi4cPShTdPXvDFp5JXe2XOxV_9f1yKy3-r-3hqjwSml_xblfWdxba9IJJ0dFWE8KzlCKzh8iB_zXDMn7-IWTS_JvWkmCMVV2OLcajjnjxqlVQEVN8kTZXqUcHNy9YLyF4-a3CjMY6FBDPPcIUY67EOxVUZ3Os13doREJ7HjpSkMZODGL_ZXN2HZDqlU3yRgkkeX22UaYW_Q3CdlZuwuO1fZJNIu40GjaXKAZk0fAnfzto9WZifDS45JLzyNoS1RKQg\"><picture><source media=\"(prefers-color-scheme: dark)\" srcset=\"https://cursor.com/fix-in-web-dark.svg\"><source media=\"(prefers-color-scheme: light)\" srcset=\"https://cursor.com/fix-in-web-light.svg\"><img alt=\"Fix in Web\" src=\"https://cursor.com/fix-in-web.svg\"></picture></a>\n\n","created_at":"2025-11-24T19:10:56Z","updated_at":"2025-11-24T19:10:56Z","html_url":"https://github.com/temporalio/temporal/pull/8563#discussion_r2557405643","pull_request_url":"https://api.github.com/repos/temporalio/temporal/pulls/8563","_links":{"self":{"href":"https://api.github.com/repos/temporalio/temporal/pulls/comments/2557405643"},"html":{"href":"https://github.com/temporalio/temporal/pull/8563#discussion_r2557405643"},"pull_request":{"href":"https://api.github.com/repos/temporalio/temporal/pulls/8563"}},"reactions":{"url":"https://api.github.com/repos/temporalio/temporal/pulls/comments/2557405643/reactions","total_count":0,"+1":0,"-1":0,"laugh":0,"hooray":0,"confused":0,"heart":0,"rocket":0,"eyes":0},"start_line":null,"original_start_line":null,"start_side":null,"line":null,"original_line":127,"side":"RIGHT","author_association":"NONE","original_position":85,"position":1,"subject_type":"line"},{"url":"https://api.github.com/repos/temporalio/temporal/pulls/comments/2557405650","pull_request_review_id":3501836960,"id":2557405650,"node_id":"PRRC_kwDODNqesM6YbunS","diff_hunk":"@@ -241,14 +257,191 @@ func (e *ChasmEngine) ReadComponent(\n \treturn readFn(chasmContext, component)\n }\n \n+// PollComponent waits until the supplied predicate is satisfied when evaluated against the\n+// component identified by the supplied component reference. If it times out due to the\n+// server-imposed long-poll timeout then it returns (nil, nil). Otherwise if there is no error, it\n+// returns (ref, nil) where ref is a component reference identifying the state at which the\n+// predicate was satisfied. The predicate must be monotonic: if it returns true at execution state\n+// transition s it must return true at all transitions t > s. It is an error if execution transition\n+// history is (after reloading from persistence) behind the requested ref, or if the ref is\n+// inconsistent with execution transition history. Thus when the predicate function is evaluated, it\n+// is guaranteed that the execution VT >= requestRef VT.\n func (e *ChasmEngine) PollComponent(\n \tctx context.Context,\n-\tentityRef chasm.ComponentRef,\n-\tpredicateFn func(chasm.Context, chasm.Component) (any, bool, error),\n-\toperationFn func(chasm.MutableContext, chasm.Component, any) error,\n-\topts ...chasm.TransitionOption,\n-) (newEntityRef []byte, retError error) {\n-\treturn nil, serviceerror.NewUnimplemented(\"PollComponent is not yet supported\")\n+\trequestRef chasm.ComponentRef,\n+\tmonotonicPredicateFn func(chasm.Context, chasm.Component) (bool, error),\n+) (retRef []byte, retError error) {\n+\tshardContext, executionLease, err := e.getExecutionLease(ctx, requestRef)\n+\tif err != nil {\n+\t\t// E.g. requestRef VT inconsistent with shard VT ('stale reference')\n+\t\t// Wrap stale state errors before returning to user\n+\t\tif errors.Is(err, consts.ErrStaleState) {\n+\t\t\treturn nil, serviceerror.NewUnavailable(\"activity state temporarily unavailable, please retry\")\n+\t\t}\n+\t\treturn nil, err\n+\t}\n+\n+\t// hold lock until return or subscription established\n+\t// TODO(dan): this will probably be called when its already been release; ok?\n+\tdefer executionLease.GetReleaseFn()(nil)\n+\n+\t// At this point it's possible that shard VT < requestRef VT (getExecutionLease does not\n+\t// guarantee that returned shard state is non-stale w.r.t. requestRef).\n+\tsatisfiedRef, err := e.predicateSatisfied(ctx, requestRef, executionLease, monotonicPredicateFn)\n+\tif err != nil {\n+\t\t// Wrap stale state errors before returning to user\n+\t\tif errors.Is(err, consts.ErrStaleState) {\n+\t\t\treturn nil, serviceerror.NewUnavailable(\"activity state temporarily unavailable, please retry\")\n+\t\t}\n+\t\treturn nil, err\n+\t}\n+\t// shard VT >= requestRef VT (enforced by checkPredicate)\n+\n+\tif satisfiedRef != nil {\n+\t\t// wait condition was satisfied\n+\t\treturn satisfiedRef, nil\n+\t}\n+\n+\t// Wait condition not satisfied; long-poll\n+\n+\tnamespaceRegistry, err := shardContext.GetNamespaceRegistry().GetNamespaceByID(\n+\t\tnamespace.ID(requestRef.EntityKey.NamespaceID),\n+\t)\n+\tif err != nil {\n+\t\treturn nil, err\n+\t}\n+\n+\t// If the long-poll times out due to the internally-imposed long-poll timeout, then we want the\n+\t// initiator of the long-poll to receive a non-error empty response indicating that they should\n+\t// continue long-polling. To achieve this, we return nil on all canceled context errors below.\n+\t// We assume that the parent will check for a canceled context independently (without relying on\n+\t// any error value we return), so that if the cancelation was due to the parent deadline rather\n+\t// than the internally-imposed long-poll timeout then the initiator of the long-poll will get a\n+\t// deadline exceeded error.\n+\n+\tif parentDeadline, ok := ctx.Deadline(); ok {\n+\t\tfmt.Println(\" parent timeout:\", time.Until(parentDeadline))\n+\t} else {\n+\t\tfmt.Println(\" parent has no timeout\")\n+\t}\n+","path":"service/history/chasm_engine.go","commit_id":"95371e919b09575ad192f881d3a75da9db364367","original_commit_id":"e95ab0ad0ba0c42c1e0e125042367ada0583ea76","user":{"login":"cursor[bot]","id":206951365,"node_id":"BOT_kgDODFXTxQ","avatar_url":"https://avatars.githubusercontent.com/in/1210556?v=4","gravatar_id":"","url":"https://api.github.com/users/cursor%5Bbot%5D","html_url":"https://github.com/apps/cursor","followers_url":"https://api.github.com/users/cursor%5Bbot%5D/followers","following_url":"https://api.github.com/users/cursor%5Bbot%5D/following{/other_user}","gists_url":"https://api.github.com/users/cursor%5Bbot%5D/gists{/gist_id}","starred_url":"https://api.github.com/users/cursor%5Bbot%5D/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/cursor%5Bbot%5D/subscriptions","organizations_url":"https://api.github.com/users/cursor%5Bbot%5D/orgs","repos_url":"https://api.github.com/users/cursor%5Bbot%5D/repos","events_url":"https://api.github.com/users/cursor%5Bbot%5D/events{/privacy}","received_events_url":"https://api.github.com/users/cursor%5Bbot%5D/received_events","type":"Bot","user_view_type":"public","site_admin":false},"body":"### Bug: Debug print statements in production code\n\n<!-- **Low Severity** -->\n\n<!-- DESCRIPTION START -->\nMultiple debug `fmt.Println` statements logging timeout information to stdout with emoji appear in the `PollComponent` method. These seem to be temporary debugging code and should use the proper logging framework or be removed entirely before production deployment.\n<!-- DESCRIPTION END -->\n\n<!-- LOCATIONS START\nservice/history/chasm_engine.go#L315-L327\nLOCATIONS END -->\n<a href=\"https://cursor.com/open?data=eyJhbGciOiJSUzI1NiIsInR5cCI6IkpXVCIsImtpZCI6ImJ1Z2JvdC12MSJ9.eyJ2ZXJzaW9uIjoxLCJ0eXBlIjoiQlVHQk9UX0ZJWF9JTl9DVVJTT1IiLCJkYXRhIjp7InJlZGlzS2V5IjoiYnVnYm90OjFmODhiNGM3LTg1YzktNDgyYi04NTI1LTIyYmFiNzRmMzNkZSIsImVuY3J5cHRpb25LZXkiOiJEaE1IUXBMRC1zUzlpc2VHd2JxMGJqZG1ybGppR25YOWZfZGZfZ1VodzRRIiwiYnJhbmNoIjoicG9sbC1jb21wb25lbnQifSwiaWF0IjoxNzY0MDExNDU1LCJleHAiOjE3NjQ2MTYyNTV9.cJ7q7YdpLjf9TC0nSmVjLGAnXacGNzALVbw3PPNqG3VWSJl8xU-WcooxSWCJ5mwE0w1IJf06B_qMbgue-0zv3tTt_t7RVOHpkiqOSNtKlGAb2mqKQw3-nDj_AeF2hKKsHz_75OYwwh7Bc-2e5S5WgYK8YtuUgQNU5ipfeR79h7RabcUj44AM49T0V9cA69ShwlmygSrKxyWe02KKIxXGYlArRjhS5kR9VCcOCzLsMFPXPJOddQxE-OlKsekadUZq363QJXAAfdFv9VfmZ09YBAC-aimH7mtSAGjRTIaF98rhAeEa7j2z236WPtcGQt_voG3MdmKXtPh5ML5UflY95Q\"><picture><source media=\"(prefers-color-scheme: dark)\" srcset=\"https://cursor.com/fix-in-cursor-dark.svg\"><source media=\"(prefers-color-scheme: light)\" srcset=\"https://cursor.com/fix-in-cursor-light.svg\"><img alt=\"Fix in Cursor\" src=\"https://cursor.com/fix-in-cursor.svg\"></picture></a>&nbsp;<a href=\"https://cursor.com/agents?data=eyJhbGciOiJSUzI1NiIsInR5cCI6IkpXVCIsImtpZCI6ImJ1Z2JvdC12MSJ9.eyJ2ZXJzaW9uIjoxLCJ0eXBlIjoiQlVHQk9UX0ZJWF9JTl9XRUIiLCJkYXRhIjp7InJlZGlzS2V5IjoiYnVnYm90OjFmODhiNGM3LTg1YzktNDgyYi04NTI1LTIyYmFiNzRmMzNkZSIsImVuY3J5cHRpb25LZXkiOiJEaE1IUXBMRC1zUzlpc2VHd2JxMGJqZG1ybGppR25YOWZfZGZfZ1VodzRRIiwiYnJhbmNoIjoicG9sbC1jb21wb25lbnQiLCJyZXBvT3duZXIiOiJ0ZW1wb3JhbGlvIiwicmVwb05hbWUiOiJ0ZW1wb3JhbCIsInByTnVtYmVyIjo4NTYzLCJjb21taXRTaGEiOiJlOTVhYjBhZDBiYTBjNDJjMWUwZTEyNTA0MjM2N2FkYTA1ODNlYTc2IiwicHJvdmlkZXIiOiJnaXRodWIifSwiaWF0IjoxNzY0MDExNDU1LCJleHAiOjE3NjQ2MTYyNTV9.P7eaZe04pL6Mv66MhhZ8Kl2RfpH8Nu4W5PI6JoPKWOmZ1ia4wVXaiqvuBy6xIZ9SnEj1ROGCNOQ1CXCgJ1jUQmzk7_t_H9Z0ACJZ9fRAaFeCwfYzkRnPcpqXHTLda4FJNzJqKN-F_N07oRDwszxXhv0qJKdMg4ZCwOjZ8dT9WfWi4SmxWeRQtwsINp0X1vniuJMIIrAo1XwaMAeNPonxNFhYPMw_W84_YgHbZxly_0I8YJH2jgIsfO136Ne5NfETbwFh0TndR08-Tcq6wKUMcFxgJDT5IjJUM2AQHBb_TXdPLhXIK_rOWGImaNdWjw1mc7HcdPhdQ2BW-UlK-njC3w\"><picture><source media=\"(prefers-color-scheme: dark)\" srcset=\"https://cursor.com/fix-in-web-dark.svg\"><source media=\"(prefers-color-scheme: light)\" srcset=\"https://cursor.com/fix-in-web-light.svg\"><img alt=\"Fix in Web\" src=\"https://cursor.com/fix-in-web.svg\"></picture></a>\n\n","created_at":"2025-11-24T19:10:56Z","updated_at":"2025-11-24T19:10:56Z","html_url":"https://github.com/temporalio/temporal/pull/8563#discussion_r2557405650","pull_request_url":"https://api.github.com/repos/temporalio/temporal/pulls/8563","_links":{"self":{"href":"https://api.github.com/repos/temporalio/temporal/pulls/comments/2557405650"},"html":{"href":"https://github.com/temporalio/temporal/pull/8563#discussion_r2557405650"},"pull_request":{"href":"https://api.github.com/repos/temporalio/temporal/pulls/8563"}},"reactions":{"url":"https://api.github.com/repos/temporalio/temporal/pulls/comments/2557405650/reactions","total_count":0,"+1":0,"-1":0,"laugh":0,"hooray":0,"confused":0,"heart":0,"rocket":0,"eyes":0},"start_line":null,"original_start_line":null,"start_side":null,"line":286,"original_line":316,"side":"RIGHT","author_association":"NONE","original_position":151,"position":1,"subject_type":"line"},{"url":"https://api.github.com/repos/temporalio/temporal/pulls/comments/2557865291","pull_request_review_id":3489746627,"id":2557865291,"node_id":"PRRC_kwDODNqesM6Yde1L","diff_hunk":"@@ -0,0 +1,46 @@\n+package chasm\n+\n+import (\n+\t\"go.temporal.io/api/serviceerror\"\n+\t\"go.temporal.io/server/common/persistence/transitionhistory\"\n+\t\"go.temporal.io/server/service/history/consts\"\n+)\n+\n+// ExecutionStateChanged returns a ref for the component if execution state has advanced beyond the state\n+// encoded in ref.\n+func ExecutionStateChanged(c Component, ctx Context, refBytes []byte) ([]byte, bool, error) {\n+\tcurrentRefBytes, err := ctx.Ref(c)\n+\tif err != nil {\n+\t\treturn nil, false, err\n+\t}\n+\tcurrentRef, err := DeserializeComponentRef(currentRefBytes)\n+\tif err != nil {\n+\t\treturn nil, false, err\n+\t}\n+\n+\tref, err := DeserializeComponentRef(refBytes)\n+\tif err != nil {\n+\t\treturn nil, false, err\n+\t}\n+\n+\tif len(refBytes) > 0 && ref.EntityKey != currentRef.EntityKey {\n+\t\treturn nil, false, serviceerror.NewInternalf(\n+\t\t\t\"ref execution key (%v) does not match component execution (%v)\", ref.EntityKey, currentRef.EntityKey)\n+\t}\n+\n+\tswitch transitionhistory.Compare(ref.entityLastUpdateVT, currentRef.entityLastUpdateVT) {\n+\tcase -1:\n+\t\t// Execution state has advanced beyond submitted ref\n+\t\treturn currentRefBytes, true, nil\n+\tcase 0:\n+\t\t// Execution state has not advanced beyond submitted ref\n+\t\treturn nil, false, nil\n+\tcase 1:\n+\t\t// Execution state is behind submitted ref\n+\t\treturn nil, false, consts.ErrStaleState\n+\tdefault:\n+\t\t// Impossible: Compare only returns -1, 0, or 1\n+\t\treturn nil, false, serviceerror.NewInternal(\"unexpected transition history comparison result\")","path":"chasm/transition_history.go","commit_id":"e95ab0ad0ba0c42c1e0e125042367ada0583ea76","original_commit_id":"da6009564e796063faf853352077eecdc1473612","user":{"login":"dandavison","id":52205,"node_id":"MDQ6VXNlcjUyMjA1","avatar_url":"https://avatars.githubusercontent.com/u/52205?v=4","gravatar_id":"","url":"https://api.github.com/users/dandavison","html_url":"https://github.com/dandavison","followers_url":"https://api.github.com/users/dandavison/followers","following_url":"https://api.github.com/users/dandavison/following{/other_user}","gists_url":"https://api.github.com/users/dandavison/gists{/gist_id}","starred_url":"https://api.github.com/users/dandavison/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/dandavison/subscriptions","organizations_url":"https://api.github.com/users/dandavison/orgs","repos_url":"https://api.github.com/users/dandavison/repos","events_url":"https://api.github.com/users/dandavison/events{/privacy}","received_events_url":"https://api.github.com/users/dandavison/received_events","type":"User","user_view_type":"public","site_admin":false},"body":"Thanks, changed to panic.","created_at":"2025-11-24T22:08:14Z","updated_at":"2025-11-27T03:19:05Z","html_url":"https://github.com/temporalio/temporal/pull/8563#discussion_r2557865291","pull_request_url":"https://api.github.com/repos/temporalio/temporal/pulls/8563","_links":{"self":{"href":"https://api.github.com/repos/temporalio/temporal/pulls/comments/2557865291"},"html":{"href":"https://github.com/temporalio/temporal/pull/8563#discussion_r2557865291"},"pull_request":{"href":"https://api.github.com/repos/temporalio/temporal/pulls/8563"}},"reactions":{"url":"https://api.github.com/repos/temporalio/temporal/pulls/comments/2557865291/reactions","total_count":0,"+1":0,"-1":0,"laugh":0,"hooray":0,"confused":0,"heart":0,"rocket":0,"eyes":0},"start_line":null,"original_start_line":null,"start_side":null,"line":null,"original_line":43,"side":"RIGHT","in_reply_to_id":2539934091,"author_association":"MEMBER","original_position":43,"position":1,"subject_type":"line"},{"url":"https://api.github.com/repos/temporalio/temporal/pulls/comments/2557876393","pull_request_review_id":3489746627,"id":2557876393,"node_id":"PRRC_kwDODNqesM6Ydhip","diff_hunk":"","path":"service/history/chasm_notifier.go","commit_id":"1d59e66d0ce5d91819f92c428ef5ab4c4efca1fb","original_commit_id":"da6009564e796063faf853352077eecdc1473612","user":{"login":"dandavison","id":52205,"node_id":"MDQ6VXNlcjUyMjA1","avatar_url":"https://avatars.githubusercontent.com/u/52205?v=4","gravatar_id":"","url":"https://api.github.com/users/dandavison","html_url":"https://github.com/dandavison","followers_url":"https://api.github.com/users/dandavison/followers","following_url":"https://api.github.com/users/dandavison/following{/other_user}","gists_url":"https://api.github.com/users/dandavison/gists{/gist_id}","starred_url":"https://api.github.com/users/dandavison/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/dandavison/subscriptions","organizations_url":"https://api.github.com/users/dandavison/orgs","repos_url":"https://api.github.com/users/dandavison/repos","events_url":"https://api.github.com/users/dandavison/events{/privacy}","received_events_url":"https://api.github.com/users/dandavison/received_events","type":"User","user_view_type":"public","site_admin":false},"body":"Thanks, I've rewritten this using an implementation somewhat similar to what you describe (also similar to `userDataManagerImpl` in matching).","created_at":"2025-11-24T22:13:36Z","updated_at":"2025-11-27T03:19:06Z","html_url":"https://github.com/temporalio/temporal/pull/8563#discussion_r2557876393","pull_request_url":"https://api.github.com/repos/temporalio/temporal/pulls/8563","_links":{"self":{"href":"https://api.github.com/repos/temporalio/temporal/pulls/comments/2557876393"},"html":{"href":"https://github.com/temporalio/temporal/pull/8563#discussion_r2557876393"},"pull_request":{"href":"https://api.github.com/repos/temporalio/temporal/pulls/8563"}},"reactions":{"url":"https://api.github.com/repos/temporalio/temporal/pulls/comments/2557876393/reactions","total_count":0,"+1":0,"-1":0,"laugh":0,"hooray":0,"confused":0,"heart":0,"rocket":0,"eyes":0},"start_line":null,"original_start_line":null,"start_side":null,"line":1,"original_line":1,"side":"RIGHT","in_reply_to_id":2540076142,"author_association":"MEMBER","original_position":1,"position":1,"subject_type":"file"},{"url":"https://api.github.com/repos/temporalio/temporal/pulls/comments/2557880054","pull_request_review_id":3489746627,"id":2557880054,"node_id":"PRRC_kwDODNqesM6Ydib2","diff_hunk":"@@ -13,30 +13,42 @@ import (\n \tenumspb \"go.temporal.io/api/enums/v1\"\n \ttaskqueuepb \"go.temporal.io/api/taskqueue/v1\"\n \t\"go.temporal.io/api/workflowservice/v1\"\n+\tpersistencespb \"go.temporal.io/server/api/persistence/v1\"\n+\t\"go.temporal.io/server/chasm\"\n+\t\"go.temporal.io/server/chasm/lib/activity\"\n \t\"go.temporal.io/server/common/dynamicconfig\"\n+\t\"go.temporal.io/server/common/payload\"\n \t\"go.temporal.io/server/tests/testcore\"\n \t\"google.golang.org/protobuf/proto\"\n \t\"google.golang.org/protobuf/types/known/durationpb\"\n )\n \n type standaloneActivityTestSuite struct {\n \ttestcore.FunctionalTestBase\n+\tchasmEngine chasm.Engine\n }\n \n func TestStandaloneActivityTestSuite(t *testing.T) {\n \tt.Parallel()\n \tsuite.Run(t, new(standaloneActivityTestSuite))\n }\n \n-func (s *standaloneActivityTestSuite) TestStartActivityExecution() {\n-\tt := s.T()\n-\tctx, cancel := context.WithTimeout(t.Context(), 10*time.Second)\n-\tdefer cancel()\n-\n+func (s *standaloneActivityTestSuite) SetupSuite() {\n+\ts.FunctionalTestBase.SetupSuite()\n \ts.OverrideDynamicConfig(","path":"tests/standalone_activity_test.go","commit_id":"1d59e66d0ce5d91819f92c428ef5ab4c4efca1fb","original_commit_id":"da6009564e796063faf853352077eecdc1473612","user":{"login":"dandavison","id":52205,"node_id":"MDQ6VXNlcjUyMjA1","avatar_url":"https://avatars.githubusercontent.com/u/52205?v=4","gravatar_id":"","url":"https://api.github.com/users/dandavison","html_url":"https://github.com/dandavison","followers_url":"https://api.github.com/users/dandavison/followers","following_url":"https://api.github.com/users/dandavison/following{/other_user}","gists_url":"https://api.github.com/users/dandavison/gists{/gist_id}","starred_url":"https://api.github.com/users/dandavison/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/dandavison/subscriptions","organizations_url":"https://api.github.com/users/dandavison/orgs","repos_url":"https://api.github.com/users/dandavison/repos","events_url":"https://api.github.com/users/dandavison/events{/privacy}","received_events_url":"https://api.github.com/users/dandavison/received_events","type":"User","user_view_type":"public","site_admin":false},"body":" this is being tracked now","created_at":"2025-11-24T22:15:32Z","updated_at":"2025-11-27T03:19:06Z","html_url":"https://github.com/temporalio/temporal/pull/8563#discussion_r2557880054","pull_request_url":"https://api.github.com/repos/temporalio/temporal/pulls/8563","_links":{"self":{"href":"https://api.github.com/repos/temporalio/temporal/pulls/comments/2557880054"},"html":{"href":"https://github.com/temporalio/temporal/pull/8563#discussion_r2557880054"},"pull_request":{"href":"https://api.github.com/repos/temporalio/temporal/pulls/8563"}},"reactions":{"url":"https://api.github.com/repos/temporalio/temporal/pulls/comments/2557880054/reactions","total_count":0,"+1":0,"-1":0,"laugh":0,"hooray":0,"confused":0,"heart":0,"rocket":0,"eyes":0},"start_line":null,"original_start_line":null,"start_side":null,"line":38,"original_line":38,"side":"RIGHT","in_reply_to_id":2540091023,"author_association":"MEMBER","original_position":31,"position":40,"subject_type":"line"},{"url":"https://api.github.com/repos/temporalio/temporal/pulls/comments/2557907646","pull_request_review_id":3489746627,"id":2557907646,"node_id":"PRRC_kwDODNqesM6YdpK-","diff_hunk":"@@ -314,3 +315,125 @@ func (a *Activity) RecordHeartbeat(ctx chasm.MutableContext, details *commonpb.P\n \t})\n \treturn nil, nil\n }\n+\n+func (a *Activity) buildActivityExecutionInfo(ctx chasm.Context, key chasm.EntityKey) (*activity.ActivityExecutionInfo, error) {\n+\tif a.ActivityState == nil {\n+\t\treturn nil, errors.New(\"activity state is nil\")\n+\t}\n+\n+\t// TODO(dan): support pause states\n+\tvar status enumspb.ActivityExecutionStatus\n+\tvar runState enumspb.PendingActivityState\n+\tswitch a.GetStatus() {\n+\tcase activitypb.ACTIVITY_EXECUTION_STATUS_UNSPECIFIED:\n+\t\tstatus = enumspb.ACTIVITY_EXECUTION_STATUS_UNSPECIFIED\n+\t\trunState = enumspb.PENDING_ACTIVITY_STATE_UNSPECIFIED\n+\tcase activitypb.ACTIVITY_EXECUTION_STATUS_SCHEDULED:\n+\t\tstatus = enumspb.ACTIVITY_EXECUTION_STATUS_RUNNING\n+\t\trunState = enumspb.PENDING_ACTIVITY_STATE_SCHEDULED\n+\tcase activitypb.ACTIVITY_EXECUTION_STATUS_STARTED:\n+\t\tstatus = enumspb.ACTIVITY_EXECUTION_STATUS_RUNNING\n+\t\trunState = enumspb.PENDING_ACTIVITY_STATE_STARTED\n+\tcase activitypb.ACTIVITY_EXECUTION_STATUS_CANCEL_REQUESTED:\n+\t\tstatus = enumspb.ACTIVITY_EXECUTION_STATUS_RUNNING\n+\t\trunState = enumspb.PENDING_ACTIVITY_STATE_CANCEL_REQUESTED\n+\tcase activitypb.ACTIVITY_EXECUTION_STATUS_COMPLETED:\n+\t\tstatus = enumspb.ACTIVITY_EXECUTION_STATUS_COMPLETED\n+\t\trunState = enumspb.PENDING_ACTIVITY_STATE_UNSPECIFIED\n+\tcase activitypb.ACTIVITY_EXECUTION_STATUS_FAILED:\n+\t\tstatus = enumspb.ACTIVITY_EXECUTION_STATUS_FAILED\n+\t\trunState = enumspb.PENDING_ACTIVITY_STATE_UNSPECIFIED\n+\tcase activitypb.ACTIVITY_EXECUTION_STATUS_CANCELED:\n+\t\tstatus = enumspb.ACTIVITY_EXECUTION_STATUS_CANCELED\n+\t\trunState = enumspb.PENDING_ACTIVITY_STATE_UNSPECIFIED\n+\tcase activitypb.ACTIVITY_EXECUTION_STATUS_TERMINATED:\n+\t\tstatus = enumspb.ACTIVITY_EXECUTION_STATUS_TERMINATED\n+\t\trunState = enumspb.PENDING_ACTIVITY_STATE_UNSPECIFIED\n+\tcase activitypb.ACTIVITY_EXECUTION_STATUS_TIMED_OUT:\n+\t\tstatus = enumspb.ACTIVITY_EXECUTION_STATUS_TIMED_OUT\n+\t\trunState = enumspb.PENDING_ACTIVITY_STATE_UNSPECIFIED\n+\tdefault:\n+\t\treturn nil, serviceerror.NewInternalf(\"unknown activity execution status: %s\", a.GetStatus())\n+\t}\n+\n+\trequestData, err := a.RequestData.Get(ctx)\n+\tif err != nil {\n+\t\treturn nil, err\n+\t}\n+\n+\tinfo := &activity.ActivityExecutionInfo{\n+\t\tActivityId:    key.BusinessID,\n+\t\tRunId:         key.EntityID,\n+\t\tActivityType:  a.GetActivityType(),\n+\t\tStatus:        status,\n+\t\tRunState:      runState,\n+\t\tScheduledTime: a.GetScheduledTime(),\n+\t\tPriority:      a.GetPriority(),\n+\t\tHeader:        requestData.GetHeader(),\n+\t\t// TODO(dan): populate remaining fields\n+\t}\n+\n+\treturn info, nil\n+}\n+\n+func (a *Activity) buildPollActivityExecutionResponse(\n+\tctx chasm.Context,\n+\treq *activitypb.PollActivityExecutionRequest,\n+) (*activitypb.PollActivityExecutionResponse, error) {\n+\trequest := req.GetFrontendRequest()\n+\n+\t// TODO(dan): pass ref into this function?\n+\tref, err := ctx.Ref(a)\n+\tif err != nil {\n+\t\treturn nil, err\n+\t}\n+\n+\tvar info *activity.ActivityExecutionInfo\n+\tif request.GetIncludeInfo() {\n+\t\tinfo, err = a.buildActivityExecutionInfo(ctx, chasm.EntityKey{\n+\t\t\tNamespaceID: req.GetNamespaceId(),\n+\t\t\tBusinessID:  request.GetActivityId(),\n+\t\t\tEntityID:    request.GetRunId(),\n+\t\t})\n+\t\tif err != nil {\n+\t\t\treturn nil, err\n+\t\t}\n+\t}\n+\n+\tvar input *commonpb.Payloads\n+\tif request.GetIncludeInput() {\n+\t\tactivityRequest, err := a.RequestData.Get(ctx)\n+\t\tif err != nil {\n+\t\t\treturn nil, err\n+\t\t}\n+\t\tinput = activityRequest.Input\n+\t}\n+\n+\tresponse := &workflowservice.PollActivityExecutionResponse{\n+\t\tInfo:                     info,\n+\t\tRunId:                    ctx.ExecutionKey().EntityID,\n+\t\tInput:                    input,\n+\t\tStateChangeLongPollToken: ref,\n+\t}\n+\n+\tif request.GetIncludeOutcome() {\n+\t\tactivityOutcome, err := a.Outcome.Get(ctx)\n+\t\tif err != nil {\n+\t\t\treturn nil, err\n+\t\t}\n+\t\tswitch v := activityOutcome.GetVariant().(type) {\n+\t\tcase *activitypb.ActivityOutcome_Failed_:\n+\t\t\tresponse.Outcome = &workflowservice.PollActivityExecutionResponse_Failure{\n+\t\t\t\tFailure: v.Failed.GetFailure(),","path":"chasm/lib/activity/activity.go","commit_id":"109a90fe02cb145ef9d0481242c354b066ca027d","original_commit_id":"b24a0220435f567e7e3cacb95bd8fe78c17dc67b","user":{"login":"dandavison","id":52205,"node_id":"MDQ6VXNlcjUyMjA1","avatar_url":"https://avatars.githubusercontent.com/u/52205?v=4","gravatar_id":"","url":"https://api.github.com/users/dandavison","html_url":"https://github.com/dandavison","followers_url":"https://api.github.com/users/dandavison/followers","following_url":"https://api.github.com/users/dandavison/following{/other_user}","gists_url":"https://api.github.com/users/dandavison/gists{/gist_id}","starred_url":"https://api.github.com/users/dandavison/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/dandavison/subscriptions","organizations_url":"https://api.github.com/users/dandavison/orgs","repos_url":"https://api.github.com/users/dandavison/repos","events_url":"https://api.github.com/users/dandavison/events{/privacy}","received_events_url":"https://api.github.com/users/dandavison/received_events","type":"User","user_view_type":"public","site_admin":false},"body":"Thanks, I've implemented this logic properly now.","created_at":"2025-11-24T22:28:15Z","updated_at":"2025-11-27T03:19:05Z","html_url":"https://github.com/temporalio/temporal/pull/8563#discussion_r2557907646","pull_request_url":"https://api.github.com/repos/temporalio/temporal/pulls/8563","_links":{"self":{"href":"https://api.github.com/repos/temporalio/temporal/pulls/comments/2557907646"},"html":{"href":"https://github.com/temporalio/temporal/pull/8563#discussion_r2557907646"},"pull_request":{"href":"https://api.github.com/repos/temporalio/temporal/pulls/8563"}},"reactions":{"url":"https://api.github.com/repos/temporalio/temporal/pulls/comments/2557907646/reactions","total_count":0,"+1":0,"-1":0,"laugh":0,"hooray":0,"confused":0,"heart":0,"rocket":0,"eyes":0},"start_line":null,"original_start_line":null,"start_side":null,"line":null,"original_line":427,"side":"RIGHT","in_reply_to_id":2525436567,"author_association":"MEMBER","original_position":147,"position":1,"subject_type":"line"},{"url":"https://api.github.com/repos/temporalio/temporal/pulls/comments/2558037772","pull_request_review_id":3502633763,"id":2558037772,"node_id":"PRRC_kwDODNqesM6YeI8M","diff_hunk":"@@ -241,14 +257,165 @@ func (e *ChasmEngine) ReadComponent(\n \treturn readFn(chasmContext, component)\n }\n \n+// PollComponent waits until the supplied predicate is satisfied when evaluated against the\n+// component identified by the supplied component reference. If there is no error, it returns (ref,\n+// nil) where ref is a component reference identifying the state at which the predicate was\n+// satisfied. The predicate must be monotonic: if it returns true at execution state transition s it\n+// must return true at all transitions t > s. It is an error if execution transition history is\n+// (after reloading from persistence) behind the requested ref, or if the ref is inconsistent with\n+// execution transition history. Thus when the predicate function is evaluated, it is guaranteed\n+// that the execution VT >= requestRef VT.\n func (e *ChasmEngine) PollComponent(\n \tctx context.Context,\n-\tentityRef chasm.ComponentRef,\n-\tpredicateFn func(chasm.Context, chasm.Component) (any, bool, error),\n-\toperationFn func(chasm.MutableContext, chasm.Component, any) error,\n-\topts ...chasm.TransitionOption,\n-) (newEntityRef []byte, retError error) {\n-\treturn nil, serviceerror.NewUnimplemented(\"PollComponent is not yet supported\")\n+\trequestRef chasm.ComponentRef,\n+\tmonotonicPredicateFn func(chasm.Context, chasm.Component) (bool, error),\n+) (retRef []byte, retError error) {\n+\tdefer func() {\n+\t\tif errors.Is(retError, consts.ErrStaleState) {\n+\t\t\tretError = serviceerror.NewUnavailable(\"please retry\")\n+\t\t}\n+\t}()\n+\n+\tshardContext, executionLease, err := e.getExecutionLease(ctx, requestRef)\n+\tif err != nil {\n+\t\t// E.g. requestRef VT inconsistent with shard VT ('stale reference')\n+\t\treturn nil, err\n+\t}\n+\n+\t// hold lock until return or subscription established\n+\t// TODO(dan): this will probably be called when its already been release; ok?\n+\tdefer executionLease.GetReleaseFn()(nil)\n+\n+\t// At this point it's possible that shard VT < requestRef VT (getExecutionLease does not\n+\t// guarantee that returned shard state is non-stale w.r.t. requestRef).\n+\tsatisfiedRef, err := e.predicateSatisfied(ctx, requestRef, executionLease, monotonicPredicateFn)\n+\tif err != nil {\n+\t\treturn nil, err\n+\t}\n+\t// shard VT >= requestRef VT (enforced by checkPredicate)\n+\n+\tif satisfiedRef != nil {\n+\t\t// wait condition was satisfied\n+\t\treturn satisfiedRef, nil\n+\t}\n+\n+\t// Wait condition not satisfied; long-poll\n+\n+\tnamespaceRegistry, err := shardContext.GetNamespaceRegistry().GetNamespaceByID(\n+\t\tnamespace.ID(requestRef.EntityKey.NamespaceID),\n+\t)\n+\tif err != nil {\n+\t\treturn nil, err\n+\t}\n+\n+\tif parentDeadline, ok := ctx.Deadline(); ok {\n+\t\tfmt.Println(\" parent timeout:\", time.Until(parentDeadline))\n+\t} else {\n+\t\tfmt.Println(\" parent has no timeout\")\n+\t}\n+\n+\tinternalLongPollTimeout := shardContext.GetConfig().LongPollExpirationInterval(namespaceRegistry.Name().String())\n+\tctx, cancel := context.WithTimeout(ctx, internalLongPollTimeout)\n+\tdefer cancel()\n+\n+\tfmt.Println(\" after applying timeout:\", internalLongPollTimeout)\n+\tif childDeadline, ok := ctx.Deadline(); ok {\n+\t\tfmt.Println(\" child timeout:\", time.Until(childDeadline))\n+\t} else {\n+\t\tfmt.Println(\" child has no timeout\")","path":"service/history/chasm_engine.go","commit_id":"95371e919b09575ad192f881d3a75da9db364367","original_commit_id":"f6d6ab731ff6dbfa33dafe99cfe4410f8f63029f","user":{"login":"cursor[bot]","id":206951365,"node_id":"BOT_kgDODFXTxQ","avatar_url":"https://avatars.githubusercontent.com/in/1210556?v=4","gravatar_id":"","url":"https://api.github.com/users/cursor%5Bbot%5D","html_url":"https://github.com/apps/cursor","followers_url":"https://api.github.com/users/cursor%5Bbot%5D/followers","following_url":"https://api.github.com/users/cursor%5Bbot%5D/following{/other_user}","gists_url":"https://api.github.com/users/cursor%5Bbot%5D/gists{/gist_id}","starred_url":"https://api.github.com/users/cursor%5Bbot%5D/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/cursor%5Bbot%5D/subscriptions","organizations_url":"https://api.github.com/users/cursor%5Bbot%5D/orgs","repos_url":"https://api.github.com/users/cursor%5Bbot%5D/repos","events_url":"https://api.github.com/users/cursor%5Bbot%5D/events{/privacy}","received_events_url":"https://api.github.com/users/cursor%5Bbot%5D/received_events","type":"Bot","user_view_type":"public","site_admin":false},"body":"### Bug: Debug print statements left in production code\n\n<!-- **Medium Severity** -->\n\n<!-- DESCRIPTION START -->\nMultiple debug `fmt.Println` statements with emoji were left in production code. These appear in `PollComponent`, `predicateSatisfied`, and `Subscribe` methods. Debug logging statements bypass the proper logging framework and will clutter production output, potentially exposing internal implementation details and affecting performance.\n<!-- DESCRIPTION END -->\n\n<!-- LOCATIONS START\nservice/history/chasm_engine.go#L311-L325\nservice/history/chasm_engine.go#L374-L417\nservice/history/chasm_notifier.go#L45-L53\nLOCATIONS END -->\n<details>\n<summary>Additional Locations (2)</summary>\n\n- [`service/history/chasm_engine.go#L374-L417`](https://github.com/temporalio/temporal/blob/f6d6ab731ff6dbfa33dafe99cfe4410f8f63029f/service/history/chasm_engine.go#L374-L417)\n- [`service/history/chasm_notifier.go#L45-L53`](https://github.com/temporalio/temporal/blob/f6d6ab731ff6dbfa33dafe99cfe4410f8f63029f/service/history/chasm_notifier.go#L45-L53)\n\n</details>\n\n<a href=\"https://cursor.com/open?data=eyJhbGciOiJSUzI1NiIsInR5cCI6IkpXVCIsImtpZCI6ImJ1Z2JvdC12MSJ9.eyJ2ZXJzaW9uIjoxLCJ0eXBlIjoiQlVHQk9UX0ZJWF9JTl9DVVJTT1IiLCJkYXRhIjp7InJlZGlzS2V5IjoiYnVnYm90OmM5ZTc1MDhhLWVlNGEtNGEzZC1iOTI2LTVkZDc4OTZjOTMyNSIsImVuY3J5cHRpb25LZXkiOiJtZEhLYllyWnlldXc5NC1Lb0VwOGI1UjV4bzVJZnRzVzdMOWpmR0pqZUVBIiwiYnJhbmNoIjoicG9sbC1jb21wb25lbnQifSwiaWF0IjoxNzY0MDI3MTU1LCJleHAiOjE3NjQ2MzE5NTV9.WLFxF61pksA2_q_7YpAxohAIiABaFSItYS-NuqtmsBc7V_rgyhznEOhZuI0CS9SHg83Oj1pdf4EiA8N768ObJR11sOEwnnbeWyb_e48CF233_r52HHkQBZGALy49h2KwJLxvoSyxgYhLmvOfypfUdgPxs4Hfzy7haJEI-eI_yoKHs6YvKmz9KPXY0brMscMA4Hs4qJV0LgHO36nlx5KPX136abkL-cnBzbHX12__Z4MryoGArrvk0h0UkxvSiu1lo8hu4pMATuJyzf0hVxFapX_I2roXNtb3vhyzLKsfZ1FIATe-htck-62PqU3SPPRFCBfInlup--gjfCCGKz39_w\"><picture><source media=\"(prefers-color-scheme: dark)\" srcset=\"https://cursor.com/fix-in-cursor-dark.svg\"><source media=\"(prefers-color-scheme: light)\" srcset=\"https://cursor.com/fix-in-cursor-light.svg\"><img alt=\"Fix in Cursor\" src=\"https://cursor.com/fix-in-cursor.svg\"></picture></a>&nbsp;<a href=\"https://cursor.com/agents?data=eyJhbGciOiJSUzI1NiIsInR5cCI6IkpXVCIsImtpZCI6ImJ1Z2JvdC12MSJ9.eyJ2ZXJzaW9uIjoxLCJ0eXBlIjoiQlVHQk9UX0ZJWF9JTl9XRUIiLCJkYXRhIjp7InJlZGlzS2V5IjoiYnVnYm90OmM5ZTc1MDhhLWVlNGEtNGEzZC1iOTI2LTVkZDc4OTZjOTMyNSIsImVuY3J5cHRpb25LZXkiOiJtZEhLYllyWnlldXc5NC1Lb0VwOGI1UjV4bzVJZnRzVzdMOWpmR0pqZUVBIiwiYnJhbmNoIjoicG9sbC1jb21wb25lbnQiLCJyZXBvT3duZXIiOiJ0ZW1wb3JhbGlvIiwicmVwb05hbWUiOiJ0ZW1wb3JhbCIsInByTnVtYmVyIjo4NTYzLCJjb21taXRTaGEiOiJmNmQ2YWI3MzFmZjZkYmZhMzNkYWZlOTljZmU0NDEwZjhmNjMwMjlmIiwicHJvdmlkZXIiOiJnaXRodWIifSwiaWF0IjoxNzY0MDI3MTU1LCJleHAiOjE3NjQ2MzE5NTV9.nRl7UYIn5bNOCx3T0jjFCX1052OXX-m2JwoGSUY-4Ax5auVsk3dCtN-SxHpEtgqdmOELZnYEKuDAZm-VW2OfTIpQUvk8gKMFeADfx0DrYP05iKW-x76Wm72qGLC9g8SgLrQnxeFXEywx5czN6Q62g7NmJY5zxF9JFTjA_W3sp4K2fUH-jnppFM-wxpPvDzTxAkh3_09p0s7A7O3pka_r2Cd86LTWB3FStt9Bi76bkw_C55oSkzVKO1ulYpJ8u46VS9FAaJ68Yjq05IEK0a29OlurE2GxkG_eQs5Q1piCANqBELQvV6sbYNpfTNcBckrBtZnT_Wk5zZ2ZD614-SFiTQ\"><picture><source media=\"(prefers-color-scheme: dark)\" srcset=\"https://cursor.com/fix-in-web-dark.svg\"><source media=\"(prefers-color-scheme: light)\" srcset=\"https://cursor.com/fix-in-web-light.svg\"><img alt=\"Fix in Web\" src=\"https://cursor.com/fix-in-web.svg\"></picture></a>\n\n","created_at":"2025-11-24T23:32:36Z","updated_at":"2025-11-24T23:32:36Z","html_url":"https://github.com/temporalio/temporal/pull/8563#discussion_r2558037772","pull_request_url":"https://api.github.com/repos/temporalio/temporal/pulls/8563","_links":{"self":{"href":"https://api.github.com/repos/temporalio/temporal/pulls/comments/2558037772"},"html":{"href":"https://github.com/temporalio/temporal/pull/8563#discussion_r2558037772"},"pull_request":{"href":"https://api.github.com/repos/temporalio/temporal/pulls/8563"}},"reactions":{"url":"https://api.github.com/repos/temporalio/temporal/pulls/comments/2558037772/reactions","total_count":0,"+1":0,"-1":0,"laugh":0,"hooray":0,"confused":0,"heart":0,"rocket":0,"eyes":0},"start_line":null,"original_start_line":null,"start_side":null,"line":null,"original_line":325,"side":"RIGHT","author_association":"NONE","original_position":149,"position":1,"subject_type":"line"},{"url":"https://api.github.com/repos/temporalio/temporal/pulls/comments/2558120296","pull_request_review_id":3502738116,"id":2558120296,"node_id":"PRRC_kwDODNqesM6YedFo","diff_hunk":"@@ -187,9 +188,34 @@ func (t *TransactionImpl) UpdateWorkflowExecution(\n \t\t},\n \t\tisWorkflow,\n \t)\n+\n \tif persistence.OperationPossiblySucceeded(err) {\n \t\tNotifyWorkflowMutationTasks(engine, currentWorkflowMutation)\n \t\tNotifyWorkflowSnapshotTasks(engine, newWorkflowSnapshot)\n+\n+\t\tif persistence.OperationPossiblySucceeded(err) {\n+\t\t\tNotifyWorkflowMutationTasks(engine, currentWorkflowMutation)\n+\t\t\tNotifyWorkflowSnapshotTasks(engine, newWorkflowSnapshot)\n+\n+\t\t\t// Notify for current workflow if it has CHASM updates\n+\t\t\tif len(currentWorkflowMutation.UpsertChasmNodes) > 0 ||\n+\t\t\t\tlen(currentWorkflowMutation.DeleteChasmNodes) > 0 {\n+\t\t\t\tengine.NotifyChasmExecution(chasm.EntityKey{\n+\t\t\t\t\tNamespaceID: currentWorkflowMutation.ExecutionInfo.NamespaceId,\n+\t\t\t\t\tBusinessID:  currentWorkflowMutation.ExecutionInfo.WorkflowId,\n+\t\t\t\t\tEntityID:    currentWorkflowMutation.ExecutionState.RunId,\n+\t\t\t\t}, nil)\n+\t\t\t}\n+\n+\t\t\t// Notify for new workflow if it has CHASM nodes\n+\t\t\tif newWorkflowSnapshot != nil && len(newWorkflowSnapshot.ChasmNodes) > 0 {\n+\t\t\t\tengine.NotifyChasmExecution(chasm.EntityKey{\n+\t\t\t\t\tNamespaceID: newWorkflowSnapshot.ExecutionInfo.NamespaceId,\n+\t\t\t\t\tBusinessID:  newWorkflowSnapshot.ExecutionInfo.WorkflowId,\n+\t\t\t\t\tEntityID:    newWorkflowSnapshot.ExecutionState.RunId,\n+\t\t\t\t}, nil)\n+\t\t\t}","path":"service/history/workflow/transaction_impl.go","commit_id":"95371e919b09575ad192f881d3a75da9db364367","original_commit_id":"1c7d5c75ef6971aec8ad9dc6970932619a10ce61","user":{"login":"cursor[bot]","id":206951365,"node_id":"BOT_kgDODFXTxQ","avatar_url":"https://avatars.githubusercontent.com/in/1210556?v=4","gravatar_id":"","url":"https://api.github.com/users/cursor%5Bbot%5D","html_url":"https://github.com/apps/cursor","followers_url":"https://api.github.com/users/cursor%5Bbot%5D/followers","following_url":"https://api.github.com/users/cursor%5Bbot%5D/following{/other_user}","gists_url":"https://api.github.com/users/cursor%5Bbot%5D/gists{/gist_id}","starred_url":"https://api.github.com/users/cursor%5Bbot%5D/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/cursor%5Bbot%5D/subscriptions","organizations_url":"https://api.github.com/users/cursor%5Bbot%5D/orgs","repos_url":"https://api.github.com/users/cursor%5Bbot%5D/repos","events_url":"https://api.github.com/users/cursor%5Bbot%5D/events{/privacy}","received_events_url":"https://api.github.com/users/cursor%5Bbot%5D/received_events","type":"Bot","user_view_type":"public","site_admin":false},"body":"### Bug: Duplicated notification calls in UpdateWorkflowExecution\n\n<!-- **Medium Severity** -->\n\n<!-- DESCRIPTION START -->\nThe code duplicates notification calls inside a nested `if persistence.OperationPossiblySucceeded(err)` block. Lines 193-198 call `NotifyWorkflowMutationTasks` and `NotifyWorkflowSnapshotTasks`, then lines 197-215 repeat the exact same calls inside another identical condition check, resulting in double notifications when the operation succeeds. The inner block at lines 196-217 should be removed, leaving only the outer notification calls.\n<!-- DESCRIPTION END -->\n\n<!-- LOCATIONS START\nservice/history/workflow/transaction_impl.go#L191-L217\nLOCATIONS END -->\n<a href=\"https://cursor.com/open?data=eyJhbGciOiJSUzI1NiIsInR5cCI6IkpXVCIsImtpZCI6ImJ1Z2JvdC12MSJ9.eyJ2ZXJzaW9uIjoxLCJ0eXBlIjoiQlVHQk9UX0ZJWF9JTl9DVVJTT1IiLCJkYXRhIjp7InJlZGlzS2V5IjoiYnVnYm90OjBiNzRkMzliLTQyYjctNDk4ZC05ZTBjLThmZGI2MzM3YTg5MiIsImVuY3J5cHRpb25LZXkiOiIzRzg5S2haWGVCZ2RuVG5LTWJZZzBrWkdTWTlYcm5uZHRHbDB5Z19vSnlVIiwiYnJhbmNoIjoicG9sbC1jb21wb25lbnQifSwiaWF0IjoxNzY0MDMwNjc0LCJleHAiOjE3NjQ2MzU0NzR9.MyuWNGkKmaFE5j2VRp03M5a2l72qXUrvVvG_uNJN1ZbhLedsK5JY475rPYjGUa3r6yXoF8C9ml-ZZiLtr90MLJyMICQN-jRvWRzGv_mtN2c_Oy_N9fCKAhxZbNIilJN111OP9KWMIsawXUj_prpsH786brGbj80N5sm331BqsyKyfCGOVVD1kMrczFXVX-NPcw0FD3NWTLglK9ZdK5qjoBa6RW0CUAghR2ycQd9VV25Iwt3rs7dI8TH3Y4_q55GLF7G7KsdDrAKHV_h27aQuxgcXAWKMECG0VXfqYCXEz6qhhnIUo_wW8uywT3Y-nvmI9Va917KR0XlgYCAjYd2z1Q\"><picture><source media=\"(prefers-color-scheme: dark)\" srcset=\"https://cursor.com/fix-in-cursor-dark.svg\"><source media=\"(prefers-color-scheme: light)\" srcset=\"https://cursor.com/fix-in-cursor-light.svg\"><img alt=\"Fix in Cursor\" src=\"https://cursor.com/fix-in-cursor.svg\"></picture></a>&nbsp;<a href=\"https://cursor.com/agents?data=eyJhbGciOiJSUzI1NiIsInR5cCI6IkpXVCIsImtpZCI6ImJ1Z2JvdC12MSJ9.eyJ2ZXJzaW9uIjoxLCJ0eXBlIjoiQlVHQk9UX0ZJWF9JTl9XRUIiLCJkYXRhIjp7InJlZGlzS2V5IjoiYnVnYm90OjBiNzRkMzliLTQyYjctNDk4ZC05ZTBjLThmZGI2MzM3YTg5MiIsImVuY3J5cHRpb25LZXkiOiIzRzg5S2haWGVCZ2RuVG5LTWJZZzBrWkdTWTlYcm5uZHRHbDB5Z19vSnlVIiwiYnJhbmNoIjoicG9sbC1jb21wb25lbnQiLCJyZXBvT3duZXIiOiJ0ZW1wb3JhbGlvIiwicmVwb05hbWUiOiJ0ZW1wb3JhbCIsInByTnVtYmVyIjo4NTYzLCJjb21taXRTaGEiOiIxYzdkNWM3NWVmNjk3MWFlYzhhZDlkYzY5NzA5MzI2MTlhMTBjZTYxIiwicHJvdmlkZXIiOiJnaXRodWIifSwiaWF0IjoxNzY0MDMwNjc0LCJleHAiOjE3NjQ2MzU0NzR9.gcQcPURCkXkqzeJ_xijtrSAkvk4ZY28NBDRGal1oU6MVJE0zzulXDg6GyYvAVWGOeAMPcsmYsrzg7-f1T71FYnUp1qqzA77cTAZ1O1s13Z2pCRHPEoJaNCigOuiFBa3aV1G45bzDszlmOkjVzvku4Fl85X13ePNjKiwh4kRVUUxTEY-H_PwnVHv_3IdvaGmEJi8GRxYgqKDALEmg4N8A2JcObSIT_NhB8yDePdOjy2NOOlUbGQRCyejPh-MmqxzYISW7i2xyJOagugaM2bDM6EF6i8_V3JyS385BwmWqf0cNQOXxmnXmdZqRUknKCIfP7_5-qVPpzwtC_GEZcmSw7g\"><picture><source media=\"(prefers-color-scheme: dark)\" srcset=\"https://cursor.com/fix-in-web-dark.svg\"><source media=\"(prefers-color-scheme: light)\" srcset=\"https://cursor.com/fix-in-web-light.svg\"><img alt=\"Fix in Web\" src=\"https://cursor.com/fix-in-web.svg\"></picture></a>\n\n","created_at":"2025-11-25T00:31:15Z","updated_at":"2025-11-25T00:31:15Z","html_url":"https://github.com/temporalio/temporal/pull/8563#discussion_r2558120296","pull_request_url":"https://api.github.com/repos/temporalio/temporal/pulls/8563","_links":{"self":{"href":"https://api.github.com/repos/temporalio/temporal/pulls/comments/2558120296"},"html":{"href":"https://github.com/temporalio/temporal/pull/8563#discussion_r2558120296"},"pull_request":{"href":"https://api.github.com/repos/temporalio/temporal/pulls/8563"}},"reactions":{"url":"https://api.github.com/repos/temporalio/temporal/pulls/comments/2558120296/reactions","total_count":0,"+1":0,"-1":0,"laugh":0,"hooray":0,"confused":0,"heart":0,"rocket":0,"eyes":0},"start_line":null,"original_start_line":null,"start_side":null,"line":null,"original_line":217,"side":"RIGHT","author_association":"NONE","original_position":38,"position":1,"subject_type":"line"},{"url":"https://api.github.com/repos/temporalio/temporal/pulls/comments/2558120300","pull_request_review_id":3502738116,"id":2558120300,"node_id":"PRRC_kwDODNqesM6YedFs","diff_hunk":"@@ -241,14 +257,165 @@ func (e *ChasmEngine) ReadComponent(\n \treturn readFn(chasmContext, component)\n }\n \n+// PollComponent waits until the supplied predicate is satisfied when evaluated against the\n+// component identified by the supplied component reference. If there is no error, it returns (ref,\n+// nil) where ref is a component reference identifying the state at which the predicate was\n+// satisfied. The predicate must be monotonic: if it returns true at execution state transition s it\n+// must return true at all transitions t > s. It is an error if execution transition history is\n+// (after reloading from persistence) behind the requested ref, or if the ref is inconsistent with\n+// execution transition history. Thus when the predicate function is evaluated, it is guaranteed\n+// that the execution VT >= requestRef VT.\n func (e *ChasmEngine) PollComponent(\n \tctx context.Context,\n-\tentityRef chasm.ComponentRef,\n-\tpredicateFn func(chasm.Context, chasm.Component) (any, bool, error),\n-\toperationFn func(chasm.MutableContext, chasm.Component, any) error,\n-\topts ...chasm.TransitionOption,\n-) (newEntityRef []byte, retError error) {\n-\treturn nil, serviceerror.NewUnimplemented(\"PollComponent is not yet supported\")\n+\trequestRef chasm.ComponentRef,\n+\tmonotonicPredicateFn func(chasm.Context, chasm.Component) (bool, error),\n+) (retRef []byte, retError error) {\n+\tdefer func() {\n+\t\tif errors.Is(retError, consts.ErrStaleState) {\n+\t\t\tretError = serviceerror.NewUnavailable(\"please retry\")\n+\t\t}\n+\t}()\n+\n+\tshardContext, executionLease, err := e.getExecutionLease(ctx, requestRef)\n+\tif err != nil {\n+\t\t// E.g. requestRef VT inconsistent with shard VT ('stale reference')\n+\t\treturn nil, err\n+\t}\n+\n+\t// hold lock until return or subscription established\n+\t// TODO(dan): this will probably be called when its already been release; ok?\n+\tdefer executionLease.GetReleaseFn()(nil)\n+\n+\t// At this point it's possible that shard VT < requestRef VT (getExecutionLease does not\n+\t// guarantee that returned shard state is non-stale w.r.t. requestRef).\n+\tsatisfiedRef, err := e.predicateSatisfied(ctx, requestRef, executionLease, monotonicPredicateFn)\n+\tif err != nil {\n+\t\treturn nil, err\n+\t}\n+\t// shard VT >= requestRef VT (enforced by checkPredicate)\n+\n+\tif satisfiedRef != nil {\n+\t\t// wait condition was satisfied\n+\t\treturn satisfiedRef, nil\n+\t}\n+\n+\t// Wait condition not satisfied; long-poll\n+\n+\tnamespaceRegistry, err := shardContext.GetNamespaceRegistry().GetNamespaceByID(\n+\t\tnamespace.ID(requestRef.EntityKey.NamespaceID),\n+\t)\n+\tif err != nil {\n+\t\treturn nil, err\n+\t}\n+\n+\tif parentDeadline, ok := ctx.Deadline(); ok {\n+\t\tfmt.Println(\" parent timeout:\", time.Until(parentDeadline))\n+\t} else {\n+\t\tfmt.Println(\" parent has no timeout\")\n+\t}\n+\n+\tinternalLongPollTimeout := shardContext.GetConfig().LongPollExpirationInterval(namespaceRegistry.Name().String())\n+\tctx, cancel := context.WithTimeout(ctx, internalLongPollTimeout)\n+\tdefer cancel()\n+\n+\tfmt.Println(\" after applying timeout:\", internalLongPollTimeout)\n+\tif childDeadline, ok := ctx.Deadline(); ok {\n+\t\tfmt.Println(\" child timeout:\", time.Until(childDeadline))\n+\t} else {\n+\t\tfmt.Println(\" child has no timeout\")\n+\t}","path":"service/history/chasm_engine.go","commit_id":"95371e919b09575ad192f881d3a75da9db364367","original_commit_id":"1c7d5c75ef6971aec8ad9dc6970932619a10ce61","user":{"login":"cursor[bot]","id":206951365,"node_id":"BOT_kgDODFXTxQ","avatar_url":"https://avatars.githubusercontent.com/in/1210556?v=4","gravatar_id":"","url":"https://api.github.com/users/cursor%5Bbot%5D","html_url":"https://github.com/apps/cursor","followers_url":"https://api.github.com/users/cursor%5Bbot%5D/followers","following_url":"https://api.github.com/users/cursor%5Bbot%5D/following{/other_user}","gists_url":"https://api.github.com/users/cursor%5Bbot%5D/gists{/gist_id}","starred_url":"https://api.github.com/users/cursor%5Bbot%5D/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/cursor%5Bbot%5D/subscriptions","organizations_url":"https://api.github.com/users/cursor%5Bbot%5D/orgs","repos_url":"https://api.github.com/users/cursor%5Bbot%5D/repos","events_url":"https://api.github.com/users/cursor%5Bbot%5D/events{/privacy}","received_events_url":"https://api.github.com/users/cursor%5Bbot%5D/received_events","type":"Bot","user_view_type":"public","site_admin":false},"body":"### Bug: Debug print statements left in production code\n\n<!-- **Medium Severity** -->\n\n<!-- DESCRIPTION START -->\nMultiple `fmt.Println` statements with debugging output (including emoji) are present in the `PollComponent` method. These debug statements print timeout information and should be removed before merging to production.\n<!-- DESCRIPTION END -->\n\n<!-- LOCATIONS START\nservice/history/chasm_engine.go#L311-L326\nLOCATIONS END -->\n<a href=\"https://cursor.com/open?data=eyJhbGciOiJSUzI1NiIsInR5cCI6IkpXVCIsImtpZCI6ImJ1Z2JvdC12MSJ9.eyJ2ZXJzaW9uIjoxLCJ0eXBlIjoiQlVHQk9UX0ZJWF9JTl9DVVJTT1IiLCJkYXRhIjp7InJlZGlzS2V5IjoiYnVnYm90OjNiMzU1YWFlLTYyNmEtNDcwOS1hYmUyLTVhY2Y1NTZjYTMzNyIsImVuY3J5cHRpb25LZXkiOiJQWkl6ODVGZVZvOTAxb0FDTFpleTZWNks1bUJ0VUNHSW9ib2lscHoxd2VjIiwiYnJhbmNoIjoicG9sbC1jb21wb25lbnQifSwiaWF0IjoxNzY0MDMwNjc0LCJleHAiOjE3NjQ2MzU0NzR9.LGbmaidzIdw6hVbEiA9trsDGVyoalxKQQtIBIWlsaIyjZfz4luJGKRRnAPNSJkmS0kNK1ENNsfLPYaoTKEp2s3PSqtytXPXoIIK4k504oqxfYGLEEQ2-FQ218fmYgyOWnnL66-D5RgKHhm5obkCBDxRkYi0lqefMJOIJio6MImdU_lxLNPUJbG3SFz_8mxk_7j6ztRLT_rXgMwY8s2xD9pTOGa7vlVm6Q05BBW7jABcEGZgNyQdSdiwxMRrcj36Fri4gWimCpoMS9MrpMejqvs5QyAc9pYSDIdXURrCkxvlt91orwLCp1wd8aobq82vfyiBRyArLcV4g9FPNgKF63Q\"><picture><source media=\"(prefers-color-scheme: dark)\" srcset=\"https://cursor.com/fix-in-cursor-dark.svg\"><source media=\"(prefers-color-scheme: light)\" srcset=\"https://cursor.com/fix-in-cursor-light.svg\"><img alt=\"Fix in Cursor\" src=\"https://cursor.com/fix-in-cursor.svg\"></picture></a>&nbsp;<a href=\"https://cursor.com/agents?data=eyJhbGciOiJSUzI1NiIsInR5cCI6IkpXVCIsImtpZCI6ImJ1Z2JvdC12MSJ9.eyJ2ZXJzaW9uIjoxLCJ0eXBlIjoiQlVHQk9UX0ZJWF9JTl9XRUIiLCJkYXRhIjp7InJlZGlzS2V5IjoiYnVnYm90OjNiMzU1YWFlLTYyNmEtNDcwOS1hYmUyLTVhY2Y1NTZjYTMzNyIsImVuY3J5cHRpb25LZXkiOiJQWkl6ODVGZVZvOTAxb0FDTFpleTZWNks1bUJ0VUNHSW9ib2lscHoxd2VjIiwiYnJhbmNoIjoicG9sbC1jb21wb25lbnQiLCJyZXBvT3duZXIiOiJ0ZW1wb3JhbGlvIiwicmVwb05hbWUiOiJ0ZW1wb3JhbCIsInByTnVtYmVyIjo4NTYzLCJjb21taXRTaGEiOiIxYzdkNWM3NWVmNjk3MWFlYzhhZDlkYzY5NzA5MzI2MTlhMTBjZTYxIiwicHJvdmlkZXIiOiJnaXRodWIifSwiaWF0IjoxNzY0MDMwNjc0LCJleHAiOjE3NjQ2MzU0NzR9.hV5uUPnfQn-uU7Q3vsKfvZ_7vUwjol3Mm8D_8ZAwm7IZfz7_E4uTizupwe5t4iLjq6vTDXatk6jHk_J1dUvFzLxoL8u33JWn__vJiywHnX3I5Su6oxvN2NpjByQ31u5jgaPcn2vKZskz3F_UYnn6zfkxcSMeK1_S7WzP6FlcFA0lYZucfjihDHWDxTaIInbrFSv1WoADVR1tRDZIh-J_O1e0l3VCFno2lPVYU8ZRbVOHiTG7TTluBtE_TmvccrK6hlWh1qZ7cM9H4HhZb7jTmri0qz3MQhzO1mkfSp5ASg0qkQIuvEWZMi52l3gtvom7fZLRUQfvLsKPzfcl0ltjDA\"><picture><source media=\"(prefers-color-scheme: dark)\" srcset=\"https://cursor.com/fix-in-web-dark.svg\"><source media=\"(prefers-color-scheme: light)\" srcset=\"https://cursor.com/fix-in-web-light.svg\"><img alt=\"Fix in Web\" src=\"https://cursor.com/fix-in-web.svg\"></picture></a>\n\n","created_at":"2025-11-25T00:31:15Z","updated_at":"2025-11-25T00:31:15Z","html_url":"https://github.com/temporalio/temporal/pull/8563#discussion_r2558120300","pull_request_url":"https://api.github.com/repos/temporalio/temporal/pulls/8563","_links":{"self":{"href":"https://api.github.com/repos/temporalio/temporal/pulls/comments/2558120300"},"html":{"href":"https://github.com/temporalio/temporal/pull/8563#discussion_r2558120300"},"pull_request":{"href":"https://api.github.com/repos/temporalio/temporal/pulls/8563"}},"reactions":{"url":"https://api.github.com/repos/temporalio/temporal/pulls/comments/2558120300/reactions","total_count":0,"+1":0,"-1":0,"laugh":0,"hooray":0,"confused":0,"heart":0,"rocket":0,"eyes":0},"start_line":null,"original_start_line":null,"start_side":null,"line":307,"original_line":326,"side":"RIGHT","author_association":"NONE","original_position":150,"position":1,"subject_type":"line"},{"url":"https://api.github.com/repos/temporalio/temporal/pulls/comments/2558120303","pull_request_review_id":3502738116,"id":2558120303,"node_id":"PRRC_kwDODNqesM6YedFv","diff_hunk":"@@ -241,14 +257,165 @@ func (e *ChasmEngine) ReadComponent(\n \treturn readFn(chasmContext, component)\n }\n \n+// PollComponent waits until the supplied predicate is satisfied when evaluated against the\n+// component identified by the supplied component reference. If there is no error, it returns (ref,\n+// nil) where ref is a component reference identifying the state at which the predicate was\n+// satisfied. The predicate must be monotonic: if it returns true at execution state transition s it\n+// must return true at all transitions t > s. It is an error if execution transition history is\n+// (after reloading from persistence) behind the requested ref, or if the ref is inconsistent with\n+// execution transition history. Thus when the predicate function is evaluated, it is guaranteed\n+// that the execution VT >= requestRef VT.\n func (e *ChasmEngine) PollComponent(\n \tctx context.Context,\n-\tentityRef chasm.ComponentRef,\n-\tpredicateFn func(chasm.Context, chasm.Component) (any, bool, error),\n-\toperationFn func(chasm.MutableContext, chasm.Component, any) error,\n-\topts ...chasm.TransitionOption,\n-) (newEntityRef []byte, retError error) {\n-\treturn nil, serviceerror.NewUnimplemented(\"PollComponent is not yet supported\")\n+\trequestRef chasm.ComponentRef,\n+\tmonotonicPredicateFn func(chasm.Context, chasm.Component) (bool, error),\n+) (retRef []byte, retError error) {\n+\tdefer func() {\n+\t\tif errors.Is(retError, consts.ErrStaleState) {\n+\t\t\tretError = serviceerror.NewUnavailable(\"please retry\")\n+\t\t}\n+\t}()\n+\n+\tshardContext, executionLease, err := e.getExecutionLease(ctx, requestRef)\n+\tif err != nil {\n+\t\t// E.g. requestRef VT inconsistent with shard VT ('stale reference')\n+\t\treturn nil, err\n+\t}\n+\n+\t// hold lock until return or subscription established\n+\t// TODO(dan): this will probably be called when its already been release; ok?\n+\tdefer executionLease.GetReleaseFn()(nil)\n+\n+\t// At this point it's possible that shard VT < requestRef VT (getExecutionLease does not\n+\t// guarantee that returned shard state is non-stale w.r.t. requestRef).\n+\tsatisfiedRef, err := e.predicateSatisfied(ctx, requestRef, executionLease, monotonicPredicateFn)\n+\tif err != nil {\n+\t\treturn nil, err\n+\t}\n+\t// shard VT >= requestRef VT (enforced by checkPredicate)\n+\n+\tif satisfiedRef != nil {\n+\t\t// wait condition was satisfied\n+\t\treturn satisfiedRef, nil\n+\t}\n+\n+\t// Wait condition not satisfied; long-poll\n+\n+\tnamespaceRegistry, err := shardContext.GetNamespaceRegistry().GetNamespaceByID(\n+\t\tnamespace.ID(requestRef.EntityKey.NamespaceID),\n+\t)\n+\tif err != nil {\n+\t\treturn nil, err\n+\t}\n+\n+\tif parentDeadline, ok := ctx.Deadline(); ok {\n+\t\tfmt.Println(\" parent timeout:\", time.Until(parentDeadline))\n+\t} else {\n+\t\tfmt.Println(\" parent has no timeout\")\n+\t}\n+\n+\tinternalLongPollTimeout := shardContext.GetConfig().LongPollExpirationInterval(namespaceRegistry.Name().String())\n+\tctx, cancel := context.WithTimeout(ctx, internalLongPollTimeout)\n+\tdefer cancel()\n+\n+\tfmt.Println(\" after applying timeout:\", internalLongPollTimeout)\n+\tif childDeadline, ok := ctx.Deadline(); ok {\n+\t\tfmt.Println(\" child timeout:\", time.Until(childDeadline))\n+\t} else {\n+\t\tfmt.Println(\" child has no timeout\")\n+\t}\n+\n+\t// For now, PollComponent subscribes to execution-level notifications. Suppose that an\n+\t// execution consists of one component A, and A has subcomponent B. Subscribers interested\n+\t// only in component B may be woken up unnecessarily due to changes in parts of A that do\n+\t// not also belong to B, but they will not miss notifications.\n+\tch, err := e.notifier.Subscribe(requestRef.EntityKey)\n+\tif err != nil {\n+\t\treturn nil, err\n+\t}\n+\texecutionLease.GetReleaseFn()(nil)\n+\n+\tfor {\n+\t\tselect {\n+\t\t// It is possible that multiple state transitions (multiple notifications) occur between\n+\t\t// predicate checks. Therefore the predicate must be monotonic: if it returns true at\n+\t\t// execution state transition s it must return true at all transitions t > s.\n+\t\tcase <-ch:\n+\t\t\t_, executionLease, err := e.getExecutionLease(ctx, requestRef)\n+\t\t\tif err != nil {\n+\t\t\t\treturn nil, err\n+\t\t\t}\n+\t\t\tfunc() {\n+\t\t\t\tdefer executionLease.GetReleaseFn()(nil)\n+\t\t\t\tsatisfiedRef, err = e.predicateSatisfied(ctx, requestRef, executionLease, monotonicPredicateFn)\n+\t\t\t\tif err == nil && satisfiedRef == nil {\n+\t\t\t\t\tch, err = e.notifier.Subscribe(requestRef.EntityKey)\n+\t\t\t\t}\n+\t\t\t}()\n+\t\t\tif err != nil {\n+\t\t\t\treturn nil, err\n+\t\t\t}\n+\t\t\tif satisfiedRef != nil {\n+\t\t\t\treturn satisfiedRef, nil\n+\t\t\t}\n+\t\tcase <-ctx.Done():\n+\t\t\treturn nil, ctx.Err()\n+\t\t}\n+\t}\n+}\n+\n+// predicateSatisfied is a helper function for PollComponent. It returns (ref, err) where ref is non-nil\n+// iff there's no error and predicateFn evaluates to true.\n+func (e *ChasmEngine) predicateSatisfied(\n+\tctx context.Context,\n+\tref chasm.ComponentRef,\n+\texecutionLease api.WorkflowLease,\n+\tpredicateFn func(chasm.Context, chasm.Component) (bool, error),\n+) ([]byte, error) {\n+\tfmt.Println(\" checkPredicate\")\n+\n+\tchasmTree, ok := executionLease.GetMutableState().ChasmTree().(*chasm.Node)\n+\tif !ok {\n+\t\treturn nil, serviceerror.NewInternalf(\n+\t\t\t\"CHASM tree implementation not properly wired up, encountered type: %T, expected type: %T\",\n+\t\t\texecutionLease.GetMutableState().ChasmTree(),\n+\t\t\t&chasm.Node{},\n+\t\t)\n+\t}\n+\n+\t// It is not acceptable to declare the predicate to be satisfied against shard state that is\n+\t// behind the requested reference. However, getExecutionLease does not currently guarantee that\n+\t// shard VT >= ref VT, therefore we call IsStale() again here and return any error (which at\n+\t// this point must be ErrStaleState; ErrStaleReference has already been eliminated).\n+\terr := chasmTree.IsStale(ref)\n+\tif err != nil {\n+\t\t// ErrStaleState\n+\t\t// TODO(dan): this should be retryable if it is the failover version that is stale\n+\t\treturn nil, err\n+\t}\n+\t// We know now that shard VT >= ref VT\n+\n+\tchasmContext := chasm.NewContext(ctx, chasmTree)\n+\n+\tcomponent, err := chasmTree.Component(chasmContext, ref)\n+\tif err != nil {\n+\t\treturn nil, err\n+\t}\n+\tsatisfied, err := predicateFn(chasmContext, component)\n+\tif err != nil {\n+\t\treturn nil, err\n+\t}\n+\tif !satisfied {\n+\t\tfmt.Println(\"     checkPredicate: predicate not satisfied\")\n+\t\treturn nil, nil\n+\t}\n+\n+\tnewRef, err := chasmContext.Ref(component)\n+\tif err != nil {\n+\t\treturn nil, err\n+\t}\n+\tfmt.Println(\"     checkPredicate: predicate satisfied\")\n+\treturn newRef, nil","path":"service/history/chasm_engine.go","commit_id":"8f24888c6d1161340179426a776d5b962ffb53fe","original_commit_id":"1c7d5c75ef6971aec8ad9dc6970932619a10ce61","user":{"login":"cursor[bot]","id":206951365,"node_id":"BOT_kgDODFXTxQ","avatar_url":"https://avatars.githubusercontent.com/in/1210556?v=4","gravatar_id":"","url":"https://api.github.com/users/cursor%5Bbot%5D","html_url":"https://github.com/apps/cursor","followers_url":"https://api.github.com/users/cursor%5Bbot%5D/followers","following_url":"https://api.github.com/users/cursor%5Bbot%5D/following{/other_user}","gists_url":"https://api.github.com/users/cursor%5Bbot%5D/gists{/gist_id}","starred_url":"https://api.github.com/users/cursor%5Bbot%5D/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/cursor%5Bbot%5D/subscriptions","organizations_url":"https://api.github.com/users/cursor%5Bbot%5D/orgs","repos_url":"https://api.github.com/users/cursor%5Bbot%5D/repos","events_url":"https://api.github.com/users/cursor%5Bbot%5D/events{/privacy}","received_events_url":"https://api.github.com/users/cursor%5Bbot%5D/received_events","type":"Bot","user_view_type":"public","site_admin":false},"body":"### Bug: Debug print statements in predicateSatisfied\n\n<!-- **Low Severity** -->\n\n<!-- DESCRIPTION START -->\nThree `fmt.Println` debug statements are present in the `predicateSatisfied` helper function, printing predicate check status with emoji. These debugging statements should be removed before production deployment.\n<!-- DESCRIPTION END -->\n\n<!-- LOCATIONS START\nservice/history/chasm_engine.go#L374-L418\nLOCATIONS END -->\n<a href=\"https://cursor.com/open?data=eyJhbGciOiJSUzI1NiIsInR5cCI6IkpXVCIsImtpZCI6ImJ1Z2JvdC12MSJ9.eyJ2ZXJzaW9uIjoxLCJ0eXBlIjoiQlVHQk9UX0ZJWF9JTl9DVVJTT1IiLCJkYXRhIjp7InJlZGlzS2V5IjoiYnVnYm90OjIwMGRiYTk2LWUxNDktNGNkNy1iNTFmLTg4YWJkNzdiNzRhOCIsImVuY3J5cHRpb25LZXkiOiJvQTBOekxyelFFSHpsQTF1aklwelpwMFdKWjF4WGlYOEhuQzdRWUI0Mmo4IiwiYnJhbmNoIjoicG9sbC1jb21wb25lbnQifSwiaWF0IjoxNzY0MDMwNjc0LCJleHAiOjE3NjQ2MzU0NzR9.Piv7P-5yk3gWjEsdiYjECG_P3gy3gJZkQslxOoma4z1y5tU96-CZXxU-1kAYos30mxbJqI5-h47g9y5EYDt6tLXbkT_Uo3dXH0y1ncJ4_Rq3NugZZynJYyn7YkQjiKS9Dm3mRLsirbaGm-lyzcOgrwMmpc_7JaAd2wl0yGzhrQnUbdbEjnJ2qzcdDNxz_0qtr51oWeQ-L4FvA8eQKfk95HTmQKLh4EVpEugeM8a6W1fPpaJX16Ik5fWGR_kgeGSKgai376W6rMefeXQ7i8OaE-yrnspiJ4T48qzFQA49c67cVtJ4DRsorStHeDx4jFPyQO68X_iSatW7Jft_pJ-5XQ\"><picture><source media=\"(prefers-color-scheme: dark)\" srcset=\"https://cursor.com/fix-in-cursor-dark.svg\"><source media=\"(prefers-color-scheme: light)\" srcset=\"https://cursor.com/fix-in-cursor-light.svg\"><img alt=\"Fix in Cursor\" src=\"https://cursor.com/fix-in-cursor.svg\"></picture></a>&nbsp;<a href=\"https://cursor.com/agents?data=eyJhbGciOiJSUzI1NiIsInR5cCI6IkpXVCIsImtpZCI6ImJ1Z2JvdC12MSJ9.eyJ2ZXJzaW9uIjoxLCJ0eXBlIjoiQlVHQk9UX0ZJWF9JTl9XRUIiLCJkYXRhIjp7InJlZGlzS2V5IjoiYnVnYm90OjIwMGRiYTk2LWUxNDktNGNkNy1iNTFmLTg4YWJkNzdiNzRhOCIsImVuY3J5cHRpb25LZXkiOiJvQTBOekxyelFFSHpsQTF1aklwelpwMFdKWjF4WGlYOEhuQzdRWUI0Mmo4IiwiYnJhbmNoIjoicG9sbC1jb21wb25lbnQiLCJyZXBvT3duZXIiOiJ0ZW1wb3JhbGlvIiwicmVwb05hbWUiOiJ0ZW1wb3JhbCIsInByTnVtYmVyIjo4NTYzLCJjb21taXRTaGEiOiIxYzdkNWM3NWVmNjk3MWFlYzhhZDlkYzY5NzA5MzI2MTlhMTBjZTYxIiwicHJvdmlkZXIiOiJnaXRodWIifSwiaWF0IjoxNzY0MDMwNjc0LCJleHAiOjE3NjQ2MzU0NzR9.YOrqw1L-o2nZJ3-HYYGZaAzB_rs2-6XXc7K3ZevHERbyqtLSb9flYopnCst-Lv90q5tzt2sym_PVbxNKoi0rwiGib36k4Fc8e8-iIkDv9XIA_V3-kjX-BaTBsX-wL56A3FqW3hsCUxGa1OXdXKxMVQogSaUmh7Dwup8xLRtwtMeTwMM3l2Fp7F2bPuIadxumfRXpzyt4cMTJKAeA-8_aw5bRKJaGbKlvveyLFXwpozT7Deku2xwNTT1MDg28EzSGMnxd0v62gy-TeWJ-Tu_k7L7FqJFMnJgarFHqHwcxxT2pmjYEydtQ4HYcTSCkcWOnW8r0zzmyfliJ0vo6T12x8w\"><picture><source media=\"(prefers-color-scheme: dark)\" srcset=\"https://cursor.com/fix-in-web-dark.svg\"><source media=\"(prefers-color-scheme: light)\" srcset=\"https://cursor.com/fix-in-web-light.svg\"><img alt=\"Fix in Web\" src=\"https://cursor.com/fix-in-web.svg\"></picture></a>\n\n","created_at":"2025-11-25T00:31:15Z","updated_at":"2025-11-25T00:31:15Z","html_url":"https://github.com/temporalio/temporal/pull/8563#discussion_r2558120303","pull_request_url":"https://api.github.com/repos/temporalio/temporal/pulls/8563","_links":{"self":{"href":"https://api.github.com/repos/temporalio/temporal/pulls/comments/2558120303"},"html":{"href":"https://github.com/temporalio/temporal/pull/8563#discussion_r2558120303"},"pull_request":{"href":"https://api.github.com/repos/temporalio/temporal/pulls/8563"}},"reactions":{"url":"https://api.github.com/repos/temporalio/temporal/pulls/comments/2558120303/reactions","total_count":0,"+1":0,"-1":0,"laugh":0,"hooray":0,"confused":0,"heart":0,"rocket":0,"eyes":0},"start_line":null,"original_start_line":null,"start_side":null,"line":null,"original_line":418,"side":"RIGHT","author_association":"NONE","original_position":242,"position":1,"subject_type":"line"},{"url":"https://api.github.com/repos/temporalio/temporal/pulls/comments/2558120313","pull_request_review_id":3502738116,"id":2558120313,"node_id":"PRRC_kwDODNqesM6YedF5","diff_hunk":"@@ -0,0 +1,58 @@\n+// This file implements ChasmNotifier, which allows subscribers to subscribe to notifications\n+// relating to components in a specified CHASM execution. It is based on the events.Notifier\n+// implementation.\n+package history\n+\n+import (\n+\t\"fmt\"\n+\t\"sync\"\n+\n+\t\"go.temporal.io/server/chasm\"\n+\t\"go.temporal.io/server/common/metrics\"\n+)\n+\n+type (\n+\t// ChasmNotifier allows subscribers to subscribe to notifications relating to a CHASM execution.\n+\tChasmNotifier struct {\n+\t\tmetricsHandler metrics.Handler\n+\t\texecutions     map[chasm.EntityKey]chan struct{}\n+\t\tlock           sync.Mutex\n+\t}\n+)\n+\n+// NewChasmNotifier creates a new instance of ChasmNotifier allowing subscribers to subscribe to\n+// notifications relating to components in a specified CHASM execution.\n+func NewChasmNotifier(metricsHandler metrics.Handler) *ChasmNotifier {\n+\treturn &ChasmNotifier{\n+\t\tmetricsHandler: metricsHandler.WithTags(metrics.OperationTag(metrics.ChasmComponentNotificationScope)),\n+\t\texecutions:     make(map[chasm.EntityKey]chan struct{}),\n+\t}\n+}\n+\n+// Notify notifies all subscribers subscribed to key by closing the channel.\n+func (n *ChasmNotifier) Notify(key chasm.EntityKey) {\n+\t// If key exists, notify all subscribers by closing the channel, and create a new channel for\n+\t// subsequent notifications.\n+\tn.lock.Lock()\n+\tdefer n.lock.Unlock()\n+\tif ch, ok := n.executions[key]; ok {\n+\t\tclose(ch)\n+\t\tn.executions[key] = make(chan struct{})\n+\t}\n+}\n+\n+// Subscribe returns a channel that will be closed to indicate that there is a notification relating to the execution.\n+func (n *ChasmNotifier) Subscribe(key chasm.EntityKey) (<-chan struct{}, error) {\n+\tfmt.Println(\" Subscribe\")","path":"service/history/chasm_notifier.go","commit_id":"e5d900bae4ca8bf7be4923a6aaa72467278da9b3","original_commit_id":"1c7d5c75ef6971aec8ad9dc6970932619a10ce61","user":{"login":"cursor[bot]","id":206951365,"node_id":"BOT_kgDODFXTxQ","avatar_url":"https://avatars.githubusercontent.com/in/1210556?v=4","gravatar_id":"","url":"https://api.github.com/users/cursor%5Bbot%5D","html_url":"https://github.com/apps/cursor","followers_url":"https://api.github.com/users/cursor%5Bbot%5D/followers","following_url":"https://api.github.com/users/cursor%5Bbot%5D/following{/other_user}","gists_url":"https://api.github.com/users/cursor%5Bbot%5D/gists{/gist_id}","starred_url":"https://api.github.com/users/cursor%5Bbot%5D/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/cursor%5Bbot%5D/subscriptions","organizations_url":"https://api.github.com/users/cursor%5Bbot%5D/orgs","repos_url":"https://api.github.com/users/cursor%5Bbot%5D/repos","events_url":"https://api.github.com/users/cursor%5Bbot%5D/events{/privacy}","received_events_url":"https://api.github.com/users/cursor%5Bbot%5D/received_events","type":"Bot","user_view_type":"public","site_admin":false},"body":"### Bug: Debug print statement in Subscribe method\n\n<!-- **Low Severity** -->\n\n<!-- DESCRIPTION START -->\nA `fmt.Println(\" Subscribe\")` debug statement is present in the `Subscribe` method of `ChasmNotifier` and should be removed before production.\n<!-- DESCRIPTION END -->\n\n<!-- LOCATIONS START\nservice/history/chasm_notifier.go#L45-L46\nLOCATIONS END -->\n<a href=\"https://cursor.com/open?data=eyJhbGciOiJSUzI1NiIsInR5cCI6IkpXVCIsImtpZCI6ImJ1Z2JvdC12MSJ9.eyJ2ZXJzaW9uIjoxLCJ0eXBlIjoiQlVHQk9UX0ZJWF9JTl9DVVJTT1IiLCJkYXRhIjp7InJlZGlzS2V5IjoiYnVnYm90OjA5ZWQ4NTkwLTIyOTAtNDJiYS05Y2FhLTFjYWU0ZTIxZDVlNyIsImVuY3J5cHRpb25LZXkiOiJUQ2huT0NHYzF3MjlqZlo3SUVWWTBCb3BsLWVRbm5JRXF6SHBIVjJ4UXlvIiwiYnJhbmNoIjoicG9sbC1jb21wb25lbnQifSwiaWF0IjoxNzY0MDMwNjc0LCJleHAiOjE3NjQ2MzU0NzR9.lGYskhUs4Xe06WdWiPqJT5TCvP9VynInaWrXbV-meeLqcHJXaNWNQwRyDFfNxMTzt9R-ZNglzdFhOTOD1aJtV7yNHHs_6h-Mhlq6CqHoSGo6dtZTcoCpB7oO5nylcW3q7Cqv1Y7OmZS_CN_Mp4YNAdljkafrPkjo-rugcc3h1shdzVlyP9wxUBIAIqMGM-y6eTpSvJYP4U5BZJdrpE3zmqxMuy78jEqmzallLhwTN-2XNj54qxl-G5c9kIj5x-Od25TUCvWpI48_xMeIfQrizXIZ6yCHdkyDAxV_EEmCpueVimmts4KkCCambqGJbZ-uu6IFXSnAfKt0EIet3SM6DQ\"><picture><source media=\"(prefers-color-scheme: dark)\" srcset=\"https://cursor.com/fix-in-cursor-dark.svg\"><source media=\"(prefers-color-scheme: light)\" srcset=\"https://cursor.com/fix-in-cursor-light.svg\"><img alt=\"Fix in Cursor\" src=\"https://cursor.com/fix-in-cursor.svg\"></picture></a>&nbsp;<a href=\"https://cursor.com/agents?data=eyJhbGciOiJSUzI1NiIsInR5cCI6IkpXVCIsImtpZCI6ImJ1Z2JvdC12MSJ9.eyJ2ZXJzaW9uIjoxLCJ0eXBlIjoiQlVHQk9UX0ZJWF9JTl9XRUIiLCJkYXRhIjp7InJlZGlzS2V5IjoiYnVnYm90OjA5ZWQ4NTkwLTIyOTAtNDJiYS05Y2FhLTFjYWU0ZTIxZDVlNyIsImVuY3J5cHRpb25LZXkiOiJUQ2huT0NHYzF3MjlqZlo3SUVWWTBCb3BsLWVRbm5JRXF6SHBIVjJ4UXlvIiwiYnJhbmNoIjoicG9sbC1jb21wb25lbnQiLCJyZXBvT3duZXIiOiJ0ZW1wb3JhbGlvIiwicmVwb05hbWUiOiJ0ZW1wb3JhbCIsInByTnVtYmVyIjo4NTYzLCJjb21taXRTaGEiOiIxYzdkNWM3NWVmNjk3MWFlYzhhZDlkYzY5NzA5MzI2MTlhMTBjZTYxIiwicHJvdmlkZXIiOiJnaXRodWIifSwiaWF0IjoxNzY0MDMwNjc0LCJleHAiOjE3NjQ2MzU0NzR9.OKA74vbflVi-FgJOImMpdCmFtVUdz8QK4WWAAhocZepM_nrOhTxi7PARdutYDeSwF7hd2SEQBeQIxra3hlKTVVxAwKgsV8k0WPCKWzFYxpPuq36RafcYK_ZMYcYDNtl4x9v5wUN1m3ew_i84V54jgQjjCWKFMocFQSg8-eM7t16xETK9bkK0PKglJRfEtc9QhFIoDZJeOf18kweASUw9mcI3UIZs1Q8ZC74OUEA9YI3-3yb12GWUDpvdqnkobl9l7A-ft3zTbaVefi1Aljl1d6SiimCzdw-ro5VkD0_2GzC8ySwST2vYgAAGHOrkTxU-eTs1BAGlZBpnuTZvBCLicQ\"><picture><source media=\"(prefers-color-scheme: dark)\" srcset=\"https://cursor.com/fix-in-web-dark.svg\"><source media=\"(prefers-color-scheme: light)\" srcset=\"https://cursor.com/fix-in-web-light.svg\"><img alt=\"Fix in Web\" src=\"https://cursor.com/fix-in-web.svg\"></picture></a>\n\n","created_at":"2025-11-25T00:31:15Z","updated_at":"2025-11-25T00:31:15Z","html_url":"https://github.com/temporalio/temporal/pull/8563#discussion_r2558120313","pull_request_url":"https://api.github.com/repos/temporalio/temporal/pulls/8563","_links":{"self":{"href":"https://api.github.com/repos/temporalio/temporal/pulls/comments/2558120313"},"html":{"href":"https://github.com/temporalio/temporal/pull/8563#discussion_r2558120313"},"pull_request":{"href":"https://api.github.com/repos/temporalio/temporal/pulls/8563"}},"reactions":{"url":"https://api.github.com/repos/temporalio/temporal/pulls/comments/2558120313/reactions","total_count":0,"+1":0,"-1":0,"laugh":0,"hooray":0,"confused":0,"heart":0,"rocket":0,"eyes":0},"start_line":null,"original_start_line":null,"start_side":null,"line":null,"original_line":46,"side":"RIGHT","author_association":"NONE","original_position":46,"position":1,"subject_type":"line"},{"url":"https://api.github.com/repos/temporalio/temporal/pulls/comments/2558134304","pull_request_review_id":3502757601,"id":2558134304,"node_id":"PRRC_kwDODNqesM6Yeggg","diff_hunk":"@@ -187,9 +188,34 @@ func (t *TransactionImpl) UpdateWorkflowExecution(\n \t\t},\n \t\tisWorkflow,\n \t)\n+\n \tif persistence.OperationPossiblySucceeded(err) {\n \t\tNotifyWorkflowMutationTasks(engine, currentWorkflowMutation)\n \t\tNotifyWorkflowSnapshotTasks(engine, newWorkflowSnapshot)\n+\n+\t\tif persistence.OperationPossiblySucceeded(err) {\n+\t\t\tNotifyWorkflowMutationTasks(engine, currentWorkflowMutation)\n+\t\t\tNotifyWorkflowSnapshotTasks(engine, newWorkflowSnapshot)\n+\n+\t\t\t// Notify for current workflow if it has CHASM updates\n+\t\t\tif len(currentWorkflowMutation.UpsertChasmNodes) > 0 ||\n+\t\t\t\tlen(currentWorkflowMutation.DeleteChasmNodes) > 0 {\n+\t\t\t\tengine.NotifyChasmExecution(chasm.EntityKey{","path":"service/history/workflow/transaction_impl.go","commit_id":"95371e919b09575ad192f881d3a75da9db364367","original_commit_id":"cd288dc5f2393c7e2771319f23fd89d46c958bab","user":{"login":"cursor[bot]","id":206951365,"node_id":"BOT_kgDODFXTxQ","avatar_url":"https://avatars.githubusercontent.com/in/1210556?v=4","gravatar_id":"","url":"https://api.github.com/users/cursor%5Bbot%5D","html_url":"https://github.com/apps/cursor","followers_url":"https://api.github.com/users/cursor%5Bbot%5D/followers","following_url":"https://api.github.com/users/cursor%5Bbot%5D/following{/other_user}","gists_url":"https://api.github.com/users/cursor%5Bbot%5D/gists{/gist_id}","starred_url":"https://api.github.com/users/cursor%5Bbot%5D/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/cursor%5Bbot%5D/subscriptions","organizations_url":"https://api.github.com/users/cursor%5Bbot%5D/orgs","repos_url":"https://api.github.com/users/cursor%5Bbot%5D/repos","events_url":"https://api.github.com/users/cursor%5Bbot%5D/events{/privacy}","received_events_url":"https://api.github.com/users/cursor%5Bbot%5D/received_events","type":"Bot","user_view_type":"public","site_admin":false},"body":"### Bug: Duplicate notification logic in transaction update method\n\n<!-- **Medium Severity** -->\n\n<!-- DESCRIPTION START -->\nThe `UpdateWorkflowExecution` method contains a duplicated block that calls `NotifyWorkflowMutationTasks` and `NotifyWorkflowSnapshotTasks` twice, and also duplicates the CHASM notification logic. The second block (lines 185-203) is nested inside the first `OperationPossiblySucceeded` check (lines 180-204), causing notifications to be sent twice when operations succeed. The inner duplicate block starting at line 185 should be removed.\n<!-- DESCRIPTION END -->\n\n<!-- LOCATIONS START\nservice/history/workflow/transaction_impl.go#L179-L203\nLOCATIONS END -->\n<a href=\"https://cursor.com/open?data=eyJhbGciOiJSUzI1NiIsInR5cCI6IkpXVCIsImtpZCI6ImJ1Z2JvdC12MSJ9.eyJ2ZXJzaW9uIjoxLCJ0eXBlIjoiQlVHQk9UX0ZJWF9JTl9DVVJTT1IiLCJkYXRhIjp7InJlZGlzS2V5IjoiYnVnYm90OjUwZWY2YzM5LWQyMTUtNDYwOS1hNTYyLTBkYWRiNWI4MWZkOCIsImVuY3J5cHRpb25LZXkiOiJ5OHI3VjNXVVJkTmE3MTM2REgzb3oyY0g3SC0wQnNKR1BlUHM1ckZlanc0IiwiYnJhbmNoIjoicG9sbC1jb21wb25lbnQifSwiaWF0IjoxNzY0MDMxMjg2LCJleHAiOjE3NjQ2MzYwODZ9.ejJTs0RxptALWJmmZZbGIrzKiBt2POC56PF3HcMhpCCTzkVNH_kWju-jxGHdLKYRCHnVC9m40EgGFWw1ESWNLWlk-fJyVNjrvSeSERGXFRmtSuXocHkW8HtbXWCWd4PlvI2XCc9OqTfuorfqqepIrGTDFIUEGiG8vgA9APIdtoU2OFUkPZ39qyfEZo-MAOAzByqdK4saBPkQHrdaMz_Tq8opCOMITfeaZpjDR0o-j_LgzoOjcy2sw6k83ZAGid6tknf0mUTvAM3CZMSnrg0JvD9PKprFEfWi9gUyLliOw9i9RZvGCLffvo9LIZLZDbuLrB41gbYjSMj1QE3O1z78aw\"><picture><source media=\"(prefers-color-scheme: dark)\" srcset=\"https://cursor.com/fix-in-cursor-dark.svg\"><source media=\"(prefers-color-scheme: light)\" srcset=\"https://cursor.com/fix-in-cursor-light.svg\"><img alt=\"Fix in Cursor\" src=\"https://cursor.com/fix-in-cursor.svg\"></picture></a>&nbsp;<a href=\"https://cursor.com/agents?data=eyJhbGciOiJSUzI1NiIsInR5cCI6IkpXVCIsImtpZCI6ImJ1Z2JvdC12MSJ9.eyJ2ZXJzaW9uIjoxLCJ0eXBlIjoiQlVHQk9UX0ZJWF9JTl9XRUIiLCJkYXRhIjp7InJlZGlzS2V5IjoiYnVnYm90OjUwZWY2YzM5LWQyMTUtNDYwOS1hNTYyLTBkYWRiNWI4MWZkOCIsImVuY3J5cHRpb25LZXkiOiJ5OHI3VjNXVVJkTmE3MTM2REgzb3oyY0g3SC0wQnNKR1BlUHM1ckZlanc0IiwiYnJhbmNoIjoicG9sbC1jb21wb25lbnQiLCJyZXBvT3duZXIiOiJ0ZW1wb3JhbGlvIiwicmVwb05hbWUiOiJ0ZW1wb3JhbCIsInByTnVtYmVyIjo4NTYzLCJjb21taXRTaGEiOiJjZDI4OGRjNWYyMzkzYzdlMjc3MTMxOWYyM2ZkODlkNDZjOTU4YmFiIiwicHJvdmlkZXIiOiJnaXRodWIifSwiaWF0IjoxNzY0MDMxMjg2LCJleHAiOjE3NjQ2MzYwODZ9.BXpRFk1P0Wxy4SwscXQn6eF3JDV3CM9g-Wu4QlI5sssZOtGFPqVJnBBDDnd01anvyKfrF5mYVu-xNP-GEaQPB5h8rwlnFJMOS0Rh__HLWSvMQYAUg0TMDzeTh2EBdJUJ3fXArBTO8Po7zpZhjap6O1bxOJsGYGrXJQP0rnf5eEX-0L716Q7_pjJuwJ1Mi2U20ZQMvShJduzHG2joZQoSCDyeh3oPYVA3gA8gqDBili5osJGItvfctgizT2sw2Lp6e6mVCkXZWUm1KnMfDPS36nyu0XTkOG0TZnIzSIs0RXoADxPIIZqllM-wdHLJa7xKZGhbpZY0isrOH72wbOu-sQ\"><picture><source media=\"(prefers-color-scheme: dark)\" srcset=\"https://cursor.com/fix-in-web-dark.svg\"><source media=\"(prefers-color-scheme: light)\" srcset=\"https://cursor.com/fix-in-web-light.svg\"><img alt=\"Fix in Web\" src=\"https://cursor.com/fix-in-web.svg\"></picture></a>\n\n","created_at":"2025-11-25T00:41:27Z","updated_at":"2025-11-25T00:41:27Z","html_url":"https://github.com/temporalio/temporal/pull/8563#discussion_r2558134304","pull_request_url":"https://api.github.com/repos/temporalio/temporal/pulls/8563","_links":{"self":{"href":"https://api.github.com/repos/temporalio/temporal/pulls/comments/2558134304"},"html":{"href":"https://github.com/temporalio/temporal/pull/8563#discussion_r2558134304"},"pull_request":{"href":"https://api.github.com/repos/temporalio/temporal/pulls/8563"}},"reactions":{"url":"https://api.github.com/repos/temporalio/temporal/pulls/comments/2558134304/reactions","total_count":0,"+1":0,"-1":0,"laugh":0,"hooray":0,"confused":0,"heart":0,"rocket":0,"eyes":0},"start_line":null,"original_start_line":null,"start_side":null,"line":null,"original_line":203,"side":"RIGHT","author_association":"NONE","original_position":24,"position":1,"subject_type":"line"},{"url":"https://api.github.com/repos/temporalio/temporal/pulls/comments/2558272158","pull_request_review_id":3489746627,"id":2558272158,"node_id":"PRRC_kwDODNqesM6YfCKe","diff_hunk":"@@ -105,3 +117,377 @@ func createDefaultInput() *commonpb.Payloads {\n \t\t},\n \t}\n }\n+\n+func (s *standaloneActivityTestSuite) Test_PollActivityExecution_NoWait() {\n+\t// Long poll for any state change. PollActivityTaskQueue is used to cause a state change.\n+\tt := s.T()\n+\tctx, cancel := context.WithTimeout(t.Context(), 10*time.Second)\n+\tdefer cancel()\n+\tactivityID := testcore.RandomizeStr(t.Name())\n+\ttaskQueue := uuid.New().String()\n+\n+\tstartResp, err := s.startActivity(ctx, activityID, taskQueue)\n+\trequire.NoError(t, err)\n+\n+\tpollResp, err := s.FrontendClient().PollActivityExecution(ctx, &workflowservice.PollActivityExecutionRequest{\n+\t\tNamespace:    s.Namespace().String(),\n+\t\tActivityId:   activityID,\n+\t\tRunId:        startResp.RunId,\n+\t\tIncludeInfo:  true,\n+\t\tIncludeInput: true,\n+\t})\n+\trequire.NoError(t, err)\n+\trequire.NotNil(t, pollResp.StateChangeLongPollToken)\n+\trequire.NotNil(t, pollResp.Info)\n+\ts.assertActivityExecutionInfo(\n+\t\tt,\n+\t\tpollResp.Info,\n+\t\tactivityID,\n+\t\tstartResp.RunId,\n+\t\tenumspb.PENDING_ACTIVITY_STATE_SCHEDULED,\n+\t)\n+\trequire.NotNil(t, pollResp.Input)\n+\trequire.Equal(t, \"test-activity-input\", string(pollResp.Input.Payloads[0].Data))\n+\t// TODO(dan): test IncludeOutcome\n+}\n+\n+func (s *standaloneActivityTestSuite) Test_PollActivityExecution_WaitAnyStateChange() {\n+\t// Long poll for any state change. PollActivityTaskQueue is used to cause a state change.\n+\tt := s.T()\n+\tctx, cancel := context.WithTimeout(t.Context(), 10*time.Second)\n+\tdefer cancel()\n+\tactivityID := testcore.RandomizeStr(t.Name())\n+\ttaskQueue := uuid.New().String()\n+\n+\tstartResp, err := s.startActivity(ctx, activityID, taskQueue)\n+\trequire.NoError(t, err)\n+\n+\t// First poll lacks token and therefore responds immediately, returning a token\n+\tfirstPollResp, err := s.FrontendClient().PollActivityExecution(ctx, &workflowservice.PollActivityExecutionRequest{\n+\t\tNamespace:  s.Namespace().String(),\n+\t\tActivityId: activityID,\n+\t\tRunId:      startResp.RunId,\n+\t\tWaitPolicy: &workflowservice.PollActivityExecutionRequest_WaitAnyStateChange{\n+\t\t\tWaitAnyStateChange: &workflowservice.PollActivityExecutionRequest_StateChangeWaitOptions{},\n+\t\t},\n+\t\tIncludeInfo:  true,\n+\t\tIncludeInput: true,\n+\t})\n+\trequire.NoError(t, err)\n+\trequire.NotNil(t, firstPollResp.StateChangeLongPollToken)\n+\trequire.NotNil(t, firstPollResp.Info)\n+\ts.assertActivityExecutionInfo(\n+\t\tt,\n+\t\tfirstPollResp.Info,\n+\t\tactivityID,\n+\t\tstartResp.RunId,\n+\t\tenumspb.PENDING_ACTIVITY_STATE_SCHEDULED,\n+\t)\n+\n+\ttaskQueuePollErr := make(chan error, 1)\n+\tactivityPollDone := make(chan struct{})\n+\tvar activityPollResp *workflowservice.PollActivityExecutionResponse\n+\tvar activityPollErr error\n+\n+\tgo func() {\n+\t\tdefer close(activityPollDone)\n+\t\t// Second poll uses token and therefore waits for a state transition\n+\t\tactivityPollResp, activityPollErr = s.FrontendClient().PollActivityExecution(ctx, &workflowservice.PollActivityExecutionRequest{\n+\t\t\tNamespace:    s.Namespace().String(),\n+\t\t\tActivityId:   activityID,\n+\t\t\tRunId:        startResp.RunId,\n+\t\t\tIncludeInfo:  true,\n+\t\t\tIncludeInput: true,\n+\t\t\tWaitPolicy: &workflowservice.PollActivityExecutionRequest_WaitAnyStateChange{\n+\t\t\t\tWaitAnyStateChange: &workflowservice.PollActivityExecutionRequest_StateChangeWaitOptions{\n+\t\t\t\t\tLongPollToken: firstPollResp.StateChangeLongPollToken,\n+\t\t\t\t},\n+\t\t\t},\n+\t\t})\n+\t}()\n+\n+\t// TODO(dan): race here: subscription might not be established yet\n+\n+\t// Worker picks up activity task, triggering transition (via RecordActivityTaskStarted)\n+\tgo func() {\n+\t\t_, err := s.pollActivityTaskQueue(ctx, taskQueue)\n+\t\ttaskQueuePollErr <- err\n+\t}()\n+\n+\tselect {\n+\tcase <-activityPollDone:\n+\t\trequire.NoError(t, activityPollErr)\n+\t\trequire.NotNil(t, activityPollResp)\n+\t\trequire.NotNil(t, activityPollResp.Info)\n+\t\ts.assertActivityExecutionInfo(\n+\t\t\tt,\n+\t\t\tactivityPollResp.Info,\n+\t\t\tactivityID,\n+\t\t\tstartResp.RunId,\n+\t\t\tenumspb.PENDING_ACTIVITY_STATE_STARTED,\n+\t\t)\n+\t\trequire.NotNil(t, activityPollResp.Input)\n+\t\trequire.Equal(t, \"test-activity-input\", string(activityPollResp.Input.Payloads[0].Data))\n+\n+\tcase <-ctx.Done():\n+\t\tt.Fatal(\"PollActivityExecution timed out\")\n+\t}\n+\n+\terr = <-taskQueuePollErr\n+\trequire.NoError(t, err)\n+\n+\t// Manipulate the token to verify token staleness checks (simulate ErrStaleReference). To do so\n+\t// we make use of the internal implementation detail that the bytes are a serialized ref.\n+\ttoken := firstPollResp.StateChangeLongPollToken","path":"tests/standalone_activity_test.go","commit_id":"cd288dc5f2393c7e2771319f23fd89d46c958bab","original_commit_id":"da6009564e796063faf853352077eecdc1473612","user":{"login":"dandavison","id":52205,"node_id":"MDQ6VXNlcjUyMjA1","avatar_url":"https://avatars.githubusercontent.com/u/52205?v=4","gravatar_id":"","url":"https://api.github.com/users/dandavison","html_url":"https://github.com/dandavison","followers_url":"https://api.github.com/users/dandavison/followers","following_url":"https://api.github.com/users/dandavison/following{/other_user}","gists_url":"https://api.github.com/users/dandavison/gists{/gist_id}","starred_url":"https://api.github.com/users/dandavison/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/dandavison/subscriptions","organizations_url":"https://api.github.com/users/dandavison/orgs","repos_url":"https://api.github.com/users/dandavison/repos","events_url":"https://api.github.com/users/dandavison/events{/privacy}","received_events_url":"https://api.github.com/users/dandavison/received_events","type":"User","user_view_type":"public","site_admin":false},"body":"Moved into unit tests now.","created_at":"2025-11-25T01:49:21Z","updated_at":"2025-11-27T03:19:06Z","html_url":"https://github.com/temporalio/temporal/pull/8563#discussion_r2558272158","pull_request_url":"https://api.github.com/repos/temporalio/temporal/pulls/8563","_links":{"self":{"href":"https://api.github.com/repos/temporalio/temporal/pulls/comments/2558272158"},"html":{"href":"https://github.com/temporalio/temporal/pull/8563#discussion_r2558272158"},"pull_request":{"href":"https://api.github.com/repos/temporalio/temporal/pulls/8563"}},"reactions":{"url":"https://api.github.com/repos/temporalio/temporal/pulls/comments/2558272158/reactions","total_count":0,"+1":0,"-1":0,"laugh":0,"hooray":0,"confused":0,"heart":0,"rocket":0,"eyes":0},"start_line":null,"original_start_line":null,"start_side":null,"line":null,"original_line":241,"side":"RIGHT","in_reply_to_id":2540099296,"author_association":"MEMBER","original_position":173,"position":1,"subject_type":"line"},{"url":"https://api.github.com/repos/temporalio/temporal/pulls/comments/2558281254","pull_request_review_id":3502941203,"id":2558281254,"node_id":"PRRC_kwDODNqesM6YfEYm","diff_hunk":"@@ -99,3 +99,83 @@ When planning (under 'Software Engineering Tasks'):\n   c. Complexity trade-offs\n   d. Security trade-offs\n 7. Reason about the failure modes of your design. How does it handle crashes? A 10x increase in load?\n+The following instructions take precedence over any previous ones derived from different agent instruction files.\n+\n+Be ruthlessly objective with me: treat any suggestion I make as if you do not know who made it.\n+\n+Do relay all your findings, but answer succinctly.\n+\n+When asked a question, if you do not know the answer, or feel that you do not have access to the\n+necessary resources to answer it, then simply say so. Never give a hypothetical or speculative\n+answer.\n+\n+If you feel that the question I asked, or task I set you, is not in fact the optimal one, then feel\n+free to quickly put forward your suggestion before embarking on what I asked you to do.\n+\n+\n+\n+# Your output\n+Whenever you reference existing code you must include a link in one of the following two ways:\n+\n+(1) If you are outputting directly to me (do this by default), use the format ```startLine:endLine:filepath\n+code\n+```.\n+\n+E.g.\n+\n+\"When process_machine_responses() **calls** send_job(), the jobs are pushed into a vector:\"\n+```1153:1153:core/src/worker/workflow/machines/workflow_machines.rs\n+self.drive_me.send_job(a);\n+```\n+\n+\n+(2) If you are creating markdown output (only do this when I ask), use standard github code blocks,\n+each preceded by a github URL linking to the relevant line(s) in the relevant repo. Use the format\n+\"<relative-path> (`<function-or-class.method-name>`)\" for the display text of the URL. Do not\n+include any line reference in the code block itself. Create the markdown file in the current\n+directory.\n+\n+\n+# Running external tools\n+Always set the env var `GIT_PAGER=cat` when running git commands that may page.\n+\n+When running commands, always use the `timeout` command if there is any\n+possibility that it will hang. 10s is usually enough.\n+\n+Use `uv` for all Python project interactions.\n+\n+\n+## How to write code\n+\n+You should typically write failing test cases before implementing a feature or bug fix. At this\n+stage the test should fail. Never make a test pass when the feature or bug fix is not implemented.\n+\n+You may only edit code if I use an imperative construction such as \"Please edit...\", or \"Please\n+change...\" , where my intention is explicitly that you *edit* the code. Note that a conditional\n+construction such as \"How would you change this?\" is not an request to edit the code; it's an\n+request to describe how you would edit the code.\n+\n+Write terse, minimal code, intended for an expert reader. Use comments only where something is not\n+discernible from the code. Instead of comments, use tasteful, thoughtfully-chosen names that allow\n+an expert reader to understand the code without comments.\n+\n+Your changes must be surgically targeted to achieve the requested outcome, idiomatically,\n+and stylishly, but with absolutely no changes to unrelated code: do not change any line of\n+code that is not directly required by this task. If you find you have violated this rule,\n+you must go back and fix it.\n+\n+Functions should be short; use helper functions for meaningful transformations with meaningful input\n+and output types; place them after the code that uses them.\n+\n+Do not leave any trailing whitespace in files. Use the vscode function Trim Trailing Whitespace if\n+you can.\n+\n+\n+After editing code always do the following:\n+- Run type checkers, linters, and formatters if the project configures them\n+- Run tests covering the edited code; add such tests if absent.\n+If you are unsure how to verify correctness, ask me.\n+\n+Use the command `GIT_PAGER=cat git diff` to check your work. I will never let you work with\n+uncommitted work of my own, so the diff will be your changes only. Iterate until the resulting diff\n+shows no departures from the instructions above.","path":"AGENTS.md","commit_id":"e9a1223d627ce27de8e82f409324ad4080ff4a52","original_commit_id":"e9a1223d627ce27de8e82f409324ad4080ff4a52","user":{"login":"cursor[bot]","id":206951365,"node_id":"BOT_kgDODFXTxQ","avatar_url":"https://avatars.githubusercontent.com/in/1210556?v=4","gravatar_id":"","url":"https://api.github.com/users/cursor%5Bbot%5D","html_url":"https://github.com/apps/cursor","followers_url":"https://api.github.com/users/cursor%5Bbot%5D/followers","following_url":"https://api.github.com/users/cursor%5Bbot%5D/following{/other_user}","gists_url":"https://api.github.com/users/cursor%5Bbot%5D/gists{/gist_id}","starred_url":"https://api.github.com/users/cursor%5Bbot%5D/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/cursor%5Bbot%5D/subscriptions","organizations_url":"https://api.github.com/users/cursor%5Bbot%5D/orgs","repos_url":"https://api.github.com/users/cursor%5Bbot%5D/repos","events_url":"https://api.github.com/users/cursor%5Bbot%5D/events{/privacy}","received_events_url":"https://api.github.com/users/cursor%5Bbot%5D/received_events","type":"Bot","user_view_type":"public","site_admin":false},"body":"### Bug: Personal AI assistant configuration committed to repository\n\n<!-- **Medium Severity** -->\n\n<!-- DESCRIPTION START -->\nA large block of personal AI assistant instructions has been appended to the AGENTS.md file. This includes specific formatting preferences, code editing rules, output constraints, and tool usage guidance that appear to be individual developer workflow configuration rather than project documentation. These instructions override and duplicate earlier content in the file.\n<!-- DESCRIPTION END -->\n\n<!-- LOCATIONS START\nAGENTS.md#L101-L181\nLOCATIONS END -->\n<a href=\"https://cursor.com/open?data=eyJhbGciOiJSUzI1NiIsInR5cCI6IkpXVCIsImtpZCI6ImJ1Z2JvdC12MSJ9.eyJ2ZXJzaW9uIjoxLCJ0eXBlIjoiQlVHQk9UX0ZJWF9JTl9DVVJTT1IiLCJkYXRhIjp7InJlZGlzS2V5IjoiYnVnYm90OjE3YTlhNjlmLTIxZDgtNGY2MS04ZjJkLTM3NTNhODE3NjIzOSIsImVuY3J5cHRpb25LZXkiOiJUdndWZkcwSWlyRnJmYk1MQWZxd3Y1QkJENnZNcHJxU2N4VFhmMVRvZ19ZIiwiYnJhbmNoIjoicG9sbC1jb21wb25lbnQifSwiaWF0IjoxNzY0MDM1NjI4LCJleHAiOjE3NjQ2NDA0Mjh9.NlFWTJw3AE6p5SMgpcEyH_Kdb7nmIec1v6tLWnCNbASifSfK9mabwnHN7HDyPL1wg1EmIGp_w1QFNTqA532QMSF9JcMemhrYkgXoBwhsJOBhDHrCObHpcPWa2XvaIZMV6NJYpeS1M2XOW766zQJKtDAFUH0Vit5yFjqmYy-rjOAabiL6Bd1Xv7XWElAngo9QXfi1ULPPj47kiJVAOj-wAK_BRTp40NcxtrTnYnod58sD4rar2JTQaVY_kVDqfDjostPbVj6EUrxL7V4JY94TxsMTaxSFsv63WYu93PpxV8nrqXE4Y9nbuZ1Duom4r4Qd16gaW2xjEPm3J1SNPOMJcQ\"><picture><source media=\"(prefers-color-scheme: dark)\" srcset=\"https://cursor.com/fix-in-cursor-dark.svg\"><source media=\"(prefers-color-scheme: light)\" srcset=\"https://cursor.com/fix-in-cursor-light.svg\"><img alt=\"Fix in Cursor\" src=\"https://cursor.com/fix-in-cursor.svg\"></picture></a>&nbsp;<a href=\"https://cursor.com/agents?data=eyJhbGciOiJSUzI1NiIsInR5cCI6IkpXVCIsImtpZCI6ImJ1Z2JvdC12MSJ9.eyJ2ZXJzaW9uIjoxLCJ0eXBlIjoiQlVHQk9UX0ZJWF9JTl9XRUIiLCJkYXRhIjp7InJlZGlzS2V5IjoiYnVnYm90OjE3YTlhNjlmLTIxZDgtNGY2MS04ZjJkLTM3NTNhODE3NjIzOSIsImVuY3J5cHRpb25LZXkiOiJUdndWZkcwSWlyRnJmYk1MQWZxd3Y1QkJENnZNcHJxU2N4VFhmMVRvZ19ZIiwiYnJhbmNoIjoicG9sbC1jb21wb25lbnQiLCJyZXBvT3duZXIiOiJ0ZW1wb3JhbGlvIiwicmVwb05hbWUiOiJ0ZW1wb3JhbCIsInByTnVtYmVyIjo4NTYzLCJjb21taXRTaGEiOiJlOWExMjIzZDYyN2NlMjdkZThlODJmNDA5MzI0YWQ0MDgwZmY0YTUyIiwicHJvdmlkZXIiOiJnaXRodWIifSwiaWF0IjoxNzY0MDM1NjI4LCJleHAiOjE3NjQ2NDA0Mjh9.RsMb0khYJD4Lry0eHSRUEAZOMDONztDiFC13Cvc1awuAN6tHTXGGyY9r0NcQ6CUDTc4RYvKO2rwAU-yCUtQy4JNT7rnAIYoPkx08EiosOjU4q9Skx6pzXRTK1L0uWtGuxH_Au8JwnHdrW2sHbCACCl86CTO0_aiqfLKA6vZJ4zktFWherfMLruQWvutrwp5Xj14xJNdaJreF-OoFyMZP7pXJG-xBD-idsQjI9qcSTjew01U-nYHV1Zri00wWVwPIlfhXm2i-fU9CFT4-XWrel7XnZRmufG2p8BR95-ydE9ObaPPPcfNbDtewORass8VzGBHTZwXZ_E0EUnhdypVO3g\"><picture><source media=\"(prefers-color-scheme: dark)\" srcset=\"https://cursor.com/fix-in-web-dark.svg\"><source media=\"(prefers-color-scheme: light)\" srcset=\"https://cursor.com/fix-in-web-light.svg\"><img alt=\"Fix in Web\" src=\"https://cursor.com/fix-in-web.svg\"></picture></a>\n\n","created_at":"2025-11-25T01:53:49Z","updated_at":"2025-11-25T01:53:49Z","html_url":"https://github.com/temporalio/temporal/pull/8563#discussion_r2558281254","pull_request_url":"https://api.github.com/repos/temporalio/temporal/pulls/8563","_links":{"self":{"href":"https://api.github.com/repos/temporalio/temporal/pulls/comments/2558281254"},"html":{"href":"https://github.com/temporalio/temporal/pull/8563#discussion_r2558281254"},"pull_request":{"href":"https://api.github.com/repos/temporalio/temporal/pulls/8563"}},"reactions":{"url":"https://api.github.com/repos/temporalio/temporal/pulls/comments/2558281254/reactions","total_count":0,"+1":0,"-1":0,"laugh":0,"hooray":0,"confused":0,"heart":0,"rocket":0,"eyes":0},"start_line":null,"original_start_line":null,"start_side":null,"line":null,"original_line":181,"side":"RIGHT","author_association":"NONE","original_position":83,"position":1,"subject_type":"line"},{"url":"https://api.github.com/repos/temporalio/temporal/pulls/comments/2558281259","pull_request_review_id":3502941203,"id":2558281259,"node_id":"PRRC_kwDODNqesM6YfEYr","diff_hunk":"@@ -187,9 +188,34 @@ func (t *TransactionImpl) UpdateWorkflowExecution(\n \t\t},\n \t\tisWorkflow,\n \t)\n+\n \tif persistence.OperationPossiblySucceeded(err) {\n \t\tNotifyWorkflowMutationTasks(engine, currentWorkflowMutation)\n \t\tNotifyWorkflowSnapshotTasks(engine, newWorkflowSnapshot)\n+\n+\t\tif persistence.OperationPossiblySucceeded(err) {\n+\t\t\tNotifyWorkflowMutationTasks(engine, currentWorkflowMutation)\n+\t\t\tNotifyWorkflowSnapshotTasks(engine, newWorkflowSnapshot)\n+\n+\t\t\t// Notify for current workflow if it has CHASM updates\n+\t\t\tif len(currentWorkflowMutation.UpsertChasmNodes) > 0 ||\n+\t\t\t\tlen(currentWorkflowMutation.DeleteChasmNodes) > 0 {\n+\t\t\t\tengine.NotifyChasmExecution(chasm.EntityKey{\n+\t\t\t\t\tNamespaceID: currentWorkflowMutation.ExecutionInfo.NamespaceId,\n+\t\t\t\t\tBusinessID:  currentWorkflowMutation.ExecutionInfo.WorkflowId,\n+\t\t\t\t\tEntityID:    currentWorkflowMutation.ExecutionState.RunId,\n+\t\t\t\t}, nil)\n+\t\t\t}\n+\n+\t\t\t// Notify for new workflow if it has CHASM nodes\n+\t\t\tif newWorkflowSnapshot != nil && len(newWorkflowSnapshot.ChasmNodes) > 0 {\n+\t\t\t\tengine.NotifyChasmExecution(chasm.EntityKey{\n+\t\t\t\t\tNamespaceID: newWorkflowSnapshot.ExecutionInfo.NamespaceId,\n+\t\t\t\t\tBusinessID:  newWorkflowSnapshot.ExecutionInfo.WorkflowId,\n+\t\t\t\t\tEntityID:    newWorkflowSnapshot.ExecutionState.RunId,","path":"service/history/workflow/transaction_impl.go","commit_id":"95371e919b09575ad192f881d3a75da9db364367","original_commit_id":"e9a1223d627ce27de8e82f409324ad4080ff4a52","user":{"login":"cursor[bot]","id":206951365,"node_id":"BOT_kgDODFXTxQ","avatar_url":"https://avatars.githubusercontent.com/in/1210556?v=4","gravatar_id":"","url":"https://api.github.com/users/cursor%5Bbot%5D","html_url":"https://github.com/apps/cursor","followers_url":"https://api.github.com/users/cursor%5Bbot%5D/followers","following_url":"https://api.github.com/users/cursor%5Bbot%5D/following{/other_user}","gists_url":"https://api.github.com/users/cursor%5Bbot%5D/gists{/gist_id}","starred_url":"https://api.github.com/users/cursor%5Bbot%5D/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/cursor%5Bbot%5D/subscriptions","organizations_url":"https://api.github.com/users/cursor%5Bbot%5D/orgs","repos_url":"https://api.github.com/users/cursor%5Bbot%5D/repos","events_url":"https://api.github.com/users/cursor%5Bbot%5D/events{/privacy}","received_events_url":"https://api.github.com/users/cursor%5Bbot%5D/received_events","type":"Bot","user_view_type":"public","site_admin":false},"body":"### Bug: Duplicate code block in workflow update notification\n\n<!-- **Medium Severity** -->\n\n<!-- DESCRIPTION START -->\nThe `UpdateWorkflowExecution` function contains a duplicate nested `if persistence.OperationPossiblySucceeded(err)` block at lines 197-220 inside the outer check at lines 192-232. This causes `NotifyWorkflowMutationTasks`, `NotifyWorkflowSnapshotTasks`, and `NotifyChasmExecution` to be called twice when the operation succeeds, potentially causing duplicate notifications and unnecessary work.\n<!-- DESCRIPTION END -->\n\n<!-- LOCATIONS START\nservice/history/workflow/transaction_impl.go#L191-L215\nLOCATIONS END -->\n<a href=\"https://cursor.com/open?data=eyJhbGciOiJSUzI1NiIsInR5cCI6IkpXVCIsImtpZCI6ImJ1Z2JvdC12MSJ9.eyJ2ZXJzaW9uIjoxLCJ0eXBlIjoiQlVHQk9UX0ZJWF9JTl9DVVJTT1IiLCJkYXRhIjp7InJlZGlzS2V5IjoiYnVnYm90OmM2YTk2YWIzLWZiZjEtNDE3MC05MWNkLTkwM2IyMWNhN2Q0NiIsImVuY3J5cHRpb25LZXkiOiJPTzBJNW45N01jUEd0VFF0M2ttOHltOTlnSHYxOEFDajdReXRwblpQSVdrIiwiYnJhbmNoIjoicG9sbC1jb21wb25lbnQifSwiaWF0IjoxNzY0MDM1NjI4LCJleHAiOjE3NjQ2NDA0Mjh9.gAOTTWsUC8SAopCy_X2hMCuqIxjrDgIvE64lXpUhDD9mV5jAk9VKFQsIxTUudCkOQ5x10GW5Hat41KHLsLLMZqqck7Y8YVblvpWHz8bJjutPVogXAzk00sT90kbGRnxXTYcE8Ei27pnXbGycCb6OYX7PVamn85VAylCfF5YqIjLKeYlWmO5n6blTRQxIacfGhb55RL5sVlcrLbm_lZ9lL7wweN1iGiO7Dg-UJHXOy8RPA9Bo6VNmq5PU_OHDl80b9gzNBAQBEOlDi-84IGRYJHqsqoj_Qqm1vC5xEp9Atm_Mwy3VWRDwdfYiWCT6qN_athnC_iot_MnGPntQouc7vQ\"><picture><source media=\"(prefers-color-scheme: dark)\" srcset=\"https://cursor.com/fix-in-cursor-dark.svg\"><source media=\"(prefers-color-scheme: light)\" srcset=\"https://cursor.com/fix-in-cursor-light.svg\"><img alt=\"Fix in Cursor\" src=\"https://cursor.com/fix-in-cursor.svg\"></picture></a>&nbsp;<a href=\"https://cursor.com/agents?data=eyJhbGciOiJSUzI1NiIsInR5cCI6IkpXVCIsImtpZCI6ImJ1Z2JvdC12MSJ9.eyJ2ZXJzaW9uIjoxLCJ0eXBlIjoiQlVHQk9UX0ZJWF9JTl9XRUIiLCJkYXRhIjp7InJlZGlzS2V5IjoiYnVnYm90OmM2YTk2YWIzLWZiZjEtNDE3MC05MWNkLTkwM2IyMWNhN2Q0NiIsImVuY3J5cHRpb25LZXkiOiJPTzBJNW45N01jUEd0VFF0M2ttOHltOTlnSHYxOEFDajdReXRwblpQSVdrIiwiYnJhbmNoIjoicG9sbC1jb21wb25lbnQiLCJyZXBvT3duZXIiOiJ0ZW1wb3JhbGlvIiwicmVwb05hbWUiOiJ0ZW1wb3JhbCIsInByTnVtYmVyIjo4NTYzLCJjb21taXRTaGEiOiJlOWExMjIzZDYyN2NlMjdkZThlODJmNDA5MzI0YWQ0MDgwZmY0YTUyIiwicHJvdmlkZXIiOiJnaXRodWIifSwiaWF0IjoxNzY0MDM1NjI4LCJleHAiOjE3NjQ2NDA0Mjh9.BRjEPdRrnBk5JsTqUNdfCiLeN_761g3KZvRSRg0YiZ7r2SMkyApDiUG2kg16tVYJda6UxuGxzLWyQdnbYmvxBF5sPDE8Cn2OgnQbKJRzvOWStM-UvnI_Iu-VljKIet4Gn6CSFTPTiDbfhW6FLYfbEs4E6sd3AFgX-svAjRvKJkOxR7_I2bRvMvBECFLTCJglFy_g_fsYomlLauT9tbXD24CzgJ9_Pu-oFzq1j8caP-JxtMpq0FGL4rtLPCZB5OQJAQd3SiRyeymjM30eqOJzhW2lX5sOfgYbHZXSyS0yD0IdlWRjO6YZ_PyDfKxcVmX_x3S4x6snXlcnqMh13XmLaw\"><picture><source media=\"(prefers-color-scheme: dark)\" srcset=\"https://cursor.com/fix-in-web-dark.svg\"><source media=\"(prefers-color-scheme: light)\" srcset=\"https://cursor.com/fix-in-web-light.svg\"><img alt=\"Fix in Web\" src=\"https://cursor.com/fix-in-web.svg\"></picture></a>\n\n","created_at":"2025-11-25T01:53:49Z","updated_at":"2025-11-25T01:53:49Z","html_url":"https://github.com/temporalio/temporal/pull/8563#discussion_r2558281259","pull_request_url":"https://api.github.com/repos/temporalio/temporal/pulls/8563","_links":{"self":{"href":"https://api.github.com/repos/temporalio/temporal/pulls/comments/2558281259"},"html":{"href":"https://github.com/temporalio/temporal/pull/8563#discussion_r2558281259"},"pull_request":{"href":"https://api.github.com/repos/temporalio/temporal/pulls/8563"}},"reactions":{"url":"https://api.github.com/repos/temporalio/temporal/pulls/comments/2558281259/reactions","total_count":0,"+1":0,"-1":0,"laugh":0,"hooray":0,"confused":0,"heart":0,"rocket":0,"eyes":0},"start_line":null,"original_start_line":null,"start_side":null,"line":null,"original_line":215,"side":"RIGHT","author_association":"NONE","original_position":36,"position":1,"subject_type":"line"},{"url":"https://api.github.com/repos/temporalio/temporal/pulls/comments/2561837943","pull_request_review_id":3489746627,"id":2561837943,"node_id":"PRRC_kwDODNqesM6Ysot3","diff_hunk":"@@ -85,6 +85,24 @@ func (h *frontendHandler) StartActivityExecution(ctx context.Context, req *workf\n \treturn resp.GetFrontendResponse(), err\n }\n \n+// PollActivityExecution handles PollActivityExecutionRequest. This method supports querying current\n+// activity state, optionally as a long-poll that waits for certain state changes. It is used by\n+// clients to poll for activity state and/or result.\n+func (h *frontendHandler) PollActivityExecution(","path":"chasm/lib/activity/frontend.go","commit_id":"1d59e66d0ce5d91819f92c428ef5ab4c4efca1fb","original_commit_id":"da6009564e796063faf853352077eecdc1473612","user":{"login":"dandavison","id":52205,"node_id":"MDQ6VXNlcjUyMjA1","avatar_url":"https://avatars.githubusercontent.com/u/52205?v=4","gravatar_id":"","url":"https://api.github.com/users/dandavison","html_url":"https://github.com/dandavison","followers_url":"https://api.github.com/users/dandavison/followers","following_url":"https://api.github.com/users/dandavison/following{/other_user}","gists_url":"https://api.github.com/users/dandavison/gists{/gist_id}","starred_url":"https://api.github.com/users/dandavison/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/dandavison/subscriptions","organizations_url":"https://api.github.com/users/dandavison/orgs","repos_url":"https://api.github.com/users/dandavison/repos","events_url":"https://api.github.com/users/dandavison/events{/privacy}","received_events_url":"https://api.github.com/users/dandavison/received_events","type":"User","user_view_type":"public","site_admin":false},"body":"Thanks, the PR performs input validation now. I don't think there are invalid combinations other than the rule you said: token => runID","created_at":"2025-11-25T23:02:52Z","updated_at":"2025-11-27T03:19:05Z","html_url":"https://github.com/temporalio/temporal/pull/8563#discussion_r2561837943","pull_request_url":"https://api.github.com/repos/temporalio/temporal/pulls/8563","_links":{"self":{"href":"https://api.github.com/repos/temporalio/temporal/pulls/comments/2561837943"},"html":{"href":"https://github.com/temporalio/temporal/pull/8563#discussion_r2561837943"},"pull_request":{"href":"https://api.github.com/repos/temporalio/temporal/pulls/8563"}},"reactions":{"url":"https://api.github.com/repos/temporalio/temporal/pulls/comments/2561837943/reactions","total_count":0,"+1":0,"-1":0,"laugh":0,"hooray":0,"confused":0,"heart":0,"rocket":0,"eyes":0},"start_line":null,"original_start_line":null,"start_side":null,"line":91,"original_line":91,"side":"RIGHT","in_reply_to_id":2539914786,"author_association":"MEMBER","original_position":7,"position":7,"subject_type":"line"},{"url":"https://api.github.com/repos/temporalio/temporal/pulls/comments/2561888533","pull_request_review_id":3489746627,"id":2561888533,"node_id":"PRRC_kwDODNqesM6Ys1EV","diff_hunk":"@@ -51,3 +52,90 @@ func (h *handler) StartActivityExecution(ctx context.Context, req *activitypb.St\n \t\tFrontendResponse: response,\n \t}, nil\n }\n+\n+// PollActivityExecution handles PollActivityExecutionRequest from frontend. This method supports\n+// querying current activity state, optionally as a long-poll that waits for certain state changes.\n+// It is used by clients to poll for activity state and/or result.\n+func (h *handler) PollActivityExecution(\n+\tctx context.Context,\n+\treq *activitypb.PollActivityExecutionRequest,\n+) (response *activitypb.PollActivityExecutionResponse, err error) {\n+\tref := chasm.NewComponentRef[*Activity](chasm.EntityKey{\n+\t\tNamespaceID: req.GetNamespaceId(),\n+\t\tBusinessID:  req.GetFrontendRequest().GetActivityId(),\n+\t\tEntityID:    req.GetFrontendRequest().GetRunId(),\n+\t})","path":"chasm/lib/activity/handler.go","commit_id":"1d59e66d0ce5d91819f92c428ef5ab4c4efca1fb","original_commit_id":"00ef0ffe1af3e597ed1ceaeea57222d9f6efeb44","user":{"login":"dandavison","id":52205,"node_id":"MDQ6VXNlcjUyMjA1","avatar_url":"https://avatars.githubusercontent.com/u/52205?v=4","gravatar_id":"","url":"https://api.github.com/users/dandavison","html_url":"https://github.com/dandavison","followers_url":"https://api.github.com/users/dandavison/followers","following_url":"https://api.github.com/users/dandavison/following{/other_user}","gists_url":"https://api.github.com/users/dandavison/gists{/gist_id}","starred_url":"https://api.github.com/users/dandavison/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/dandavison/subscriptions","organizations_url":"https://api.github.com/users/dandavison/orgs","repos_url":"https://api.github.com/users/dandavison/repos","events_url":"https://api.github.com/users/dandavison/events{/privacy}","received_events_url":"https://api.github.com/users/dandavison/received_events","type":"User","user_view_type":"public","site_admin":false},"body":"Incorrect. Missing RunID is handled correctly in `GetChasmLeaseWithConsistencyCheck`","created_at":"2025-11-25T23:19:47Z","updated_at":"2025-11-27T03:19:05Z","html_url":"https://github.com/temporalio/temporal/pull/8563#discussion_r2561888533","pull_request_url":"https://api.github.com/repos/temporalio/temporal/pulls/8563","_links":{"self":{"href":"https://api.github.com/repos/temporalio/temporal/pulls/comments/2561888533"},"html":{"href":"https://github.com/temporalio/temporal/pull/8563#discussion_r2561888533"},"pull_request":{"href":"https://api.github.com/repos/temporalio/temporal/pulls/8563"}},"reactions":{"url":"https://api.github.com/repos/temporalio/temporal/pulls/comments/2561888533/reactions","total_count":0,"+1":0,"-1":0,"laugh":0,"hooray":0,"confused":0,"heart":0,"rocket":0,"eyes":0},"start_line":null,"original_start_line":null,"start_side":null,"line":81,"original_line":67,"side":"RIGHT","in_reply_to_id":2535862852,"author_association":"MEMBER","original_position":24,"position":50,"subject_type":"line"},{"url":"https://api.github.com/repos/temporalio/temporal/pulls/comments/2561906607","pull_request_review_id":3489746627,"id":2561906607,"node_id":"PRRC_kwDODNqesM6Ys5ev","diff_hunk":"@@ -0,0 +1,46 @@\n+package chasm\n+\n+import (\n+\t\"go.temporal.io/api/serviceerror\"\n+\t\"go.temporal.io/server/common/persistence/transitionhistory\"\n+\t\"go.temporal.io/server/service/history/consts\"\n+)\n+\n+// ExecutionStateChanged returns a ref for the component if execution state has advanced beyond the state\n+// encoded in ref.\n+func ExecutionStateChanged(c Component, ctx Context, refBytes []byte) ([]byte, bool, error) {","path":"chasm/transition_history.go","commit_id":"e4dd35d8e015d10cbfbc5f7cf1cdf7ebf72be925","original_commit_id":"da6009564e796063faf853352077eecdc1473612","user":{"login":"dandavison","id":52205,"node_id":"MDQ6VXNlcjUyMjA1","avatar_url":"https://avatars.githubusercontent.com/u/52205?v=4","gravatar_id":"","url":"https://api.github.com/users/dandavison","html_url":"https://github.com/dandavison","followers_url":"https://api.github.com/users/dandavison/followers","following_url":"https://api.github.com/users/dandavison/following{/other_user}","gists_url":"https://api.github.com/users/dandavison/gists{/gist_id}","starred_url":"https://api.github.com/users/dandavison/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/dandavison/subscriptions","organizations_url":"https://api.github.com/users/dandavison/orgs","repos_url":"https://api.github.com/users/dandavison/repos","events_url":"https://api.github.com/users/dandavison/events{/privacy}","received_events_url":"https://api.github.com/users/dandavison/received_events","type":"User","user_view_type":"public","site_admin":false},"body":"Good call, I like it -- there's only one caller currently and it ignores that return value.","created_at":"2025-11-25T23:26:28Z","updated_at":"2025-11-27T03:19:05Z","html_url":"https://github.com/temporalio/temporal/pull/8563#discussion_r2561906607","pull_request_url":"https://api.github.com/repos/temporalio/temporal/pulls/8563","_links":{"self":{"href":"https://api.github.com/repos/temporalio/temporal/pulls/comments/2561906607"},"html":{"href":"https://github.com/temporalio/temporal/pull/8563#discussion_r2561906607"},"pull_request":{"href":"https://api.github.com/repos/temporalio/temporal/pulls/8563"}},"reactions":{"url":"https://api.github.com/repos/temporalio/temporal/pulls/comments/2561906607/reactions","total_count":0,"+1":0,"-1":0,"laugh":0,"hooray":0,"confused":0,"heart":0,"rocket":0,"eyes":0},"start_line":null,"original_start_line":null,"start_side":null,"line":null,"original_line":11,"side":"RIGHT","in_reply_to_id":2539941018,"author_association":"MEMBER","original_position":11,"position":1,"subject_type":"line"},{"url":"https://api.github.com/repos/temporalio/temporal/pulls/comments/2565695718","pull_request_review_id":3489746627,"id":2565695718,"node_id":"PRRC_kwDODNqesM6Y7Wjm","diff_hunk":"@@ -241,14 +285,182 @@ func (e *ChasmEngine) ReadComponent(\n \treturn readFn(chasmContext, component)\n }\n \n+// PollComponent waits until the supplied predicate is satisfied when evaluated against the\n+// component identified by the supplied component reference. If it times out due to the\n+// server-imposed long-poll timeout then it returns (nil, nil). Otherwise if there is no error, it\n+// returns (ref, nil) where ref is a component reference identifying the state at which the\n+// predicate was satisfied. It is an error if execution transition history is (after reloading from\n+// persistence) behind the requested ref, or if the ref is inconsistent with execution transition\n+// history. Thus when the predicate function is evaluated, it is guaranteed that the execution VT >=\n+// requestRef VT.\n func (e *ChasmEngine) PollComponent(\n \tctx context.Context,\n-\tentityRef chasm.ComponentRef,\n-\tpredicateFn func(chasm.Context, chasm.Component) (any, bool, error),\n-\toperationFn func(chasm.MutableContext, chasm.Component, any) error,\n-\topts ...chasm.TransitionOption,\n-) (newEntityRef []byte, retError error) {\n-\treturn nil, serviceerror.NewUnimplemented(\"PollComponent is not yet supported\")\n+\trequestRef chasm.ComponentRef,\n+\tpredicateFn func(chasm.Context, chasm.Component) (bool, error),\n+) ([]byte, error) {\n+\t// 1. Acquire lock\n+\t// 2. Error if shard execution VT < requestRef VT ('stale state')\n+\t// 3. If predicate satisfied, release lock and return\n+\t// 4. Subscribe to notifications for this execution\n+\t// 5. Release lock\n+\t// 6. On notification repeat (1) and (2)\n+\n+\tshardContext, executionLease, err := e.getExecutionLease(ctx, requestRef)\n+\tif err != nil {\n+\t\t// E.g. requestRef VT inconsistent with shard VT ('stale reference')\n+\t\treturn nil, err\n+\t}\n+\n+\t// hold lock until return or subscription established\n+\treleased := false\n+\tdefer func() {\n+\t\tif !released {\n+\t\t\t// read-only operation; don't pass error\n+\t\t\texecutionLease.GetReleaseFn()(nil)\n+\t\t}\n+\t}()\n+\n+\t// At this point it's possible that shard VT < requestRef VT (getExecutionLease does not\n+\t// guarantee that returned shard state is non-stale w.r.t. requestRef).\n+\tcurrentRef, err := e.checkPredicate(ctx, requestRef, executionLease, predicateFn)\n+\tif err != nil {\n+\t\treturn nil, err\n+\t}\n+\t// shard VT >= requestRef VT (enforced by checkPredicate)\n+\n+\tif currentRef != nil {\n+\t\t// wait condition was satisfied\n+\t\treturn currentRef, nil\n+\t}\n+\n+\t// Wait condition not satisfied; long-poll\n+\n+\t// TODO(dan) For now, UpdateComponent emits execution-level notifications, and PollComponent\n+\t// subscribes to execution-level notifications. This means that PollComponent may be woken up\n+\t// unnecessarily, but it will not miss notifications. In the future we may want to change\n+\t// PollComponent to subscribe to component-level notifications, and change UpdateComponent so\n+\t// that notifications are emitted only for nodes that were mutated in the transaction.\n+\tchannel, subscriberID, err := e.notifier.Subscribe(requestRef.EntityKey)\n+\tif err != nil {\n+\t\treturn nil, err\n+\t}\n+\tdefer func() {\n+\t\t_ = e.notifier.Unsubscribe(requestRef.EntityKey, subscriberID)\n+\t}()\n+\n+\t// Release the lock, now that we are subscribed\n+\texecutionLease.GetReleaseFn()(nil)\n+\treleased = true\n+\n+\tnamespaceRegistry, err := shardContext.GetNamespaceRegistry().GetNamespaceByID(\n+\t\tnamespace.ID(requestRef.EntityKey.NamespaceID),\n+\t)\n+\tif err != nil {\n+\t\treturn nil, err\n+\t}\n+\n+\t// Long-poll timeout semantics are the same as PollWorkflowExecutionUpdate: if the long-poll\n+\t// times out due to the server-imposed soft timeout, then return a non-error empty response\n+\t// indicating to a caller that they should continue long-polling. Unlike\n+\t// PollWorkflowExecutionUpdate we reserve 1s buffer.\n+\tsoftTimeout := shardContext.GetConfig().LongPollExpirationInterval(namespaceRegistry.Name().String())\n+\tstCtx, stCancel := contextutil.WithDeadlineBuffer(ctx, softTimeout, time.Second)\n+\tdefer stCancel()\n+\n+\tfor {\n+\t\tselect {\n+\t\tcase notification := <-channel:\n+\t\t\tif notification == nil {\n+\t\t\t\treturn nil, serviceerror.NewInternal(\"nil component notification\")\n+\t\t\t}\n+\t\t\t// Received a notification. Re-acquire the lock and check the predicate.\n+\t\t\t_, executionLease, err := e.getExecutionLease(stCtx, requestRef)\n+\t\t\tif err != nil {\n+\t\t\t\tif ctx.Err() != nil && errors.Is(err, ctx.Err()) {\n+\t\t\t\t\treturn nil, ctx.Err()\n+\t\t\t\t}\n+\t\t\t\tif errors.Is(err, stCtx.Err()) {\n+\t\t\t\t\t// Server-imposed timeout; caller should continue long-polling.\n+\t\t\t\t\treturn nil, nil\n+\t\t\t\t}\n+\t\t\t\treturn nil, err\n+\t\t\t}","path":"service/history/chasm_engine.go","commit_id":"1d59e66d0ce5d91819f92c428ef5ab4c4efca1fb","original_commit_id":"da6009564e796063faf853352077eecdc1473612","user":{"login":"dandavison","id":52205,"node_id":"MDQ6VXNlcjUyMjA1","avatar_url":"https://avatars.githubusercontent.com/u/52205?v=4","gravatar_id":"","url":"https://api.github.com/users/dandavison","html_url":"https://github.com/dandavison","followers_url":"https://api.github.com/users/dandavison/followers","following_url":"https://api.github.com/users/dandavison/following{/other_user}","gists_url":"https://api.github.com/users/dandavison/gists{/gist_id}","starred_url":"https://api.github.com/users/dandavison/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/dandavison/subscriptions","organizations_url":"https://api.github.com/users/dandavison/orgs","repos_url":"https://api.github.com/users/dandavison/repos","events_url":"https://api.github.com/users/dandavison/events{/privacy}","received_events_url":"https://api.github.com/users/dandavison/received_events","type":"User","user_view_type":"public","site_admin":false},"body":"Thanks, this code has been rewritten. `PollComponent` now simply returns errors. The handler is responsible for adding the 1s buffer and for distinguishing between caller deadline vs long-poll deadline expiry.","created_at":"2025-11-26T16:37:15Z","updated_at":"2025-11-27T03:19:05Z","html_url":"https://github.com/temporalio/temporal/pull/8563#discussion_r2565695718","pull_request_url":"https://api.github.com/repos/temporalio/temporal/pulls/8563","_links":{"self":{"href":"https://api.github.com/repos/temporalio/temporal/pulls/comments/2565695718"},"html":{"href":"https://github.com/temporalio/temporal/pull/8563#discussion_r2565695718"},"pull_request":{"href":"https://api.github.com/repos/temporalio/temporal/pulls/8563"}},"reactions":{"url":"https://api.github.com/repos/temporalio/temporal/pulls/comments/2565695718/reactions","total_count":0,"+1":0,"-1":0,"laugh":0,"hooray":0,"confused":0,"heart":0,"rocket":0,"eyes":0},"start_line":318,"original_start_line":378,"start_side":"RIGHT","line":320,"original_line":387,"side":"RIGHT","in_reply_to_id":2539998404,"author_association":"MEMBER","original_position":221,"position":132,"subject_type":"line"},{"url":"https://api.github.com/repos/temporalio/temporal/pulls/comments/2565696757","pull_request_review_id":3489746627,"id":2565696757,"node_id":"PRRC_kwDODNqesM6Y7Wz1","diff_hunk":"@@ -241,14 +285,182 @@ func (e *ChasmEngine) ReadComponent(\n \treturn readFn(chasmContext, component)\n }\n \n+// PollComponent waits until the supplied predicate is satisfied when evaluated against the\n+// component identified by the supplied component reference. If it times out due to the\n+// server-imposed long-poll timeout then it returns (nil, nil). Otherwise if there is no error, it\n+// returns (ref, nil) where ref is a component reference identifying the state at which the\n+// predicate was satisfied. It is an error if execution transition history is (after reloading from\n+// persistence) behind the requested ref, or if the ref is inconsistent with execution transition\n+// history. Thus when the predicate function is evaluated, it is guaranteed that the execution VT >=\n+// requestRef VT.\n func (e *ChasmEngine) PollComponent(\n \tctx context.Context,\n-\tentityRef chasm.ComponentRef,\n-\tpredicateFn func(chasm.Context, chasm.Component) (any, bool, error),\n-\toperationFn func(chasm.MutableContext, chasm.Component, any) error,\n-\topts ...chasm.TransitionOption,\n-) (newEntityRef []byte, retError error) {\n-\treturn nil, serviceerror.NewUnimplemented(\"PollComponent is not yet supported\")\n+\trequestRef chasm.ComponentRef,\n+\tpredicateFn func(chasm.Context, chasm.Component) (bool, error),\n+) ([]byte, error) {\n+\t// 1. Acquire lock\n+\t// 2. Error if shard execution VT < requestRef VT ('stale state')\n+\t// 3. If predicate satisfied, release lock and return\n+\t// 4. Subscribe to notifications for this execution\n+\t// 5. Release lock\n+\t// 6. On notification repeat (1) and (2)\n+\n+\tshardContext, executionLease, err := e.getExecutionLease(ctx, requestRef)\n+\tif err != nil {\n+\t\t// E.g. requestRef VT inconsistent with shard VT ('stale reference')\n+\t\treturn nil, err\n+\t}\n+\n+\t// hold lock until return or subscription established\n+\treleased := false\n+\tdefer func() {\n+\t\tif !released {\n+\t\t\t// read-only operation; don't pass error\n+\t\t\texecutionLease.GetReleaseFn()(nil)\n+\t\t}\n+\t}()\n+\n+\t// At this point it's possible that shard VT < requestRef VT (getExecutionLease does not\n+\t// guarantee that returned shard state is non-stale w.r.t. requestRef).\n+\tcurrentRef, err := e.checkPredicate(ctx, requestRef, executionLease, predicateFn)\n+\tif err != nil {\n+\t\treturn nil, err\n+\t}\n+\t// shard VT >= requestRef VT (enforced by checkPredicate)\n+\n+\tif currentRef != nil {\n+\t\t// wait condition was satisfied\n+\t\treturn currentRef, nil\n+\t}\n+\n+\t// Wait condition not satisfied; long-poll\n+\n+\t// TODO(dan) For now, UpdateComponent emits execution-level notifications, and PollComponent\n+\t// subscribes to execution-level notifications. This means that PollComponent may be woken up\n+\t// unnecessarily, but it will not miss notifications. In the future we may want to change\n+\t// PollComponent to subscribe to component-level notifications, and change UpdateComponent so\n+\t// that notifications are emitted only for nodes that were mutated in the transaction.\n+\tchannel, subscriberID, err := e.notifier.Subscribe(requestRef.EntityKey)\n+\tif err != nil {\n+\t\treturn nil, err\n+\t}\n+\tdefer func() {\n+\t\t_ = e.notifier.Unsubscribe(requestRef.EntityKey, subscriberID)\n+\t}()\n+\n+\t// Release the lock, now that we are subscribed\n+\texecutionLease.GetReleaseFn()(nil)\n+\treleased = true\n+\n+\tnamespaceRegistry, err := shardContext.GetNamespaceRegistry().GetNamespaceByID(\n+\t\tnamespace.ID(requestRef.EntityKey.NamespaceID),\n+\t)\n+\tif err != nil {\n+\t\treturn nil, err\n+\t}\n+\n+\t// Long-poll timeout semantics are the same as PollWorkflowExecutionUpdate: if the long-poll\n+\t// times out due to the server-imposed soft timeout, then return a non-error empty response\n+\t// indicating to a caller that they should continue long-polling. Unlike\n+\t// PollWorkflowExecutionUpdate we reserve 1s buffer.\n+\tsoftTimeout := shardContext.GetConfig().LongPollExpirationInterval(namespaceRegistry.Name().String())\n+\tstCtx, stCancel := contextutil.WithDeadlineBuffer(ctx, softTimeout, time.Second)\n+\tdefer stCancel()\n+\n+\tfor {\n+\t\tselect {\n+\t\tcase notification := <-channel:\n+\t\t\tif notification == nil {\n+\t\t\t\treturn nil, serviceerror.NewInternal(\"nil component notification\")\n+\t\t\t}\n+\t\t\t// Received a notification. Re-acquire the lock and check the predicate.\n+\t\t\t_, executionLease, err := e.getExecutionLease(stCtx, requestRef)\n+\t\t\tif err != nil {\n+\t\t\t\tif ctx.Err() != nil && errors.Is(err, ctx.Err()) {\n+\t\t\t\t\treturn nil, ctx.Err()\n+\t\t\t\t}\n+\t\t\t\tif errors.Is(err, stCtx.Err()) {\n+\t\t\t\t\t// Server-imposed timeout; caller should continue long-polling.\n+\t\t\t\t\treturn nil, nil\n+\t\t\t\t}\n+\t\t\t\treturn nil, err\n+\t\t\t}\n+\n+\t\t\tnewRef, err := e.checkPredicate(stCtx, requestRef, executionLease, predicateFn)\n+\t\t\texecutionLease.GetReleaseFn()(nil)","path":"service/history/chasm_engine.go","commit_id":"da6009564e796063faf853352077eecdc1473612","original_commit_id":"da6009564e796063faf853352077eecdc1473612","user":{"login":"dandavison","id":52205,"node_id":"MDQ6VXNlcjUyMjA1","avatar_url":"https://avatars.githubusercontent.com/u/52205?v=4","gravatar_id":"","url":"https://api.github.com/users/dandavison","html_url":"https://github.com/dandavison","followers_url":"https://api.github.com/users/dandavison/followers","following_url":"https://api.github.com/users/dandavison/following{/other_user}","gists_url":"https://api.github.com/users/dandavison/gists{/gist_id}","starred_url":"https://api.github.com/users/dandavison/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/dandavison/subscriptions","organizations_url":"https://api.github.com/users/dandavison/orgs","repos_url":"https://api.github.com/users/dandavison/repos","events_url":"https://api.github.com/users/dandavison/events{/privacy}","received_events_url":"https://api.github.com/users/dandavison/received_events","type":"User","user_view_type":"public","site_admin":false},"body":"Thanks, the rewritten implementation does that.","created_at":"2025-11-26T16:37:36Z","updated_at":"2025-11-27T03:19:05Z","html_url":"https://github.com/temporalio/temporal/pull/8563#discussion_r2565696757","pull_request_url":"https://api.github.com/repos/temporalio/temporal/pulls/8563","_links":{"self":{"href":"https://api.github.com/repos/temporalio/temporal/pulls/comments/2565696757"},"html":{"href":"https://github.com/temporalio/temporal/pull/8563#discussion_r2565696757"},"pull_request":{"href":"https://api.github.com/repos/temporalio/temporal/pulls/8563"}},"reactions":{"url":"https://api.github.com/repos/temporalio/temporal/pulls/comments/2565696757/reactions","total_count":0,"+1":0,"-1":0,"laugh":0,"hooray":0,"confused":0,"heart":0,"rocket":0,"eyes":0},"start_line":null,"original_start_line":null,"start_side":null,"line":null,"original_line":390,"side":"RIGHT","in_reply_to_id":2540009330,"author_association":"MEMBER","original_position":224,"position":1,"subject_type":"line"},{"url":"https://api.github.com/repos/temporalio/temporal/pulls/comments/2565697815","pull_request_review_id":3489746627,"id":2565697815,"node_id":"PRRC_kwDODNqesM6Y7XEX","diff_hunk":"@@ -241,14 +285,182 @@ func (e *ChasmEngine) ReadComponent(\n \treturn readFn(chasmContext, component)\n }\n \n+// PollComponent waits until the supplied predicate is satisfied when evaluated against the\n+// component identified by the supplied component reference. If it times out due to the\n+// server-imposed long-poll timeout then it returns (nil, nil). Otherwise if there is no error, it\n+// returns (ref, nil) where ref is a component reference identifying the state at which the\n+// predicate was satisfied. It is an error if execution transition history is (after reloading from\n+// persistence) behind the requested ref, or if the ref is inconsistent with execution transition\n+// history. Thus when the predicate function is evaluated, it is guaranteed that the execution VT >=\n+// requestRef VT.\n func (e *ChasmEngine) PollComponent(\n \tctx context.Context,\n-\tentityRef chasm.ComponentRef,\n-\tpredicateFn func(chasm.Context, chasm.Component) (any, bool, error),\n-\toperationFn func(chasm.MutableContext, chasm.Component, any) error,\n-\topts ...chasm.TransitionOption,\n-) (newEntityRef []byte, retError error) {\n-\treturn nil, serviceerror.NewUnimplemented(\"PollComponent is not yet supported\")\n+\trequestRef chasm.ComponentRef,\n+\tpredicateFn func(chasm.Context, chasm.Component) (bool, error),\n+) ([]byte, error) {\n+\t// 1. Acquire lock\n+\t// 2. Error if shard execution VT < requestRef VT ('stale state')\n+\t// 3. If predicate satisfied, release lock and return\n+\t// 4. Subscribe to notifications for this execution\n+\t// 5. Release lock\n+\t// 6. On notification repeat (1) and (2)\n+\n+\tshardContext, executionLease, err := e.getExecutionLease(ctx, requestRef)\n+\tif err != nil {\n+\t\t// E.g. requestRef VT inconsistent with shard VT ('stale reference')\n+\t\treturn nil, err\n+\t}\n+\n+\t// hold lock until return or subscription established\n+\treleased := false\n+\tdefer func() {\n+\t\tif !released {\n+\t\t\t// read-only operation; don't pass error\n+\t\t\texecutionLease.GetReleaseFn()(nil)\n+\t\t}\n+\t}()\n+\n+\t// At this point it's possible that shard VT < requestRef VT (getExecutionLease does not\n+\t// guarantee that returned shard state is non-stale w.r.t. requestRef).\n+\tcurrentRef, err := e.checkPredicate(ctx, requestRef, executionLease, predicateFn)\n+\tif err != nil {\n+\t\treturn nil, err\n+\t}\n+\t// shard VT >= requestRef VT (enforced by checkPredicate)\n+\n+\tif currentRef != nil {\n+\t\t// wait condition was satisfied\n+\t\treturn currentRef, nil\n+\t}\n+\n+\t// Wait condition not satisfied; long-poll\n+\n+\t// TODO(dan) For now, UpdateComponent emits execution-level notifications, and PollComponent\n+\t// subscribes to execution-level notifications. This means that PollComponent may be woken up\n+\t// unnecessarily, but it will not miss notifications. In the future we may want to change\n+\t// PollComponent to subscribe to component-level notifications, and change UpdateComponent so\n+\t// that notifications are emitted only for nodes that were mutated in the transaction.\n+\tchannel, subscriberID, err := e.notifier.Subscribe(requestRef.EntityKey)\n+\tif err != nil {\n+\t\treturn nil, err\n+\t}\n+\tdefer func() {\n+\t\t_ = e.notifier.Unsubscribe(requestRef.EntityKey, subscriberID)\n+\t}()\n+\n+\t// Release the lock, now that we are subscribed\n+\texecutionLease.GetReleaseFn()(nil)\n+\treleased = true\n+\n+\tnamespaceRegistry, err := shardContext.GetNamespaceRegistry().GetNamespaceByID(\n+\t\tnamespace.ID(requestRef.EntityKey.NamespaceID),\n+\t)\n+\tif err != nil {\n+\t\treturn nil, err\n+\t}\n+\n+\t// Long-poll timeout semantics are the same as PollWorkflowExecutionUpdate: if the long-poll\n+\t// times out due to the server-imposed soft timeout, then return a non-error empty response\n+\t// indicating to a caller that they should continue long-polling. Unlike\n+\t// PollWorkflowExecutionUpdate we reserve 1s buffer.\n+\tsoftTimeout := shardContext.GetConfig().LongPollExpirationInterval(namespaceRegistry.Name().String())\n+\tstCtx, stCancel := contextutil.WithDeadlineBuffer(ctx, softTimeout, time.Second)\n+\tdefer stCancel()\n+\n+\tfor {\n+\t\tselect {\n+\t\tcase notification := <-channel:\n+\t\t\tif notification == nil {\n+\t\t\t\treturn nil, serviceerror.NewInternal(\"nil component notification\")\n+\t\t\t}\n+\t\t\t// Received a notification. Re-acquire the lock and check the predicate.\n+\t\t\t_, executionLease, err := e.getExecutionLease(stCtx, requestRef)\n+\t\t\tif err != nil {\n+\t\t\t\tif ctx.Err() != nil && errors.Is(err, ctx.Err()) {\n+\t\t\t\t\treturn nil, ctx.Err()\n+\t\t\t\t}\n+\t\t\t\tif errors.Is(err, stCtx.Err()) {\n+\t\t\t\t\t// Server-imposed timeout; caller should continue long-polling.\n+\t\t\t\t\treturn nil, nil\n+\t\t\t\t}\n+\t\t\t\treturn nil, err\n+\t\t\t}\n+\n+\t\t\tnewRef, err := e.checkPredicate(stCtx, requestRef, executionLease, predicateFn)\n+\t\t\texecutionLease.GetReleaseFn()(nil)\n+\t\t\tif err != nil {\n+\t\t\t\tif ctx.Err() != nil && errors.Is(err, ctx.Err()) {\n+\t\t\t\t\treturn nil, ctx.Err()\n+\t\t\t\t}\n+\t\t\t\tif errors.Is(err, stCtx.Err()) {\n+\t\t\t\t\t// Server-imposed timeout; caller should continue long-polling.\n+\t\t\t\t\treturn nil, nil\n+\t\t\t\t}\n+\t\t\t\treturn nil, err\n+\t\t\t}\n+\t\t\tif newRef != nil {\n+\t\t\t\t// Wait condition was satisfied.\n+\t\t\t\treturn newRef, nil\n+\t\t\t}","path":"service/history/chasm_engine.go","commit_id":"da6009564e796063faf853352077eecdc1473612","original_commit_id":"da6009564e796063faf853352077eecdc1473612","user":{"login":"dandavison","id":52205,"node_id":"MDQ6VXNlcjUyMjA1","avatar_url":"https://avatars.githubusercontent.com/u/52205?v=4","gravatar_id":"","url":"https://api.github.com/users/dandavison","html_url":"https://github.com/dandavison","followers_url":"https://api.github.com/users/dandavison/followers","following_url":"https://api.github.com/users/dandavison/following{/other_user}","gists_url":"https://api.github.com/users/dandavison/gists{/gist_id}","starred_url":"https://api.github.com/users/dandavison/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/dandavison/subscriptions","organizations_url":"https://api.github.com/users/dandavison/orgs","repos_url":"https://api.github.com/users/dandavison/repos","events_url":"https://api.github.com/users/dandavison/events{/privacy}","received_events_url":"https://api.github.com/users/dandavison/received_events","type":"User","user_view_type":"public","site_admin":false},"body":" ","created_at":"2025-11-26T16:37:57Z","updated_at":"2025-11-27T03:19:05Z","html_url":"https://github.com/temporalio/temporal/pull/8563#discussion_r2565697815","pull_request_url":"https://api.github.com/repos/temporalio/temporal/pulls/8563","_links":{"self":{"href":"https://api.github.com/repos/temporalio/temporal/pulls/comments/2565697815"},"html":{"href":"https://github.com/temporalio/temporal/pull/8563#discussion_r2565697815"},"pull_request":{"href":"https://api.github.com/repos/temporalio/temporal/pulls/8563"}},"reactions":{"url":"https://api.github.com/repos/temporalio/temporal/pulls/comments/2565697815/reactions","total_count":0,"+1":0,"-1":0,"laugh":0,"hooray":0,"confused":0,"heart":0,"rocket":0,"eyes":0},"start_line":318,"original_start_line":391,"start_side":"RIGHT","line":323,"original_line":404,"side":"RIGHT","in_reply_to_id":2540011133,"author_association":"MEMBER","original_position":238,"position":1,"subject_type":"line"},{"url":"https://api.github.com/repos/temporalio/temporal/pulls/comments/2565702783","pull_request_review_id":3489746627,"id":2565702783,"node_id":"PRRC_kwDODNqesM6Y7YR_","diff_hunk":"@@ -0,0 +1,178 @@\n+// This file implements ChasmNotifier, which allows subscribers to subscribe to notifications\n+// relating to components in a specified CHASM execution. It is based on the events.Notifier\n+// implementation.\n+package history\n+\n+import (\n+\t\"sync/atomic\"\n+\t\"time\"\n+\n+\t\"github.com/dgryski/go-farm\"\n+\t\"github.com/google/uuid\"\n+\t\"go.temporal.io/api/serviceerror\"\n+\t\"go.temporal.io/server/chasm\"\n+\t\"go.temporal.io/server/common\"\n+\t\"go.temporal.io/server/common/clock\"\n+\t\"go.temporal.io/server/common/collection\"\n+\t\"go.temporal.io/server/common/metrics\"\n+\t\"go.temporal.io/server/service/history/configs\"\n+)\n+\n+type (\n+\t// ChasmNotifier allows subscribers to subscribe to notifications relating to components in a\n+\t// specified CHASM execution.\n+\tChasmNotifier struct {\n+\t\ttimeSource      clock.TimeSource\n+\t\tmetricsHandler  metrics.Handler\n+\t\tstatus          int32","path":"service/history/chasm_notifier.go","commit_id":"9f8d762f3279f3b16d2217ae254bb3f85df69b44","original_commit_id":"da6009564e796063faf853352077eecdc1473612","user":{"login":"dandavison","id":52205,"node_id":"MDQ6VXNlcjUyMjA1","avatar_url":"https://avatars.githubusercontent.com/u/52205?v=4","gravatar_id":"","url":"https://api.github.com/users/dandavison","html_url":"https://github.com/dandavison","followers_url":"https://api.github.com/users/dandavison/followers","following_url":"https://api.github.com/users/dandavison/following{/other_user}","gists_url":"https://api.github.com/users/dandavison/gists{/gist_id}","starred_url":"https://api.github.com/users/dandavison/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/dandavison/subscriptions","organizations_url":"https://api.github.com/users/dandavison/orgs","repos_url":"https://api.github.com/users/dandavison/repos","events_url":"https://api.github.com/users/dandavison/events{/privacy}","received_events_url":"https://api.github.com/users/dandavison/received_events","type":"User","user_view_type":"public","site_admin":false},"body":"Thanks, I've now changed the PR to have a CHASM-specific notifier with a much simpler implementation than the workflow one. There is no longer a `status` field.","created_at":"2025-11-26T16:39:28Z","updated_at":"2025-11-27T03:19:06Z","html_url":"https://github.com/temporalio/temporal/pull/8563#discussion_r2565702783","pull_request_url":"https://api.github.com/repos/temporalio/temporal/pulls/8563","_links":{"self":{"href":"https://api.github.com/repos/temporalio/temporal/pulls/comments/2565702783"},"html":{"href":"https://github.com/temporalio/temporal/pull/8563#discussion_r2565702783"},"pull_request":{"href":"https://api.github.com/repos/temporalio/temporal/pulls/8563"}},"reactions":{"url":"https://api.github.com/repos/temporalio/temporal/pulls/comments/2565702783/reactions","total_count":0,"+1":0,"-1":0,"laugh":0,"hooray":0,"confused":0,"heart":0,"rocket":0,"eyes":0},"start_line":null,"original_start_line":null,"start_side":null,"line":null,"original_line":27,"side":"RIGHT","in_reply_to_id":2540016674,"author_association":"MEMBER","original_position":27,"position":1,"subject_type":"line"},{"url":"https://api.github.com/repos/temporalio/temporal/pulls/comments/2565712912","pull_request_review_id":3489746627,"id":2565712912,"node_id":"PRRC_kwDODNqesM6Y7awQ","diff_hunk":"@@ -0,0 +1,178 @@\n+// This file implements ChasmNotifier, which allows subscribers to subscribe to notifications\n+// relating to components in a specified CHASM execution. It is based on the events.Notifier\n+// implementation.\n+package history\n+\n+import (\n+\t\"sync/atomic\"\n+\t\"time\"\n+\n+\t\"github.com/dgryski/go-farm\"\n+\t\"github.com/google/uuid\"\n+\t\"go.temporal.io/api/serviceerror\"\n+\t\"go.temporal.io/server/chasm\"\n+\t\"go.temporal.io/server/common\"\n+\t\"go.temporal.io/server/common/clock\"\n+\t\"go.temporal.io/server/common/collection\"\n+\t\"go.temporal.io/server/common/metrics\"\n+\t\"go.temporal.io/server/service/history/configs\"\n+)\n+\n+type (\n+\t// ChasmNotifier allows subscribers to subscribe to notifications relating to components in a\n+\t// specified CHASM execution.\n+\tChasmNotifier struct {\n+\t\ttimeSource      clock.TimeSource\n+\t\tmetricsHandler  metrics.Handler\n+\t\tstatus          int32\n+\t\tnotificationsCh chan *ChasmComponentNotification\n+\t\tstopCh          chan bool\n+\t\tsubscribers     collection.ConcurrentTxMap\n+\t}\n+\n+\t// ChasmComponentNotification is a notification relating to a CHASM component.\n+\tChasmComponentNotification struct {\n+\t\t// TODO(dan): confirm that we want Key in addition to the key in serialized ref\n+\t\tKey       chasm.EntityKey\n+\t\tRef       []byte\n+\t\ttimestamp time.Time\n+\t}\n+)\n+\n+// NewChasmNotifier creates a new instance of ChasmNotifier allowing subscribers to subscribe to\n+// notifications relating to components in a specified CHASM execution.\n+func NewChasmNotifier(\n+\ttimeSource clock.TimeSource,\n+\tmetricsHandler metrics.Handler,\n+\tconfig *configs.Config,\n+) *ChasmNotifier {\n+\treturn &ChasmNotifier{\n+\t\ttimeSource:      timeSource,\n+\t\tmetricsHandler:  metricsHandler.WithTags(metrics.OperationTag(metrics.ChasmComponentNotificationScope)),\n+\t\tstatus:          common.DaemonStatusInitialized,\n+\t\tstopCh:          make(chan bool),","path":"service/history/chasm_notifier.go","commit_id":"9f8d762f3279f3b16d2217ae254bb3f85df69b44","original_commit_id":"da6009564e796063faf853352077eecdc1473612","user":{"login":"dandavison","id":52205,"node_id":"MDQ6VXNlcjUyMjA1","avatar_url":"https://avatars.githubusercontent.com/u/52205?v=4","gravatar_id":"","url":"https://api.github.com/users/dandavison","html_url":"https://github.com/dandavison","followers_url":"https://api.github.com/users/dandavison/followers","following_url":"https://api.github.com/users/dandavison/following{/other_user}","gists_url":"https://api.github.com/users/dandavison/gists{/gist_id}","starred_url":"https://api.github.com/users/dandavison/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/dandavison/subscriptions","organizations_url":"https://api.github.com/users/dandavison/orgs","repos_url":"https://api.github.com/users/dandavison/repos","events_url":"https://api.github.com/users/dandavison/events{/privacy}","received_events_url":"https://api.github.com/users/dandavison/received_events","type":"User","user_view_type":"public","site_admin":false},"body":"Thanks, `stopCh` doesn't exist any longer","created_at":"2025-11-26T16:42:45Z","updated_at":"2025-11-27T03:19:06Z","html_url":"https://github.com/temporalio/temporal/pull/8563#discussion_r2565712912","pull_request_url":"https://api.github.com/repos/temporalio/temporal/pulls/8563","_links":{"self":{"href":"https://api.github.com/repos/temporalio/temporal/pulls/comments/2565712912"},"html":{"href":"https://github.com/temporalio/temporal/pull/8563#discussion_r2565712912"},"pull_request":{"href":"https://api.github.com/repos/temporalio/temporal/pulls/8563"}},"reactions":{"url":"https://api.github.com/repos/temporalio/temporal/pulls/comments/2565712912/reactions","total_count":0,"+1":0,"-1":0,"laugh":0,"hooray":0,"confused":0,"heart":0,"rocket":0,"eyes":0},"start_line":null,"original_start_line":null,"start_side":null,"line":null,"original_line":53,"side":"RIGHT","in_reply_to_id":2540019207,"author_association":"MEMBER","original_position":53,"position":1,"subject_type":"line"},{"url":"https://api.github.com/repos/temporalio/temporal/pulls/comments/2565716645","pull_request_review_id":3489746627,"id":2565716645,"node_id":"PRRC_kwDODNqesM6Y7bql","diff_hunk":"@@ -0,0 +1,178 @@\n+// This file implements ChasmNotifier, which allows subscribers to subscribe to notifications\n+// relating to components in a specified CHASM execution. It is based on the events.Notifier\n+// implementation.\n+package history\n+\n+import (\n+\t\"sync/atomic\"\n+\t\"time\"\n+\n+\t\"github.com/dgryski/go-farm\"\n+\t\"github.com/google/uuid\"\n+\t\"go.temporal.io/api/serviceerror\"\n+\t\"go.temporal.io/server/chasm\"\n+\t\"go.temporal.io/server/common\"\n+\t\"go.temporal.io/server/common/clock\"\n+\t\"go.temporal.io/server/common/collection\"\n+\t\"go.temporal.io/server/common/metrics\"\n+\t\"go.temporal.io/server/service/history/configs\"\n+)\n+\n+type (\n+\t// ChasmNotifier allows subscribers to subscribe to notifications relating to components in a\n+\t// specified CHASM execution.\n+\tChasmNotifier struct {\n+\t\ttimeSource      clock.TimeSource\n+\t\tmetricsHandler  metrics.Handler\n+\t\tstatus          int32\n+\t\tnotificationsCh chan *ChasmComponentNotification\n+\t\tstopCh          chan bool\n+\t\tsubscribers     collection.ConcurrentTxMap\n+\t}\n+\n+\t// ChasmComponentNotification is a notification relating to a CHASM component.\n+\tChasmComponentNotification struct {\n+\t\t// TODO(dan): confirm that we want Key in addition to the key in serialized ref\n+\t\tKey       chasm.EntityKey\n+\t\tRef       []byte\n+\t\ttimestamp time.Time\n+\t}\n+)\n+\n+// NewChasmNotifier creates a new instance of ChasmNotifier allowing subscribers to subscribe to\n+// notifications relating to components in a specified CHASM execution.\n+func NewChasmNotifier(\n+\ttimeSource clock.TimeSource,\n+\tmetricsHandler metrics.Handler,\n+\tconfig *configs.Config,\n+) *ChasmNotifier {\n+\treturn &ChasmNotifier{\n+\t\ttimeSource:      timeSource,\n+\t\tmetricsHandler:  metricsHandler.WithTags(metrics.OperationTag(metrics.ChasmComponentNotificationScope)),\n+\t\tstatus:          common.DaemonStatusInitialized,\n+\t\tstopCh:          make(chan bool),\n+\t\tnotificationsCh: make(chan *ChasmComponentNotification, 1000),","path":"service/history/chasm_notifier.go","commit_id":"da6009564e796063faf853352077eecdc1473612","original_commit_id":"da6009564e796063faf853352077eecdc1473612","user":{"login":"dandavison","id":52205,"node_id":"MDQ6VXNlcjUyMjA1","avatar_url":"https://avatars.githubusercontent.com/u/52205?v=4","gravatar_id":"","url":"https://api.github.com/users/dandavison","html_url":"https://github.com/dandavison","followers_url":"https://api.github.com/users/dandavison/followers","following_url":"https://api.github.com/users/dandavison/following{/other_user}","gists_url":"https://api.github.com/users/dandavison/gists{/gist_id}","starred_url":"https://api.github.com/users/dandavison/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/dandavison/subscriptions","organizations_url":"https://api.github.com/users/dandavison/orgs","repos_url":"https://api.github.com/users/dandavison/repos","events_url":"https://api.github.com/users/dandavison/events{/privacy}","received_events_url":"https://api.github.com/users/dandavison/received_events","type":"User","user_view_type":"public","site_admin":false},"body":"This was a copy of the workflow implementation. But I've changed the PR now so that CHASM has a notifier with a different implementation.","created_at":"2025-11-26T16:43:43Z","updated_at":"2025-11-27T03:19:06Z","html_url":"https://github.com/temporalio/temporal/pull/8563#discussion_r2565716645","pull_request_url":"https://api.github.com/repos/temporalio/temporal/pulls/8563","_links":{"self":{"href":"https://api.github.com/repos/temporalio/temporal/pulls/comments/2565716645"},"html":{"href":"https://github.com/temporalio/temporal/pull/8563#discussion_r2565716645"},"pull_request":{"href":"https://api.github.com/repos/temporalio/temporal/pulls/8563"}},"reactions":{"url":"https://api.github.com/repos/temporalio/temporal/pulls/comments/2565716645/reactions","total_count":0,"+1":0,"-1":0,"laugh":0,"hooray":0,"confused":0,"heart":0,"rocket":0,"eyes":0},"start_line":null,"original_start_line":null,"start_side":null,"line":null,"original_line":54,"side":"RIGHT","in_reply_to_id":2540019430,"author_association":"MEMBER","original_position":54,"position":1,"subject_type":"line"},{"url":"https://api.github.com/repos/temporalio/temporal/pulls/comments/2565717715","pull_request_review_id":3489746627,"id":2565717715,"node_id":"PRRC_kwDODNqesM6Y7b7T","diff_hunk":"@@ -0,0 +1,178 @@\n+// This file implements ChasmNotifier, which allows subscribers to subscribe to notifications\n+// relating to components in a specified CHASM execution. It is based on the events.Notifier\n+// implementation.\n+package history\n+\n+import (\n+\t\"sync/atomic\"\n+\t\"time\"\n+\n+\t\"github.com/dgryski/go-farm\"\n+\t\"github.com/google/uuid\"\n+\t\"go.temporal.io/api/serviceerror\"\n+\t\"go.temporal.io/server/chasm\"\n+\t\"go.temporal.io/server/common\"\n+\t\"go.temporal.io/server/common/clock\"\n+\t\"go.temporal.io/server/common/collection\"\n+\t\"go.temporal.io/server/common/metrics\"\n+\t\"go.temporal.io/server/service/history/configs\"\n+)\n+\n+type (\n+\t// ChasmNotifier allows subscribers to subscribe to notifications relating to components in a\n+\t// specified CHASM execution.\n+\tChasmNotifier struct {\n+\t\ttimeSource      clock.TimeSource\n+\t\tmetricsHandler  metrics.Handler\n+\t\tstatus          int32\n+\t\tnotificationsCh chan *ChasmComponentNotification\n+\t\tstopCh          chan bool\n+\t\tsubscribers     collection.ConcurrentTxMap\n+\t}\n+\n+\t// ChasmComponentNotification is a notification relating to a CHASM component.\n+\tChasmComponentNotification struct {\n+\t\t// TODO(dan): confirm that we want Key in addition to the key in serialized ref\n+\t\tKey       chasm.EntityKey\n+\t\tRef       []byte\n+\t\ttimestamp time.Time\n+\t}\n+)\n+\n+// NewChasmNotifier creates a new instance of ChasmNotifier allowing subscribers to subscribe to\n+// notifications relating to components in a specified CHASM execution.\n+func NewChasmNotifier(\n+\ttimeSource clock.TimeSource,\n+\tmetricsHandler metrics.Handler,\n+\tconfig *configs.Config,\n+) *ChasmNotifier {\n+\treturn &ChasmNotifier{\n+\t\ttimeSource:      timeSource,\n+\t\tmetricsHandler:  metricsHandler.WithTags(metrics.OperationTag(metrics.ChasmComponentNotificationScope)),\n+\t\tstatus:          common.DaemonStatusInitialized,\n+\t\tstopCh:          make(chan bool),\n+\t\tnotificationsCh: make(chan *ChasmComponentNotification, 1000),\n+\t\tsubscribers: collection.NewShardedConcurrentTxMap(1024, func(key any) uint32 {\n+\t\t\texecutionKey, ok := key.(chasm.EntityKey)\n+\t\t\tif !ok {\n+\t\t\t\treturn 0\n+\t\t\t}\n+\t\t\treturn farm.Fingerprint32([]byte(executionKey.NamespaceID + \"_\" + executionKey.BusinessID))","path":"service/history/chasm_notifier.go","commit_id":"9f8d762f3279f3b16d2217ae254bb3f85df69b44","original_commit_id":"da6009564e796063faf853352077eecdc1473612","user":{"login":"dandavison","id":52205,"node_id":"MDQ6VXNlcjUyMjA1","avatar_url":"https://avatars.githubusercontent.com/u/52205?v=4","gravatar_id":"","url":"https://api.github.com/users/dandavison","html_url":"https://github.com/dandavison","followers_url":"https://api.github.com/users/dandavison/followers","following_url":"https://api.github.com/users/dandavison/following{/other_user}","gists_url":"https://api.github.com/users/dandavison/gists{/gist_id}","starred_url":"https://api.github.com/users/dandavison/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/dandavison/subscriptions","organizations_url":"https://api.github.com/users/dandavison/orgs","repos_url":"https://api.github.com/users/dandavison/repos","events_url":"https://api.github.com/users/dandavison/events{/privacy}","received_events_url":"https://api.github.com/users/dandavison/received_events","type":"User","user_view_type":"public","site_admin":false},"body":"Thanks, this was copied from the workflow MS notifier impl.","created_at":"2025-11-26T16:44:04Z","updated_at":"2025-11-27T03:19:06Z","html_url":"https://github.com/temporalio/temporal/pull/8563#discussion_r2565717715","pull_request_url":"https://api.github.com/repos/temporalio/temporal/pulls/8563","_links":{"self":{"href":"https://api.github.com/repos/temporalio/temporal/pulls/comments/2565717715"},"html":{"href":"https://github.com/temporalio/temporal/pull/8563#discussion_r2565717715"},"pull_request":{"href":"https://api.github.com/repos/temporalio/temporal/pulls/8563"}},"reactions":{"url":"https://api.github.com/repos/temporalio/temporal/pulls/comments/2565717715/reactions","total_count":0,"+1":0,"-1":0,"laugh":0,"hooray":0,"confused":0,"heart":0,"rocket":0,"eyes":0},"start_line":null,"original_start_line":null,"start_side":null,"line":null,"original_line":60,"side":"RIGHT","in_reply_to_id":2540025103,"author_association":"MEMBER","original_position":60,"position":1,"subject_type":"line"},{"url":"https://api.github.com/repos/temporalio/temporal/pulls/comments/2565719107","pull_request_review_id":3489746627,"id":2565719107,"node_id":"PRRC_kwDODNqesM6Y7cRD","diff_hunk":"@@ -0,0 +1,178 @@\n+// This file implements ChasmNotifier, which allows subscribers to subscribe to notifications\n+// relating to components in a specified CHASM execution. It is based on the events.Notifier\n+// implementation.\n+package history\n+\n+import (\n+\t\"sync/atomic\"\n+\t\"time\"\n+\n+\t\"github.com/dgryski/go-farm\"\n+\t\"github.com/google/uuid\"\n+\t\"go.temporal.io/api/serviceerror\"\n+\t\"go.temporal.io/server/chasm\"\n+\t\"go.temporal.io/server/common\"\n+\t\"go.temporal.io/server/common/clock\"\n+\t\"go.temporal.io/server/common/collection\"\n+\t\"go.temporal.io/server/common/metrics\"\n+\t\"go.temporal.io/server/service/history/configs\"\n+)\n+\n+type (\n+\t// ChasmNotifier allows subscribers to subscribe to notifications relating to components in a\n+\t// specified CHASM execution.\n+\tChasmNotifier struct {\n+\t\ttimeSource      clock.TimeSource\n+\t\tmetricsHandler  metrics.Handler\n+\t\tstatus          int32\n+\t\tnotificationsCh chan *ChasmComponentNotification\n+\t\tstopCh          chan bool\n+\t\tsubscribers     collection.ConcurrentTxMap\n+\t}\n+\n+\t// ChasmComponentNotification is a notification relating to a CHASM component.\n+\tChasmComponentNotification struct {\n+\t\t// TODO(dan): confirm that we want Key in addition to the key in serialized ref\n+\t\tKey       chasm.EntityKey\n+\t\tRef       []byte\n+\t\ttimestamp time.Time\n+\t}\n+)\n+\n+// NewChasmNotifier creates a new instance of ChasmNotifier allowing subscribers to subscribe to\n+// notifications relating to components in a specified CHASM execution.\n+func NewChasmNotifier(\n+\ttimeSource clock.TimeSource,\n+\tmetricsHandler metrics.Handler,\n+\tconfig *configs.Config,\n+) *ChasmNotifier {\n+\treturn &ChasmNotifier{\n+\t\ttimeSource:      timeSource,\n+\t\tmetricsHandler:  metricsHandler.WithTags(metrics.OperationTag(metrics.ChasmComponentNotificationScope)),\n+\t\tstatus:          common.DaemonStatusInitialized,\n+\t\tstopCh:          make(chan bool),\n+\t\tnotificationsCh: make(chan *ChasmComponentNotification, 1000),\n+\t\tsubscribers: collection.NewShardedConcurrentTxMap(1024, func(key any) uint32 {\n+\t\t\texecutionKey, ok := key.(chasm.EntityKey)\n+\t\t\tif !ok {\n+\t\t\t\treturn 0\n+\t\t\t}\n+\t\t\treturn farm.Fingerprint32([]byte(executionKey.NamespaceID + \"_\" + executionKey.BusinessID))\n+\t\t}),\n+\t}\n+}\n+\n+// Start starts the ChasmNotifier.\n+func (n *ChasmNotifier) Start() {\n+\tif !atomic.CompareAndSwapInt32(&n.status, common.DaemonStatusInitialized, common.DaemonStatusStarted) {\n+\t\treturn\n+\t}\n+\tgo n.dequeueLoop()\n+}\n+\n+// Stop stops the ChasmNotifier.\n+func (n *ChasmNotifier) Stop() {\n+\tif !atomic.CompareAndSwapInt32(&n.status, common.DaemonStatusStarted, common.DaemonStatusStopped) {\n+\t\treturn\n+\t}\n+\tclose(n.stopCh)\n+}\n+\n+// Notify sends a notification about a CHASM component.\n+func (n *ChasmNotifier) Notify(notification *ChasmComponentNotification) {\n+\tn.enqueue(notification)\n+}\n+\n+// Subscribe returns a channel that will receive notifications relating to the execution, along with\n+// a subscriber ID that can be passed to UnsubscribeNotification.\n+//\n+// TODO(dan): support subscribing to notifications for a specific component only?\n+func (n *ChasmNotifier) Subscribe(key chasm.EntityKey) (chan *ChasmComponentNotification, string, error) {\n+\tchannel := make(chan *ChasmComponentNotification, 1)\n+\tsubscriberID := uuid.NewString()","path":"service/history/chasm_notifier.go","commit_id":"9f8d762f3279f3b16d2217ae254bb3f85df69b44","original_commit_id":"da6009564e796063faf853352077eecdc1473612","user":{"login":"dandavison","id":52205,"node_id":"MDQ6VXNlcjUyMjA1","avatar_url":"https://avatars.githubusercontent.com/u/52205?v=4","gravatar_id":"","url":"https://api.github.com/users/dandavison","html_url":"https://github.com/dandavison","followers_url":"https://api.github.com/users/dandavison/followers","following_url":"https://api.github.com/users/dandavison/following{/other_user}","gists_url":"https://api.github.com/users/dandavison/gists{/gist_id}","starred_url":"https://api.github.com/users/dandavison/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/dandavison/subscriptions","organizations_url":"https://api.github.com/users/dandavison/orgs","repos_url":"https://api.github.com/users/dandavison/repos","events_url":"https://api.github.com/users/dandavison/events{/privacy}","received_events_url":"https://api.github.com/users/dandavison/received_events","type":"User","user_view_type":"public","site_admin":false},"body":"Thanks, there are no subscriberIDs any longer.","created_at":"2025-11-26T16:44:28Z","updated_at":"2025-11-27T03:19:06Z","html_url":"https://github.com/temporalio/temporal/pull/8563#discussion_r2565719107","pull_request_url":"https://api.github.com/repos/temporalio/temporal/pulls/8563","_links":{"self":{"href":"https://api.github.com/repos/temporalio/temporal/pulls/comments/2565719107"},"html":{"href":"https://github.com/temporalio/temporal/pull/8563#discussion_r2565719107"},"pull_request":{"href":"https://api.github.com/repos/temporalio/temporal/pulls/8563"}},"reactions":{"url":"https://api.github.com/repos/temporalio/temporal/pulls/comments/2565719107/reactions","total_count":0,"+1":0,"-1":0,"laugh":0,"hooray":0,"confused":0,"heart":0,"rocket":0,"eyes":0},"start_line":null,"original_start_line":null,"start_side":null,"line":null,"original_line":92,"side":"RIGHT","in_reply_to_id":2540027863,"author_association":"MEMBER","original_position":92,"position":1,"subject_type":"line"},{"url":"https://api.github.com/repos/temporalio/temporal/pulls/comments/2565721498","pull_request_review_id":3489746627,"id":2565721498,"node_id":"PRRC_kwDODNqesM6Y7c2a","diff_hunk":"@@ -0,0 +1,178 @@\n+// This file implements ChasmNotifier, which allows subscribers to subscribe to notifications\n+// relating to components in a specified CHASM execution. It is based on the events.Notifier\n+// implementation.\n+package history\n+\n+import (\n+\t\"sync/atomic\"\n+\t\"time\"\n+\n+\t\"github.com/dgryski/go-farm\"\n+\t\"github.com/google/uuid\"\n+\t\"go.temporal.io/api/serviceerror\"\n+\t\"go.temporal.io/server/chasm\"\n+\t\"go.temporal.io/server/common\"\n+\t\"go.temporal.io/server/common/clock\"\n+\t\"go.temporal.io/server/common/collection\"\n+\t\"go.temporal.io/server/common/metrics\"\n+\t\"go.temporal.io/server/service/history/configs\"\n+)\n+\n+type (\n+\t// ChasmNotifier allows subscribers to subscribe to notifications relating to components in a\n+\t// specified CHASM execution.\n+\tChasmNotifier struct {\n+\t\ttimeSource      clock.TimeSource\n+\t\tmetricsHandler  metrics.Handler\n+\t\tstatus          int32\n+\t\tnotificationsCh chan *ChasmComponentNotification\n+\t\tstopCh          chan bool\n+\t\tsubscribers     collection.ConcurrentTxMap\n+\t}\n+\n+\t// ChasmComponentNotification is a notification relating to a CHASM component.\n+\tChasmComponentNotification struct {\n+\t\t// TODO(dan): confirm that we want Key in addition to the key in serialized ref\n+\t\tKey       chasm.EntityKey\n+\t\tRef       []byte\n+\t\ttimestamp time.Time\n+\t}\n+)\n+\n+// NewChasmNotifier creates a new instance of ChasmNotifier allowing subscribers to subscribe to\n+// notifications relating to components in a specified CHASM execution.\n+func NewChasmNotifier(\n+\ttimeSource clock.TimeSource,\n+\tmetricsHandler metrics.Handler,\n+\tconfig *configs.Config,\n+) *ChasmNotifier {\n+\treturn &ChasmNotifier{\n+\t\ttimeSource:      timeSource,\n+\t\tmetricsHandler:  metricsHandler.WithTags(metrics.OperationTag(metrics.ChasmComponentNotificationScope)),\n+\t\tstatus:          common.DaemonStatusInitialized,\n+\t\tstopCh:          make(chan bool),\n+\t\tnotificationsCh: make(chan *ChasmComponentNotification, 1000),\n+\t\tsubscribers: collection.NewShardedConcurrentTxMap(1024, func(key any) uint32 {\n+\t\t\texecutionKey, ok := key.(chasm.EntityKey)\n+\t\t\tif !ok {\n+\t\t\t\treturn 0\n+\t\t\t}\n+\t\t\treturn farm.Fingerprint32([]byte(executionKey.NamespaceID + \"_\" + executionKey.BusinessID))\n+\t\t}),\n+\t}\n+}\n+\n+// Start starts the ChasmNotifier.\n+func (n *ChasmNotifier) Start() {\n+\tif !atomic.CompareAndSwapInt32(&n.status, common.DaemonStatusInitialized, common.DaemonStatusStarted) {\n+\t\treturn\n+\t}\n+\tgo n.dequeueLoop()\n+}\n+\n+// Stop stops the ChasmNotifier.\n+func (n *ChasmNotifier) Stop() {\n+\tif !atomic.CompareAndSwapInt32(&n.status, common.DaemonStatusStarted, common.DaemonStatusStopped) {\n+\t\treturn\n+\t}\n+\tclose(n.stopCh)\n+}\n+\n+// Notify sends a notification about a CHASM component.\n+func (n *ChasmNotifier) Notify(notification *ChasmComponentNotification) {\n+\tn.enqueue(notification)\n+}\n+\n+// Subscribe returns a channel that will receive notifications relating to the execution, along with\n+// a subscriber ID that can be passed to UnsubscribeNotification.\n+//\n+// TODO(dan): support subscribing to notifications for a specific component only?\n+func (n *ChasmNotifier) Subscribe(key chasm.EntityKey) (chan *ChasmComponentNotification, string, error) {\n+\tchannel := make(chan *ChasmComponentNotification, 1)\n+\tsubscriberID := uuid.NewString()\n+\n+\t// TODO(dan): This allocates a value that will not be used if key already has subscribers (code\n+\t// copied from events.Notifier)\n+\tsubscribers := map[string]chan *ChasmComponentNotification{\n+\t\tsubscriberID: channel,\n+\t}\n+\n+\t// If key exists then add new subscriber to that second-level map. Otherwise, add a new\n+\t// second-level map containing the new subscriber.\n+\t_, _, err := n.subscribers.PutOrDo(key, subscribers, func(key any, value any) error {\n+\t\tsubscribers := value.(map[string]chan *ChasmComponentNotification)\n+\t\tif _, ok := subscribers[subscriberID]; ok {\n+\t\t\t// uuid collision\n+\t\t\treturn serviceerror.NewUnavailable(\"Unable to watch component.\")\n+\t\t}\n+\t\tsubscribers[subscriberID] = channel\n+\t\treturn nil\n+\t})\n+\tif err != nil {\n+\t\treturn nil, \"\", err\n+\t}\n+\treturn channel, subscriberID, nil\n+}\n+\n+// Unsubscribe unsubscribes the subscriber from notifications relating to the execution.\n+func (n *ChasmNotifier) Unsubscribe(key chasm.EntityKey, subscriberID string) error {\n+\tsuccess := true\n+\tn.subscribers.RemoveIf(key, func(key any, value any) bool {\n+\t\tsubscribers := value.(map[string]chan *ChasmComponentNotification)\n+\t\tif _, ok := subscribers[subscriberID]; !ok {\n+\t\t\tsuccess = false\n+\t\t} else {\n+\t\t\tdelete(subscribers, subscriberID)\n+\t\t}\n+\t\treturn len(subscribers) == 0\n+\t})\n+\tif !success {\n+\t\t// This indicates a bug\n+\t\treturn serviceerror.NewInternal(\"Unable to unwatch component.\")\n+\t}\n+\treturn nil\n+}\n+\n+func (n *ChasmNotifier) enqueue(notification *ChasmComponentNotification) {","path":"service/history/chasm_notifier.go","commit_id":"da6009564e796063faf853352077eecdc1473612","original_commit_id":"da6009564e796063faf853352077eecdc1473612","user":{"login":"dandavison","id":52205,"node_id":"MDQ6VXNlcjUyMjA1","avatar_url":"https://avatars.githubusercontent.com/u/52205?v=4","gravatar_id":"","url":"https://api.github.com/users/dandavison","html_url":"https://github.com/dandavison","followers_url":"https://api.github.com/users/dandavison/followers","following_url":"https://api.github.com/users/dandavison/following{/other_user}","gists_url":"https://api.github.com/users/dandavison/gists{/gist_id}","starred_url":"https://api.github.com/users/dandavison/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/dandavison/subscriptions","organizations_url":"https://api.github.com/users/dandavison/orgs","repos_url":"https://api.github.com/users/dandavison/repos","events_url":"https://api.github.com/users/dandavison/events{/privacy}","received_events_url":"https://api.github.com/users/dandavison/received_events","type":"User","user_view_type":"public","site_admin":false},"body":"Thanks, agreed -- I think I noted that the workflow impl was problematic in a comment. This has all gone now.","created_at":"2025-11-26T16:45:14Z","updated_at":"2025-11-27T03:19:06Z","html_url":"https://github.com/temporalio/temporal/pull/8563#discussion_r2565721498","pull_request_url":"https://api.github.com/repos/temporalio/temporal/pulls/8563","_links":{"self":{"href":"https://api.github.com/repos/temporalio/temporal/pulls/comments/2565721498"},"html":{"href":"https://github.com/temporalio/temporal/pull/8563#discussion_r2565721498"},"pull_request":{"href":"https://api.github.com/repos/temporalio/temporal/pulls/8563"}},"reactions":{"url":"https://api.github.com/repos/temporalio/temporal/pulls/comments/2565721498/reactions","total_count":0,"+1":0,"-1":0,"laugh":0,"hooray":0,"confused":0,"heart":0,"rocket":0,"eyes":0},"start_line":null,"original_start_line":null,"start_side":null,"line":null,"original_line":136,"side":"RIGHT","in_reply_to_id":2540038631,"author_association":"MEMBER","original_position":136,"position":1,"subject_type":"line"},{"url":"https://api.github.com/repos/temporalio/temporal/pulls/comments/2565818616","pull_request_review_id":3489746627,"id":2565818616,"node_id":"PRRC_kwDODNqesM6Y70j4","diff_hunk":"@@ -105,3 +117,377 @@ func createDefaultInput() *commonpb.Payloads {\n \t\t},\n \t}\n }\n+\n+func (s *standaloneActivityTestSuite) Test_PollActivityExecution_NoWait() {\n+\t// Long poll for any state change. PollActivityTaskQueue is used to cause a state change.\n+\tt := s.T()\n+\tctx, cancel := context.WithTimeout(t.Context(), 10*time.Second)\n+\tdefer cancel()\n+\tactivityID := testcore.RandomizeStr(t.Name())\n+\ttaskQueue := uuid.New().String()\n+\n+\tstartResp, err := s.startActivity(ctx, activityID, taskQueue)\n+\trequire.NoError(t, err)\n+\n+\tpollResp, err := s.FrontendClient().PollActivityExecution(ctx, &workflowservice.PollActivityExecutionRequest{\n+\t\tNamespace:    s.Namespace().String(),\n+\t\tActivityId:   activityID,\n+\t\tRunId:        startResp.RunId,\n+\t\tIncludeInfo:  true,\n+\t\tIncludeInput: true,\n+\t})\n+\trequire.NoError(t, err)\n+\trequire.NotNil(t, pollResp.StateChangeLongPollToken)\n+\trequire.NotNil(t, pollResp.Info)\n+\ts.assertActivityExecutionInfo(\n+\t\tt,\n+\t\tpollResp.Info,\n+\t\tactivityID,\n+\t\tstartResp.RunId,\n+\t\tenumspb.PENDING_ACTIVITY_STATE_SCHEDULED,\n+\t)\n+\trequire.NotNil(t, pollResp.Input)\n+\trequire.Equal(t, \"test-activity-input\", string(pollResp.Input.Payloads[0].Data))\n+\t// TODO(dan): test IncludeOutcome\n+}\n+\n+func (s *standaloneActivityTestSuite) Test_PollActivityExecution_WaitAnyStateChange() {\n+\t// Long poll for any state change. PollActivityTaskQueue is used to cause a state change.\n+\tt := s.T()\n+\tctx, cancel := context.WithTimeout(t.Context(), 10*time.Second)\n+\tdefer cancel()\n+\tactivityID := testcore.RandomizeStr(t.Name())\n+\ttaskQueue := uuid.New().String()\n+\n+\tstartResp, err := s.startActivity(ctx, activityID, taskQueue)\n+\trequire.NoError(t, err)\n+\n+\t// First poll lacks token and therefore responds immediately, returning a token\n+\tfirstPollResp, err := s.FrontendClient().PollActivityExecution(ctx, &workflowservice.PollActivityExecutionRequest{\n+\t\tNamespace:  s.Namespace().String(),\n+\t\tActivityId: activityID,\n+\t\tRunId:      startResp.RunId,\n+\t\tWaitPolicy: &workflowservice.PollActivityExecutionRequest_WaitAnyStateChange{\n+\t\t\tWaitAnyStateChange: &workflowservice.PollActivityExecutionRequest_StateChangeWaitOptions{},\n+\t\t},\n+\t\tIncludeInfo:  true,\n+\t\tIncludeInput: true,\n+\t})\n+\trequire.NoError(t, err)\n+\trequire.NotNil(t, firstPollResp.StateChangeLongPollToken)\n+\trequire.NotNil(t, firstPollResp.Info)\n+\ts.assertActivityExecutionInfo(\n+\t\tt,\n+\t\tfirstPollResp.Info,\n+\t\tactivityID,\n+\t\tstartResp.RunId,\n+\t\tenumspb.PENDING_ACTIVITY_STATE_SCHEDULED,\n+\t)\n+\n+\ttaskQueuePollErr := make(chan error, 1)\n+\tactivityPollDone := make(chan struct{})\n+\tvar activityPollResp *workflowservice.PollActivityExecutionResponse\n+\tvar activityPollErr error\n+\n+\tgo func() {\n+\t\tdefer close(activityPollDone)\n+\t\t// Second poll uses token and therefore waits for a state transition\n+\t\tactivityPollResp, activityPollErr = s.FrontendClient().PollActivityExecution(ctx, &workflowservice.PollActivityExecutionRequest{\n+\t\t\tNamespace:    s.Namespace().String(),\n+\t\t\tActivityId:   activityID,\n+\t\t\tRunId:        startResp.RunId,\n+\t\t\tIncludeInfo:  true,\n+\t\t\tIncludeInput: true,\n+\t\t\tWaitPolicy: &workflowservice.PollActivityExecutionRequest_WaitAnyStateChange{\n+\t\t\t\tWaitAnyStateChange: &workflowservice.PollActivityExecutionRequest_StateChangeWaitOptions{\n+\t\t\t\t\tLongPollToken: firstPollResp.StateChangeLongPollToken,\n+\t\t\t\t},\n+\t\t\t},\n+\t\t})\n+\t}()\n+\n+\t// TODO(dan): race here: subscription might not be established yet\n+\n+\t// Worker picks up activity task, triggering transition (via RecordActivityTaskStarted)\n+\tgo func() {\n+\t\t_, err := s.pollActivityTaskQueue(ctx, taskQueue)\n+\t\ttaskQueuePollErr <- err\n+\t}()\n+\n+\tselect {\n+\tcase <-activityPollDone:\n+\t\trequire.NoError(t, activityPollErr)\n+\t\trequire.NotNil(t, activityPollResp)\n+\t\trequire.NotNil(t, activityPollResp.Info)\n+\t\ts.assertActivityExecutionInfo(\n+\t\t\tt,\n+\t\t\tactivityPollResp.Info,\n+\t\t\tactivityID,\n+\t\t\tstartResp.RunId,\n+\t\t\tenumspb.PENDING_ACTIVITY_STATE_STARTED,\n+\t\t)\n+\t\trequire.NotNil(t, activityPollResp.Input)\n+\t\trequire.Equal(t, \"test-activity-input\", string(activityPollResp.Input.Payloads[0].Data))\n+\n+\tcase <-ctx.Done():\n+\t\tt.Fatal(\"PollActivityExecution timed out\")\n+\t}\n+\n+\terr = <-taskQueuePollErr\n+\trequire.NoError(t, err)\n+\n+\t// Manipulate the token to verify token staleness checks (simulate ErrStaleReference). To do so\n+\t// we make use of the internal implementation detail that the bytes are a serialized ref.\n+\ttoken := firstPollResp.StateChangeLongPollToken\n+\tvar pRef persistencespb.ChasmComponentRef\n+\terr = pRef.Unmarshal(token)\n+\trequire.NoError(t, err)\n+\tif pRef.EntityVersionedTransition != nil {\n+\t\tpRef.EntityVersionedTransition.NamespaceFailoverVersion += 1\n+\t}\n+\ttoken, err = pRef.Marshal()\n+\trequire.NoError(t, err)\n+\n+\t_, err = s.FrontendClient().PollActivityExecution(ctx, &workflowservice.PollActivityExecutionRequest{\n+\t\tNamespace:  s.Namespace().String(),\n+\t\tActivityId: activityID,\n+\t\tRunId:      startResp.RunId,\n+\t\tWaitPolicy: &workflowservice.PollActivityExecutionRequest_WaitAnyStateChange{\n+\t\t\tWaitAnyStateChange: &workflowservice.PollActivityExecutionRequest_StateChangeWaitOptions{\n+\t\t\t\tLongPollToken: token,\n+\t\t\t},\n+\t\t},\n+\t})\n+\trequire.Error(t, err)","path":"tests/standalone_activity_test.go","commit_id":"e95ab0ad0ba0c42c1e0e125042367ada0583ea76","original_commit_id":"da6009564e796063faf853352077eecdc1473612","user":{"login":"dandavison","id":52205,"node_id":"MDQ6VXNlcjUyMjA1","avatar_url":"https://avatars.githubusercontent.com/u/52205?v=4","gravatar_id":"","url":"https://api.github.com/users/dandavison","html_url":"https://github.com/dandavison","followers_url":"https://api.github.com/users/dandavison/followers","following_url":"https://api.github.com/users/dandavison/following{/other_user}","gists_url":"https://api.github.com/users/dandavison/gists{/gist_id}","starred_url":"https://api.github.com/users/dandavison/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/dandavison/subscriptions","organizations_url":"https://api.github.com/users/dandavison/orgs","repos_url":"https://api.github.com/users/dandavison/repos","events_url":"https://api.github.com/users/dandavison/events{/privacy}","received_events_url":"https://api.github.com/users/dandavison/received_events","type":"User","user_view_type":"public","site_admin":false},"body":"Thanks, done","created_at":"2025-11-26T17:08:08Z","updated_at":"2025-11-27T03:19:06Z","html_url":"https://github.com/temporalio/temporal/pull/8563#discussion_r2565818616","pull_request_url":"https://api.github.com/repos/temporalio/temporal/pulls/8563","_links":{"self":{"href":"https://api.github.com/repos/temporalio/temporal/pulls/comments/2565818616"},"html":{"href":"https://github.com/temporalio/temporal/pull/8563#discussion_r2565818616"},"pull_request":{"href":"https://api.github.com/repos/temporalio/temporal/pulls/8563"}},"reactions":{"url":"https://api.github.com/repos/temporalio/temporal/pulls/comments/2565818616/reactions","total_count":0,"+1":0,"-1":0,"laugh":0,"hooray":0,"confused":0,"heart":0,"rocket":0,"eyes":0},"start_line":null,"original_start_line":null,"start_side":null,"line":null,"original_line":261,"side":"RIGHT","in_reply_to_id":2540101065,"author_association":"MEMBER","original_position":193,"position":1,"subject_type":"line"},{"url":"https://api.github.com/repos/temporalio/temporal/pulls/comments/2565864499","pull_request_review_id":3489746627,"id":2565864499,"node_id":"PRRC_kwDODNqesM6Y7_wz","diff_hunk":"@@ -105,3 +117,377 @@ func createDefaultInput() *commonpb.Payloads {\n \t\t},\n \t}\n }\n+\n+func (s *standaloneActivityTestSuite) Test_PollActivityExecution_NoWait() {\n+\t// Long poll for any state change. PollActivityTaskQueue is used to cause a state change.\n+\tt := s.T()\n+\tctx, cancel := context.WithTimeout(t.Context(), 10*time.Second)\n+\tdefer cancel()\n+\tactivityID := testcore.RandomizeStr(t.Name())\n+\ttaskQueue := uuid.New().String()\n+\n+\tstartResp, err := s.startActivity(ctx, activityID, taskQueue)\n+\trequire.NoError(t, err)\n+\n+\tpollResp, err := s.FrontendClient().PollActivityExecution(ctx, &workflowservice.PollActivityExecutionRequest{\n+\t\tNamespace:    s.Namespace().String(),\n+\t\tActivityId:   activityID,\n+\t\tRunId:        startResp.RunId,\n+\t\tIncludeInfo:  true,\n+\t\tIncludeInput: true,\n+\t})\n+\trequire.NoError(t, err)\n+\trequire.NotNil(t, pollResp.StateChangeLongPollToken)\n+\trequire.NotNil(t, pollResp.Info)\n+\ts.assertActivityExecutionInfo(\n+\t\tt,\n+\t\tpollResp.Info,\n+\t\tactivityID,\n+\t\tstartResp.RunId,\n+\t\tenumspb.PENDING_ACTIVITY_STATE_SCHEDULED,\n+\t)\n+\trequire.NotNil(t, pollResp.Input)\n+\trequire.Equal(t, \"test-activity-input\", string(pollResp.Input.Payloads[0].Data))\n+\t// TODO(dan): test IncludeOutcome\n+}\n+\n+func (s *standaloneActivityTestSuite) Test_PollActivityExecution_WaitAnyStateChange() {\n+\t// Long poll for any state change. PollActivityTaskQueue is used to cause a state change.\n+\tt := s.T()\n+\tctx, cancel := context.WithTimeout(t.Context(), 10*time.Second)\n+\tdefer cancel()\n+\tactivityID := testcore.RandomizeStr(t.Name())\n+\ttaskQueue := uuid.New().String()\n+\n+\tstartResp, err := s.startActivity(ctx, activityID, taskQueue)\n+\trequire.NoError(t, err)\n+\n+\t// First poll lacks token and therefore responds immediately, returning a token\n+\tfirstPollResp, err := s.FrontendClient().PollActivityExecution(ctx, &workflowservice.PollActivityExecutionRequest{\n+\t\tNamespace:  s.Namespace().String(),\n+\t\tActivityId: activityID,\n+\t\tRunId:      startResp.RunId,\n+\t\tWaitPolicy: &workflowservice.PollActivityExecutionRequest_WaitAnyStateChange{\n+\t\t\tWaitAnyStateChange: &workflowservice.PollActivityExecutionRequest_StateChangeWaitOptions{},\n+\t\t},\n+\t\tIncludeInfo:  true,\n+\t\tIncludeInput: true,\n+\t})\n+\trequire.NoError(t, err)\n+\trequire.NotNil(t, firstPollResp.StateChangeLongPollToken)\n+\trequire.NotNil(t, firstPollResp.Info)\n+\ts.assertActivityExecutionInfo(\n+\t\tt,\n+\t\tfirstPollResp.Info,\n+\t\tactivityID,\n+\t\tstartResp.RunId,\n+\t\tenumspb.PENDING_ACTIVITY_STATE_SCHEDULED,\n+\t)\n+\n+\ttaskQueuePollErr := make(chan error, 1)\n+\tactivityPollDone := make(chan struct{})\n+\tvar activityPollResp *workflowservice.PollActivityExecutionResponse\n+\tvar activityPollErr error\n+\n+\tgo func() {\n+\t\tdefer close(activityPollDone)\n+\t\t// Second poll uses token and therefore waits for a state transition\n+\t\tactivityPollResp, activityPollErr = s.FrontendClient().PollActivityExecution(ctx, &workflowservice.PollActivityExecutionRequest{\n+\t\t\tNamespace:    s.Namespace().String(),\n+\t\t\tActivityId:   activityID,\n+\t\t\tRunId:        startResp.RunId,\n+\t\t\tIncludeInfo:  true,\n+\t\t\tIncludeInput: true,\n+\t\t\tWaitPolicy: &workflowservice.PollActivityExecutionRequest_WaitAnyStateChange{\n+\t\t\t\tWaitAnyStateChange: &workflowservice.PollActivityExecutionRequest_StateChangeWaitOptions{\n+\t\t\t\t\tLongPollToken: firstPollResp.StateChangeLongPollToken,\n+\t\t\t\t},\n+\t\t\t},\n+\t\t})\n+\t}()\n+\n+\t// TODO(dan): race here: subscription might not be established yet\n+\n+\t// Worker picks up activity task, triggering transition (via RecordActivityTaskStarted)\n+\tgo func() {\n+\t\t_, err := s.pollActivityTaskQueue(ctx, taskQueue)\n+\t\ttaskQueuePollErr <- err\n+\t}()\n+\n+\tselect {\n+\tcase <-activityPollDone:\n+\t\trequire.NoError(t, activityPollErr)\n+\t\trequire.NotNil(t, activityPollResp)\n+\t\trequire.NotNil(t, activityPollResp.Info)\n+\t\ts.assertActivityExecutionInfo(\n+\t\t\tt,\n+\t\t\tactivityPollResp.Info,\n+\t\t\tactivityID,\n+\t\t\tstartResp.RunId,\n+\t\t\tenumspb.PENDING_ACTIVITY_STATE_STARTED,\n+\t\t)\n+\t\trequire.NotNil(t, activityPollResp.Input)\n+\t\trequire.Equal(t, \"test-activity-input\", string(activityPollResp.Input.Payloads[0].Data))\n+\n+\tcase <-ctx.Done():\n+\t\tt.Fatal(\"PollActivityExecution timed out\")\n+\t}\n+\n+\terr = <-taskQueuePollErr\n+\trequire.NoError(t, err)\n+\n+\t// Manipulate the token to verify token staleness checks (simulate ErrStaleReference). To do so\n+\t// we make use of the internal implementation detail that the bytes are a serialized ref.\n+\ttoken := firstPollResp.StateChangeLongPollToken\n+\tvar pRef persistencespb.ChasmComponentRef\n+\terr = pRef.Unmarshal(token)\n+\trequire.NoError(t, err)\n+\tif pRef.EntityVersionedTransition != nil {\n+\t\tpRef.EntityVersionedTransition.NamespaceFailoverVersion += 1\n+\t}\n+\ttoken, err = pRef.Marshal()\n+\trequire.NoError(t, err)\n+\n+\t_, err = s.FrontendClient().PollActivityExecution(ctx, &workflowservice.PollActivityExecutionRequest{\n+\t\tNamespace:  s.Namespace().String(),\n+\t\tActivityId: activityID,\n+\t\tRunId:      startResp.RunId,\n+\t\tWaitPolicy: &workflowservice.PollActivityExecutionRequest_WaitAnyStateChange{\n+\t\t\tWaitAnyStateChange: &workflowservice.PollActivityExecutionRequest_StateChangeWaitOptions{\n+\t\t\t\tLongPollToken: token,\n+\t\t\t},\n+\t\t},\n+\t})\n+\trequire.Error(t, err)\n+\trequire.ErrorContains(t, err, \"cached mutable state could potentially be stale\")","path":"tests/standalone_activity_test.go","commit_id":"ee79ea9d2857dc0da255fec35a8ec05b24ecc8c6","original_commit_id":"da6009564e796063faf853352077eecdc1473612","user":{"login":"dandavison","id":52205,"node_id":"MDQ6VXNlcjUyMjA1","avatar_url":"https://avatars.githubusercontent.com/u/52205?v=4","gravatar_id":"","url":"https://api.github.com/users/dandavison","html_url":"https://github.com/dandavison","followers_url":"https://api.github.com/users/dandavison/followers","following_url":"https://api.github.com/users/dandavison/following{/other_user}","gists_url":"https://api.github.com/users/dandavison/gists{/gist_id}","starred_url":"https://api.github.com/users/dandavison/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/dandavison/subscriptions","organizations_url":"https://api.github.com/users/dandavison/orgs","repos_url":"https://api.github.com/users/dandavison/repos","events_url":"https://api.github.com/users/dandavison/events{/privacy}","received_events_url":"https://api.github.com/users/dandavison/received_events","type":"User","user_view_type":"public","site_admin":false},"body":"Thanks. This is now a unit test `TestChasmEngineSuite/TestPollComponent_StaleState`. It verifies that `engine.PollComponent` returns `serviceerror.Unavailable`  with message `\"please retry\"`. I think this is closer to what we want; I haven't thought of a better error message yet, and is `engine.PollComponent` too deep in internals to be returning `serviceerror`?","created_at":"2025-11-26T17:21:08Z","updated_at":"2025-11-27T03:19:06Z","html_url":"https://github.com/temporalio/temporal/pull/8563#discussion_r2565864499","pull_request_url":"https://api.github.com/repos/temporalio/temporal/pulls/8563","_links":{"self":{"href":"https://api.github.com/repos/temporalio/temporal/pulls/comments/2565864499"},"html":{"href":"https://github.com/temporalio/temporal/pull/8563#discussion_r2565864499"},"pull_request":{"href":"https://api.github.com/repos/temporalio/temporal/pulls/8563"}},"reactions":{"url":"https://api.github.com/repos/temporalio/temporal/pulls/comments/2565864499/reactions","total_count":0,"+1":0,"-1":0,"laugh":0,"hooray":0,"confused":0,"heart":0,"rocket":0,"eyes":0},"start_line":null,"original_start_line":null,"start_side":null,"line":null,"original_line":262,"side":"RIGHT","in_reply_to_id":2540101660,"author_association":"MEMBER","original_position":194,"position":1,"subject_type":"line"},{"url":"https://api.github.com/repos/temporalio/temporal/pulls/comments/2565886881","pull_request_review_id":3512033154,"id":2565886881,"node_id":"PRRC_kwDODNqesM6Y8FOh","diff_hunk":"@@ -266,3 +267,30 @@ func validateAndNormalizeSearchAttributes(\n \n \treturn saValidator.ValidateSize(searchAttributes, namespaceName)\n }\n+\n+// ValidatePollActivityExecutionRequest validates the request for PollActivityExecution API.\n+func ValidatePollActivityExecutionRequest(\n+\treq *workflowservice.PollActivityExecutionRequest,\n+\tmaxIDLengthLimit int,\n+) error {\n+\tif req.GetActivityId() == \"\" {\n+\t\treturn serviceerror.NewInvalidArgument(\"activity ID is required\")\n+\t}\n+\tif len(req.GetActivityId()) > maxIDLengthLimit {\n+\t\treturn serviceerror.NewInvalidArgumentf(\"activity ID exceeds length limit. Length=%d Limit=%d\",\n+\t\t\tlen(req.GetActivityId()), maxIDLengthLimit)\n+\t}\n+\thasRunID := req.GetRunId() != \"\"\n+\thasLongPollToken := len(req.GetWaitAnyStateChange().GetLongPollToken()) > 0","path":"chasm/lib/activity/validator.go","commit_id":"1d59e66d0ce5d91819f92c428ef5ab4c4efca1fb","original_commit_id":"f414f2db4e832632683445eef479d54a2be90653","user":{"login":"cursor[bot]","id":206951365,"node_id":"BOT_kgDODFXTxQ","avatar_url":"https://avatars.githubusercontent.com/in/1210556?v=4","gravatar_id":"","url":"https://api.github.com/users/cursor%5Bbot%5D","html_url":"https://github.com/apps/cursor","followers_url":"https://api.github.com/users/cursor%5Bbot%5D/followers","following_url":"https://api.github.com/users/cursor%5Bbot%5D/following{/other_user}","gists_url":"https://api.github.com/users/cursor%5Bbot%5D/gists{/gist_id}","starred_url":"https://api.github.com/users/cursor%5Bbot%5D/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/cursor%5Bbot%5D/subscriptions","organizations_url":"https://api.github.com/users/cursor%5Bbot%5D/orgs","repos_url":"https://api.github.com/users/cursor%5Bbot%5D/repos","events_url":"https://api.github.com/users/cursor%5Bbot%5D/events{/privacy}","received_events_url":"https://api.github.com/users/cursor%5Bbot%5D/received_events","type":"Bot","user_view_type":"public","site_admin":false},"body":"### Bug: Nil pointer dereference in request validation\n\n<!-- **High Severity** -->\n\n<!-- DESCRIPTION START -->\nThe validation calls `req.GetWaitAnyStateChange().GetLongPollToken()` without first checking if `WaitPolicy` is set or is of type `WaitAnyStateChange`. When `WaitPolicy` is `nil` (which is valid according to the handler logic at line 72 in `handler.go`) or when it's `WaitCompletion`, this causes a nil pointer dereference panic. The test at line 224 in `standalone_activity_test.go` omits `WaitPolicy` entirely, which would trigger this bug during validation.\n<!-- DESCRIPTION END -->\n\n<!-- LOCATIONS START\nchasm/lib/activity/validator.go#L283-L284\nLOCATIONS END -->\n<a href=\"https://cursor.com/open?data=eyJhbGciOiJSUzI1NiIsInR5cCI6IkpXVCIsImtpZCI6ImJ1Z2JvdC12MSJ9.eyJ2ZXJzaW9uIjoxLCJ0eXBlIjoiQlVHQk9UX0ZJWF9JTl9DVVJTT1IiLCJkYXRhIjp7InJlZGlzS2V5IjoiYnVnYm90OjlhNmI2ZDE5LTkyZjMtNDcyNy04N2I3LWE4MGZiNWU3MDQyMCIsImVuY3J5cHRpb25LZXkiOiJIaFhrWkdvT2FBWFNMcThxVnVCSlR0MXVnVmZma3dBNzBwc29JV1FaeUM0IiwiYnJhbmNoIjoicG9sbC1jb21wb25lbnQifSwiaWF0IjoxNzY0MTc4MDEzLCJleHAiOjE3NjQ3ODI4MTN9.dmG0zZjgEDxbP8Jfjlj0G98OVxQpXi03fzm2SJLbKbzyWm9ILiOtMlZrwbLA2FGhYqbG3hBUWLZms74bxPl1RLGaw55QqyQw4qZqq94l9Xlw4Sr-3_Z8JKsc7zVIfQnlT4dyHy0Sc7e9BDqiYwpS2eAdmD4u1EEpAkKw8vCDVbh-V3913l6bPUOSFj79eQlK95JTfxIAlxkAuvqTRx--5vqPHcGkho_e82ibngY3zNt3_o4VfQYJN6OS9-CvW08Z510YWf_RFhEzsbAwWGoFduJz1rvU8UK0lGHowtwDZ6nxYafh4Y64_xphzKp377HUZHJYw8AqH-0GQ4GTuRKlRA\"><picture><source media=\"(prefers-color-scheme: dark)\" srcset=\"https://cursor.com/fix-in-cursor-dark.svg\"><source media=\"(prefers-color-scheme: light)\" srcset=\"https://cursor.com/fix-in-cursor-light.svg\"><img alt=\"Fix in Cursor\" src=\"https://cursor.com/fix-in-cursor.svg\"></picture></a>&nbsp;<a href=\"https://cursor.com/agents?data=eyJhbGciOiJSUzI1NiIsInR5cCI6IkpXVCIsImtpZCI6ImJ1Z2JvdC12MSJ9.eyJ2ZXJzaW9uIjoxLCJ0eXBlIjoiQlVHQk9UX0ZJWF9JTl9XRUIiLCJkYXRhIjp7InJlZGlzS2V5IjoiYnVnYm90OjlhNmI2ZDE5LTkyZjMtNDcyNy04N2I3LWE4MGZiNWU3MDQyMCIsImVuY3J5cHRpb25LZXkiOiJIaFhrWkdvT2FBWFNMcThxVnVCSlR0MXVnVmZma3dBNzBwc29JV1FaeUM0IiwiYnJhbmNoIjoicG9sbC1jb21wb25lbnQiLCJyZXBvT3duZXIiOiJ0ZW1wb3JhbGlvIiwicmVwb05hbWUiOiJ0ZW1wb3JhbCIsInByTnVtYmVyIjo4NTYzLCJjb21taXRTaGEiOiJmNDE0ZjJkYjRlODMyNjMyNjgzNDQ1ZWVmNDc5ZDU0YTJiZTkwNjUzIiwicHJvdmlkZXIiOiJnaXRodWIifSwiaWF0IjoxNzY0MTc4MDEzLCJleHAiOjE3NjQ3ODI4MTN9.ico0p-19vG3ggmMSViO-i84jID2l4qn64jfyZiP950Y5Oge_LQl5oFxg3OcnHOR5ORdnx9WjlXfhYM7uDtLm8ND1_cyHuvgckRM6eL3Avy84zUka9E-lQuZCK-pgEKk-YJVg6IHh1uXp42pyMp4YlD7Us1LHUGpue-OW5JN_ziBo2ZH18BixIbPZc36z9atMSxdfPT_kkOpAJwmQ_AKivRUFj1YudvY4Omqq9-BJKpGo0kINowU-xt5gp1E1sqRoSe2Ei1H5fCQ07rn93IxLzFn3N0QJvTMOLSphHlKZCGGCyoPp2kA6djG2lCpEof-euSoBt2X0lZvJP2W3sEFPhA\"><picture><source media=\"(prefers-color-scheme: dark)\" srcset=\"https://cursor.com/fix-in-web-dark.svg\"><source media=\"(prefers-color-scheme: light)\" srcset=\"https://cursor.com/fix-in-web-light.svg\"><img alt=\"Fix in Web\" src=\"https://cursor.com/fix-in-web.svg\"></picture></a>\n\n","created_at":"2025-11-26T17:26:54Z","updated_at":"2025-11-26T17:26:54Z","html_url":"https://github.com/temporalio/temporal/pull/8563#discussion_r2565886881","pull_request_url":"https://api.github.com/repos/temporalio/temporal/pulls/8563","_links":{"self":{"href":"https://api.github.com/repos/temporalio/temporal/pulls/comments/2565886881"},"html":{"href":"https://github.com/temporalio/temporal/pull/8563#discussion_r2565886881"},"pull_request":{"href":"https://api.github.com/repos/temporalio/temporal/pulls/8563"}},"reactions":{"url":"https://api.github.com/repos/temporalio/temporal/pulls/comments/2565886881/reactions","total_count":1,"+1":0,"-1":1,"laugh":0,"hooray":0,"confused":0,"heart":0,"rocket":0,"eyes":0},"start_line":null,"original_start_line":null,"start_side":null,"line":284,"original_line":284,"side":"RIGHT","author_association":"NONE","original_position":26,"position":26,"subject_type":"line"},{"url":"https://api.github.com/repos/temporalio/temporal/pulls/comments/2566250941","pull_request_review_id":3512466959,"id":2566250941,"node_id":"PRRC_kwDODNqesM6Y9eG9","diff_hunk":"@@ -241,14 +256,137 @@ func (e *ChasmEngine) ReadComponent(\n \treturn readFn(chasmContext, component)\n }\n \n+// PollComponent waits until the supplied predicate is satisfied when evaluated against the\n+// component identified by the supplied component reference. If there is no error, it returns (ref,\n+// nil) where ref is a component reference identifying the state at which the predicate was\n+// satisfied. The predicate must be monotonic: if it returns true at execution state transition s it\n+// must return true at all transitions t > s. It is an error if execution transition history is\n+// (after reloading from persistence) behind the requested ref, or if the ref is inconsistent with\n+// execution transition history. Thus when the predicate function is evaluated, it is guaranteed\n+// that the execution VT >= requestRef VT. opts are currently ignored.\n func (e *ChasmEngine) PollComponent(\n \tctx context.Context,\n-\tentityRef chasm.ComponentRef,\n-\tpredicateFn func(chasm.Context, chasm.Component) (any, bool, error),\n-\toperationFn func(chasm.MutableContext, chasm.Component, any) error,\n+\trequestRef chasm.ComponentRef,\n+\tmonotonicPredicate func(chasm.Context, chasm.Component) (bool, error),\n \topts ...chasm.TransitionOption,\n-) (newEntityRef []byte, retError error) {\n-\treturn nil, serviceerror.NewUnimplemented(\"PollComponent is not yet supported\")\n+) (retRef []byte, retError error) {\n+\tdefer func() {\n+\t\tif errors.Is(retError, consts.ErrStaleState) {\n+\t\t\tretError = serviceerror.NewUnavailable(\"please retry\")\n+\t\t}\n+\t}()\n+\n+\tshardContext, executionLease, err := e.getExecutionLease(ctx, requestRef)\n+\tif err != nil {\n+\t\t// E.g. requestRef VT inconsistent with execution VT ('stale reference')\n+\t\treturn nil, err\n+\t}\n+\tdefer executionLease.GetReleaseFn()(nil)\n+\n+\t// At this point it's possible that execution VT < requestRef VT (getExecutionLease does not\n+\t// guarantee that returned execution state is non-stale w.r.t. requestRef).\n+\tsatisfiedRef, err := e.predicateSatisfied(ctx, monotonicPredicate, requestRef, executionLease)\n+\tif err != nil {\n+\t\treturn nil, err\n+\t}\n+\t// execution VT >= requestRef VT (enforced by predicateSatisfied)\n+\n+\tif satisfiedRef != nil {\n+\t\t// wait condition was satisfied\n+\t\treturn satisfiedRef, nil\n+\t}\n+\n+\t// Wait condition not satisfied; long-poll\n+\n+\tnamespaceRegistry, err := shardContext.GetNamespaceRegistry().GetNamespaceByID(\n+\t\tnamespace.ID(requestRef.EntityKey.NamespaceID),\n+\t)\n+\tif err != nil {\n+\t\treturn nil, err\n+\t}\n+\n+\tinternalLongPollTimeout := shardContext.GetConfig().LongPollExpirationInterval(namespaceRegistry.Name().String())\n+\tctx, cancel := context.WithTimeout(ctx, internalLongPollTimeout)\n+\tdefer cancel()\n+\n+\t// PollComponent subscribes to execution-level notifications. Suppose that an execution consists\n+\t// of one component A, and A has subcomponent B. Subscribers interested only in component B may\n+\t// be woken up unnecessarily (and thus evaluate the predicate unnecessarily) due to changes in\n+\t// parts of A that do not also belong to B.\n+\tch := e.notifier.Subscribe(requestRef.EntityKey)\n+\texecutionLease.GetReleaseFn()(nil)\n+\n+\tfor {\n+\t\tselect {\n+\t\t// It is possible that multiple state transitions (multiple notifications) occur between\n+\t\t// predicate checks, therefore the predicate must be monotonic: if it returns true at\n+\t\t// execution state transition s then it must return true at all transitions t > s.\n+\t\tcase <-ch:\n+\t\t\t_, executionLease, err := e.getExecutionLease(ctx, requestRef)\n+\t\t\tif err != nil {\n+\t\t\t\treturn nil, err\n+\t\t\t}\n+\t\t\tfunc() {\n+\t\t\t\tdefer executionLease.GetReleaseFn()(nil)\n+\t\t\t\tsatisfiedRef, err = e.predicateSatisfied(ctx, monotonicPredicate, requestRef, executionLease)\n+\t\t\t\tif err == nil && satisfiedRef == nil {\n+\t\t\t\t\tch = e.notifier.Subscribe(requestRef.EntityKey)\n+\t\t\t\t}\n+\t\t\t}()\n+\t\t\tif err != nil {\n+\t\t\t\treturn nil, err\n+\t\t\t}\n+\t\t\tif satisfiedRef != nil {\n+\t\t\t\treturn satisfiedRef, nil\n+\t\t\t}\n+\t\tcase <-ctx.Done():\n+\t\t\treturn nil, ctx.Err()","path":"service/history/chasm_engine.go","commit_id":"1d59e66d0ce5d91819f92c428ef5ab4c4efca1fb","original_commit_id":"43326011d16ad3d25483ef1b9a1befff81f3a66f","user":{"login":"cursor[bot]","id":206951365,"node_id":"BOT_kgDODFXTxQ","avatar_url":"https://avatars.githubusercontent.com/in/1210556?v=4","gravatar_id":"","url":"https://api.github.com/users/cursor%5Bbot%5D","html_url":"https://github.com/apps/cursor","followers_url":"https://api.github.com/users/cursor%5Bbot%5D/followers","following_url":"https://api.github.com/users/cursor%5Bbot%5D/following{/other_user}","gists_url":"https://api.github.com/users/cursor%5Bbot%5D/gists{/gist_id}","starred_url":"https://api.github.com/users/cursor%5Bbot%5D/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/cursor%5Bbot%5D/subscriptions","organizations_url":"https://api.github.com/users/cursor%5Bbot%5D/orgs","repos_url":"https://api.github.com/users/cursor%5Bbot%5D/repos","events_url":"https://api.github.com/users/cursor%5Bbot%5D/events{/privacy}","received_events_url":"https://api.github.com/users/cursor%5Bbot%5D/received_events","type":"Bot","user_view_type":"public","site_admin":false},"body":"### Bug: Memory leak from uncleaned subscriptions on timeout\n\n<!-- **High Severity** -->\n\n<!-- DESCRIPTION START -->\nWhen `PollComponent` times out via `ctx.Done()`, it returns without cleaning up the subscription created at line 316. The `ChasmNotifier.Subscribe` method creates a channel and stores it in the `executions` map, but this channel is only removed when `Notify` is called. If a notification never arrives (due to timeout, context cancellation, or errors), the channel remains in the map indefinitely, causing a memory leak. Each timed-out or cancelled poll request will leak one channel and map entry. The notifier needs either an unsubscribe mechanism or the caller must ensure cleanup before returning.\n<!-- DESCRIPTION END -->\n\n<!-- LOCATIONS START\nservice/history/chasm_engine.go#L341-L343\nservice/history/chasm_notifier.go#L26-L46\nLOCATIONS END -->\n<details>\n<summary>Additional Locations (1)</summary>\n\n- [`service/history/chasm_notifier.go#L26-L46`](https://github.com/temporalio/temporal/blob/43326011d16ad3d25483ef1b9a1befff81f3a66f/service/history/chasm_notifier.go#L26-L46)\n\n</details>\n\n<a href=\"https://cursor.com/open?data=eyJhbGciOiJSUzI1NiIsInR5cCI6IkpXVCIsImtpZCI6ImJ1Z2JvdC12MSJ9.eyJ2ZXJzaW9uIjoxLCJ0eXBlIjoiQlVHQk9UX0ZJWF9JTl9DVVJTT1IiLCJkYXRhIjp7InJlZGlzS2V5IjoiYnVnYm90OjdjZjIwMTFlLWZmMGItNDk0Ni05ZTdmLTUyM2ZkNjBlNjQ2MCIsImVuY3J5cHRpb25LZXkiOiJYN1RTRm5JTU8yS18yQVVqeUZja1BIdWNrZTRzbXNqV3NWem1HWG5SWVFzIiwiYnJhbmNoIjoicG9sbC1jb21wb25lbnQifSwiaWF0IjoxNzY0MTg1MDU5LCJleHAiOjE3NjQ3ODk4NTl9.l1zsUnK1_HJkmghPVwKNUVeIUzTL_ILE_TLYP6ahCwqcw-tv_hzaOJ0MF88Irg99C93_m4ovI5tVUbt656SYnCz--7-iQYKBmQ7M1muuFiSIAMzV_K1aDXU4W1h356WN3_cLO4SHMIC22yd68Kv_dUtOJ1LrRKRuNnMXqWpd-QMcmkvWANSjedBymrMKhh4_60qxtTOa6jwa-UlrmVePUdu4Q6cT436dg2g4XOmIMMbPo51acNI3q2vzzR1jYbw1kQBNDhiQ2QTO95dCq9UJE3s_midU_5cRMFg8K4CSRB0Yd-GkZ9t_roOP4zt-oe-BipbHNStEQmch531WuCj7VQ\"><picture><source media=\"(prefers-color-scheme: dark)\" srcset=\"https://cursor.com/fix-in-cursor-dark.svg\"><source media=\"(prefers-color-scheme: light)\" srcset=\"https://cursor.com/fix-in-cursor-light.svg\"><img alt=\"Fix in Cursor\" src=\"https://cursor.com/fix-in-cursor.svg\"></picture></a>&nbsp;<a href=\"https://cursor.com/agents?data=eyJhbGciOiJSUzI1NiIsInR5cCI6IkpXVCIsImtpZCI6ImJ1Z2JvdC12MSJ9.eyJ2ZXJzaW9uIjoxLCJ0eXBlIjoiQlVHQk9UX0ZJWF9JTl9XRUIiLCJkYXRhIjp7InJlZGlzS2V5IjoiYnVnYm90OjdjZjIwMTFlLWZmMGItNDk0Ni05ZTdmLTUyM2ZkNjBlNjQ2MCIsImVuY3J5cHRpb25LZXkiOiJYN1RTRm5JTU8yS18yQVVqeUZja1BIdWNrZTRzbXNqV3NWem1HWG5SWVFzIiwiYnJhbmNoIjoicG9sbC1jb21wb25lbnQiLCJyZXBvT3duZXIiOiJ0ZW1wb3JhbGlvIiwicmVwb05hbWUiOiJ0ZW1wb3JhbCIsInByTnVtYmVyIjo4NTYzLCJjb21taXRTaGEiOiI0MzMyNjAxMWQxNmFkM2QyNTQ4M2VmMWI5YTFiZWZmZjgxZjNhNjZmIiwicHJvdmlkZXIiOiJnaXRodWIifSwiaWF0IjoxNzY0MTg1MDU5LCJleHAiOjE3NjQ3ODk4NTl9.QO0xx5TYlWV4mX91-SuCEBpJS2nuAm4vfcR7_6abGeynRn2pv8KaWNgz41tngED2SeL_5JXYt2v8kN5gPbKRk0Mf0dcrQvSwxpl5oFBsPKt0NSx9DEOu0uE_CQ6W1jqWh-5gm4G3vLKkix6QzshaxeX-_czmZ0WbXTt0lJa3HjM0Oz91MQIdAJtusIh-QZ76BWjfKEJMGslU2jVNRA2ykeQkM-2pgK6GX9nyxfaEJbDhQD_1qBKDv6dXR_-BXxQnaZZF7JdIVEkWGRTLRtLAjOZzvROASMJIPj5Lpb7i-9RODhkE7M_LYohfGdSJviYTQ_ZALsRGQtyejfz5HSMzGQ\"><picture><source media=\"(prefers-color-scheme: dark)\" srcset=\"https://cursor.com/fix-in-web-dark.svg\"><source media=\"(prefers-color-scheme: light)\" srcset=\"https://cursor.com/fix-in-web-light.svg\"><img alt=\"Fix in Web\" src=\"https://cursor.com/fix-in-web.svg\"></picture></a>\n\n","created_at":"2025-11-26T19:24:20Z","updated_at":"2025-11-26T19:24:20Z","html_url":"https://github.com/temporalio/temporal/pull/8563#discussion_r2566250941","pull_request_url":"https://api.github.com/repos/temporalio/temporal/pulls/8563","_links":{"self":{"href":"https://api.github.com/repos/temporalio/temporal/pulls/comments/2566250941"},"html":{"href":"https://github.com/temporalio/temporal/pull/8563#discussion_r2566250941"},"pull_request":{"href":"https://api.github.com/repos/temporalio/temporal/pulls/8563"}},"reactions":{"url":"https://api.github.com/repos/temporalio/temporal/pulls/comments/2566250941/reactions","total_count":1,"+1":1,"-1":0,"laugh":0,"hooray":0,"confused":0,"heart":0,"rocket":0,"eyes":0},"start_line":null,"original_start_line":null,"start_side":null,"line":325,"original_line":343,"side":"RIGHT","author_association":"NONE","original_position":159,"position":137,"subject_type":"line"},{"url":"https://api.github.com/repos/temporalio/temporal/pulls/comments/2566308603","pull_request_review_id":3512534221,"id":2566308603,"node_id":"PRRC_kwDODNqesM6Y9sL7","diff_hunk":"@@ -241,14 +256,137 @@ func (e *ChasmEngine) ReadComponent(\n \treturn readFn(chasmContext, component)\n }\n \n+// PollComponent waits until the supplied predicate is satisfied when evaluated against the\n+// component identified by the supplied component reference. If there is no error, it returns (ref,\n+// nil) where ref is a component reference identifying the state at which the predicate was\n+// satisfied. The predicate must be monotonic: if it returns true at execution state transition s it\n+// must return true at all transitions t > s. It is an error if execution transition history is\n+// (after reloading from persistence) behind the requested ref, or if the ref is inconsistent with\n+// execution transition history. Thus when the predicate function is evaluated, it is guaranteed\n+// that the execution VT >= requestRef VT. opts are currently ignored.\n func (e *ChasmEngine) PollComponent(\n \tctx context.Context,\n-\tentityRef chasm.ComponentRef,\n-\tpredicateFn func(chasm.Context, chasm.Component) (any, bool, error),\n-\toperationFn func(chasm.MutableContext, chasm.Component, any) error,\n+\trequestRef chasm.ComponentRef,\n+\tmonotonicPredicate func(chasm.Context, chasm.Component) (bool, error),\n \topts ...chasm.TransitionOption,\n-) (newEntityRef []byte, retError error) {\n-\treturn nil, serviceerror.NewUnimplemented(\"PollComponent is not yet supported\")\n+) (retRef []byte, retError error) {\n+\tdefer func() {\n+\t\tif errors.Is(retError, consts.ErrStaleState) {\n+\t\t\tretError = serviceerror.NewUnavailable(\"please retry\")\n+\t\t}\n+\t}()\n+\n+\tshardContext, executionLease, err := e.getExecutionLease(ctx, requestRef)\n+\tif err != nil {\n+\t\t// E.g. requestRef VT inconsistent with execution VT ('stale reference')\n+\t\treturn nil, err\n+\t}\n+\tdefer executionLease.GetReleaseFn()(nil)\n+\n+\t// At this point it's possible that execution VT < requestRef VT (getExecutionLease does not\n+\t// guarantee that returned execution state is non-stale w.r.t. requestRef).\n+\tsatisfiedRef, err := e.predicateSatisfied(ctx, monotonicPredicate, requestRef, executionLease)\n+\tif err != nil {\n+\t\treturn nil, err\n+\t}\n+\t// execution VT >= requestRef VT (enforced by predicateSatisfied)\n+\n+\tif satisfiedRef != nil {\n+\t\t// wait condition was satisfied\n+\t\treturn satisfiedRef, nil\n+\t}\n+\n+\t// Wait condition not satisfied; long-poll\n+\n+\tnamespaceRegistry, err := shardContext.GetNamespaceRegistry().GetNamespaceByID(\n+\t\tnamespace.ID(requestRef.EntityKey.NamespaceID),\n+\t)\n+\tif err != nil {\n+\t\treturn nil, err\n+\t}\n+\n+\tinternalLongPollTimeout := shardContext.GetConfig().LongPollExpirationInterval(namespaceRegistry.Name().String())\n+\tctx, cancel := context.WithTimeout(ctx, internalLongPollTimeout)\n+\tdefer cancel()\n+\n+\t// PollComponent subscribes to execution-level notifications. Suppose that an execution consists\n+\t// of one component A, and A has subcomponent B. Subscribers interested only in component B may\n+\t// be woken up unnecessarily (and thus evaluate the predicate unnecessarily) due to changes in\n+\t// parts of A that do not also belong to B.\n+\tch := e.notifier.Subscribe(requestRef.EntityKey)\n+\texecutionLease.GetReleaseFn()(nil)","path":"service/history/chasm_engine.go","commit_id":"372cc0a17931bd461ec03349b8509b57820e36c2","original_commit_id":"98f5e1321791f6942a3341e0ed54e5117b7d2a08","user":{"login":"cursor[bot]","id":206951365,"node_id":"BOT_kgDODFXTxQ","avatar_url":"https://avatars.githubusercontent.com/in/1210556?v=4","gravatar_id":"","url":"https://api.github.com/users/cursor%5Bbot%5D","html_url":"https://github.com/apps/cursor","followers_url":"https://api.github.com/users/cursor%5Bbot%5D/followers","following_url":"https://api.github.com/users/cursor%5Bbot%5D/following{/other_user}","gists_url":"https://api.github.com/users/cursor%5Bbot%5D/gists{/gist_id}","starred_url":"https://api.github.com/users/cursor%5Bbot%5D/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/cursor%5Bbot%5D/subscriptions","organizations_url":"https://api.github.com/users/cursor%5Bbot%5D/orgs","repos_url":"https://api.github.com/users/cursor%5Bbot%5D/repos","events_url":"https://api.github.com/users/cursor%5Bbot%5D/events{/privacy}","received_events_url":"https://api.github.com/users/cursor%5Bbot%5D/received_events","type":"Bot","user_view_type":"public","site_admin":false},"body":"### Bug: Double release of execution lease in PollComponent\n\n<!-- **High Severity** -->\n\n<!-- DESCRIPTION START -->\nThe `PollComponent` method releases the same execution lease twice. Line 284 sets up a deferred release with `defer executionLease.GetReleaseFn()(nil)`, and line 317 explicitly calls `executionLease.GetReleaseFn()(nil)` before the long-poll loop. When the function eventually returns (via `ctx.Done()` or successful predicate), the deferred release will execute again on the already-released lease. This differs from `UpdateComponent` and `ReadComponent`, which correctly release only once. Double-releasing a workflow cache lease can cause undefined behavior or panics depending on the cache implementation.\n<!-- DESCRIPTION END -->\n\n<!-- LOCATIONS START\nservice/history/chasm_engine.go#L283-L317\nLOCATIONS END -->\n<a href=\"https://cursor.com/open?data=eyJhbGciOiJSUzI1NiIsInR5cCI6IkpXVCIsImtpZCI6ImJ1Z2JvdC12MSJ9.eyJ2ZXJzaW9uIjoxLCJ0eXBlIjoiQlVHQk9UX0ZJWF9JTl9DVVJTT1IiLCJkYXRhIjp7InJlZGlzS2V5IjoiYnVnYm90OmEyYmQxYzg4LTU2MDUtNGI3MS05ZmMzLWRjMDRjYjM2ZTU2ZSIsImVuY3J5cHRpb25LZXkiOiIzWjZJUlc5bWtHWmhRemV6V3FWazQzNmFlTllsOFVSRUFzWGJRSEpzMk5zIiwiYnJhbmNoIjoicG9sbC1jb21wb25lbnQifSwiaWF0IjoxNzY0MTg2MjM2LCJleHAiOjE3NjQ3OTEwMzZ9.UopWmK8JoUQAJQdkqNlrgStSY6mIC-5n9blSS3H2zoOQj3NhalfmXXk6OSkQLpcgVwo5O1ZrDtD0B6bjhIq1dv4Dr7FYlkg4Z48LWWD-fDa7cKX0mI56cxMYyf57FOjxXkEkypnImMD_5ta9cTEajuN0bNyjRwAenAScqEtYost1wPD2edBPXcGQAVXP7p1JRecdTcJXp0fm6_yhlLenLcUYZGo2TN1VvXzcwBrtud5rtVTYdC3NLu4AjdHMnBaXZX8X9MgJJfT0oBLpF0IujdqmYtyZqWse7xxzPoZbrk-b4hEecZcK6NcALUYrmBiHAUi3pbXudi8oIBdZ5St0sw\"><picture><source media=\"(prefers-color-scheme: dark)\" srcset=\"https://cursor.com/fix-in-cursor-dark.svg\"><source media=\"(prefers-color-scheme: light)\" srcset=\"https://cursor.com/fix-in-cursor-light.svg\"><img alt=\"Fix in Cursor\" src=\"https://cursor.com/fix-in-cursor.svg\"></picture></a>&nbsp;<a href=\"https://cursor.com/agents?data=eyJhbGciOiJSUzI1NiIsInR5cCI6IkpXVCIsImtpZCI6ImJ1Z2JvdC12MSJ9.eyJ2ZXJzaW9uIjoxLCJ0eXBlIjoiQlVHQk9UX0ZJWF9JTl9XRUIiLCJkYXRhIjp7InJlZGlzS2V5IjoiYnVnYm90OmEyYmQxYzg4LTU2MDUtNGI3MS05ZmMzLWRjMDRjYjM2ZTU2ZSIsImVuY3J5cHRpb25LZXkiOiIzWjZJUlc5bWtHWmhRemV6V3FWazQzNmFlTllsOFVSRUFzWGJRSEpzMk5zIiwiYnJhbmNoIjoicG9sbC1jb21wb25lbnQiLCJyZXBvT3duZXIiOiJ0ZW1wb3JhbGlvIiwicmVwb05hbWUiOiJ0ZW1wb3JhbCIsInByTnVtYmVyIjo4NTYzLCJjb21taXRTaGEiOiI5OGY1ZTEzMjE3OTFmNjk0MmEzMzQxZTBlZDU0ZTUxMTdiN2QyYTA4IiwicHJvdmlkZXIiOiJnaXRodWIifSwiaWF0IjoxNzY0MTg2MjM2LCJleHAiOjE3NjQ3OTEwMzZ9.kljcQ_JJmvDrZKqlwqybOyhhOp8IJ_Z2HabiLDfcxeNtoTXVSaCS-CA5QquGGCtRwdnbVRZmxSZNKypk76sSptNlkdxChb2OWtufxEA20bgp8DdiYEc_1CkAEgzoCiHX44OjJxhyBFz_GvouZvrSp5iwM2CHPQoMjRPqSJTpudkg7QJMfpSBi6X2mn9YSfBWV9eiND06eGK5kmeSVON-qGqY51KJfV0x4NT44gDkKbaoE28GBOMJvgfLSpL0zYM6AXcDhk_Ben3xSHNx3GvPNCrocQ5TZjpPqfm4oZaW-BHRGSB56ToSGpeGKAGVwkrw_lj-4FkX2Sk11MunWY9lAg\"><picture><source media=\"(prefers-color-scheme: dark)\" srcset=\"https://cursor.com/fix-in-web-dark.svg\"><source media=\"(prefers-color-scheme: light)\" srcset=\"https://cursor.com/fix-in-web-light.svg\"><img alt=\"Fix in Web\" src=\"https://cursor.com/fix-in-web.svg\"></picture></a>\n\n","created_at":"2025-11-26T19:43:56Z","updated_at":"2025-11-26T19:43:56Z","html_url":"https://github.com/temporalio/temporal/pull/8563#discussion_r2566308603","pull_request_url":"https://api.github.com/repos/temporalio/temporal/pulls/8563","_links":{"self":{"href":"https://api.github.com/repos/temporalio/temporal/pulls/comments/2566308603"},"html":{"href":"https://github.com/temporalio/temporal/pull/8563#discussion_r2566308603"},"pull_request":{"href":"https://api.github.com/repos/temporalio/temporal/pulls/8563"}},"reactions":{"url":"https://api.github.com/repos/temporalio/temporal/pulls/comments/2566308603/reactions","total_count":0,"+1":0,"-1":0,"laugh":0,"hooray":0,"confused":0,"heart":0,"rocket":0,"eyes":0},"start_line":null,"original_start_line":null,"start_side":null,"line":null,"original_line":317,"side":"RIGHT","author_association":"NONE","original_position":133,"position":1,"subject_type":"line"},{"url":"https://api.github.com/repos/temporalio/temporal/pulls/comments/2567017490","pull_request_review_id":3513384216,"id":2567017490,"node_id":"PRRC_kwDODNqesM6ZAZQS","diff_hunk":"@@ -37,14 +40,12 @@ type Activity struct {\n \n \t*activitypb.ActivityState\n \n-\t// Standalone only\n \tVisibility    chasm.Field[*chasm.Visibility]\n \tAttempt       chasm.Field[*activitypb.ActivityAttemptState]\n \tLastHeartbeat chasm.Field[*activitypb.ActivityHeartbeatState]\n+\tOutcome       chasm.Field[*activitypb.ActivityOutcome]","path":"chasm/lib/activity/activity.go","commit_id":"f3115e38e18a1ba16dc583d8ef987c679a7e9683","original_commit_id":"98f5e1321791f6942a3341e0ed54e5117b7d2a08","user":{"login":"bergundy","id":52304,"node_id":"MDQ6VXNlcjUyMzA0","avatar_url":"https://avatars.githubusercontent.com/u/52304?v=4","gravatar_id":"","url":"https://api.github.com/users/bergundy","html_url":"https://github.com/bergundy","followers_url":"https://api.github.com/users/bergundy/followers","following_url":"https://api.github.com/users/bergundy/following{/other_user}","gists_url":"https://api.github.com/users/bergundy/gists{/gist_id}","starred_url":"https://api.github.com/users/bergundy/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/bergundy/subscriptions","organizations_url":"https://api.github.com/users/bergundy/orgs","repos_url":"https://api.github.com/users/bergundy/repos","events_url":"https://api.github.com/users/bergundy/events{/privacy}","received_events_url":"https://api.github.com/users/bergundy/received_events","type":"User","user_view_type":"public","site_admin":false},"body":"Outcome is standalone only, don't move this field.","created_at":"2025-11-27T02:52:06Z","updated_at":"2025-11-27T03:09:05Z","html_url":"https://github.com/temporalio/temporal/pull/8563#discussion_r2567017490","pull_request_url":"https://api.github.com/repos/temporalio/temporal/pulls/8563","_links":{"self":{"href":"https://api.github.com/repos/temporalio/temporal/pulls/comments/2567017490"},"html":{"href":"https://github.com/temporalio/temporal/pull/8563#discussion_r2567017490"},"pull_request":{"href":"https://api.github.com/repos/temporalio/temporal/pulls/8563"}},"reactions":{"url":"https://api.github.com/repos/temporalio/temporal/pulls/comments/2567017490/reactions","total_count":0,"+1":0,"-1":0,"laugh":0,"hooray":0,"confused":0,"heart":0,"rocket":0,"eyes":0},"start_line":null,"original_start_line":null,"start_side":null,"line":null,"original_line":46,"side":"RIGHT","author_association":"MEMBER","original_position":26,"position":1,"subject_type":"line"},{"url":"https://api.github.com/repos/temporalio/temporal/pulls/comments/2567018624","pull_request_review_id":3513384216,"id":2567018624,"node_id":"PRRC_kwDODNqesM6ZAZiA","diff_hunk":"@@ -314,3 +315,123 @@ func (a *Activity) RecordHeartbeat(ctx chasm.MutableContext, details *commonpb.P\n \t})\n \treturn nil, nil\n }\n+\n+func (a *Activity) buildActivityExecutionInfo(ctx chasm.Context) (*activity.ActivityExecutionInfo, error) {\n+\tif a.ActivityState == nil {\n+\t\treturn nil, errors.New(\"activity state is nil\")\n+\t}\n+\n+\t// TODO(dan): support pause states\n+\tvar status enumspb.ActivityExecutionStatus\n+\tvar runState enumspb.PendingActivityState\n+\tswitch a.GetStatus() {\n+\tcase activitypb.ACTIVITY_EXECUTION_STATUS_UNSPECIFIED:\n+\t\tstatus = enumspb.ACTIVITY_EXECUTION_STATUS_UNSPECIFIED\n+\t\trunState = enumspb.PENDING_ACTIVITY_STATE_UNSPECIFIED\n+\tcase activitypb.ACTIVITY_EXECUTION_STATUS_SCHEDULED:\n+\t\tstatus = enumspb.ACTIVITY_EXECUTION_STATUS_RUNNING\n+\t\trunState = enumspb.PENDING_ACTIVITY_STATE_SCHEDULED\n+\tcase activitypb.ACTIVITY_EXECUTION_STATUS_STARTED:\n+\t\tstatus = enumspb.ACTIVITY_EXECUTION_STATUS_RUNNING\n+\t\trunState = enumspb.PENDING_ACTIVITY_STATE_STARTED\n+\tcase activitypb.ACTIVITY_EXECUTION_STATUS_CANCEL_REQUESTED:\n+\t\tstatus = enumspb.ACTIVITY_EXECUTION_STATUS_RUNNING\n+\t\trunState = enumspb.PENDING_ACTIVITY_STATE_CANCEL_REQUESTED\n+\tcase activitypb.ACTIVITY_EXECUTION_STATUS_COMPLETED:\n+\t\tstatus = enumspb.ACTIVITY_EXECUTION_STATUS_COMPLETED\n+\t\trunState = enumspb.PENDING_ACTIVITY_STATE_UNSPECIFIED\n+\tcase activitypb.ACTIVITY_EXECUTION_STATUS_FAILED:\n+\t\tstatus = enumspb.ACTIVITY_EXECUTION_STATUS_FAILED\n+\t\trunState = enumspb.PENDING_ACTIVITY_STATE_UNSPECIFIED\n+\tcase activitypb.ACTIVITY_EXECUTION_STATUS_CANCELED:\n+\t\tstatus = enumspb.ACTIVITY_EXECUTION_STATUS_CANCELED\n+\t\trunState = enumspb.PENDING_ACTIVITY_STATE_UNSPECIFIED\n+\tcase activitypb.ACTIVITY_EXECUTION_STATUS_TERMINATED:\n+\t\tstatus = enumspb.ACTIVITY_EXECUTION_STATUS_TERMINATED\n+\t\trunState = enumspb.PENDING_ACTIVITY_STATE_UNSPECIFIED\n+\tcase activitypb.ACTIVITY_EXECUTION_STATUS_TIMED_OUT:\n+\t\tstatus = enumspb.ACTIVITY_EXECUTION_STATUS_TIMED_OUT\n+\t\trunState = enumspb.PENDING_ACTIVITY_STATE_UNSPECIFIED\n+\tdefault:\n+\t\treturn nil, serviceerror.NewInternalf(\"unknown activity execution status: %s\", a.GetStatus())\n+\t}\n+\n+\trequestData, err := a.RequestData.Get(ctx)\n+\tif err != nil {\n+\t\treturn nil, err\n+\t}\n+\n+\tkey := ctx.ExecutionKey()\n+\n+\tinfo := &activity.ActivityExecutionInfo{\n+\t\tActivityId:    key.BusinessID,\n+\t\tRunId:         key.EntityID,\n+\t\tActivityType:  a.GetActivityType(),\n+\t\tStatus:        status,\n+\t\tRunState:      runState,\n+\t\tScheduledTime: a.GetScheduledTime(),\n+\t\tPriority:      a.GetPriority(),\n+\t\tHeader:        requestData.GetHeader(),\n+\t\t// TODO(dan): populate remaining fields\n+\t}\n+\n+\treturn info, nil\n+}\n+\n+func (a *Activity) buildPollActivityExecutionResponse(\n+\tctx chasm.Context,\n+\treq *activitypb.PollActivityExecutionRequest,","path":"chasm/lib/activity/activity.go","commit_id":"1d59e66d0ce5d91819f92c428ef5ab4c4efca1fb","original_commit_id":"da6009564e796063faf853352077eecdc1473612","user":{"login":"bergundy","id":52304,"node_id":"MDQ6VXNlcjUyMzA0","avatar_url":"https://avatars.githubusercontent.com/u/52304?v=4","gravatar_id":"","url":"https://api.github.com/users/bergundy","html_url":"https://github.com/bergundy","followers_url":"https://api.github.com/users/bergundy/followers","following_url":"https://api.github.com/users/bergundy/following{/other_user}","gists_url":"https://api.github.com/users/bergundy/gists{/gist_id}","starred_url":"https://api.github.com/users/bergundy/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/bergundy/subscriptions","organizations_url":"https://api.github.com/users/bergundy/orgs","repos_url":"https://api.github.com/users/bergundy/repos","events_url":"https://api.github.com/users/bergundy/events{/privacy}","received_events_url":"https://api.github.com/users/bergundy/received_events","type":"User","user_view_type":"public","site_admin":false},"body":"WDYT?","created_at":"2025-11-27T02:53:02Z","updated_at":"2025-11-27T03:09:05Z","html_url":"https://github.com/temporalio/temporal/pull/8563#discussion_r2567018624","pull_request_url":"https://api.github.com/repos/temporalio/temporal/pulls/8563","_links":{"self":{"href":"https://api.github.com/repos/temporalio/temporal/pulls/comments/2567018624"},"html":{"href":"https://github.com/temporalio/temporal/pull/8563#discussion_r2567018624"},"pull_request":{"href":"https://api.github.com/repos/temporalio/temporal/pulls/8563"}},"reactions":{"url":"https://api.github.com/repos/temporalio/temporal/pulls/comments/2567018624/reactions","total_count":0,"+1":0,"-1":0,"laugh":0,"hooray":0,"confused":0,"heart":0,"rocket":0,"eyes":0},"start_line":null,"original_start_line":null,"start_side":null,"line":383,"original_line":383,"side":"RIGHT","in_reply_to_id":2539839248,"author_association":"MEMBER","original_position":103,"position":99,"subject_type":"line"},{"url":"https://api.github.com/repos/temporalio/temporal/pulls/comments/2567021052","pull_request_review_id":3513384216,"id":2567021052,"node_id":"PRRC_kwDODNqesM6ZAaH8","diff_hunk":"@@ -314,3 +315,141 @@ func (a *Activity) RecordHeartbeat(ctx chasm.MutableContext, details *commonpb.P\n \t})\n \treturn nil, nil\n }\n+\n+func (a *Activity) buildActivityExecutionInfo(ctx chasm.Context) (*activity.ActivityExecutionInfo, error) {\n+\tif a.ActivityState == nil {\n+\t\treturn nil, errors.New(\"activity state is nil\")\n+\t}\n+\n+\t// TODO(dan): support pause states\n+\tvar status enumspb.ActivityExecutionStatus\n+\tvar runState enumspb.PendingActivityState\n+\tswitch a.GetStatus() {\n+\tcase activitypb.ACTIVITY_EXECUTION_STATUS_UNSPECIFIED:\n+\t\tstatus = enumspb.ACTIVITY_EXECUTION_STATUS_UNSPECIFIED\n+\t\trunState = enumspb.PENDING_ACTIVITY_STATE_UNSPECIFIED\n+\tcase activitypb.ACTIVITY_EXECUTION_STATUS_SCHEDULED:\n+\t\tstatus = enumspb.ACTIVITY_EXECUTION_STATUS_RUNNING\n+\t\trunState = enumspb.PENDING_ACTIVITY_STATE_SCHEDULED\n+\tcase activitypb.ACTIVITY_EXECUTION_STATUS_STARTED:\n+\t\tstatus = enumspb.ACTIVITY_EXECUTION_STATUS_RUNNING\n+\t\trunState = enumspb.PENDING_ACTIVITY_STATE_STARTED\n+\tcase activitypb.ACTIVITY_EXECUTION_STATUS_CANCEL_REQUESTED:\n+\t\tstatus = enumspb.ACTIVITY_EXECUTION_STATUS_RUNNING\n+\t\trunState = enumspb.PENDING_ACTIVITY_STATE_CANCEL_REQUESTED\n+\tcase activitypb.ACTIVITY_EXECUTION_STATUS_COMPLETED:\n+\t\tstatus = enumspb.ACTIVITY_EXECUTION_STATUS_COMPLETED\n+\t\trunState = enumspb.PENDING_ACTIVITY_STATE_UNSPECIFIED\n+\tcase activitypb.ACTIVITY_EXECUTION_STATUS_FAILED:\n+\t\tstatus = enumspb.ACTIVITY_EXECUTION_STATUS_FAILED\n+\t\trunState = enumspb.PENDING_ACTIVITY_STATE_UNSPECIFIED\n+\tcase activitypb.ACTIVITY_EXECUTION_STATUS_CANCELED:\n+\t\tstatus = enumspb.ACTIVITY_EXECUTION_STATUS_CANCELED\n+\t\trunState = enumspb.PENDING_ACTIVITY_STATE_UNSPECIFIED\n+\tcase activitypb.ACTIVITY_EXECUTION_STATUS_TERMINATED:\n+\t\tstatus = enumspb.ACTIVITY_EXECUTION_STATUS_TERMINATED\n+\t\trunState = enumspb.PENDING_ACTIVITY_STATE_UNSPECIFIED\n+\tcase activitypb.ACTIVITY_EXECUTION_STATUS_TIMED_OUT:\n+\t\tstatus = enumspb.ACTIVITY_EXECUTION_STATUS_TIMED_OUT\n+\t\trunState = enumspb.PENDING_ACTIVITY_STATE_UNSPECIFIED\n+\tdefault:\n+\t\treturn nil, serviceerror.NewInternalf(\"unknown activity execution status: %s\", a.GetStatus())\n+\t}\n+\n+\trequestData, err := a.RequestData.Get(ctx)\n+\tif err != nil {\n+\t\treturn nil, err\n+\t}\n+\n+\tkey := ctx.ExecutionKey()\n+\n+\tinfo := &activity.ActivityExecutionInfo{\n+\t\tActivityId:    key.BusinessID,\n+\t\tRunId:         key.EntityID,\n+\t\tActivityType:  a.GetActivityType(),\n+\t\tStatus:        status,\n+\t\tRunState:      runState,\n+\t\tScheduledTime: a.GetScheduledTime(),\n+\t\tPriority:      a.GetPriority(),\n+\t\tHeader:        requestData.GetHeader(),\n+\t\t// TODO(dan): populate remaining fields\n+\t}\n+\n+\treturn info, nil\n+}\n+\n+func (a *Activity) buildPollActivityExecutionResponse(\n+\tctx chasm.Context,\n+\treq *activitypb.PollActivityExecutionRequest,\n+) (*activitypb.PollActivityExecutionResponse, error) {\n+\trequest := req.GetFrontendRequest()\n+\n+\ttoken, err := ctx.Ref(a)\n+\tif err != nil {\n+\t\treturn nil, err\n+\t}\n+\n+\tvar info *activity.ActivityExecutionInfo\n+\tif request.GetIncludeInfo() {\n+\t\tinfo, err = a.buildActivityExecutionInfo(ctx)\n+\t\tif err != nil {\n+\t\t\treturn nil, err\n+\t\t}\n+\t}\n+\n+\tvar input *commonpb.Payloads\n+\tif request.GetIncludeInput() {\n+\t\tactivityRequest, err := a.RequestData.Get(ctx)\n+\t\tif err != nil {\n+\t\t\treturn nil, err\n+\t\t}\n+\t\tinput = activityRequest.GetInput()\n+\t}\n+\n+\tresponse := &workflowservice.PollActivityExecutionResponse{\n+\t\tInfo:                     info,\n+\t\tRunId:                    ctx.ExecutionKey().EntityID,\n+\t\tInput:                    input,\n+\t\tStateChangeLongPollToken: token,\n+\t}\n+\n+\tif request.GetIncludeOutcome() {","path":"chasm/lib/activity/activity.go","commit_id":"1d59e66d0ce5d91819f92c428ef5ab4c4efca1fb","original_commit_id":"98f5e1321791f6942a3341e0ed54e5117b7d2a08","user":{"login":"bergundy","id":52304,"node_id":"MDQ6VXNlcjUyMzA0","avatar_url":"https://avatars.githubusercontent.com/u/52304?v=4","gravatar_id":"","url":"https://api.github.com/users/bergundy","html_url":"https://github.com/bergundy","followers_url":"https://api.github.com/users/bergundy/followers","following_url":"https://api.github.com/users/bergundy/following{/other_user}","gists_url":"https://api.github.com/users/bergundy/gists{/gist_id}","starred_url":"https://api.github.com/users/bergundy/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/bergundy/subscriptions","organizations_url":"https://api.github.com/users/bergundy/orgs","repos_url":"https://api.github.com/users/bergundy/repos","events_url":"https://api.github.com/users/bergundy/events{/privacy}","received_events_url":"https://api.github.com/users/bergundy/received_events","type":"User","user_view_type":"public","site_admin":false},"body":"I think this logic looks good but maybe @fretz12 can take a look too.","created_at":"2025-11-27T02:55:10Z","updated_at":"2025-11-27T03:09:05Z","html_url":"https://github.com/temporalio/temporal/pull/8563#discussion_r2567021052","pull_request_url":"https://api.github.com/repos/temporalio/temporal/pulls/8563","_links":{"self":{"href":"https://api.github.com/repos/temporalio/temporal/pulls/comments/2567021052"},"html":{"href":"https://github.com/temporalio/temporal/pull/8563#discussion_r2567021052"},"pull_request":{"href":"https://api.github.com/repos/temporalio/temporal/pulls/8563"}},"reactions":{"url":"https://api.github.com/repos/temporalio/temporal/pulls/comments/2567021052/reactions","total_count":0,"+1":0,"-1":0,"laugh":0,"hooray":0,"confused":0,"heart":0,"rocket":0,"eyes":0},"start_line":null,"original_start_line":null,"start_side":null,"line":416,"original_line":416,"side":"RIGHT","author_association":"MEMBER","original_position":136,"position":132,"subject_type":"line"},{"url":"https://api.github.com/repos/temporalio/temporal/pulls/comments/2567023825","pull_request_review_id":3513384216,"id":2567023825,"node_id":"PRRC_kwDODNqesM6ZAazR","diff_hunk":"@@ -51,3 +54,115 @@ func (h *handler) StartActivityExecution(ctx context.Context, req *activitypb.St\n \t\tFrontendResponse: response,\n \t}, nil\n }\n+\n+// PollActivityExecution handles PollActivityExecutionRequest from frontend. This method supports\n+// querying current activity state, optionally as a long-poll that waits for certain state changes.\n+// It is used by clients to poll for activity state and/or result.\n+func (h *handler) PollActivityExecution(\n+\tctx context.Context,\n+\treq *activitypb.PollActivityExecutionRequest,\n+) (response *activitypb.PollActivityExecutionResponse, err error) {\n+\tref := chasm.NewComponentRef[*Activity](chasm.EntityKey{\n+\t\tNamespaceID: req.GetNamespaceId(),\n+\t\tBusinessID:  req.GetFrontendRequest().GetActivityId(),\n+\t\tEntityID:    req.GetFrontendRequest().GetRunId(),\n+\t})\n+\tdefer func() {\n+\t\tvar notFound *serviceerror.NotFound\n+\t\tif errors.As(err, &notFound) {\n+\t\t\t// TODO(dan): include execution key in error message; we may do this at the CHASM\n+\t\t\t// framework level.\n+\t\t\t// cf. \"workflow execution not found for workflow ID XXX and run ID YYY\"\n+\t\t\terr = serviceerror.NewNotFound(\"activity execution not found\")\n+\t\t}\n+\t}()\n+\n+\twaitPolicy := req.GetFrontendRequest().GetWaitPolicy()\n+\n+\tif waitPolicy == nil {\n+\t\treturn chasm.ReadComponent(ctx, ref, (*Activity).buildPollActivityExecutionResponse, req, nil)\n+\t}\n+\n+\t// Do not allow long-poll to use all remaining time\n+\tchildCtx := ctx\n+\tif deadline, ok := ctx.Deadline(); ok {","path":"chasm/lib/activity/handler.go","commit_id":"59d749626d6a00c5fff76abe79a85eb627366521","original_commit_id":"98f5e1321791f6942a3341e0ed54e5117b7d2a08","user":{"login":"bergundy","id":52304,"node_id":"MDQ6VXNlcjUyMzA0","avatar_url":"https://avatars.githubusercontent.com/u/52304?v=4","gravatar_id":"","url":"https://api.github.com/users/bergundy","html_url":"https://github.com/bergundy","followers_url":"https://api.github.com/users/bergundy/followers","following_url":"https://api.github.com/users/bergundy/following{/other_user}","gists_url":"https://api.github.com/users/bergundy/gists{/gist_id}","starred_url":"https://api.github.com/users/bergundy/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/bergundy/subscriptions","organizations_url":"https://api.github.com/users/bergundy/orgs","repos_url":"https://api.github.com/users/bergundy/repos","events_url":"https://api.github.com/users/bergundy/events{/privacy}","received_events_url":"https://api.github.com/users/bergundy/received_events","type":"User","user_view_type":"public","site_admin":false},"body":"Use the helper from `contextutil` and cap the wait timeout to a minute like other long poll APIs.","created_at":"2025-11-27T02:57:21Z","updated_at":"2025-11-27T03:09:05Z","html_url":"https://github.com/temporalio/temporal/pull/8563#discussion_r2567023825","pull_request_url":"https://api.github.com/repos/temporalio/temporal/pulls/8563","_links":{"self":{"href":"https://api.github.com/repos/temporalio/temporal/pulls/comments/2567023825"},"html":{"href":"https://github.com/temporalio/temporal/pull/8563#discussion_r2567023825"},"pull_request":{"href":"https://api.github.com/repos/temporalio/temporal/pulls/8563"}},"reactions":{"url":"https://api.github.com/repos/temporalio/temporal/pulls/comments/2567023825/reactions","total_count":0,"+1":0,"-1":0,"laugh":0,"hooray":0,"confused":0,"heart":0,"rocket":0,"eyes":0},"start_line":null,"original_start_line":null,"start_side":null,"line":null,"original_line":88,"side":"RIGHT","author_association":"MEMBER","original_position":46,"position":1,"subject_type":"line"},{"url":"https://api.github.com/repos/temporalio/temporal/pulls/comments/2567026182","pull_request_review_id":3513384216,"id":2567026182,"node_id":"PRRC_kwDODNqesM6ZAbYG","diff_hunk":"@@ -51,3 +54,115 @@ func (h *handler) StartActivityExecution(ctx context.Context, req *activitypb.St\n \t\tFrontendResponse: response,\n \t}, nil\n }\n+\n+// PollActivityExecution handles PollActivityExecutionRequest from frontend. This method supports\n+// querying current activity state, optionally as a long-poll that waits for certain state changes.\n+// It is used by clients to poll for activity state and/or result.\n+func (h *handler) PollActivityExecution(\n+\tctx context.Context,\n+\treq *activitypb.PollActivityExecutionRequest,\n+) (response *activitypb.PollActivityExecutionResponse, err error) {\n+\tref := chasm.NewComponentRef[*Activity](chasm.EntityKey{\n+\t\tNamespaceID: req.GetNamespaceId(),\n+\t\tBusinessID:  req.GetFrontendRequest().GetActivityId(),\n+\t\tEntityID:    req.GetFrontendRequest().GetRunId(),\n+\t})\n+\tdefer func() {\n+\t\tvar notFound *serviceerror.NotFound\n+\t\tif errors.As(err, &notFound) {\n+\t\t\t// TODO(dan): include execution key in error message; we may do this at the CHASM\n+\t\t\t// framework level.\n+\t\t\t// cf. \"workflow execution not found for workflow ID XXX and run ID YYY\"\n+\t\t\terr = serviceerror.NewNotFound(\"activity execution not found\")\n+\t\t}\n+\t}()\n+\n+\twaitPolicy := req.GetFrontendRequest().GetWaitPolicy()\n+\n+\tif waitPolicy == nil {\n+\t\treturn chasm.ReadComponent(ctx, ref, (*Activity).buildPollActivityExecutionResponse, req, nil)\n+\t}\n+\n+\t// Do not allow long-poll to use all remaining time\n+\tchildCtx := ctx\n+\tif deadline, ok := ctx.Deadline(); ok {\n+\t\tvar cancel context.CancelFunc\n+\t\tchildCtx, cancel = context.WithDeadline(ctx, deadline.Add(-time.Second))\n+\t\tdefer cancel()\n+\t}\n+\n+\tswitch waitPolicy.(type) {\n+\tcase *workflowservice.PollActivityExecutionRequest_WaitAnyStateChange:\n+\t\ttoken := req.GetFrontendRequest().\n+\t\t\tGetWaitPolicy().(*workflowservice.PollActivityExecutionRequest_WaitAnyStateChange).\n+\t\t\tWaitAnyStateChange.GetLongPollToken()\n+\t\tif len(token) == 0 {","path":"chasm/lib/activity/handler.go","commit_id":"1d59e66d0ce5d91819f92c428ef5ab4c4efca1fb","original_commit_id":"98f5e1321791f6942a3341e0ed54e5117b7d2a08","user":{"login":"bergundy","id":52304,"node_id":"MDQ6VXNlcjUyMzA0","avatar_url":"https://avatars.githubusercontent.com/u/52304?v=4","gravatar_id":"","url":"https://api.github.com/users/bergundy","html_url":"https://github.com/bergundy","followers_url":"https://api.github.com/users/bergundy/followers","following_url":"https://api.github.com/users/bergundy/following{/other_user}","gists_url":"https://api.github.com/users/bergundy/gists{/gist_id}","starred_url":"https://api.github.com/users/bergundy/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/bergundy/subscriptions","organizations_url":"https://api.github.com/users/bergundy/orgs","repos_url":"https://api.github.com/users/bergundy/repos","events_url":"https://api.github.com/users/bergundy/events{/privacy}","received_events_url":"https://api.github.com/users/bergundy/received_events","type":"User","user_view_type":"public","site_admin":false},"body":"That seems like a bad request to me but I'm not worrying about it since we are going to change this API structure.","created_at":"2025-11-27T02:59:22Z","updated_at":"2025-11-27T03:09:05Z","html_url":"https://github.com/temporalio/temporal/pull/8563#discussion_r2567026182","pull_request_url":"https://api.github.com/repos/temporalio/temporal/pulls/8563","_links":{"self":{"href":"https://api.github.com/repos/temporalio/temporal/pulls/comments/2567026182"},"html":{"href":"https://github.com/temporalio/temporal/pull/8563#discussion_r2567026182"},"pull_request":{"href":"https://api.github.com/repos/temporalio/temporal/pulls/8563"}},"reactions":{"url":"https://api.github.com/repos/temporalio/temporal/pulls/comments/2567026182/reactions","total_count":1,"+1":1,"-1":0,"laugh":0,"hooray":0,"confused":0,"heart":0,"rocket":0,"eyes":0},"start_line":null,"original_start_line":null,"start_side":null,"line":110,"original_line":99,"side":"RIGHT","author_association":"MEMBER","original_position":57,"position":79,"subject_type":"line"},{"url":"https://api.github.com/repos/temporalio/temporal/pulls/comments/2567037755","pull_request_review_id":3513384216,"id":2567037755,"node_id":"PRRC_kwDODNqesM6ZAeM7","diff_hunk":"@@ -53,3 +56,115 @@ func (h *handler) StartActivityExecution(ctx context.Context, req *activitypb.St\n \t\tFrontendResponse: response,\n \t}, nil\n }\n+\n+// PollActivityExecution handles PollActivityExecutionRequest from frontend. This method supports\n+// querying current activity state, optionally as a long-poll that waits for certain state changes.\n+// It is used by clients to poll for activity state and/or result.\n+func (h *handler) PollActivityExecution(\n+\tctx context.Context,\n+\treq *activitypb.PollActivityExecutionRequest,\n+) (response *activitypb.PollActivityExecutionResponse, err error) {\n+\tref := chasm.NewComponentRef[*Activity](chasm.EntityKey{\n+\t\tNamespaceID: req.GetNamespaceId(),\n+\t\tBusinessID:  req.GetFrontendRequest().GetActivityId(),\n+\t\tEntityID:    req.GetFrontendRequest().GetRunId(),\n+\t})\n+\tdefer func() {\n+\t\tvar notFound *serviceerror.NotFound\n+\t\tif errors.As(err, &notFound) {\n+\t\t\t// TODO(dan): include execution key in error message; we may do this at the CHASM\n+\t\t\t// framework level.\n+\t\t\t// cf. \"workflow execution not found for workflow ID XXX and run ID YYY\"\n+\t\t\terr = serviceerror.NewNotFound(\"activity execution not found\")\n+\t\t}\n+\t}()\n+\n+\twaitPolicy := req.GetFrontendRequest().GetWaitPolicy()\n+\n+\tif waitPolicy == nil {\n+\t\treturn chasm.ReadComponent(ctx, ref, (*Activity).buildPollActivityExecutionResponse, req, nil)\n+\t}\n+\n+\t// Do not allow long-poll to use all remaining time\n+\tchildCtx := ctx\n+\tif deadline, ok := ctx.Deadline(); ok {\n+\t\tvar cancel context.CancelFunc\n+\t\tchildCtx, cancel = context.WithDeadline(ctx, deadline.Add(-time.Second))","path":"chasm/lib/activity/handler.go","commit_id":"59d749626d6a00c5fff76abe79a85eb627366521","original_commit_id":"f3115e38e18a1ba16dc583d8ef987c679a7e9683","user":{"login":"bergundy","id":52304,"node_id":"MDQ6VXNlcjUyMzA0","avatar_url":"https://avatars.githubusercontent.com/u/52304?v=4","gravatar_id":"","url":"https://api.github.com/users/bergundy","html_url":"https://github.com/bergundy","followers_url":"https://api.github.com/users/bergundy/followers","following_url":"https://api.github.com/users/bergundy/following{/other_user}","gists_url":"https://api.github.com/users/bergundy/gists{/gist_id}","starred_url":"https://api.github.com/users/bergundy/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/bergundy/subscriptions","organizations_url":"https://api.github.com/users/bergundy/orgs","repos_url":"https://api.github.com/users/bergundy/repos","events_url":"https://api.github.com/users/bergundy/events{/privacy}","received_events_url":"https://api.github.com/users/bergundy/received_events","type":"User","user_view_type":"public","site_admin":false},"body":"Use the utility from contextutils, you always want to cap the long poll timeout to a minute.","created_at":"2025-11-27T03:05:34Z","updated_at":"2025-11-27T03:09:05Z","html_url":"https://github.com/temporalio/temporal/pull/8563#discussion_r2567037755","pull_request_url":"https://api.github.com/repos/temporalio/temporal/pulls/8563","_links":{"self":{"href":"https://api.github.com/repos/temporalio/temporal/pulls/comments/2567037755"},"html":{"href":"https://github.com/temporalio/temporal/pull/8563#discussion_r2567037755"},"pull_request":{"href":"https://api.github.com/repos/temporalio/temporal/pulls/8563"}},"reactions":{"url":"https://api.github.com/repos/temporalio/temporal/pulls/comments/2567037755/reactions","total_count":0,"+1":0,"-1":0,"laugh":0,"hooray":0,"confused":0,"heart":0,"rocket":0,"eyes":0},"start_line":null,"original_start_line":null,"start_side":null,"line":null,"original_line":92,"side":"RIGHT","author_association":"MEMBER","original_position":48,"position":1,"subject_type":"line"},{"url":"https://api.github.com/repos/temporalio/temporal/pulls/comments/2567038615","pull_request_review_id":3513384216,"id":2567038615,"node_id":"PRRC_kwDODNqesM6ZAeaX","diff_hunk":"@@ -53,3 +56,115 @@ func (h *handler) StartActivityExecution(ctx context.Context, req *activitypb.St\n \t\tFrontendResponse: response,\n \t}, nil\n }\n+\n+// PollActivityExecution handles PollActivityExecutionRequest from frontend. This method supports\n+// querying current activity state, optionally as a long-poll that waits for certain state changes.\n+// It is used by clients to poll for activity state and/or result.\n+func (h *handler) PollActivityExecution(\n+\tctx context.Context,\n+\treq *activitypb.PollActivityExecutionRequest,\n+) (response *activitypb.PollActivityExecutionResponse, err error) {\n+\tref := chasm.NewComponentRef[*Activity](chasm.EntityKey{\n+\t\tNamespaceID: req.GetNamespaceId(),\n+\t\tBusinessID:  req.GetFrontendRequest().GetActivityId(),\n+\t\tEntityID:    req.GetFrontendRequest().GetRunId(),\n+\t})\n+\tdefer func() {\n+\t\tvar notFound *serviceerror.NotFound\n+\t\tif errors.As(err, &notFound) {\n+\t\t\t// TODO(dan): include execution key in error message; we may do this at the CHASM\n+\t\t\t// framework level.\n+\t\t\t// cf. \"workflow execution not found for workflow ID XXX and run ID YYY\"\n+\t\t\terr = serviceerror.NewNotFound(\"activity execution not found\")\n+\t\t}\n+\t}()\n+\n+\twaitPolicy := req.GetFrontendRequest().GetWaitPolicy()\n+\n+\tif waitPolicy == nil {\n+\t\treturn chasm.ReadComponent(ctx, ref, (*Activity).buildPollActivityExecutionResponse, req, nil)\n+\t}\n+\n+\t// Do not allow long-poll to use all remaining time\n+\tchildCtx := ctx\n+\tif deadline, ok := ctx.Deadline(); ok {\n+\t\tvar cancel context.CancelFunc\n+\t\tchildCtx, cancel = context.WithDeadline(ctx, deadline.Add(-time.Second))\n+\t\tdefer cancel()\n+\t}\n+\n+\tswitch waitPolicy.(type) {\n+\tcase *workflowservice.PollActivityExecutionRequest_WaitAnyStateChange:\n+\t\ttoken := req.GetFrontendRequest().\n+\t\t\tGetWaitPolicy().(*workflowservice.PollActivityExecutionRequest_WaitAnyStateChange).\n+\t\t\tWaitAnyStateChange.GetLongPollToken()\n+\t\tif len(token) == 0 {\n+\t\t\treturn chasm.ReadComponent(ctx, ref, (*Activity).buildPollActivityExecutionResponse, req, nil)\n+\t\t}\n+\t\tresponse, _, err = chasm.PollComponent(childCtx, ref, func(\n+\t\t\ta *Activity,\n+\t\t\tctx chasm.Context,\n+\t\t\treq *activitypb.PollActivityExecutionRequest,\n+\t\t) (*activitypb.PollActivityExecutionResponse, bool, error) {\n+\t\t\tchanged, err := chasm.ExecutionStateChanged(a, ctx, token)\n+\t\t\tif err != nil {\n+\t\t\t\tif errors.Is(err, chasm.ErrMalformedComponentRef) {\n+\t\t\t\t\treturn nil, false, serviceerror.NewInvalidArgument(\"invalid long poll token\")\n+\t\t\t\t}\n+\t\t\t\tif errors.Is(err, chasm.ErrInvalidComponentRef) {\n+\t\t\t\t\treturn nil, false, serviceerror.NewInvalidArgument(\"long poll token does not match execution\")\n+\t\t\t\t}\n+\t\t\t\treturn nil, false, err\n+\t\t\t}\n+\t\t\tif changed {\n+\t\t\t\tresponse, err := a.buildPollActivityExecutionResponse(ctx, req)\n+\t\t\t\treturn response, true, err\n+\t\t\t} else {\n+\t\t\t\treturn nil, false, nil\n+\t\t\t}\n+\t\t}, req)\n+\tcase *workflowservice.PollActivityExecutionRequest_WaitCompletion:\n+\t\t// TODO(dan): add functional test when RecordActivityTaskCompleted is implemented\n+\t\tresponse, _, err = chasm.PollComponent(childCtx, ref, func(\n+\t\t\ta *Activity,\n+\t\t\tctx chasm.Context,\n+\t\t\treq *activitypb.PollActivityExecutionRequest,\n+\t\t) (*activitypb.PollActivityExecutionResponse, bool, error) {\n+\t\t\t// TODO(dan): check for terminal activity states\n+\t\t\tpanic(\"pollActivityExecutionWaitCompletion is not implemented\")\n+\t\t\tcompleted := false\n+\t\t\tif completed {\n+\t\t\t\tresponse, err := a.buildPollActivityExecutionResponse(ctx, req)\n+\t\t\t\tif err != nil {\n+\t\t\t\t\treturn nil, true, err\n+\t\t\t\t}\n+\t\t\t\treturn response, true, nil\n+\t\t\t}\n+\t\t\treturn nil, false, nil\n+\t\t}, req)\n+\tdefault:\n+\t\treturn nil, serviceerror.NewInvalidArgumentf(\"unexpected wait policy type: %T\", waitPolicy)\n+\t}\n+\n+\tif childCtx.Err() != nil {\n+\t\t// Caller deadline exceeded\n+\t\treturn nil, childCtx.Err()\n+\t}\n+\tif errors.Is(err, context.DeadlineExceeded) {","path":"chasm/lib/activity/handler.go","commit_id":"59d749626d6a00c5fff76abe79a85eb627366521","original_commit_id":"f3115e38e18a1ba16dc583d8ef987c679a7e9683","user":{"login":"bergundy","id":52304,"node_id":"MDQ6VXNlcjUyMzA0","avatar_url":"https://avatars.githubusercontent.com/u/52304?v=4","gravatar_id":"","url":"https://api.github.com/users/bergundy","html_url":"https://github.com/bergundy","followers_url":"https://api.github.com/users/bergundy/followers","following_url":"https://api.github.com/users/bergundy/following{/other_user}","gists_url":"https://api.github.com/users/bergundy/gists{/gist_id}","starred_url":"https://api.github.com/users/bergundy/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/bergundy/subscriptions","organizations_url":"https://api.github.com/users/bergundy/orgs","repos_url":"https://api.github.com/users/bergundy/repos","events_url":"https://api.github.com/users/bergundy/events{/privacy}","received_events_url":"https://api.github.com/users/bergundy/received_events","type":"User","user_view_type":"public","site_admin":false},"body":"```suggestion\n```","created_at":"2025-11-27T03:06:16Z","updated_at":"2025-11-27T03:09:05Z","html_url":"https://github.com/temporalio/temporal/pull/8563#discussion_r2567038615","pull_request_url":"https://api.github.com/repos/temporalio/temporal/pulls/8563","_links":{"self":{"href":"https://api.github.com/repos/temporalio/temporal/pulls/comments/2567038615"},"html":{"href":"https://github.com/temporalio/temporal/pull/8563#discussion_r2567038615"},"pull_request":{"href":"https://api.github.com/repos/temporalio/temporal/pulls/8563"}},"reactions":{"url":"https://api.github.com/repos/temporalio/temporal/pulls/comments/2567038615/reactions","total_count":0,"+1":0,"-1":0,"laugh":0,"hooray":0,"confused":0,"heart":0,"rocket":0,"eyes":0},"start_line":null,"original_start_line":151,"start_side":"RIGHT","line":null,"original_line":153,"side":"RIGHT","author_association":"MEMBER","original_position":109,"position":1,"subject_type":"line"},{"url":"https://api.github.com/repos/temporalio/temporal/pulls/comments/2567040398","pull_request_review_id":3513384216,"id":2567040398,"node_id":"PRRC_kwDODNqesM6ZAe2O","diff_hunk":"@@ -53,3 +56,115 @@ func (h *handler) StartActivityExecution(ctx context.Context, req *activitypb.St\n \t\tFrontendResponse: response,\n \t}, nil\n }\n+\n+// PollActivityExecution handles PollActivityExecutionRequest from frontend. This method supports\n+// querying current activity state, optionally as a long-poll that waits for certain state changes.\n+// It is used by clients to poll for activity state and/or result.\n+func (h *handler) PollActivityExecution(\n+\tctx context.Context,\n+\treq *activitypb.PollActivityExecutionRequest,\n+) (response *activitypb.PollActivityExecutionResponse, err error) {\n+\tref := chasm.NewComponentRef[*Activity](chasm.EntityKey{\n+\t\tNamespaceID: req.GetNamespaceId(),\n+\t\tBusinessID:  req.GetFrontendRequest().GetActivityId(),\n+\t\tEntityID:    req.GetFrontendRequest().GetRunId(),\n+\t})\n+\tdefer func() {\n+\t\tvar notFound *serviceerror.NotFound\n+\t\tif errors.As(err, &notFound) {\n+\t\t\t// TODO(dan): include execution key in error message; we may do this at the CHASM\n+\t\t\t// framework level.\n+\t\t\t// cf. \"workflow execution not found for workflow ID XXX and run ID YYY\"\n+\t\t\terr = serviceerror.NewNotFound(\"activity execution not found\")\n+\t\t}\n+\t}()\n+\n+\twaitPolicy := req.GetFrontendRequest().GetWaitPolicy()\n+\n+\tif waitPolicy == nil {\n+\t\treturn chasm.ReadComponent(ctx, ref, (*Activity).buildPollActivityExecutionResponse, req, nil)\n+\t}\n+\n+\t// Do not allow long-poll to use all remaining time\n+\tchildCtx := ctx\n+\tif deadline, ok := ctx.Deadline(); ok {\n+\t\tvar cancel context.CancelFunc\n+\t\tchildCtx, cancel = context.WithDeadline(ctx, deadline.Add(-time.Second))\n+\t\tdefer cancel()\n+\t}\n+\n+\tswitch waitPolicy.(type) {\n+\tcase *workflowservice.PollActivityExecutionRequest_WaitAnyStateChange:\n+\t\ttoken := req.GetFrontendRequest().\n+\t\t\tGetWaitPolicy().(*workflowservice.PollActivityExecutionRequest_WaitAnyStateChange).\n+\t\t\tWaitAnyStateChange.GetLongPollToken()\n+\t\tif len(token) == 0 {\n+\t\t\treturn chasm.ReadComponent(ctx, ref, (*Activity).buildPollActivityExecutionResponse, req, nil)\n+\t\t}\n+\t\tresponse, _, err = chasm.PollComponent(childCtx, ref, func(\n+\t\t\ta *Activity,\n+\t\t\tctx chasm.Context,\n+\t\t\treq *activitypb.PollActivityExecutionRequest,\n+\t\t) (*activitypb.PollActivityExecutionResponse, bool, error) {\n+\t\t\tchanged, err := chasm.ExecutionStateChanged(a, ctx, token)\n+\t\t\tif err != nil {\n+\t\t\t\tif errors.Is(err, chasm.ErrMalformedComponentRef) {\n+\t\t\t\t\treturn nil, false, serviceerror.NewInvalidArgument(\"invalid long poll token\")\n+\t\t\t\t}\n+\t\t\t\tif errors.Is(err, chasm.ErrInvalidComponentRef) {\n+\t\t\t\t\treturn nil, false, serviceerror.NewInvalidArgument(\"long poll token does not match execution\")\n+\t\t\t\t}\n+\t\t\t\treturn nil, false, err\n+\t\t\t}\n+\t\t\tif changed {\n+\t\t\t\tresponse, err := a.buildPollActivityExecutionResponse(ctx, req)\n+\t\t\t\treturn response, true, err\n+\t\t\t} else {\n+\t\t\t\treturn nil, false, nil\n+\t\t\t}\n+\t\t}, req)\n+\tcase *workflowservice.PollActivityExecutionRequest_WaitCompletion:\n+\t\t// TODO(dan): add functional test when RecordActivityTaskCompleted is implemented\n+\t\tresponse, _, err = chasm.PollComponent(childCtx, ref, func(\n+\t\t\ta *Activity,\n+\t\t\tctx chasm.Context,\n+\t\t\treq *activitypb.PollActivityExecutionRequest,\n+\t\t) (*activitypb.PollActivityExecutionResponse, bool, error) {\n+\t\t\t// TODO(dan): check for terminal activity states\n+\t\t\tpanic(\"pollActivityExecutionWaitCompletion is not implemented\")\n+\t\t\tcompleted := false\n+\t\t\tif completed {\n+\t\t\t\tresponse, err := a.buildPollActivityExecutionResponse(ctx, req)\n+\t\t\t\tif err != nil {\n+\t\t\t\t\treturn nil, true, err\n+\t\t\t\t}\n+\t\t\t\treturn response, true, nil\n+\t\t\t}\n+\t\t\treturn nil, false, nil\n+\t\t}, req)\n+\tdefault:\n+\t\treturn nil, serviceerror.NewInvalidArgumentf(\"unexpected wait policy type: %T\", waitPolicy)\n+\t}\n+\n+\tif childCtx.Err() != nil {\n+\t\t// Caller deadline exceeded\n+\t\treturn nil, childCtx.Err()\n+\t}\n+\tif errors.Is(err, context.DeadlineExceeded) {","path":"chasm/lib/activity/handler.go","commit_id":"59d749626d6a00c5fff76abe79a85eb627366521","original_commit_id":"f3115e38e18a1ba16dc583d8ef987c679a7e9683","user":{"login":"bergundy","id":52304,"node_id":"MDQ6VXNlcjUyMzA0","avatar_url":"https://avatars.githubusercontent.com/u/52304?v=4","gravatar_id":"","url":"https://api.github.com/users/bergundy","html_url":"https://github.com/bergundy","followers_url":"https://api.github.com/users/bergundy/followers","following_url":"https://api.github.com/users/bergundy/following{/other_user}","gists_url":"https://api.github.com/users/bergundy/gists{/gist_id}","starred_url":"https://api.github.com/users/bergundy/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/bergundy/subscriptions","organizations_url":"https://api.github.com/users/bergundy/orgs","repos_url":"https://api.github.com/users/bergundy/repos","events_url":"https://api.github.com/users/bergundy/events{/privacy}","received_events_url":"https://api.github.com/users/bergundy/received_events","type":"User","user_view_type":"public","site_admin":false},"body":"Always translate context deadline errors to empty responses.\nMaybe with the exception of canceled contexts, need to think about that.","created_at":"2025-11-27T03:07:41Z","updated_at":"2025-11-27T03:09:05Z","html_url":"https://github.com/temporalio/temporal/pull/8563#discussion_r2567040398","pull_request_url":"https://api.github.com/repos/temporalio/temporal/pulls/8563","_links":{"self":{"href":"https://api.github.com/repos/temporalio/temporal/pulls/comments/2567040398"},"html":{"href":"https://github.com/temporalio/temporal/pull/8563#discussion_r2567040398"},"pull_request":{"href":"https://api.github.com/repos/temporalio/temporal/pulls/8563"}},"reactions":{"url":"https://api.github.com/repos/temporalio/temporal/pulls/comments/2567040398/reactions","total_count":0,"+1":0,"-1":0,"laugh":0,"hooray":0,"confused":0,"heart":0,"rocket":0,"eyes":0},"start_line":null,"original_start_line":151,"start_side":"RIGHT","line":null,"original_line":153,"side":"RIGHT","in_reply_to_id":2567038615,"author_association":"MEMBER","original_position":109,"position":1,"subject_type":"line"},{"url":"https://api.github.com/repos/temporalio/temporal/pulls/comments/2567041845","pull_request_review_id":3513384216,"id":2567041845,"node_id":"PRRC_kwDODNqesM6ZAfM1","diff_hunk":"@@ -131,6 +132,9 @@ func (r *ComponentRef) Serialize(\n // DeserializeComponentRef deserializes a byte slice into a ComponentRef.\n // Provides caller the access to information including EntityKey, Archetype, and ShardingKey.\n func DeserializeComponentRef(data []byte) (ComponentRef, error) {\n+\tif len(data) == 0 {\n+\t\treturn ComponentRef{}, errors.New(\"empty chasm component ref\")","path":"chasm/ref.go","commit_id":"f3115e38e18a1ba16dc583d8ef987c679a7e9683","original_commit_id":"f3115e38e18a1ba16dc583d8ef987c679a7e9683","user":{"login":"bergundy","id":52304,"node_id":"MDQ6VXNlcjUyMzA0","avatar_url":"https://avatars.githubusercontent.com/u/52304?v=4","gravatar_id":"","url":"https://api.github.com/users/bergundy","html_url":"https://github.com/bergundy","followers_url":"https://api.github.com/users/bergundy/followers","following_url":"https://api.github.com/users/bergundy/following{/other_user}","gists_url":"https://api.github.com/users/bergundy/gists{/gist_id}","starred_url":"https://api.github.com/users/bergundy/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/bergundy/subscriptions","organizations_url":"https://api.github.com/users/bergundy/orgs","repos_url":"https://api.github.com/users/bergundy/repos","events_url":"https://api.github.com/users/bergundy/events{/privacy}","received_events_url":"https://api.github.com/users/bergundy/received_events","type":"User","user_view_type":"public","site_admin":false},"body":"Define this error as an exported constant.","created_at":"2025-11-27T03:08:51Z","updated_at":"2025-11-27T03:09:05Z","html_url":"https://github.com/temporalio/temporal/pull/8563#discussion_r2567041845","pull_request_url":"https://api.github.com/repos/temporalio/temporal/pulls/8563","_links":{"self":{"href":"https://api.github.com/repos/temporalio/temporal/pulls/comments/2567041845"},"html":{"href":"https://github.com/temporalio/temporal/pull/8563#discussion_r2567041845"},"pull_request":{"href":"https://api.github.com/repos/temporalio/temporal/pulls/8563"}},"reactions":{"url":"https://api.github.com/repos/temporalio/temporal/pulls/comments/2567041845/reactions","total_count":0,"+1":0,"-1":0,"laugh":0,"hooray":0,"confused":0,"heart":0,"rocket":0,"eyes":0},"start_line":null,"original_start_line":null,"start_side":null,"line":null,"original_line":136,"side":"RIGHT","author_association":"MEMBER","original_position":13,"position":1,"subject_type":"line"},{"url":"https://api.github.com/repos/temporalio/temporal/pulls/comments/2567059216","pull_request_review_id":3513427370,"id":2567059216,"node_id":"PRRC_kwDODNqesM6ZAjcQ","diff_hunk":"@@ -314,3 +315,123 @@ func (a *Activity) RecordHeartbeat(ctx chasm.MutableContext, details *commonpb.P\n \t})\n \treturn nil, nil\n }\n+\n+func (a *Activity) buildActivityExecutionInfo(ctx chasm.Context) (*activity.ActivityExecutionInfo, error) {\n+\tif a.ActivityState == nil {\n+\t\treturn nil, errors.New(\"activity state is nil\")\n+\t}\n+\n+\t// TODO(dan): support pause states\n+\tvar status enumspb.ActivityExecutionStatus\n+\tvar runState enumspb.PendingActivityState\n+\tswitch a.GetStatus() {\n+\tcase activitypb.ACTIVITY_EXECUTION_STATUS_UNSPECIFIED:\n+\t\tstatus = enumspb.ACTIVITY_EXECUTION_STATUS_UNSPECIFIED\n+\t\trunState = enumspb.PENDING_ACTIVITY_STATE_UNSPECIFIED\n+\tcase activitypb.ACTIVITY_EXECUTION_STATUS_SCHEDULED:\n+\t\tstatus = enumspb.ACTIVITY_EXECUTION_STATUS_RUNNING\n+\t\trunState = enumspb.PENDING_ACTIVITY_STATE_SCHEDULED\n+\tcase activitypb.ACTIVITY_EXECUTION_STATUS_STARTED:\n+\t\tstatus = enumspb.ACTIVITY_EXECUTION_STATUS_RUNNING\n+\t\trunState = enumspb.PENDING_ACTIVITY_STATE_STARTED\n+\tcase activitypb.ACTIVITY_EXECUTION_STATUS_CANCEL_REQUESTED:\n+\t\tstatus = enumspb.ACTIVITY_EXECUTION_STATUS_RUNNING\n+\t\trunState = enumspb.PENDING_ACTIVITY_STATE_CANCEL_REQUESTED\n+\tcase activitypb.ACTIVITY_EXECUTION_STATUS_COMPLETED:\n+\t\tstatus = enumspb.ACTIVITY_EXECUTION_STATUS_COMPLETED\n+\t\trunState = enumspb.PENDING_ACTIVITY_STATE_UNSPECIFIED\n+\tcase activitypb.ACTIVITY_EXECUTION_STATUS_FAILED:\n+\t\tstatus = enumspb.ACTIVITY_EXECUTION_STATUS_FAILED\n+\t\trunState = enumspb.PENDING_ACTIVITY_STATE_UNSPECIFIED\n+\tcase activitypb.ACTIVITY_EXECUTION_STATUS_CANCELED:\n+\t\tstatus = enumspb.ACTIVITY_EXECUTION_STATUS_CANCELED\n+\t\trunState = enumspb.PENDING_ACTIVITY_STATE_UNSPECIFIED\n+\tcase activitypb.ACTIVITY_EXECUTION_STATUS_TERMINATED:\n+\t\tstatus = enumspb.ACTIVITY_EXECUTION_STATUS_TERMINATED\n+\t\trunState = enumspb.PENDING_ACTIVITY_STATE_UNSPECIFIED\n+\tcase activitypb.ACTIVITY_EXECUTION_STATUS_TIMED_OUT:\n+\t\tstatus = enumspb.ACTIVITY_EXECUTION_STATUS_TIMED_OUT\n+\t\trunState = enumspb.PENDING_ACTIVITY_STATE_UNSPECIFIED\n+\tdefault:\n+\t\treturn nil, serviceerror.NewInternalf(\"unknown activity execution status: %s\", a.GetStatus())\n+\t}\n+\n+\trequestData, err := a.RequestData.Get(ctx)\n+\tif err != nil {\n+\t\treturn nil, err\n+\t}\n+\n+\tkey := ctx.ExecutionKey()\n+\n+\tinfo := &activity.ActivityExecutionInfo{\n+\t\tActivityId:    key.BusinessID,\n+\t\tRunId:         key.EntityID,\n+\t\tActivityType:  a.GetActivityType(),\n+\t\tStatus:        status,\n+\t\tRunState:      runState,\n+\t\tScheduledTime: a.GetScheduledTime(),\n+\t\tPriority:      a.GetPriority(),\n+\t\tHeader:        requestData.GetHeader(),\n+\t\t// TODO(dan): populate remaining fields\n+\t}\n+\n+\treturn info, nil\n+}\n+\n+func (a *Activity) buildPollActivityExecutionResponse(\n+\tctx chasm.Context,\n+\treq *activitypb.PollActivityExecutionRequest,","path":"chasm/lib/activity/activity.go","commit_id":"1d59e66d0ce5d91819f92c428ef5ab4c4efca1fb","original_commit_id":"da6009564e796063faf853352077eecdc1473612","user":{"login":"dandavison","id":52205,"node_id":"MDQ6VXNlcjUyMjA1","avatar_url":"https://avatars.githubusercontent.com/u/52205?v=4","gravatar_id":"","url":"https://api.github.com/users/dandavison","html_url":"https://github.com/dandavison","followers_url":"https://api.github.com/users/dandavison/followers","following_url":"https://api.github.com/users/dandavison/following{/other_user}","gists_url":"https://api.github.com/users/dandavison/gists{/gist_id}","starred_url":"https://api.github.com/users/dandavison/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/dandavison/subscriptions","organizations_url":"https://api.github.com/users/dandavison/orgs","repos_url":"https://api.github.com/users/dandavison/repos","events_url":"https://api.github.com/users/dandavison/events{/privacy}","received_events_url":"https://api.github.com/users/dandavison/received_events","type":"User","user_view_type":"public","site_admin":false},"body":"Sorry I'd forgotten to submit my pending replies. Reply above.","created_at":"2025-11-27T03:20:21Z","updated_at":"2025-11-27T03:20:22Z","html_url":"https://github.com/temporalio/temporal/pull/8563#discussion_r2567059216","pull_request_url":"https://api.github.com/repos/temporalio/temporal/pulls/8563","_links":{"self":{"href":"https://api.github.com/repos/temporalio/temporal/pulls/comments/2567059216"},"html":{"href":"https://github.com/temporalio/temporal/pull/8563#discussion_r2567059216"},"pull_request":{"href":"https://api.github.com/repos/temporalio/temporal/pulls/8563"}},"reactions":{"url":"https://api.github.com/repos/temporalio/temporal/pulls/comments/2567059216/reactions","total_count":0,"+1":0,"-1":0,"laugh":0,"hooray":0,"confused":0,"heart":0,"rocket":0,"eyes":0},"start_line":null,"original_start_line":null,"start_side":null,"line":383,"original_line":383,"side":"RIGHT","in_reply_to_id":2539839248,"author_association":"MEMBER","original_position":103,"position":99,"subject_type":"line"},{"url":"https://api.github.com/repos/temporalio/temporal/pulls/comments/2568385324","pull_request_review_id":3514986910,"id":2568385324,"node_id":"PRRC_kwDODNqesM6ZFnMs","diff_hunk":"@@ -37,14 +40,12 @@ type Activity struct {\n \n \t*activitypb.ActivityState\n \n-\t// Standalone only\n \tVisibility    chasm.Field[*chasm.Visibility]\n \tAttempt       chasm.Field[*activitypb.ActivityAttemptState]\n \tLastHeartbeat chasm.Field[*activitypb.ActivityHeartbeatState]\n+\tOutcome       chasm.Field[*activitypb.ActivityOutcome]","path":"chasm/lib/activity/activity.go","commit_id":"f3115e38e18a1ba16dc583d8ef987c679a7e9683","original_commit_id":"98f5e1321791f6942a3341e0ed54e5117b7d2a08","user":{"login":"dandavison","id":52205,"node_id":"MDQ6VXNlcjUyMjA1","avatar_url":"https://avatars.githubusercontent.com/u/52205?v=4","gravatar_id":"","url":"https://api.github.com/users/dandavison","html_url":"https://github.com/dandavison","followers_url":"https://api.github.com/users/dandavison/followers","following_url":"https://api.github.com/users/dandavison/following{/other_user}","gists_url":"https://api.github.com/users/dandavison/gists{/gist_id}","starred_url":"https://api.github.com/users/dandavison/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/dandavison/subscriptions","organizations_url":"https://api.github.com/users/dandavison/orgs","repos_url":"https://api.github.com/users/dandavison/repos","events_url":"https://api.github.com/users/dandavison/events{/privacy}","received_events_url":"https://api.github.com/users/dandavison/received_events","type":"User","user_view_type":"public","site_admin":false},"body":"Moved it back, not sure why I moved it in the first place.","created_at":"2025-11-27T12:16:17Z","updated_at":"2025-11-27T12:28:44Z","html_url":"https://github.com/temporalio/temporal/pull/8563#discussion_r2568385324","pull_request_url":"https://api.github.com/repos/temporalio/temporal/pulls/8563","_links":{"self":{"href":"https://api.github.com/repos/temporalio/temporal/pulls/comments/2568385324"},"html":{"href":"https://github.com/temporalio/temporal/pull/8563#discussion_r2568385324"},"pull_request":{"href":"https://api.github.com/repos/temporalio/temporal/pulls/8563"}},"reactions":{"url":"https://api.github.com/repos/temporalio/temporal/pulls/comments/2568385324/reactions","total_count":0,"+1":0,"-1":0,"laugh":0,"hooray":0,"confused":0,"heart":0,"rocket":0,"eyes":0},"start_line":null,"original_start_line":null,"start_side":null,"line":null,"original_line":46,"side":"RIGHT","in_reply_to_id":2567017490,"author_association":"MEMBER","original_position":26,"position":1,"subject_type":"line"},{"url":"https://api.github.com/repos/temporalio/temporal/pulls/comments/2568405787","pull_request_review_id":3514986910,"id":2568405787,"node_id":"PRRC_kwDODNqesM6ZFsMb","diff_hunk":"@@ -53,3 +56,115 @@ func (h *handler) StartActivityExecution(ctx context.Context, req *activitypb.St\n \t\tFrontendResponse: response,\n \t}, nil\n }\n+\n+// PollActivityExecution handles PollActivityExecutionRequest from frontend. This method supports\n+// querying current activity state, optionally as a long-poll that waits for certain state changes.\n+// It is used by clients to poll for activity state and/or result.\n+func (h *handler) PollActivityExecution(\n+\tctx context.Context,\n+\treq *activitypb.PollActivityExecutionRequest,\n+) (response *activitypb.PollActivityExecutionResponse, err error) {\n+\tref := chasm.NewComponentRef[*Activity](chasm.EntityKey{\n+\t\tNamespaceID: req.GetNamespaceId(),\n+\t\tBusinessID:  req.GetFrontendRequest().GetActivityId(),\n+\t\tEntityID:    req.GetFrontendRequest().GetRunId(),\n+\t})\n+\tdefer func() {\n+\t\tvar notFound *serviceerror.NotFound\n+\t\tif errors.As(err, &notFound) {\n+\t\t\t// TODO(dan): include execution key in error message; we may do this at the CHASM\n+\t\t\t// framework level.\n+\t\t\t// cf. \"workflow execution not found for workflow ID XXX and run ID YYY\"\n+\t\t\terr = serviceerror.NewNotFound(\"activity execution not found\")\n+\t\t}\n+\t}()\n+\n+\twaitPolicy := req.GetFrontendRequest().GetWaitPolicy()\n+\n+\tif waitPolicy == nil {\n+\t\treturn chasm.ReadComponent(ctx, ref, (*Activity).buildPollActivityExecutionResponse, req, nil)\n+\t}\n+\n+\t// Do not allow long-poll to use all remaining time\n+\tchildCtx := ctx\n+\tif deadline, ok := ctx.Deadline(); ok {\n+\t\tvar cancel context.CancelFunc\n+\t\tchildCtx, cancel = context.WithDeadline(ctx, deadline.Add(-time.Second))\n+\t\tdefer cancel()\n+\t}\n+\n+\tswitch waitPolicy.(type) {\n+\tcase *workflowservice.PollActivityExecutionRequest_WaitAnyStateChange:\n+\t\ttoken := req.GetFrontendRequest().\n+\t\t\tGetWaitPolicy().(*workflowservice.PollActivityExecutionRequest_WaitAnyStateChange).\n+\t\t\tWaitAnyStateChange.GetLongPollToken()\n+\t\tif len(token) == 0 {\n+\t\t\treturn chasm.ReadComponent(ctx, ref, (*Activity).buildPollActivityExecutionResponse, req, nil)\n+\t\t}\n+\t\tresponse, _, err = chasm.PollComponent(childCtx, ref, func(\n+\t\t\ta *Activity,\n+\t\t\tctx chasm.Context,\n+\t\t\treq *activitypb.PollActivityExecutionRequest,\n+\t\t) (*activitypb.PollActivityExecutionResponse, bool, error) {\n+\t\t\tchanged, err := chasm.ExecutionStateChanged(a, ctx, token)\n+\t\t\tif err != nil {\n+\t\t\t\tif errors.Is(err, chasm.ErrMalformedComponentRef) {\n+\t\t\t\t\treturn nil, false, serviceerror.NewInvalidArgument(\"invalid long poll token\")\n+\t\t\t\t}\n+\t\t\t\tif errors.Is(err, chasm.ErrInvalidComponentRef) {\n+\t\t\t\t\treturn nil, false, serviceerror.NewInvalidArgument(\"long poll token does not match execution\")\n+\t\t\t\t}\n+\t\t\t\treturn nil, false, err\n+\t\t\t}\n+\t\t\tif changed {\n+\t\t\t\tresponse, err := a.buildPollActivityExecutionResponse(ctx, req)\n+\t\t\t\treturn response, true, err\n+\t\t\t} else {\n+\t\t\t\treturn nil, false, nil\n+\t\t\t}\n+\t\t}, req)\n+\tcase *workflowservice.PollActivityExecutionRequest_WaitCompletion:\n+\t\t// TODO(dan): add functional test when RecordActivityTaskCompleted is implemented\n+\t\tresponse, _, err = chasm.PollComponent(childCtx, ref, func(\n+\t\t\ta *Activity,\n+\t\t\tctx chasm.Context,\n+\t\t\treq *activitypb.PollActivityExecutionRequest,\n+\t\t) (*activitypb.PollActivityExecutionResponse, bool, error) {\n+\t\t\t// TODO(dan): check for terminal activity states\n+\t\t\tpanic(\"pollActivityExecutionWaitCompletion is not implemented\")\n+\t\t\tcompleted := false\n+\t\t\tif completed {\n+\t\t\t\tresponse, err := a.buildPollActivityExecutionResponse(ctx, req)\n+\t\t\t\tif err != nil {\n+\t\t\t\t\treturn nil, true, err\n+\t\t\t\t}\n+\t\t\t\treturn response, true, nil\n+\t\t\t}\n+\t\t\treturn nil, false, nil\n+\t\t}, req)\n+\tdefault:\n+\t\treturn nil, serviceerror.NewInvalidArgumentf(\"unexpected wait policy type: %T\", waitPolicy)\n+\t}\n+\n+\tif childCtx.Err() != nil {\n+\t\t// Caller deadline exceeded\n+\t\treturn nil, childCtx.Err()\n+\t}\n+\tif errors.Is(err, context.DeadlineExceeded) {","path":"chasm/lib/activity/handler.go","commit_id":"59d749626d6a00c5fff76abe79a85eb627366521","original_commit_id":"f3115e38e18a1ba16dc583d8ef987c679a7e9683","user":{"login":"dandavison","id":52205,"node_id":"MDQ6VXNlcjUyMjA1","avatar_url":"https://avatars.githubusercontent.com/u/52205?v=4","gravatar_id":"","url":"https://api.github.com/users/dandavison","html_url":"https://github.com/dandavison","followers_url":"https://api.github.com/users/dandavison/followers","following_url":"https://api.github.com/users/dandavison/following{/other_user}","gists_url":"https://api.github.com/users/dandavison/gists{/gist_id}","starred_url":"https://api.github.com/users/dandavison/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/dandavison/subscriptions","organizations_url":"https://api.github.com/users/dandavison/orgs","repos_url":"https://api.github.com/users/dandavison/repos","events_url":"https://api.github.com/users/dandavison/events{/privacy}","received_events_url":"https://api.github.com/users/dandavison/received_events","type":"User","user_view_type":"public","site_admin":false},"body":"> Always translate context deadline errors to empty responses.\r\n\r\nThe logic we're aiming to implement is that there is an empty response if the server-imposed deadline expires, but if the caller's deadline expires it's `DeadlineExceeded` as usual. Here `childCtx` represents the caller's deadline (minus `1s` buffer).","created_at":"2025-11-27T12:21:35Z","updated_at":"2025-11-27T12:28:44Z","html_url":"https://github.com/temporalio/temporal/pull/8563#discussion_r2568405787","pull_request_url":"https://api.github.com/repos/temporalio/temporal/pulls/8563","_links":{"self":{"href":"https://api.github.com/repos/temporalio/temporal/pulls/comments/2568405787"},"html":{"href":"https://github.com/temporalio/temporal/pull/8563#discussion_r2568405787"},"pull_request":{"href":"https://api.github.com/repos/temporalio/temporal/pulls/8563"}},"reactions":{"url":"https://api.github.com/repos/temporalio/temporal/pulls/comments/2568405787/reactions","total_count":0,"+1":0,"-1":0,"laugh":0,"hooray":0,"confused":0,"heart":0,"rocket":0,"eyes":0},"start_line":null,"original_start_line":151,"start_side":"RIGHT","line":null,"original_line":153,"side":"RIGHT","in_reply_to_id":2567038615,"author_association":"MEMBER","original_position":109,"position":1,"subject_type":"line"},{"url":"https://api.github.com/repos/temporalio/temporal/pulls/comments/2568408368","pull_request_review_id":3514986910,"id":2568408368,"node_id":"PRRC_kwDODNqesM6ZFs0w","diff_hunk":"@@ -51,3 +54,115 @@ func (h *handler) StartActivityExecution(ctx context.Context, req *activitypb.St\n \t\tFrontendResponse: response,\n \t}, nil\n }\n+\n+// PollActivityExecution handles PollActivityExecutionRequest from frontend. This method supports\n+// querying current activity state, optionally as a long-poll that waits for certain state changes.\n+// It is used by clients to poll for activity state and/or result.\n+func (h *handler) PollActivityExecution(\n+\tctx context.Context,\n+\treq *activitypb.PollActivityExecutionRequest,\n+) (response *activitypb.PollActivityExecutionResponse, err error) {\n+\tref := chasm.NewComponentRef[*Activity](chasm.EntityKey{\n+\t\tNamespaceID: req.GetNamespaceId(),\n+\t\tBusinessID:  req.GetFrontendRequest().GetActivityId(),\n+\t\tEntityID:    req.GetFrontendRequest().GetRunId(),\n+\t})\n+\tdefer func() {\n+\t\tvar notFound *serviceerror.NotFound\n+\t\tif errors.As(err, &notFound) {\n+\t\t\t// TODO(dan): include execution key in error message; we may do this at the CHASM\n+\t\t\t// framework level.\n+\t\t\t// cf. \"workflow execution not found for workflow ID XXX and run ID YYY\"\n+\t\t\terr = serviceerror.NewNotFound(\"activity execution not found\")\n+\t\t}\n+\t}()\n+\n+\twaitPolicy := req.GetFrontendRequest().GetWaitPolicy()\n+\n+\tif waitPolicy == nil {\n+\t\treturn chasm.ReadComponent(ctx, ref, (*Activity).buildPollActivityExecutionResponse, req, nil)\n+\t}\n+\n+\t// Do not allow long-poll to use all remaining time\n+\tchildCtx := ctx\n+\tif deadline, ok := ctx.Deadline(); ok {","path":"chasm/lib/activity/handler.go","commit_id":"59d749626d6a00c5fff76abe79a85eb627366521","original_commit_id":"98f5e1321791f6942a3341e0ed54e5117b7d2a08","user":{"login":"dandavison","id":52205,"node_id":"MDQ6VXNlcjUyMjA1","avatar_url":"https://avatars.githubusercontent.com/u/52205?v=4","gravatar_id":"","url":"https://api.github.com/users/dandavison","html_url":"https://github.com/dandavison","followers_url":"https://api.github.com/users/dandavison/followers","following_url":"https://api.github.com/users/dandavison/following{/other_user}","gists_url":"https://api.github.com/users/dandavison/gists{/gist_id}","starred_url":"https://api.github.com/users/dandavison/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/dandavison/subscriptions","organizations_url":"https://api.github.com/users/dandavison/orgs","repos_url":"https://api.github.com/users/dandavison/repos","events_url":"https://api.github.com/users/dandavison/events{/privacy}","received_events_url":"https://api.github.com/users/dandavison/received_events","type":"User","user_view_type":"public","site_admin":false},"body":"The long-poll is capped to `LongPollExpirationInterval` in `PollComponent`. Are you suggesting we add an additional ad-hoc cap here?","created_at":"2025-11-27T12:22:14Z","updated_at":"2025-11-27T12:29:53Z","html_url":"https://github.com/temporalio/temporal/pull/8563#discussion_r2568408368","pull_request_url":"https://api.github.com/repos/temporalio/temporal/pulls/8563","_links":{"self":{"href":"https://api.github.com/repos/temporalio/temporal/pulls/comments/2568408368"},"html":{"href":"https://github.com/temporalio/temporal/pull/8563#discussion_r2568408368"},"pull_request":{"href":"https://api.github.com/repos/temporalio/temporal/pulls/8563"}},"reactions":{"url":"https://api.github.com/repos/temporalio/temporal/pulls/comments/2568408368/reactions","total_count":0,"+1":0,"-1":0,"laugh":0,"hooray":0,"confused":0,"heart":0,"rocket":0,"eyes":0},"start_line":null,"original_start_line":null,"start_side":null,"line":null,"original_line":88,"side":"RIGHT","in_reply_to_id":2567023825,"author_association":"MEMBER","original_position":46,"position":1,"subject_type":"line"},{"url":"https://api.github.com/repos/temporalio/temporal/pulls/comments/2568433276","pull_request_review_id":3514986910,"id":2568433276,"node_id":"PRRC_kwDODNqesM6ZFy58","diff_hunk":"@@ -131,6 +132,9 @@ func (r *ComponentRef) Serialize(\n // DeserializeComponentRef deserializes a byte slice into a ComponentRef.\n // Provides caller the access to information including EntityKey, Archetype, and ShardingKey.\n func DeserializeComponentRef(data []byte) (ComponentRef, error) {\n+\tif len(data) == 0 {\n+\t\treturn ComponentRef{}, errors.New(\"empty chasm component ref\")","path":"chasm/ref.go","commit_id":"f3115e38e18a1ba16dc583d8ef987c679a7e9683","original_commit_id":"f3115e38e18a1ba16dc583d8ef987c679a7e9683","user":{"login":"dandavison","id":52205,"node_id":"MDQ6VXNlcjUyMjA1","avatar_url":"https://avatars.githubusercontent.com/u/52205?v=4","gravatar_id":"","url":"https://api.github.com/users/dandavison","html_url":"https://github.com/dandavison","followers_url":"https://api.github.com/users/dandavison/followers","following_url":"https://api.github.com/users/dandavison/following{/other_user}","gists_url":"https://api.github.com/users/dandavison/gists{/gist_id}","starred_url":"https://api.github.com/users/dandavison/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/dandavison/subscriptions","organizations_url":"https://api.github.com/users/dandavison/orgs","repos_url":"https://api.github.com/users/dandavison/repos","events_url":"https://api.github.com/users/dandavison/events{/privacy}","received_events_url":"https://api.github.com/users/dandavison/received_events","type":"User","user_view_type":"public","site_admin":false},"body":"Done","created_at":"2025-11-27T12:27:54Z","updated_at":"2025-11-27T12:28:44Z","html_url":"https://github.com/temporalio/temporal/pull/8563#discussion_r2568433276","pull_request_url":"https://api.github.com/repos/temporalio/temporal/pulls/8563","_links":{"self":{"href":"https://api.github.com/repos/temporalio/temporal/pulls/comments/2568433276"},"html":{"href":"https://github.com/temporalio/temporal/pull/8563#discussion_r2568433276"},"pull_request":{"href":"https://api.github.com/repos/temporalio/temporal/pulls/8563"}},"reactions":{"url":"https://api.github.com/repos/temporalio/temporal/pulls/comments/2568433276/reactions","total_count":0,"+1":0,"-1":0,"laugh":0,"hooray":0,"confused":0,"heart":0,"rocket":0,"eyes":0},"start_line":null,"original_start_line":null,"start_side":null,"line":null,"original_line":136,"side":"RIGHT","in_reply_to_id":2567041845,"author_association":"MEMBER","original_position":13,"position":1,"subject_type":"line"},{"url":"https://api.github.com/repos/temporalio/temporal/pulls/comments/2568440789","pull_request_review_id":3515058471,"id":2568440789,"node_id":"PRRC_kwDODNqesM6ZF0vV","diff_hunk":"@@ -53,3 +56,115 @@ func (h *handler) StartActivityExecution(ctx context.Context, req *activitypb.St\n \t\tFrontendResponse: response,\n \t}, nil\n }\n+\n+// PollActivityExecution handles PollActivityExecutionRequest from frontend. This method supports\n+// querying current activity state, optionally as a long-poll that waits for certain state changes.\n+// It is used by clients to poll for activity state and/or result.\n+func (h *handler) PollActivityExecution(\n+\tctx context.Context,\n+\treq *activitypb.PollActivityExecutionRequest,\n+) (response *activitypb.PollActivityExecutionResponse, err error) {\n+\tref := chasm.NewComponentRef[*Activity](chasm.EntityKey{\n+\t\tNamespaceID: req.GetNamespaceId(),\n+\t\tBusinessID:  req.GetFrontendRequest().GetActivityId(),\n+\t\tEntityID:    req.GetFrontendRequest().GetRunId(),\n+\t})\n+\tdefer func() {\n+\t\tvar notFound *serviceerror.NotFound\n+\t\tif errors.As(err, &notFound) {\n+\t\t\t// TODO(dan): include execution key in error message; we may do this at the CHASM\n+\t\t\t// framework level.\n+\t\t\t// cf. \"workflow execution not found for workflow ID XXX and run ID YYY\"\n+\t\t\terr = serviceerror.NewNotFound(\"activity execution not found\")\n+\t\t}\n+\t}()\n+\n+\twaitPolicy := req.GetFrontendRequest().GetWaitPolicy()\n+\n+\tif waitPolicy == nil {\n+\t\treturn chasm.ReadComponent(ctx, ref, (*Activity).buildPollActivityExecutionResponse, req, nil)\n+\t}\n+\n+\t// Do not allow long-poll to use all remaining time\n+\tchildCtx := ctx\n+\tif deadline, ok := ctx.Deadline(); ok {\n+\t\tvar cancel context.CancelFunc\n+\t\tchildCtx, cancel = context.WithDeadline(ctx, deadline.Add(-time.Second))","path":"chasm/lib/activity/handler.go","commit_id":"59d749626d6a00c5fff76abe79a85eb627366521","original_commit_id":"f3115e38e18a1ba16dc583d8ef987c679a7e9683","user":{"login":"dandavison","id":52205,"node_id":"MDQ6VXNlcjUyMjA1","avatar_url":"https://avatars.githubusercontent.com/u/52205?v=4","gravatar_id":"","url":"https://api.github.com/users/dandavison","html_url":"https://github.com/dandavison","followers_url":"https://api.github.com/users/dandavison/followers","following_url":"https://api.github.com/users/dandavison/following{/other_user}","gists_url":"https://api.github.com/users/dandavison/gists{/gist_id}","starred_url":"https://api.github.com/users/dandavison/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/dandavison/subscriptions","organizations_url":"https://api.github.com/users/dandavison/orgs","repos_url":"https://api.github.com/users/dandavison/repos","events_url":"https://api.github.com/users/dandavison/events{/privacy}","received_events_url":"https://api.github.com/users/dandavison/received_events","type":"User","user_view_type":"public","site_admin":false},"body":"Please see reply below.","created_at":"2025-11-27T12:29:30Z","updated_at":"2025-11-27T12:29:30Z","html_url":"https://github.com/temporalio/temporal/pull/8563#discussion_r2568440789","pull_request_url":"https://api.github.com/repos/temporalio/temporal/pulls/8563","_links":{"self":{"href":"https://api.github.com/repos/temporalio/temporal/pulls/comments/2568440789"},"html":{"href":"https://github.com/temporalio/temporal/pull/8563#discussion_r2568440789"},"pull_request":{"href":"https://api.github.com/repos/temporalio/temporal/pulls/8563"}},"reactions":{"url":"https://api.github.com/repos/temporalio/temporal/pulls/comments/2568440789/reactions","total_count":0,"+1":0,"-1":0,"laugh":0,"hooray":0,"confused":0,"heart":0,"rocket":0,"eyes":0},"start_line":null,"original_start_line":null,"start_side":null,"line":null,"original_line":92,"side":"RIGHT","in_reply_to_id":2567037755,"author_association":"MEMBER","original_position":48,"position":1,"subject_type":"line"},{"url":"https://api.github.com/repos/temporalio/temporal/pulls/comments/2569499461","pull_request_review_id":3516352893,"id":2569499461,"node_id":"PRRC_kwDODNqesM6ZJ3NF","diff_hunk":"@@ -53,3 +56,115 @@ func (h *handler) StartActivityExecution(ctx context.Context, req *activitypb.St\n \t\tFrontendResponse: response,\n \t}, nil\n }\n+\n+// PollActivityExecution handles PollActivityExecutionRequest from frontend. This method supports\n+// querying current activity state, optionally as a long-poll that waits for certain state changes.\n+// It is used by clients to poll for activity state and/or result.\n+func (h *handler) PollActivityExecution(\n+\tctx context.Context,\n+\treq *activitypb.PollActivityExecutionRequest,\n+) (response *activitypb.PollActivityExecutionResponse, err error) {\n+\tref := chasm.NewComponentRef[*Activity](chasm.EntityKey{\n+\t\tNamespaceID: req.GetNamespaceId(),\n+\t\tBusinessID:  req.GetFrontendRequest().GetActivityId(),\n+\t\tEntityID:    req.GetFrontendRequest().GetRunId(),\n+\t})\n+\tdefer func() {\n+\t\tvar notFound *serviceerror.NotFound\n+\t\tif errors.As(err, &notFound) {\n+\t\t\t// TODO(dan): include execution key in error message; we may do this at the CHASM\n+\t\t\t// framework level.\n+\t\t\t// cf. \"workflow execution not found for workflow ID XXX and run ID YYY\"\n+\t\t\terr = serviceerror.NewNotFound(\"activity execution not found\")\n+\t\t}\n+\t}()\n+\n+\twaitPolicy := req.GetFrontendRequest().GetWaitPolicy()\n+\n+\tif waitPolicy == nil {\n+\t\treturn chasm.ReadComponent(ctx, ref, (*Activity).buildPollActivityExecutionResponse, req, nil)\n+\t}\n+\n+\t// Do not allow long-poll to use all remaining time\n+\tchildCtx := ctx\n+\tif deadline, ok := ctx.Deadline(); ok {\n+\t\tvar cancel context.CancelFunc\n+\t\tchildCtx, cancel = context.WithDeadline(ctx, deadline.Add(-time.Second))\n+\t\tdefer cancel()\n+\t}\n+\n+\tswitch waitPolicy.(type) {\n+\tcase *workflowservice.PollActivityExecutionRequest_WaitAnyStateChange:\n+\t\ttoken := req.GetFrontendRequest().\n+\t\t\tGetWaitPolicy().(*workflowservice.PollActivityExecutionRequest_WaitAnyStateChange).\n+\t\t\tWaitAnyStateChange.GetLongPollToken()\n+\t\tif len(token) == 0 {\n+\t\t\treturn chasm.ReadComponent(ctx, ref, (*Activity).buildPollActivityExecutionResponse, req, nil)\n+\t\t}\n+\t\tresponse, _, err = chasm.PollComponent(childCtx, ref, func(\n+\t\t\ta *Activity,\n+\t\t\tctx chasm.Context,\n+\t\t\treq *activitypb.PollActivityExecutionRequest,\n+\t\t) (*activitypb.PollActivityExecutionResponse, bool, error) {\n+\t\t\tchanged, err := chasm.ExecutionStateChanged(a, ctx, token)\n+\t\t\tif err != nil {\n+\t\t\t\tif errors.Is(err, chasm.ErrMalformedComponentRef) {\n+\t\t\t\t\treturn nil, false, serviceerror.NewInvalidArgument(\"invalid long poll token\")\n+\t\t\t\t}\n+\t\t\t\tif errors.Is(err, chasm.ErrInvalidComponentRef) {\n+\t\t\t\t\treturn nil, false, serviceerror.NewInvalidArgument(\"long poll token does not match execution\")\n+\t\t\t\t}\n+\t\t\t\treturn nil, false, err\n+\t\t\t}\n+\t\t\tif changed {\n+\t\t\t\tresponse, err := a.buildPollActivityExecutionResponse(ctx, req)\n+\t\t\t\treturn response, true, err\n+\t\t\t} else {\n+\t\t\t\treturn nil, false, nil\n+\t\t\t}\n+\t\t}, req)\n+\tcase *workflowservice.PollActivityExecutionRequest_WaitCompletion:\n+\t\t// TODO(dan): add functional test when RecordActivityTaskCompleted is implemented\n+\t\tresponse, _, err = chasm.PollComponent(childCtx, ref, func(\n+\t\t\ta *Activity,\n+\t\t\tctx chasm.Context,\n+\t\t\treq *activitypb.PollActivityExecutionRequest,\n+\t\t) (*activitypb.PollActivityExecutionResponse, bool, error) {\n+\t\t\t// TODO(dan): check for terminal activity states\n+\t\t\tpanic(\"pollActivityExecutionWaitCompletion is not implemented\")\n+\t\t\tcompleted := false\n+\t\t\tif completed {\n+\t\t\t\tresponse, err := a.buildPollActivityExecutionResponse(ctx, req)\n+\t\t\t\tif err != nil {\n+\t\t\t\t\treturn nil, true, err\n+\t\t\t\t}\n+\t\t\t\treturn response, true, nil\n+\t\t\t}\n+\t\t\treturn nil, false, nil\n+\t\t}, req)\n+\tdefault:\n+\t\treturn nil, serviceerror.NewInvalidArgumentf(\"unexpected wait policy type: %T\", waitPolicy)\n+\t}\n+\n+\tif childCtx.Err() != nil {\n+\t\t// Caller deadline exceeded\n+\t\treturn nil, childCtx.Err()\n+\t}\n+\tif errors.Is(err, context.DeadlineExceeded) {","path":"chasm/lib/activity/handler.go","commit_id":"59d749626d6a00c5fff76abe79a85eb627366521","original_commit_id":"f3115e38e18a1ba16dc583d8ef987c679a7e9683","user":{"login":"dandavison","id":52205,"node_id":"MDQ6VXNlcjUyMjA1","avatar_url":"https://avatars.githubusercontent.com/u/52205?v=4","gravatar_id":"","url":"https://api.github.com/users/dandavison","html_url":"https://github.com/dandavison","followers_url":"https://api.github.com/users/dandavison/followers","following_url":"https://api.github.com/users/dandavison/following{/other_user}","gists_url":"https://api.github.com/users/dandavison/gists{/gist_id}","starred_url":"https://api.github.com/users/dandavison/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/dandavison/subscriptions","organizations_url":"https://api.github.com/users/dandavison/orgs","repos_url":"https://api.github.com/users/dandavison/repos","events_url":"https://api.github.com/users/dandavison/events{/privacy}","received_events_url":"https://api.github.com/users/dandavison/received_events","type":"User","user_view_type":"public","site_admin":false},"body":"If we're not on the same page here then let's first agree on requirements via the test `Test_PollActivityExecution_DeadlineExceeded`. Then once the requirements are agreed we can settle the implementation.","created_at":"2025-11-27T16:37:46Z","updated_at":"2025-11-27T16:38:02Z","html_url":"https://github.com/temporalio/temporal/pull/8563#discussion_r2569499461","pull_request_url":"https://api.github.com/repos/temporalio/temporal/pulls/8563","_links":{"self":{"href":"https://api.github.com/repos/temporalio/temporal/pulls/comments/2569499461"},"html":{"href":"https://github.com/temporalio/temporal/pull/8563#discussion_r2569499461"},"pull_request":{"href":"https://api.github.com/repos/temporalio/temporal/pulls/8563"}},"reactions":{"url":"https://api.github.com/repos/temporalio/temporal/pulls/comments/2569499461/reactions","total_count":0,"+1":0,"-1":0,"laugh":0,"hooray":0,"confused":0,"heart":0,"rocket":0,"eyes":0},"start_line":null,"original_start_line":151,"start_side":"RIGHT","line":null,"original_line":153,"side":"RIGHT","in_reply_to_id":2567038615,"author_association":"MEMBER","original_position":109,"position":1,"subject_type":"line"},{"url":"https://api.github.com/repos/temporalio/temporal/pulls/comments/2569732238","pull_request_review_id":3516617760,"id":2569732238,"node_id":"PRRC_kwDODNqesM6ZKwCO","diff_hunk":"@@ -314,3 +315,141 @@ func (a *Activity) RecordHeartbeat(ctx chasm.MutableContext, details *commonpb.P\n \t})\n \treturn nil, nil\n }\n+\n+func (a *Activity) buildActivityExecutionInfo(ctx chasm.Context) (*activity.ActivityExecutionInfo, error) {\n+\tif a.ActivityState == nil {\n+\t\treturn nil, errors.New(\"activity state is nil\")\n+\t}\n+\n+\t// TODO(dan): support pause states\n+\tvar status enumspb.ActivityExecutionStatus\n+\tvar runState enumspb.PendingActivityState\n+\tswitch a.GetStatus() {\n+\tcase activitypb.ACTIVITY_EXECUTION_STATUS_UNSPECIFIED:\n+\t\tstatus = enumspb.ACTIVITY_EXECUTION_STATUS_UNSPECIFIED\n+\t\trunState = enumspb.PENDING_ACTIVITY_STATE_UNSPECIFIED\n+\tcase activitypb.ACTIVITY_EXECUTION_STATUS_SCHEDULED:\n+\t\tstatus = enumspb.ACTIVITY_EXECUTION_STATUS_RUNNING\n+\t\trunState = enumspb.PENDING_ACTIVITY_STATE_SCHEDULED\n+\tcase activitypb.ACTIVITY_EXECUTION_STATUS_STARTED:\n+\t\tstatus = enumspb.ACTIVITY_EXECUTION_STATUS_RUNNING\n+\t\trunState = enumspb.PENDING_ACTIVITY_STATE_STARTED\n+\tcase activitypb.ACTIVITY_EXECUTION_STATUS_CANCEL_REQUESTED:\n+\t\tstatus = enumspb.ACTIVITY_EXECUTION_STATUS_RUNNING\n+\t\trunState = enumspb.PENDING_ACTIVITY_STATE_CANCEL_REQUESTED\n+\tcase activitypb.ACTIVITY_EXECUTION_STATUS_COMPLETED:\n+\t\tstatus = enumspb.ACTIVITY_EXECUTION_STATUS_COMPLETED\n+\t\trunState = enumspb.PENDING_ACTIVITY_STATE_UNSPECIFIED\n+\tcase activitypb.ACTIVITY_EXECUTION_STATUS_FAILED:\n+\t\tstatus = enumspb.ACTIVITY_EXECUTION_STATUS_FAILED\n+\t\trunState = enumspb.PENDING_ACTIVITY_STATE_UNSPECIFIED\n+\tcase activitypb.ACTIVITY_EXECUTION_STATUS_CANCELED:\n+\t\tstatus = enumspb.ACTIVITY_EXECUTION_STATUS_CANCELED\n+\t\trunState = enumspb.PENDING_ACTIVITY_STATE_UNSPECIFIED\n+\tcase activitypb.ACTIVITY_EXECUTION_STATUS_TERMINATED:\n+\t\tstatus = enumspb.ACTIVITY_EXECUTION_STATUS_TERMINATED\n+\t\trunState = enumspb.PENDING_ACTIVITY_STATE_UNSPECIFIED\n+\tcase activitypb.ACTIVITY_EXECUTION_STATUS_TIMED_OUT:\n+\t\tstatus = enumspb.ACTIVITY_EXECUTION_STATUS_TIMED_OUT\n+\t\trunState = enumspb.PENDING_ACTIVITY_STATE_UNSPECIFIED\n+\tdefault:\n+\t\treturn nil, serviceerror.NewInternalf(\"unknown activity execution status: %s\", a.GetStatus())\n+\t}\n+\n+\trequestData, err := a.RequestData.Get(ctx)\n+\tif err != nil {\n+\t\treturn nil, err\n+\t}\n+\n+\tkey := ctx.ExecutionKey()\n+\n+\tinfo := &activity.ActivityExecutionInfo{\n+\t\tActivityId:    key.BusinessID,\n+\t\tRunId:         key.EntityID,\n+\t\tActivityType:  a.GetActivityType(),\n+\t\tStatus:        status,\n+\t\tRunState:      runState,\n+\t\tScheduledTime: a.GetScheduledTime(),\n+\t\tPriority:      a.GetPriority(),\n+\t\tHeader:        requestData.GetHeader(),\n+\t\t// TODO(dan): populate remaining fields\n+\t}\n+\n+\treturn info, nil\n+}\n+\n+func (a *Activity) buildPollActivityExecutionResponse(\n+\tctx chasm.Context,\n+\treq *activitypb.PollActivityExecutionRequest,\n+) (*activitypb.PollActivityExecutionResponse, error) {\n+\trequest := req.GetFrontendRequest()\n+\n+\ttoken, err := ctx.Ref(a)\n+\tif err != nil {\n+\t\treturn nil, err\n+\t}\n+\n+\tvar info *activity.ActivityExecutionInfo\n+\tif request.GetIncludeInfo() {\n+\t\tinfo, err = a.buildActivityExecutionInfo(ctx)\n+\t\tif err != nil {\n+\t\t\treturn nil, err\n+\t\t}\n+\t}\n+\n+\tvar input *commonpb.Payloads\n+\tif request.GetIncludeInput() {\n+\t\tactivityRequest, err := a.RequestData.Get(ctx)\n+\t\tif err != nil {\n+\t\t\treturn nil, err\n+\t\t}\n+\t\tinput = activityRequest.GetInput()\n+\t}\n+\n+\tresponse := &workflowservice.PollActivityExecutionResponse{\n+\t\tInfo:                     info,\n+\t\tRunId:                    ctx.ExecutionKey().EntityID,\n+\t\tInput:                    input,\n+\t\tStateChangeLongPollToken: token,\n+\t}\n+\n+\tif request.GetIncludeOutcome() {","path":"chasm/lib/activity/activity.go","commit_id":"1d59e66d0ce5d91819f92c428ef5ab4c4efca1fb","original_commit_id":"98f5e1321791f6942a3341e0ed54e5117b7d2a08","user":{"login":"dandavison","id":52205,"node_id":"MDQ6VXNlcjUyMjA1","avatar_url":"https://avatars.githubusercontent.com/u/52205?v=4","gravatar_id":"","url":"https://api.github.com/users/dandavison","html_url":"https://github.com/dandavison","followers_url":"https://api.github.com/users/dandavison/followers","following_url":"https://api.github.com/users/dandavison/following{/other_user}","gists_url":"https://api.github.com/users/dandavison/gists{/gist_id}","starred_url":"https://api.github.com/users/dandavison/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/dandavison/subscriptions","organizations_url":"https://api.github.com/users/dandavison/orgs","repos_url":"https://api.github.com/users/dandavison/repos","events_url":"https://api.github.com/users/dandavison/events{/privacy}","received_events_url":"https://api.github.com/users/dandavison/received_events","type":"User","user_view_type":"public","site_admin":false},"body":"I think it's not correct yet: it's checking for `nil` outcome, but in @fretz12's later branches we are setting the outcome failure to an empty struct on handling `RecordActivityTaskFailed` when retries are exhausted: https://github.com/temporalio/temporal/blob/saa-id-policy/chasm/lib/activity/activity.go#L395.\r\n\r\nThe result will be that we fail to obtain the failure from the attempt last failure details. I'll creating a failing test case on a subsequent PR; marking with a TODO on this branch as its not testable here.","created_at":"2025-11-27T18:25:11Z","updated_at":"2025-11-27T18:26:27Z","html_url":"https://github.com/temporalio/temporal/pull/8563#discussion_r2569732238","pull_request_url":"https://api.github.com/repos/temporalio/temporal/pulls/8563","_links":{"self":{"href":"https://api.github.com/repos/temporalio/temporal/pulls/comments/2569732238"},"html":{"href":"https://github.com/temporalio/temporal/pull/8563#discussion_r2569732238"},"pull_request":{"href":"https://api.github.com/repos/temporalio/temporal/pulls/8563"}},"reactions":{"url":"https://api.github.com/repos/temporalio/temporal/pulls/comments/2569732238/reactions","total_count":0,"+1":0,"-1":0,"laugh":0,"hooray":0,"confused":0,"heart":0,"rocket":0,"eyes":0},"start_line":null,"original_start_line":null,"start_side":null,"line":416,"original_line":416,"side":"RIGHT","in_reply_to_id":2567021052,"author_association":"MEMBER","original_position":136,"position":132,"subject_type":"line"},{"url":"https://api.github.com/repos/temporalio/temporal/pulls/comments/2570465393","pull_request_review_id":3517467078,"id":2570465393,"node_id":"PRRC_kwDODNqesM6ZNjBx","diff_hunk":"@@ -314,3 +315,141 @@ func (a *Activity) RecordHeartbeat(ctx chasm.MutableContext, details *commonpb.P\n \t})\n \treturn nil, nil\n }\n+\n+func (a *Activity) buildActivityExecutionInfo(ctx chasm.Context) (*activity.ActivityExecutionInfo, error) {\n+\tif a.ActivityState == nil {\n+\t\treturn nil, errors.New(\"activity state is nil\")\n+\t}\n+\n+\t// TODO(dan): support pause states\n+\tvar status enumspb.ActivityExecutionStatus\n+\tvar runState enumspb.PendingActivityState\n+\tswitch a.GetStatus() {\n+\tcase activitypb.ACTIVITY_EXECUTION_STATUS_UNSPECIFIED:\n+\t\tstatus = enumspb.ACTIVITY_EXECUTION_STATUS_UNSPECIFIED\n+\t\trunState = enumspb.PENDING_ACTIVITY_STATE_UNSPECIFIED\n+\tcase activitypb.ACTIVITY_EXECUTION_STATUS_SCHEDULED:\n+\t\tstatus = enumspb.ACTIVITY_EXECUTION_STATUS_RUNNING\n+\t\trunState = enumspb.PENDING_ACTIVITY_STATE_SCHEDULED\n+\tcase activitypb.ACTIVITY_EXECUTION_STATUS_STARTED:\n+\t\tstatus = enumspb.ACTIVITY_EXECUTION_STATUS_RUNNING\n+\t\trunState = enumspb.PENDING_ACTIVITY_STATE_STARTED\n+\tcase activitypb.ACTIVITY_EXECUTION_STATUS_CANCEL_REQUESTED:\n+\t\tstatus = enumspb.ACTIVITY_EXECUTION_STATUS_RUNNING\n+\t\trunState = enumspb.PENDING_ACTIVITY_STATE_CANCEL_REQUESTED\n+\tcase activitypb.ACTIVITY_EXECUTION_STATUS_COMPLETED:\n+\t\tstatus = enumspb.ACTIVITY_EXECUTION_STATUS_COMPLETED\n+\t\trunState = enumspb.PENDING_ACTIVITY_STATE_UNSPECIFIED\n+\tcase activitypb.ACTIVITY_EXECUTION_STATUS_FAILED:\n+\t\tstatus = enumspb.ACTIVITY_EXECUTION_STATUS_FAILED\n+\t\trunState = enumspb.PENDING_ACTIVITY_STATE_UNSPECIFIED\n+\tcase activitypb.ACTIVITY_EXECUTION_STATUS_CANCELED:\n+\t\tstatus = enumspb.ACTIVITY_EXECUTION_STATUS_CANCELED\n+\t\trunState = enumspb.PENDING_ACTIVITY_STATE_UNSPECIFIED\n+\tcase activitypb.ACTIVITY_EXECUTION_STATUS_TERMINATED:\n+\t\tstatus = enumspb.ACTIVITY_EXECUTION_STATUS_TERMINATED\n+\t\trunState = enumspb.PENDING_ACTIVITY_STATE_UNSPECIFIED\n+\tcase activitypb.ACTIVITY_EXECUTION_STATUS_TIMED_OUT:\n+\t\tstatus = enumspb.ACTIVITY_EXECUTION_STATUS_TIMED_OUT\n+\t\trunState = enumspb.PENDING_ACTIVITY_STATE_UNSPECIFIED\n+\tdefault:\n+\t\treturn nil, serviceerror.NewInternalf(\"unknown activity execution status: %s\", a.GetStatus())\n+\t}\n+\n+\trequestData, err := a.RequestData.Get(ctx)\n+\tif err != nil {\n+\t\treturn nil, err\n+\t}\n+\n+\tkey := ctx.ExecutionKey()\n+\n+\tinfo := &activity.ActivityExecutionInfo{\n+\t\tActivityId:    key.BusinessID,\n+\t\tRunId:         key.EntityID,\n+\t\tActivityType:  a.GetActivityType(),\n+\t\tStatus:        status,\n+\t\tRunState:      runState,\n+\t\tScheduledTime: a.GetScheduledTime(),\n+\t\tPriority:      a.GetPriority(),\n+\t\tHeader:        requestData.GetHeader(),\n+\t\t// TODO(dan): populate remaining fields\n+\t}\n+\n+\treturn info, nil\n+}\n+\n+func (a *Activity) buildPollActivityExecutionResponse(\n+\tctx chasm.Context,\n+\treq *activitypb.PollActivityExecutionRequest,\n+) (*activitypb.PollActivityExecutionResponse, error) {\n+\trequest := req.GetFrontendRequest()\n+\n+\ttoken, err := ctx.Ref(a)\n+\tif err != nil {\n+\t\treturn nil, err\n+\t}\n+\n+\tvar info *activity.ActivityExecutionInfo\n+\tif request.GetIncludeInfo() {\n+\t\tinfo, err = a.buildActivityExecutionInfo(ctx)\n+\t\tif err != nil {\n+\t\t\treturn nil, err\n+\t\t}\n+\t}\n+\n+\tvar input *commonpb.Payloads\n+\tif request.GetIncludeInput() {\n+\t\tactivityRequest, err := a.RequestData.Get(ctx)\n+\t\tif err != nil {\n+\t\t\treturn nil, err\n+\t\t}\n+\t\tinput = activityRequest.GetInput()\n+\t}\n+\n+\tresponse := &workflowservice.PollActivityExecutionResponse{\n+\t\tInfo:                     info,\n+\t\tRunId:                    ctx.ExecutionKey().EntityID,\n+\t\tInput:                    input,\n+\t\tStateChangeLongPollToken: token,\n+\t}\n+\n+\tif request.GetIncludeOutcome() {","path":"chasm/lib/activity/activity.go","commit_id":"1d59e66d0ce5d91819f92c428ef5ab4c4efca1fb","original_commit_id":"98f5e1321791f6942a3341e0ed54e5117b7d2a08","user":{"login":"dandavison","id":52205,"node_id":"MDQ6VXNlcjUyMjA1","avatar_url":"https://avatars.githubusercontent.com/u/52205?v=4","gravatar_id":"","url":"https://api.github.com/users/dandavison","html_url":"https://github.com/dandavison","followers_url":"https://api.github.com/users/dandavison/followers","following_url":"https://api.github.com/users/dandavison/following{/other_user}","gists_url":"https://api.github.com/users/dandavison/gists{/gist_id}","starred_url":"https://api.github.com/users/dandavison/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/dandavison/subscriptions","organizations_url":"https://api.github.com/users/dandavison/orgs","repos_url":"https://api.github.com/users/dandavison/repos","events_url":"https://api.github.com/users/dandavison/events{/privacy}","received_events_url":"https://api.github.com/users/dandavison/received_events","type":"User","user_view_type":"public","site_admin":false},"body":"I've updated this branch with a correct implementation.","created_at":"2025-11-28T04:49:01Z","updated_at":"2025-11-28T04:49:01Z","html_url":"https://github.com/temporalio/temporal/pull/8563#discussion_r2570465393","pull_request_url":"https://api.github.com/repos/temporalio/temporal/pulls/8563","_links":{"self":{"href":"https://api.github.com/repos/temporalio/temporal/pulls/comments/2570465393"},"html":{"href":"https://github.com/temporalio/temporal/pull/8563#discussion_r2570465393"},"pull_request":{"href":"https://api.github.com/repos/temporalio/temporal/pulls/8563"}},"reactions":{"url":"https://api.github.com/repos/temporalio/temporal/pulls/comments/2570465393/reactions","total_count":0,"+1":0,"-1":0,"laugh":0,"hooray":0,"confused":0,"heart":0,"rocket":0,"eyes":0},"start_line":null,"original_start_line":null,"start_side":null,"line":416,"original_line":416,"side":"RIGHT","in_reply_to_id":2567021052,"author_association":"MEMBER","original_position":136,"position":132,"subject_type":"line"},{"url":"https://api.github.com/repos/temporalio/temporal/pulls/comments/2570467981","pull_request_review_id":3517469441,"id":2570467981,"node_id":"PRRC_kwDODNqesM6ZNjqN","diff_hunk":"@@ -314,3 +315,141 @@ func (a *Activity) RecordHeartbeat(ctx chasm.MutableContext, details *commonpb.P\n \t})\n \treturn nil, nil\n }\n+\n+func (a *Activity) buildActivityExecutionInfo(ctx chasm.Context) (*activity.ActivityExecutionInfo, error) {\n+\tif a.ActivityState == nil {\n+\t\treturn nil, errors.New(\"activity state is nil\")\n+\t}\n+\n+\t// TODO(dan): support pause states\n+\tvar status enumspb.ActivityExecutionStatus\n+\tvar runState enumspb.PendingActivityState\n+\tswitch a.GetStatus() {\n+\tcase activitypb.ACTIVITY_EXECUTION_STATUS_UNSPECIFIED:\n+\t\tstatus = enumspb.ACTIVITY_EXECUTION_STATUS_UNSPECIFIED\n+\t\trunState = enumspb.PENDING_ACTIVITY_STATE_UNSPECIFIED\n+\tcase activitypb.ACTIVITY_EXECUTION_STATUS_SCHEDULED:\n+\t\tstatus = enumspb.ACTIVITY_EXECUTION_STATUS_RUNNING\n+\t\trunState = enumspb.PENDING_ACTIVITY_STATE_SCHEDULED\n+\tcase activitypb.ACTIVITY_EXECUTION_STATUS_STARTED:\n+\t\tstatus = enumspb.ACTIVITY_EXECUTION_STATUS_RUNNING\n+\t\trunState = enumspb.PENDING_ACTIVITY_STATE_STARTED\n+\tcase activitypb.ACTIVITY_EXECUTION_STATUS_CANCEL_REQUESTED:\n+\t\tstatus = enumspb.ACTIVITY_EXECUTION_STATUS_RUNNING\n+\t\trunState = enumspb.PENDING_ACTIVITY_STATE_CANCEL_REQUESTED\n+\tcase activitypb.ACTIVITY_EXECUTION_STATUS_COMPLETED:\n+\t\tstatus = enumspb.ACTIVITY_EXECUTION_STATUS_COMPLETED\n+\t\trunState = enumspb.PENDING_ACTIVITY_STATE_UNSPECIFIED\n+\tcase activitypb.ACTIVITY_EXECUTION_STATUS_FAILED:\n+\t\tstatus = enumspb.ACTIVITY_EXECUTION_STATUS_FAILED\n+\t\trunState = enumspb.PENDING_ACTIVITY_STATE_UNSPECIFIED\n+\tcase activitypb.ACTIVITY_EXECUTION_STATUS_CANCELED:\n+\t\tstatus = enumspb.ACTIVITY_EXECUTION_STATUS_CANCELED\n+\t\trunState = enumspb.PENDING_ACTIVITY_STATE_UNSPECIFIED\n+\tcase activitypb.ACTIVITY_EXECUTION_STATUS_TERMINATED:\n+\t\tstatus = enumspb.ACTIVITY_EXECUTION_STATUS_TERMINATED\n+\t\trunState = enumspb.PENDING_ACTIVITY_STATE_UNSPECIFIED\n+\tcase activitypb.ACTIVITY_EXECUTION_STATUS_TIMED_OUT:\n+\t\tstatus = enumspb.ACTIVITY_EXECUTION_STATUS_TIMED_OUT\n+\t\trunState = enumspb.PENDING_ACTIVITY_STATE_UNSPECIFIED\n+\tdefault:\n+\t\treturn nil, serviceerror.NewInternalf(\"unknown activity execution status: %s\", a.GetStatus())\n+\t}\n+\n+\trequestData, err := a.RequestData.Get(ctx)\n+\tif err != nil {\n+\t\treturn nil, err\n+\t}\n+\n+\tkey := ctx.ExecutionKey()\n+\n+\tinfo := &activity.ActivityExecutionInfo{\n+\t\tActivityId:    key.BusinessID,\n+\t\tRunId:         key.EntityID,\n+\t\tActivityType:  a.GetActivityType(),\n+\t\tStatus:        status,\n+\t\tRunState:      runState,\n+\t\tScheduledTime: a.GetScheduledTime(),\n+\t\tPriority:      a.GetPriority(),\n+\t\tHeader:        requestData.GetHeader(),\n+\t\t// TODO(dan): populate remaining fields\n+\t}\n+\n+\treturn info, nil\n+}\n+\n+func (a *Activity) buildPollActivityExecutionResponse(\n+\tctx chasm.Context,\n+\treq *activitypb.PollActivityExecutionRequest,\n+) (*activitypb.PollActivityExecutionResponse, error) {\n+\trequest := req.GetFrontendRequest()\n+\n+\ttoken, err := ctx.Ref(a)\n+\tif err != nil {\n+\t\treturn nil, err\n+\t}\n+\n+\tvar info *activity.ActivityExecutionInfo\n+\tif request.GetIncludeInfo() {\n+\t\tinfo, err = a.buildActivityExecutionInfo(ctx)\n+\t\tif err != nil {\n+\t\t\treturn nil, err\n+\t\t}\n+\t}\n+\n+\tvar input *commonpb.Payloads\n+\tif request.GetIncludeInput() {\n+\t\tactivityRequest, err := a.RequestData.Get(ctx)\n+\t\tif err != nil {\n+\t\t\treturn nil, err\n+\t\t}\n+\t\tinput = activityRequest.GetInput()\n+\t}\n+\n+\tresponse := &workflowservice.PollActivityExecutionResponse{\n+\t\tInfo:                     info,\n+\t\tRunId:                    ctx.ExecutionKey().EntityID,\n+\t\tInput:                    input,\n+\t\tStateChangeLongPollToken: token,\n+\t}\n+\n+\tif request.GetIncludeOutcome() {","path":"chasm/lib/activity/activity.go","commit_id":"1d59e66d0ce5d91819f92c428ef5ab4c4efca1fb","original_commit_id":"98f5e1321791f6942a3341e0ed54e5117b7d2a08","user":{"login":"dandavison","id":52205,"node_id":"MDQ6VXNlcjUyMjA1","avatar_url":"https://avatars.githubusercontent.com/u/52205?v=4","gravatar_id":"","url":"https://api.github.com/users/dandavison","html_url":"https://github.com/dandavison","followers_url":"https://api.github.com/users/dandavison/followers","following_url":"https://api.github.com/users/dandavison/following{/other_user}","gists_url":"https://api.github.com/users/dandavison/gists{/gist_id}","starred_url":"https://api.github.com/users/dandavison/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/dandavison/subscriptions","organizations_url":"https://api.github.com/users/dandavison/orgs","repos_url":"https://api.github.com/users/dandavison/repos","events_url":"https://api.github.com/users/dandavison/events{/privacy}","received_events_url":"https://api.github.com/users/dandavison/received_events","type":"User","user_view_type":"public","site_admin":false},"body":"I don't like the way we set the outcome failure to empty struct on handling `RecordActivityTaskFailed` when retries are exhausted; hopefully we can make it so that that is not necessary.","created_at":"2025-11-28T04:51:04Z","updated_at":"2025-11-28T04:51:04Z","html_url":"https://github.com/temporalio/temporal/pull/8563#discussion_r2570467981","pull_request_url":"https://api.github.com/repos/temporalio/temporal/pulls/8563","_links":{"self":{"href":"https://api.github.com/repos/temporalio/temporal/pulls/comments/2570467981"},"html":{"href":"https://github.com/temporalio/temporal/pull/8563#discussion_r2570467981"},"pull_request":{"href":"https://api.github.com/repos/temporalio/temporal/pulls/8563"}},"reactions":{"url":"https://api.github.com/repos/temporalio/temporal/pulls/comments/2570467981/reactions","total_count":0,"+1":0,"-1":0,"laugh":0,"hooray":0,"confused":0,"heart":0,"rocket":0,"eyes":0},"start_line":null,"original_start_line":null,"start_side":null,"line":416,"original_line":416,"side":"RIGHT","in_reply_to_id":2567021052,"author_association":"MEMBER","original_position":136,"position":132,"subject_type":"line"},{"url":"https://api.github.com/repos/temporalio/temporal/pulls/comments/2571740413","pull_request_review_id":3519065306,"id":2571740413,"node_id":"PRRC_kwDODNqesM6ZSaT9","diff_hunk":"@@ -241,14 +256,137 @@ func (e *ChasmEngine) ReadComponent(\n \treturn readFn(chasmContext, component)\n }\n \n+// PollComponent waits until the supplied predicate is satisfied when evaluated against the\n+// component identified by the supplied component reference. If there is no error, it returns (ref,\n+// nil) where ref is a component reference identifying the state at which the predicate was\n+// satisfied. The predicate must be monotonic: if it returns true at execution state transition s it\n+// must return true at all transitions t > s. It is an error if execution transition history is\n+// (after reloading from persistence) behind the requested ref, or if the ref is inconsistent with\n+// execution transition history. Thus when the predicate function is evaluated, it is guaranteed\n+// that the execution VT >= requestRef VT. opts are currently ignored.\n func (e *ChasmEngine) PollComponent(\n \tctx context.Context,\n-\tentityRef chasm.ComponentRef,\n-\tpredicateFn func(chasm.Context, chasm.Component) (any, bool, error),\n-\toperationFn func(chasm.MutableContext, chasm.Component, any) error,\n+\trequestRef chasm.ComponentRef,\n+\tmonotonicPredicate func(chasm.Context, chasm.Component) (bool, error),\n \topts ...chasm.TransitionOption,\n-) (newEntityRef []byte, retError error) {\n-\treturn nil, serviceerror.NewUnimplemented(\"PollComponent is not yet supported\")\n+) (retRef []byte, retError error) {\n+\tdefer func() {\n+\t\tif errors.Is(retError, consts.ErrStaleState) {\n+\t\t\tretError = serviceerror.NewUnavailable(\"please retry\")\n+\t\t}\n+\t}()\n+\n+\tshardContext, executionLease, err := e.getExecutionLease(ctx, requestRef)\n+\tif err != nil {\n+\t\t// E.g. requestRef VT inconsistent with execution VT ('stale reference')\n+\t\treturn nil, err\n+\t}\n+\tdefer executionLease.GetReleaseFn()(nil)\n+\n+\t// At this point it's possible that execution VT < requestRef VT (getExecutionLease does not\n+\t// guarantee that returned execution state is non-stale w.r.t. requestRef).\n+\tsatisfiedRef, err := e.predicateSatisfied(ctx, monotonicPredicate, requestRef, executionLease)\n+\tif err != nil {\n+\t\treturn nil, err\n+\t}\n+\t// execution VT >= requestRef VT (enforced by predicateSatisfied)\n+\n+\tif satisfiedRef != nil {\n+\t\t// wait condition was satisfied\n+\t\treturn satisfiedRef, nil\n+\t}\n+\n+\t// Wait condition not satisfied; long-poll\n+\n+\tnamespaceRegistry, err := shardContext.GetNamespaceRegistry().GetNamespaceByID(\n+\t\tnamespace.ID(requestRef.EntityKey.NamespaceID),\n+\t)\n+\tif err != nil {\n+\t\treturn nil, err\n+\t}\n+\n+\tinternalLongPollTimeout := shardContext.GetConfig().LongPollExpirationInterval(namespaceRegistry.Name().String())\n+\tctx, cancel := context.WithTimeout(ctx, internalLongPollTimeout)\n+\tdefer cancel()\n+\n+\t// PollComponent subscribes to execution-level notifications. Suppose that an execution consists\n+\t// of one component A, and A has subcomponent B. Subscribers interested only in component B may\n+\t// be woken up unnecessarily (and thus evaluate the predicate unnecessarily) due to changes in\n+\t// parts of A that do not also belong to B.\n+\tch := e.notifier.Subscribe(requestRef.EntityKey)\n+\texecutionLease.GetReleaseFn()(nil)","path":"service/history/chasm_engine.go","commit_id":"372cc0a17931bd461ec03349b8509b57820e36c2","original_commit_id":"68ff22759462e9eb10f5e1f6ab7072f0fd8aae75","user":{"login":"cursor[bot]","id":206951365,"node_id":"BOT_kgDODFXTxQ","avatar_url":"https://avatars.githubusercontent.com/in/1210556?v=4","gravatar_id":"","url":"https://api.github.com/users/cursor%5Bbot%5D","html_url":"https://github.com/apps/cursor","followers_url":"https://api.github.com/users/cursor%5Bbot%5D/followers","following_url":"https://api.github.com/users/cursor%5Bbot%5D/following{/other_user}","gists_url":"https://api.github.com/users/cursor%5Bbot%5D/gists{/gist_id}","starred_url":"https://api.github.com/users/cursor%5Bbot%5D/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/cursor%5Bbot%5D/subscriptions","organizations_url":"https://api.github.com/users/cursor%5Bbot%5D/orgs","repos_url":"https://api.github.com/users/cursor%5Bbot%5D/repos","events_url":"https://api.github.com/users/cursor%5Bbot%5D/events{/privacy}","received_events_url":"https://api.github.com/users/cursor%5Bbot%5D/received_events","type":"Bot","user_view_type":"public","site_admin":false},"body":"### Bug: Double-release of execution lease in PollComponent long-poll path\n\n<!-- **High Severity** -->\n\n<!-- DESCRIPTION START -->\nThe `PollComponent` method has both a `defer executionLease.GetReleaseFn()(nil)` at line 284 and an explicit release call at line 317 for the same lease. When the predicate is not initially satisfied and the code enters the long-poll loop, the lease is explicitly released at line 317 before waiting for notifications. However, when the function eventually returns from the loop, the defer at line 284 executes again, causing a double-release of the original `executionLease`. This pattern differs from `ReadComponent` and `UpdateComponent` which correctly use only a single release mechanism.\n<!-- DESCRIPTION END -->\n\n<!-- LOCATIONS START\nservice/history/chasm_engine.go#L283-L317\nLOCATIONS END -->\n<a href=\"https://cursor.com/open?data=eyJhbGciOiJSUzI1NiIsInR5cCI6IkpXVCIsImtpZCI6ImJ1Z2JvdC12MSJ9.eyJ2ZXJzaW9uIjoxLCJ0eXBlIjoiQlVHQk9UX0ZJWF9JTl9DVVJTT1IiLCJkYXRhIjp7InJlZGlzS2V5IjoiYnVnYm90OjM2NWM5ZmUyLTZiMDUtNDE0YS04ZmNjLTk5ZjlkZTllOGIzNyIsImVuY3J5cHRpb25LZXkiOiJFV2FCLVNsMDlzVjR6SE8tZVNSeTJqVTd3d0J6ME1ybkh3WjRiOU1UM2RjIiwiYnJhbmNoIjoicG9sbC1jb21wb25lbnQifSwiaWF0IjoxNzY0MzM3NDg4LCJleHAiOjE3NjQ5NDIyODh9.HEBivHjpGPDaIYIci4N97Z3mt3KiPX8NH2-JbmAOtg8Hihsi-8yifn5-2TTLQEElVqjU0OCrt4DywzBxmNNqy4LwtUsIOrtrbc4d4xR0ty4vUskIAy20UGdJ4rW0hznQxSN2-DgzadLbLd9DzAAn0BzWgGRHyRM0BERTwqU2F_Bg_1c9jrmyiYJvFK6LhAZ8PsRmagIaaaVGsdnxvrkRJmbxbSO-D2OlTRQhP8Jv1gT7Y4xygR_48fScZLTPtoM8fchs5h1NAvtTpzQBsHFCHwAbdJ8yMeUbOQod8OKU9vbvyhRmtxVajiC2wTK0yD7m9wCAsQesibrVnetOqr7V4g\"><picture><source media=\"(prefers-color-scheme: dark)\" srcset=\"https://cursor.com/fix-in-cursor-dark.svg\"><source media=\"(prefers-color-scheme: light)\" srcset=\"https://cursor.com/fix-in-cursor-light.svg\"><img alt=\"Fix in Cursor\" src=\"https://cursor.com/fix-in-cursor.svg\"></picture></a>&nbsp;<a href=\"https://cursor.com/agents?data=eyJhbGciOiJSUzI1NiIsInR5cCI6IkpXVCIsImtpZCI6ImJ1Z2JvdC12MSJ9.eyJ2ZXJzaW9uIjoxLCJ0eXBlIjoiQlVHQk9UX0ZJWF9JTl9XRUIiLCJkYXRhIjp7InJlZGlzS2V5IjoiYnVnYm90OjM2NWM5ZmUyLTZiMDUtNDE0YS04ZmNjLTk5ZjlkZTllOGIzNyIsImVuY3J5cHRpb25LZXkiOiJFV2FCLVNsMDlzVjR6SE8tZVNSeTJqVTd3d0J6ME1ybkh3WjRiOU1UM2RjIiwiYnJhbmNoIjoicG9sbC1jb21wb25lbnQiLCJyZXBvT3duZXIiOiJ0ZW1wb3JhbGlvIiwicmVwb05hbWUiOiJ0ZW1wb3JhbCIsInByTnVtYmVyIjo4NTYzLCJjb21taXRTaGEiOiI2OGZmMjI3NTk0NjJlOWViMTBmNWUxZjZhYjcwNzJmMGZkOGFhZTc1IiwicHJvdmlkZXIiOiJnaXRodWIifSwiaWF0IjoxNzY0MzM3NDg4LCJleHAiOjE3NjQ5NDIyODh9.gVMXCq3OFm33IAJGAGOyJFwvql-Lm1QKpyeU5czsqBjw5TBCXFqoIOsm_Iwy6vcvqHCxuN90rod8duSkoQ0PE64h8GOFBAo8A7R-BBMCJaS6XV9_kKHiVW5Ap3lThb7LpxQPf5JC6dn-G_SMsrG-1Yesf71_fDXY8xtTsxN8qrxZc3R9LHvpWxu7hutvHMsmIUCg8EEnpEkynMO_RaKTvX2QLJCWFg2VQXa7tP_pyNDEgyRCkz3hm83XTiarYiV2sP7SRzpIgCP5F5OGYq3iPT6-2l2u9sd7yCH_QxsBKWVOKAzfTgn0LMqLHnyvsIXRTQ1pTnrMex_-VWd8-t_bkQ\"><picture><source media=\"(prefers-color-scheme: dark)\" srcset=\"https://cursor.com/fix-in-web-dark.svg\"><source media=\"(prefers-color-scheme: light)\" srcset=\"https://cursor.com/fix-in-web-light.svg\"><img alt=\"Fix in Web\" src=\"https://cursor.com/fix-in-web.svg\"></picture></a>\n\n","created_at":"2025-11-28T13:44:49Z","updated_at":"2025-11-28T13:44:49Z","html_url":"https://github.com/temporalio/temporal/pull/8563#discussion_r2571740413","pull_request_url":"https://api.github.com/repos/temporalio/temporal/pulls/8563","_links":{"self":{"href":"https://api.github.com/repos/temporalio/temporal/pulls/comments/2571740413"},"html":{"href":"https://github.com/temporalio/temporal/pull/8563#discussion_r2571740413"},"pull_request":{"href":"https://api.github.com/repos/temporalio/temporal/pulls/8563"}},"reactions":{"url":"https://api.github.com/repos/temporalio/temporal/pulls/comments/2571740413/reactions","total_count":0,"+1":0,"-1":0,"laugh":0,"hooray":0,"confused":0,"heart":0,"rocket":0,"eyes":0},"start_line":null,"original_start_line":null,"start_side":null,"line":null,"original_line":317,"side":"RIGHT","author_association":"NONE","original_position":133,"position":1,"subject_type":"line"},{"url":"https://api.github.com/repos/temporalio/temporal/pulls/comments/2578224109","pull_request_review_id":3526477399,"id":2578224109,"node_id":"PRRC_kwDODNqesM6ZrJPt","diff_hunk":"@@ -314,3 +315,145 @@ func (a *Activity) RecordHeartbeat(ctx chasm.MutableContext, details *commonpb.P\n \t})\n \treturn nil, nil\n }\n+\n+func (a *Activity) buildActivityExecutionInfo(ctx chasm.Context) (*activity.ActivityExecutionInfo, error) {\n+\tif a.ActivityState == nil {\n+\t\treturn nil, errors.New(\"activity state is nil\")","path":"chasm/lib/activity/activity.go","commit_id":"37c5f7fa3194434813e3df63aa07231df81d239b","original_commit_id":"59d749626d6a00c5fff76abe79a85eb627366521","user":{"login":"bergundy","id":52304,"node_id":"MDQ6VXNlcjUyMzA0","avatar_url":"https://avatars.githubusercontent.com/u/52304?v=4","gravatar_id":"","url":"https://api.github.com/users/bergundy","html_url":"https://github.com/bergundy","followers_url":"https://api.github.com/users/bergundy/followers","following_url":"https://api.github.com/users/bergundy/following{/other_user}","gists_url":"https://api.github.com/users/bergundy/gists{/gist_id}","starred_url":"https://api.github.com/users/bergundy/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/bergundy/subscriptions","organizations_url":"https://api.github.com/users/bergundy/orgs","repos_url":"https://api.github.com/users/bergundy/repos","events_url":"https://api.github.com/users/bergundy/events{/privacy}","received_events_url":"https://api.github.com/users/bergundy/received_events","type":"User","user_view_type":"public","site_admin":false},"body":"Why would this be `nil`? You can just assume the activity is properly initialized and let Go panic if it isn't.","created_at":"2025-12-01T18:40:21Z","updated_at":"2025-12-02T00:31:36Z","html_url":"https://github.com/temporalio/temporal/pull/8563#discussion_r2578224109","pull_request_url":"https://api.github.com/repos/temporalio/temporal/pulls/8563","_links":{"self":{"href":"https://api.github.com/repos/temporalio/temporal/pulls/comments/2578224109"},"html":{"href":"https://github.com/temporalio/temporal/pull/8563#discussion_r2578224109"},"pull_request":{"href":"https://api.github.com/repos/temporalio/temporal/pulls/8563"}},"reactions":{"url":"https://api.github.com/repos/temporalio/temporal/pulls/comments/2578224109/reactions","total_count":0,"+1":0,"-1":0,"laugh":0,"hooray":0,"confused":0,"heart":0,"rocket":0,"eyes":0},"start_line":null,"original_start_line":null,"start_side":null,"line":null,"original_line":321,"side":"RIGHT","author_association":"MEMBER","original_position":40,"position":1,"subject_type":"line"},{"url":"https://api.github.com/repos/temporalio/temporal/pulls/comments/2578229733","pull_request_review_id":3526477399,"id":2578229733,"node_id":"PRRC_kwDODNqesM6ZrKnl","diff_hunk":"@@ -314,3 +315,123 @@ func (a *Activity) RecordHeartbeat(ctx chasm.MutableContext, details *commonpb.P\n \t})\n \treturn nil, nil\n }\n+\n+func (a *Activity) buildActivityExecutionInfo(ctx chasm.Context) (*activity.ActivityExecutionInfo, error) {\n+\tif a.ActivityState == nil {\n+\t\treturn nil, errors.New(\"activity state is nil\")\n+\t}\n+\n+\t// TODO(dan): support pause states\n+\tvar status enumspb.ActivityExecutionStatus\n+\tvar runState enumspb.PendingActivityState\n+\tswitch a.GetStatus() {\n+\tcase activitypb.ACTIVITY_EXECUTION_STATUS_UNSPECIFIED:\n+\t\tstatus = enumspb.ACTIVITY_EXECUTION_STATUS_UNSPECIFIED\n+\t\trunState = enumspb.PENDING_ACTIVITY_STATE_UNSPECIFIED\n+\tcase activitypb.ACTIVITY_EXECUTION_STATUS_SCHEDULED:\n+\t\tstatus = enumspb.ACTIVITY_EXECUTION_STATUS_RUNNING\n+\t\trunState = enumspb.PENDING_ACTIVITY_STATE_SCHEDULED\n+\tcase activitypb.ACTIVITY_EXECUTION_STATUS_STARTED:\n+\t\tstatus = enumspb.ACTIVITY_EXECUTION_STATUS_RUNNING\n+\t\trunState = enumspb.PENDING_ACTIVITY_STATE_STARTED\n+\tcase activitypb.ACTIVITY_EXECUTION_STATUS_CANCEL_REQUESTED:\n+\t\tstatus = enumspb.ACTIVITY_EXECUTION_STATUS_RUNNING\n+\t\trunState = enumspb.PENDING_ACTIVITY_STATE_CANCEL_REQUESTED\n+\tcase activitypb.ACTIVITY_EXECUTION_STATUS_COMPLETED:\n+\t\tstatus = enumspb.ACTIVITY_EXECUTION_STATUS_COMPLETED\n+\t\trunState = enumspb.PENDING_ACTIVITY_STATE_UNSPECIFIED\n+\tcase activitypb.ACTIVITY_EXECUTION_STATUS_FAILED:\n+\t\tstatus = enumspb.ACTIVITY_EXECUTION_STATUS_FAILED\n+\t\trunState = enumspb.PENDING_ACTIVITY_STATE_UNSPECIFIED\n+\tcase activitypb.ACTIVITY_EXECUTION_STATUS_CANCELED:\n+\t\tstatus = enumspb.ACTIVITY_EXECUTION_STATUS_CANCELED\n+\t\trunState = enumspb.PENDING_ACTIVITY_STATE_UNSPECIFIED\n+\tcase activitypb.ACTIVITY_EXECUTION_STATUS_TERMINATED:\n+\t\tstatus = enumspb.ACTIVITY_EXECUTION_STATUS_TERMINATED\n+\t\trunState = enumspb.PENDING_ACTIVITY_STATE_UNSPECIFIED\n+\tcase activitypb.ACTIVITY_EXECUTION_STATUS_TIMED_OUT:\n+\t\tstatus = enumspb.ACTIVITY_EXECUTION_STATUS_TIMED_OUT\n+\t\trunState = enumspb.PENDING_ACTIVITY_STATE_UNSPECIFIED\n+\tdefault:\n+\t\treturn nil, serviceerror.NewInternalf(\"unknown activity execution status: %s\", a.GetStatus())\n+\t}\n+\n+\trequestData, err := a.RequestData.Get(ctx)\n+\tif err != nil {\n+\t\treturn nil, err\n+\t}\n+\n+\tkey := ctx.ExecutionKey()\n+\n+\tinfo := &activity.ActivityExecutionInfo{\n+\t\tActivityId:    key.BusinessID,\n+\t\tRunId:         key.EntityID,\n+\t\tActivityType:  a.GetActivityType(),\n+\t\tStatus:        status,\n+\t\tRunState:      runState,\n+\t\tScheduledTime: a.GetScheduledTime(),\n+\t\tPriority:      a.GetPriority(),\n+\t\tHeader:        requestData.GetHeader(),\n+\t\t// TODO(dan): populate remaining fields\n+\t}\n+\n+\treturn info, nil\n+}\n+\n+func (a *Activity) buildPollActivityExecutionResponse(\n+\tctx chasm.Context,\n+\treq *activitypb.PollActivityExecutionRequest,","path":"chasm/lib/activity/activity.go","commit_id":"1d59e66d0ce5d91819f92c428ef5ab4c4efca1fb","original_commit_id":"da6009564e796063faf853352077eecdc1473612","user":{"login":"bergundy","id":52304,"node_id":"MDQ6VXNlcjUyMzA0","avatar_url":"https://avatars.githubusercontent.com/u/52304?v=4","gravatar_id":"","url":"https://api.github.com/users/bergundy","html_url":"https://github.com/bergundy","followers_url":"https://api.github.com/users/bergundy/followers","following_url":"https://api.github.com/users/bergundy/following{/other_user}","gists_url":"https://api.github.com/users/bergundy/gists{/gist_id}","starred_url":"https://api.github.com/users/bergundy/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/bergundy/subscriptions","organizations_url":"https://api.github.com/users/bergundy/orgs","repos_url":"https://api.github.com/users/bergundy/repos","events_url":"https://api.github.com/users/bergundy/events{/privacy}","received_events_url":"https://api.github.com/users/bergundy/received_events","type":"User","user_view_type":"public","site_admin":false},"body":"Not strongly opinionated but let's be consistent.","created_at":"2025-12-01T18:41:55Z","updated_at":"2025-12-02T00:31:37Z","html_url":"https://github.com/temporalio/temporal/pull/8563#discussion_r2578229733","pull_request_url":"https://api.github.com/repos/temporalio/temporal/pulls/8563","_links":{"self":{"href":"https://api.github.com/repos/temporalio/temporal/pulls/comments/2578229733"},"html":{"href":"https://github.com/temporalio/temporal/pull/8563#discussion_r2578229733"},"pull_request":{"href":"https://api.github.com/repos/temporalio/temporal/pulls/8563"}},"reactions":{"url":"https://api.github.com/repos/temporalio/temporal/pulls/comments/2578229733/reactions","total_count":0,"+1":0,"-1":0,"laugh":0,"hooray":0,"confused":0,"heart":0,"rocket":0,"eyes":0},"start_line":null,"original_start_line":null,"start_side":null,"line":383,"original_line":383,"side":"RIGHT","in_reply_to_id":2539839248,"author_association":"MEMBER","original_position":103,"position":99,"subject_type":"line"},{"url":"https://api.github.com/repos/temporalio/temporal/pulls/comments/2578233172","pull_request_review_id":3526477399,"id":2578233172,"node_id":"PRRC_kwDODNqesM6ZrLdU","diff_hunk":"@@ -131,6 +131,9 @@ func (r *ComponentRef) Serialize(\n // DeserializeComponentRef deserializes a byte slice into a ComponentRef.\n // Provides caller the access to information including EntityKey, Archetype, and ShardingKey.\n func DeserializeComponentRef(data []byte) (ComponentRef, error) {\n+\tif len(data) == 0 {","path":"chasm/ref.go","commit_id":"1d59e66d0ce5d91819f92c428ef5ab4c4efca1fb","original_commit_id":"59d749626d6a00c5fff76abe79a85eb627366521","user":{"login":"bergundy","id":52304,"node_id":"MDQ6VXNlcjUyMzA0","avatar_url":"https://avatars.githubusercontent.com/u/52304?v=4","gravatar_id":"","url":"https://api.github.com/users/bergundy","html_url":"https://github.com/bergundy","followers_url":"https://api.github.com/users/bergundy/followers","following_url":"https://api.github.com/users/bergundy/following{/other_user}","gists_url":"https://api.github.com/users/bergundy/gists{/gist_id}","starred_url":"https://api.github.com/users/bergundy/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/bergundy/subscriptions","organizations_url":"https://api.github.com/users/bergundy/orgs","repos_url":"https://api.github.com/users/bergundy/repos","events_url":"https://api.github.com/users/bergundy/events{/privacy}","received_events_url":"https://api.github.com/users/bergundy/received_events","type":"User","user_view_type":"public","site_admin":false},"body":"We mentioned that we would want to validate that the execution ID and namespace ID are not empty either. Both of these fields would be minimally required for the ref to be valid.","created_at":"2025-12-01T18:43:25Z","updated_at":"2025-12-02T00:31:36Z","html_url":"https://github.com/temporalio/temporal/pull/8563#discussion_r2578233172","pull_request_url":"https://api.github.com/repos/temporalio/temporal/pulls/8563","_links":{"self":{"href":"https://api.github.com/repos/temporalio/temporal/pulls/comments/2578233172"},"html":{"href":"https://github.com/temporalio/temporal/pull/8563#discussion_r2578233172"},"pull_request":{"href":"https://api.github.com/repos/temporalio/temporal/pulls/8563"}},"reactions":{"url":"https://api.github.com/repos/temporalio/temporal/pulls/comments/2578233172/reactions","total_count":0,"+1":0,"-1":0,"laugh":0,"hooray":0,"confused":0,"heart":0,"rocket":0,"eyes":0},"start_line":null,"original_start_line":null,"start_side":null,"line":138,"original_line":134,"side":"RIGHT","author_association":"MEMBER","original_position":23,"position":21,"subject_type":"line"},{"url":"https://api.github.com/repos/temporalio/temporal/pulls/comments/2578234377","pull_request_review_id":3526477399,"id":2578234377,"node_id":"PRRC_kwDODNqesM6ZrLwJ","diff_hunk":"@@ -76,6 +76,11 @@ func (s *componentRefSuite) TestShardingKey() {\n }\n \n func (s *componentRefSuite) TestSerializeDeserialize() {\n+\t_, err := DeserializeComponentRef(nil)\n+\ts.Error(err)","path":"chasm/ref_test.go","commit_id":"66fabe0d082c4981de3eaca9daf97fbe262d9b1b","original_commit_id":"59d749626d6a00c5fff76abe79a85eb627366521","user":{"login":"bergundy","id":52304,"node_id":"MDQ6VXNlcjUyMzA0","avatar_url":"https://avatars.githubusercontent.com/u/52304?v=4","gravatar_id":"","url":"https://api.github.com/users/bergundy","html_url":"https://github.com/bergundy","followers_url":"https://api.github.com/users/bergundy/followers","following_url":"https://api.github.com/users/bergundy/following{/other_user}","gists_url":"https://api.github.com/users/bergundy/gists{/gist_id}","starred_url":"https://api.github.com/users/bergundy/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/bergundy/subscriptions","organizations_url":"https://api.github.com/users/bergundy/orgs","repos_url":"https://api.github.com/users/bergundy/repos","events_url":"https://api.github.com/users/bergundy/events{/privacy}","received_events_url":"https://api.github.com/users/bergundy/received_events","type":"User","user_view_type":"public","site_admin":false},"body":"Use `s.ErrorIs` to verify the error type.","created_at":"2025-12-01T18:43:51Z","updated_at":"2025-12-02T00:31:36Z","html_url":"https://github.com/temporalio/temporal/pull/8563#discussion_r2578234377","pull_request_url":"https://api.github.com/repos/temporalio/temporal/pulls/8563","_links":{"self":{"href":"https://api.github.com/repos/temporalio/temporal/pulls/comments/2578234377"},"html":{"href":"https://github.com/temporalio/temporal/pull/8563#discussion_r2578234377"},"pull_request":{"href":"https://api.github.com/repos/temporalio/temporal/pulls/8563"}},"reactions":{"url":"https://api.github.com/repos/temporalio/temporal/pulls/comments/2578234377/reactions","total_count":0,"+1":0,"-1":0,"laugh":0,"hooray":0,"confused":0,"heart":0,"rocket":0,"eyes":0},"start_line":null,"original_start_line":null,"start_side":null,"line":null,"original_line":80,"side":"RIGHT","author_association":"MEMBER","original_position":5,"position":1,"subject_type":"line"},{"url":"https://api.github.com/repos/temporalio/temporal/pulls/comments/2578239317","pull_request_review_id":3526477399,"id":2578239317,"node_id":"PRRC_kwDODNqesM6ZrM9V","diff_hunk":"@@ -0,0 +1,47 @@\n+package chasm\n+\n+import (\n+\t\"go.temporal.io/api/serviceerror\"\n+\t\"go.temporal.io/server/common/persistence/transitionhistory\"\n+\t\"go.temporal.io/server/service/history/consts\"\n+)\n+\n+// ErrMalformedComponentRef is returned when the provided component ref cannot be deserialized.\n+var ErrMalformedComponentRef = serviceerror.NewInternal(\"malformed component ref\")\n+\n+// ErrInvalidComponentRef is returned when the provided component ref does not match the target execution.\n+var ErrInvalidComponentRef = serviceerror.NewInvalidArgument(\"invalid component ref\")\n+\n+// ExecutionStateChanged returns true if execution state has advanced beyond the state encoded in\n+// refBytes.\n+func ExecutionStateChanged(c Component, ctx Context, refBytes []byte) (bool, error) {\n+\tref, err := DeserializeComponentRef(refBytes)\n+\tif err != nil {\n+\t\treturn false, ErrMalformedComponentRef","path":"chasm/transition_history.go","commit_id":"37c5f7fa3194434813e3df63aa07231df81d239b","original_commit_id":"59d749626d6a00c5fff76abe79a85eb627366521","user":{"login":"bergundy","id":52304,"node_id":"MDQ6VXNlcjUyMzA0","avatar_url":"https://avatars.githubusercontent.com/u/52304?v=4","gravatar_id":"","url":"https://api.github.com/users/bergundy","html_url":"https://github.com/bergundy","followers_url":"https://api.github.com/users/bergundy/followers","following_url":"https://api.github.com/users/bergundy/following{/other_user}","gists_url":"https://api.github.com/users/bergundy/gists{/gist_id}","starred_url":"https://api.github.com/users/bergundy/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/bergundy/subscriptions","organizations_url":"https://api.github.com/users/bergundy/orgs","repos_url":"https://api.github.com/users/bergundy/repos","events_url":"https://api.github.com/users/bergundy/events{/privacy}","received_events_url":"https://api.github.com/users/bergundy/received_events","type":"User","user_view_type":"public","site_admin":false},"body":"Why translate the error here? Why is this an internal error? What if the user messes up a token? Would we verify that before hitting the history service? That would make sense to me but please add a comment explaining this.","created_at":"2025-12-01T18:45:58Z","updated_at":"2025-12-02T00:31:36Z","html_url":"https://github.com/temporalio/temporal/pull/8563#discussion_r2578239317","pull_request_url":"https://api.github.com/repos/temporalio/temporal/pulls/8563","_links":{"self":{"href":"https://api.github.com/repos/temporalio/temporal/pulls/comments/2578239317"},"html":{"href":"https://github.com/temporalio/temporal/pull/8563#discussion_r2578239317"},"pull_request":{"href":"https://api.github.com/repos/temporalio/temporal/pulls/8563"}},"reactions":{"url":"https://api.github.com/repos/temporalio/temporal/pulls/comments/2578239317/reactions","total_count":0,"+1":0,"-1":0,"laugh":0,"hooray":0,"confused":0,"heart":0,"rocket":0,"eyes":0},"start_line":null,"original_start_line":null,"start_side":null,"line":14,"original_line":20,"side":"RIGHT","author_association":"MEMBER","original_position":20,"position":1,"subject_type":"line"},{"url":"https://api.github.com/repos/temporalio/temporal/pulls/comments/2578267576","pull_request_review_id":3526477399,"id":2578267576,"node_id":"PRRC_kwDODNqesM6ZrT24","diff_hunk":"@@ -0,0 +1,47 @@\n+package chasm\n+\n+import (\n+\t\"go.temporal.io/api/serviceerror\"\n+\t\"go.temporal.io/server/common/persistence/transitionhistory\"\n+\t\"go.temporal.io/server/service/history/consts\"\n+)\n+\n+// ErrMalformedComponentRef is returned when the provided component ref cannot be deserialized.\n+var ErrMalformedComponentRef = serviceerror.NewInternal(\"malformed component ref\")\n+\n+// ErrInvalidComponentRef is returned when the provided component ref does not match the target execution.\n+var ErrInvalidComponentRef = serviceerror.NewInvalidArgument(\"invalid component ref\")\n+\n+// ExecutionStateChanged returns true if execution state has advanced beyond the state encoded in\n+// refBytes.\n+func ExecutionStateChanged(c Component, ctx Context, refBytes []byte) (bool, error) {\n+\tref, err := DeserializeComponentRef(refBytes)\n+\tif err != nil {\n+\t\treturn false, ErrMalformedComponentRef\n+\t}\n+\tcurrentRefBytes, err := ctx.Ref(c)\n+\tif err != nil {\n+\t\treturn false, err\n+\t}\n+\tcurrentRef, err := DeserializeComponentRef(currentRefBytes)","path":"chasm/transition_history.go","commit_id":"5f9a597e9bd7c7385dfa0d068fccf04333860856","original_commit_id":"59d749626d6a00c5fff76abe79a85eb627366521","user":{"login":"bergundy","id":52304,"node_id":"MDQ6VXNlcjUyMzA0","avatar_url":"https://avatars.githubusercontent.com/u/52304?v=4","gravatar_id":"","url":"https://api.github.com/users/bergundy","html_url":"https://github.com/bergundy","followers_url":"https://api.github.com/users/bergundy/followers","following_url":"https://api.github.com/users/bergundy/following{/other_user}","gists_url":"https://api.github.com/users/bergundy/gists{/gist_id}","starred_url":"https://api.github.com/users/bergundy/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/bergundy/subscriptions","organizations_url":"https://api.github.com/users/bergundy/orgs","repos_url":"https://api.github.com/users/bergundy/repos","events_url":"https://api.github.com/users/bergundy/events{/privacy}","received_events_url":"https://api.github.com/users/bergundy/received_events","type":"User","user_view_type":"public","site_admin":false},"body":"I would consider adding a non exported `ctx.structuredRef(component)` method to avoid the serialization round trip. ","created_at":"2025-12-01T18:57:06Z","updated_at":"2025-12-02T00:31:36Z","html_url":"https://github.com/temporalio/temporal/pull/8563#discussion_r2578267576","pull_request_url":"https://api.github.com/repos/temporalio/temporal/pulls/8563","_links":{"self":{"href":"https://api.github.com/repos/temporalio/temporal/pulls/comments/2578267576"},"html":{"href":"https://github.com/temporalio/temporal/pull/8563#discussion_r2578267576"},"pull_request":{"href":"https://api.github.com/repos/temporalio/temporal/pulls/8563"}},"reactions":{"url":"https://api.github.com/repos/temporalio/temporal/pulls/comments/2578267576/reactions","total_count":0,"+1":0,"-1":0,"laugh":0,"hooray":0,"confused":0,"heart":0,"rocket":0,"eyes":0},"start_line":null,"original_start_line":22,"start_side":"RIGHT","line":null,"original_line":26,"side":"RIGHT","author_association":"MEMBER","original_position":26,"position":1,"subject_type":"line"},{"url":"https://api.github.com/repos/temporalio/temporal/pulls/comments/2578343493","pull_request_review_id":3526477399,"id":2578343493,"node_id":"PRRC_kwDODNqesM6ZrmZF","diff_hunk":"@@ -241,14 +256,137 @@ func (e *ChasmEngine) ReadComponent(\n \treturn readFn(chasmContext, component)\n }\n \n+// PollComponent waits until the supplied predicate is satisfied when evaluated against the\n+// component identified by the supplied component reference. If there is no error, it returns (ref,\n+// nil) where ref is a component reference identifying the state at which the predicate was\n+// satisfied. The predicate must be monotonic: if it returns true at execution state transition s it\n+// must return true at all transitions t > s. It is an error if execution transition history is\n+// (after reloading from persistence) behind the requested ref, or if the ref is inconsistent with\n+// execution transition history. Thus when the predicate function is evaluated, it is guaranteed\n+// that the execution VT >= requestRef VT. opts are currently ignored.\n func (e *ChasmEngine) PollComponent(\n \tctx context.Context,\n-\tentityRef chasm.ComponentRef,\n-\tpredicateFn func(chasm.Context, chasm.Component) (any, bool, error),\n-\toperationFn func(chasm.MutableContext, chasm.Component, any) error,\n+\trequestRef chasm.ComponentRef,\n+\tmonotonicPredicate func(chasm.Context, chasm.Component) (bool, error),\n \topts ...chasm.TransitionOption,\n-) (newEntityRef []byte, retError error) {\n-\treturn nil, serviceerror.NewUnimplemented(\"PollComponent is not yet supported\")\n+) (retRef []byte, retError error) {\n+\tdefer func() {","path":"service/history/chasm_engine.go","commit_id":"1d59e66d0ce5d91819f92c428ef5ab4c4efca1fb","original_commit_id":"59d749626d6a00c5fff76abe79a85eb627366521","user":{"login":"bergundy","id":52304,"node_id":"MDQ6VXNlcjUyMzA0","avatar_url":"https://avatars.githubusercontent.com/u/52304?v=4","gravatar_id":"","url":"https://api.github.com/users/bergundy","html_url":"https://github.com/bergundy","followers_url":"https://api.github.com/users/bergundy/followers","following_url":"https://api.github.com/users/bergundy/following{/other_user}","gists_url":"https://api.github.com/users/bergundy/gists{/gist_id}","starred_url":"https://api.github.com/users/bergundy/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/bergundy/subscriptions","organizations_url":"https://api.github.com/users/bergundy/orgs","repos_url":"https://api.github.com/users/bergundy/repos","events_url":"https://api.github.com/users/bergundy/events{/privacy}","received_events_url":"https://api.github.com/users/bergundy/received_events","type":"User","user_view_type":"public","site_admin":false},"body":"Instead of this defer function, you can call `return nil, translateErr(err)` where needed, it's a more direct and idiomatic way of doing this.","created_at":"2025-12-01T19:27:43Z","updated_at":"2025-12-02T00:31:36Z","html_url":"https://github.com/temporalio/temporal/pull/8563#discussion_r2578343493","pull_request_url":"https://api.github.com/repos/temporalio/temporal/pulls/8563","_links":{"self":{"href":"https://api.github.com/repos/temporalio/temporal/pulls/comments/2578343493"},"html":{"href":"https://github.com/temporalio/temporal/pull/8563#discussion_r2578343493"},"pull_request":{"href":"https://api.github.com/repos/temporalio/temporal/pulls/8563"}},"reactions":{"url":"https://api.github.com/repos/temporalio/temporal/pulls/comments/2578343493/reactions","total_count":0,"+1":0,"-1":0,"laugh":0,"hooray":0,"confused":0,"heart":0,"rocket":0,"eyes":0},"start_line":null,"original_start_line":null,"start_side":null,"line":281,"original_line":273,"side":"RIGHT","author_association":"MEMBER","original_position":89,"position":93,"subject_type":"line"},{"url":"https://api.github.com/repos/temporalio/temporal/pulls/comments/2578349210","pull_request_review_id":3526477399,"id":2578349210,"node_id":"PRRC_kwDODNqesM6Zrnya","diff_hunk":"@@ -241,14 +256,137 @@ func (e *ChasmEngine) ReadComponent(\n \treturn readFn(chasmContext, component)\n }\n \n+// PollComponent waits until the supplied predicate is satisfied when evaluated against the\n+// component identified by the supplied component reference. If there is no error, it returns (ref,\n+// nil) where ref is a component reference identifying the state at which the predicate was\n+// satisfied. The predicate must be monotonic: if it returns true at execution state transition s it\n+// must return true at all transitions t > s. It is an error if execution transition history is\n+// (after reloading from persistence) behind the requested ref, or if the ref is inconsistent with\n+// execution transition history. Thus when the predicate function is evaluated, it is guaranteed\n+// that the execution VT >= requestRef VT. opts are currently ignored.\n func (e *ChasmEngine) PollComponent(\n \tctx context.Context,\n-\tentityRef chasm.ComponentRef,\n-\tpredicateFn func(chasm.Context, chasm.Component) (any, bool, error),\n-\toperationFn func(chasm.MutableContext, chasm.Component, any) error,\n+\trequestRef chasm.ComponentRef,\n+\tmonotonicPredicate func(chasm.Context, chasm.Component) (bool, error),\n \topts ...chasm.TransitionOption,\n-) (newEntityRef []byte, retError error) {\n-\treturn nil, serviceerror.NewUnimplemented(\"PollComponent is not yet supported\")\n+) (retRef []byte, retError error) {\n+\tdefer func() {\n+\t\tif errors.Is(retError, consts.ErrStaleState) {\n+\t\t\tretError = serviceerror.NewUnavailable(\"please retry\")\n+\t\t}\n+\t}()\n+\n+\tshardContext, executionLease, err := e.getExecutionLease(ctx, requestRef)\n+\tif err != nil {\n+\t\t// E.g. requestRef VT inconsistent with execution VT ('stale reference')\n+\t\treturn nil, err\n+\t}\n+\tdefer executionLease.GetReleaseFn()(nil)\n+\n+\t// At this point it's possible that execution VT < requestRef VT (getExecutionLease does not\n+\t// guarantee that returned execution state is non-stale w.r.t. requestRef).\n+\tsatisfiedRef, err := e.predicateSatisfied(ctx, monotonicPredicate, requestRef, executionLease)\n+\tif err != nil {\n+\t\treturn nil, err\n+\t}\n+\t// execution VT >= requestRef VT (enforced by predicateSatisfied)\n+\n+\tif satisfiedRef != nil {\n+\t\t// wait condition was satisfied\n+\t\treturn satisfiedRef, nil\n+\t}\n+\n+\t// Wait condition not satisfied; long-poll\n+\n+\tnamespaceRegistry, err := shardContext.GetNamespaceRegistry().GetNamespaceByID(","path":"service/history/chasm_engine.go","commit_id":"59d749626d6a00c5fff76abe79a85eb627366521","original_commit_id":"59d749626d6a00c5fff76abe79a85eb627366521","user":{"login":"bergundy","id":52304,"node_id":"MDQ6VXNlcjUyMzA0","avatar_url":"https://avatars.githubusercontent.com/u/52304?v=4","gravatar_id":"","url":"https://api.github.com/users/bergundy","html_url":"https://github.com/bergundy","followers_url":"https://api.github.com/users/bergundy/followers","following_url":"https://api.github.com/users/bergundy/following{/other_user}","gists_url":"https://api.github.com/users/bergundy/gists{/gist_id}","starred_url":"https://api.github.com/users/bergundy/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/bergundy/subscriptions","organizations_url":"https://api.github.com/users/bergundy/orgs","repos_url":"https://api.github.com/users/bergundy/repos","events_url":"https://api.github.com/users/bergundy/events{/privacy}","received_events_url":"https://api.github.com/users/bergundy/received_events","type":"User","user_view_type":"public","site_admin":false},"body":"This variable name is misleading.","created_at":"2025-12-01T19:29:47Z","updated_at":"2025-12-02T00:31:36Z","html_url":"https://github.com/temporalio/temporal/pull/8563#discussion_r2578349210","pull_request_url":"https://api.github.com/repos/temporalio/temporal/pulls/8563","_links":{"self":{"href":"https://api.github.com/repos/temporalio/temporal/pulls/comments/2578349210"},"html":{"href":"https://github.com/temporalio/temporal/pull/8563#discussion_r2578349210"},"pull_request":{"href":"https://api.github.com/repos/temporalio/temporal/pulls/8563"}},"reactions":{"url":"https://api.github.com/repos/temporalio/temporal/pulls/comments/2578349210/reactions","total_count":0,"+1":0,"-1":0,"laugh":0,"hooray":0,"confused":0,"heart":0,"rocket":0,"eyes":0},"start_line":null,"original_start_line":null,"start_side":null,"line":null,"original_line":301,"side":"RIGHT","author_association":"MEMBER","original_position":117,"position":1,"subject_type":"line"},{"url":"https://api.github.com/repos/temporalio/temporal/pulls/comments/2578360812","pull_request_review_id":3526477399,"id":2578360812,"node_id":"PRRC_kwDODNqesM6Zrqns","diff_hunk":"@@ -241,14 +256,137 @@ func (e *ChasmEngine) ReadComponent(\n \treturn readFn(chasmContext, component)\n }\n \n+// PollComponent waits until the supplied predicate is satisfied when evaluated against the\n+// component identified by the supplied component reference. If there is no error, it returns (ref,\n+// nil) where ref is a component reference identifying the state at which the predicate was\n+// satisfied. The predicate must be monotonic: if it returns true at execution state transition s it\n+// must return true at all transitions t > s. It is an error if execution transition history is\n+// (after reloading from persistence) behind the requested ref, or if the ref is inconsistent with\n+// execution transition history. Thus when the predicate function is evaluated, it is guaranteed\n+// that the execution VT >= requestRef VT. opts are currently ignored.\n func (e *ChasmEngine) PollComponent(\n \tctx context.Context,\n-\tentityRef chasm.ComponentRef,\n-\tpredicateFn func(chasm.Context, chasm.Component) (any, bool, error),\n-\toperationFn func(chasm.MutableContext, chasm.Component, any) error,\n+\trequestRef chasm.ComponentRef,\n+\tmonotonicPredicate func(chasm.Context, chasm.Component) (bool, error),\n \topts ...chasm.TransitionOption,\n-) (newEntityRef []byte, retError error) {\n-\treturn nil, serviceerror.NewUnimplemented(\"PollComponent is not yet supported\")\n+) (retRef []byte, retError error) {\n+\tdefer func() {\n+\t\tif errors.Is(retError, consts.ErrStaleState) {\n+\t\t\tretError = serviceerror.NewUnavailable(\"please retry\")\n+\t\t}\n+\t}()\n+\n+\tshardContext, executionLease, err := e.getExecutionLease(ctx, requestRef)\n+\tif err != nil {\n+\t\t// E.g. requestRef VT inconsistent with execution VT ('stale reference')\n+\t\treturn nil, err\n+\t}\n+\tdefer executionLease.GetReleaseFn()(nil)\n+\n+\t// At this point it's possible that execution VT < requestRef VT (getExecutionLease does not\n+\t// guarantee that returned execution state is non-stale w.r.t. requestRef).\n+\tsatisfiedRef, err := e.predicateSatisfied(ctx, monotonicPredicate, requestRef, executionLease)\n+\tif err != nil {\n+\t\treturn nil, err\n+\t}\n+\t// execution VT >= requestRef VT (enforced by predicateSatisfied)\n+\n+\tif satisfiedRef != nil {\n+\t\t// wait condition was satisfied\n+\t\treturn satisfiedRef, nil\n+\t}\n+\n+\t// Wait condition not satisfied; long-poll\n+\n+\tnamespaceRegistry, err := shardContext.GetNamespaceRegistry().GetNamespaceByID(\n+\t\tnamespace.ID(requestRef.EntityKey.NamespaceID),\n+\t)\n+\tif err != nil {\n+\t\treturn nil, err\n+\t}\n+\n+\tinternalLongPollTimeout := shardContext.GetConfig().LongPollExpirationInterval(namespaceRegistry.Name().String())\n+\tctx, cancel := context.WithTimeout(ctx, internalLongPollTimeout)\n+\tdefer cancel()","path":"service/history/chasm_engine.go","commit_id":"59d749626d6a00c5fff76abe79a85eb627366521","original_commit_id":"59d749626d6a00c5fff76abe79a85eb627366521","user":{"login":"bergundy","id":52304,"node_id":"MDQ6VXNlcjUyMzA0","avatar_url":"https://avatars.githubusercontent.com/u/52304?v=4","gravatar_id":"","url":"https://api.github.com/users/bergundy","html_url":"https://github.com/bergundy","followers_url":"https://api.github.com/users/bergundy/followers","following_url":"https://api.github.com/users/bergundy/following{/other_user}","gists_url":"https://api.github.com/users/bergundy/gists{/gist_id}","starred_url":"https://api.github.com/users/bergundy/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/bergundy/subscriptions","organizations_url":"https://api.github.com/users/bergundy/orgs","repos_url":"https://api.github.com/users/bergundy/repos","events_url":"https://api.github.com/users/bergundy/events{/privacy}","received_events_url":"https://api.github.com/users/bergundy/received_events","type":"User","user_view_type":"public","site_admin":false},"body":"In our last conversation we said that the timeout would be enforced on the caller side where the deadline buffer is set. You will need to enforce a max deadline in the request handler anyways. The way you've implemented this is complicating the code and isn't the right behavior.","created_at":"2025-12-01T19:34:30Z","updated_at":"2025-12-02T00:31:36Z","html_url":"https://github.com/temporalio/temporal/pull/8563#discussion_r2578360812","pull_request_url":"https://api.github.com/repos/temporalio/temporal/pulls/8563","_links":{"self":{"href":"https://api.github.com/repos/temporalio/temporal/pulls/comments/2578360812"},"html":{"href":"https://github.com/temporalio/temporal/pull/8563#discussion_r2578360812"},"pull_request":{"href":"https://api.github.com/repos/temporalio/temporal/pulls/8563"}},"reactions":{"url":"https://api.github.com/repos/temporalio/temporal/pulls/comments/2578360812/reactions","total_count":0,"+1":0,"-1":0,"laugh":0,"hooray":0,"confused":0,"heart":0,"rocket":0,"eyes":0},"start_line":null,"original_start_line":null,"start_side":null,"line":null,"original_line":310,"side":"RIGHT","author_association":"MEMBER","original_position":126,"position":1,"subject_type":"line"},{"url":"https://api.github.com/repos/temporalio/temporal/pulls/comments/2579102749","pull_request_review_id":3526477399,"id":2579102749,"node_id":"PRRC_kwDODNqesM6Zufwd","diff_hunk":"@@ -53,3 +56,115 @@ func (h *handler) StartActivityExecution(ctx context.Context, req *activitypb.St\n \t\tFrontendResponse: response,\n \t}, nil\n }\n+\n+// PollActivityExecution handles PollActivityExecutionRequest from frontend. This method supports\n+// querying current activity state, optionally as a long-poll that waits for certain state changes.\n+// It is used by clients to poll for activity state and/or result.\n+func (h *handler) PollActivityExecution(\n+\tctx context.Context,\n+\treq *activitypb.PollActivityExecutionRequest,\n+) (response *activitypb.PollActivityExecutionResponse, err error) {\n+\tref := chasm.NewComponentRef[*Activity](chasm.EntityKey{\n+\t\tNamespaceID: req.GetNamespaceId(),\n+\t\tBusinessID:  req.GetFrontendRequest().GetActivityId(),\n+\t\tEntityID:    req.GetFrontendRequest().GetRunId(),\n+\t})\n+\tdefer func() {\n+\t\tvar notFound *serviceerror.NotFound\n+\t\tif errors.As(err, &notFound) {\n+\t\t\t// TODO(dan): include execution key in error message; we may do this at the CHASM\n+\t\t\t// framework level.\n+\t\t\t// cf. \"workflow execution not found for workflow ID XXX and run ID YYY\"\n+\t\t\terr = serviceerror.NewNotFound(\"activity execution not found\")\n+\t\t}\n+\t}()\n+\n+\twaitPolicy := req.GetFrontendRequest().GetWaitPolicy()\n+\n+\tif waitPolicy == nil {\n+\t\treturn chasm.ReadComponent(ctx, ref, (*Activity).buildPollActivityExecutionResponse, req, nil)\n+\t}\n+\n+\t// Do not allow long-poll to use all remaining time\n+\tchildCtx := ctx\n+\tif deadline, ok := ctx.Deadline(); ok {\n+\t\tvar cancel context.CancelFunc\n+\t\tchildCtx, cancel = context.WithDeadline(ctx, deadline.Add(-time.Second))\n+\t\tdefer cancel()\n+\t}\n+\n+\tswitch waitPolicy.(type) {\n+\tcase *workflowservice.PollActivityExecutionRequest_WaitAnyStateChange:\n+\t\ttoken := req.GetFrontendRequest().\n+\t\t\tGetWaitPolicy().(*workflowservice.PollActivityExecutionRequest_WaitAnyStateChange).\n+\t\t\tWaitAnyStateChange.GetLongPollToken()\n+\t\tif len(token) == 0 {\n+\t\t\treturn chasm.ReadComponent(ctx, ref, (*Activity).buildPollActivityExecutionResponse, req, nil)\n+\t\t}\n+\t\tresponse, _, err = chasm.PollComponent(childCtx, ref, func(\n+\t\t\ta *Activity,\n+\t\t\tctx chasm.Context,\n+\t\t\treq *activitypb.PollActivityExecutionRequest,\n+\t\t) (*activitypb.PollActivityExecutionResponse, bool, error) {\n+\t\t\tchanged, err := chasm.ExecutionStateChanged(a, ctx, token)\n+\t\t\tif err != nil {\n+\t\t\t\tif errors.Is(err, chasm.ErrMalformedComponentRef) {\n+\t\t\t\t\treturn nil, false, serviceerror.NewInvalidArgument(\"invalid long poll token\")\n+\t\t\t\t}\n+\t\t\t\tif errors.Is(err, chasm.ErrInvalidComponentRef) {\n+\t\t\t\t\treturn nil, false, serviceerror.NewInvalidArgument(\"long poll token does not match execution\")\n+\t\t\t\t}\n+\t\t\t\treturn nil, false, err\n+\t\t\t}\n+\t\t\tif changed {\n+\t\t\t\tresponse, err := a.buildPollActivityExecutionResponse(ctx, req)\n+\t\t\t\treturn response, true, err\n+\t\t\t} else {\n+\t\t\t\treturn nil, false, nil\n+\t\t\t}\n+\t\t}, req)\n+\tcase *workflowservice.PollActivityExecutionRequest_WaitCompletion:\n+\t\t// TODO(dan): add functional test when RecordActivityTaskCompleted is implemented\n+\t\tresponse, _, err = chasm.PollComponent(childCtx, ref, func(\n+\t\t\ta *Activity,\n+\t\t\tctx chasm.Context,\n+\t\t\treq *activitypb.PollActivityExecutionRequest,\n+\t\t) (*activitypb.PollActivityExecutionResponse, bool, error) {\n+\t\t\t// TODO(dan): check for terminal activity states\n+\t\t\tpanic(\"pollActivityExecutionWaitCompletion is not implemented\")\n+\t\t\tcompleted := false\n+\t\t\tif completed {\n+\t\t\t\tresponse, err := a.buildPollActivityExecutionResponse(ctx, req)\n+\t\t\t\tif err != nil {\n+\t\t\t\t\treturn nil, true, err\n+\t\t\t\t}\n+\t\t\t\treturn response, true, nil\n+\t\t\t}\n+\t\t\treturn nil, false, nil\n+\t\t}, req)\n+\tdefault:\n+\t\treturn nil, serviceerror.NewInvalidArgumentf(\"unexpected wait policy type: %T\", waitPolicy)\n+\t}\n+\n+\tif childCtx.Err() != nil {","path":"chasm/lib/activity/handler.go","commit_id":"59d749626d6a00c5fff76abe79a85eb627366521","original_commit_id":"59d749626d6a00c5fff76abe79a85eb627366521","user":{"login":"bergundy","id":52304,"node_id":"MDQ6VXNlcjUyMzA0","avatar_url":"https://avatars.githubusercontent.com/u/52304?v=4","gravatar_id":"","url":"https://api.github.com/users/bergundy","html_url":"https://github.com/bergundy","followers_url":"https://api.github.com/users/bergundy/followers","following_url":"https://api.github.com/users/bergundy/following{/other_user}","gists_url":"https://api.github.com/users/bergundy/gists{/gist_id}","starred_url":"https://api.github.com/users/bergundy/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/bergundy/subscriptions","organizations_url":"https://api.github.com/users/bergundy/orgs","repos_url":"https://api.github.com/users/bergundy/repos","events_url":"https://api.github.com/users/bergundy/events{/privacy}","received_events_url":"https://api.github.com/users/bergundy/received_events","type":"User","user_view_type":"public","site_admin":false},"body":"You should't error out here, you want to return an empty response. Use `contextutil.WithDeadlineBuffer` here instead of enforcing a max wait time in the poll component implementation.","created_at":"2025-12-01T23:48:06Z","updated_at":"2025-12-02T00:31:36Z","html_url":"https://github.com/temporalio/temporal/pull/8563#discussion_r2579102749","pull_request_url":"https://api.github.com/repos/temporalio/temporal/pulls/8563","_links":{"self":{"href":"https://api.github.com/repos/temporalio/temporal/pulls/comments/2579102749"},"html":{"href":"https://github.com/temporalio/temporal/pull/8563#discussion_r2579102749"},"pull_request":{"href":"https://api.github.com/repos/temporalio/temporal/pulls/8563"}},"reactions":{"url":"https://api.github.com/repos/temporalio/temporal/pulls/comments/2579102749/reactions","total_count":0,"+1":0,"-1":0,"laugh":0,"hooray":0,"confused":0,"heart":0,"rocket":0,"eyes":0},"start_line":null,"original_start_line":null,"start_side":null,"line":null,"original_line":149,"side":"RIGHT","author_association":"MEMBER","original_position":105,"position":1,"subject_type":"line"},{"url":"https://api.github.com/repos/temporalio/temporal/pulls/comments/2579110212","pull_request_review_id":3526477399,"id":2579110212,"node_id":"PRRC_kwDODNqesM6ZuhlE","diff_hunk":"@@ -241,14 +256,137 @@ func (e *ChasmEngine) ReadComponent(\n \treturn readFn(chasmContext, component)\n }\n \n+// PollComponent waits until the supplied predicate is satisfied when evaluated against the\n+// component identified by the supplied component reference. If there is no error, it returns (ref,\n+// nil) where ref is a component reference identifying the state at which the predicate was\n+// satisfied. The predicate must be monotonic: if it returns true at execution state transition s it\n+// must return true at all transitions t > s. It is an error if execution transition history is\n+// (after reloading from persistence) behind the requested ref, or if the ref is inconsistent with\n+// execution transition history. Thus when the predicate function is evaluated, it is guaranteed\n+// that the execution VT >= requestRef VT. opts are currently ignored.\n func (e *ChasmEngine) PollComponent(\n \tctx context.Context,\n-\tentityRef chasm.ComponentRef,\n-\tpredicateFn func(chasm.Context, chasm.Component) (any, bool, error),\n-\toperationFn func(chasm.MutableContext, chasm.Component, any) error,\n+\trequestRef chasm.ComponentRef,\n+\tmonotonicPredicate func(chasm.Context, chasm.Component) (bool, error),\n \topts ...chasm.TransitionOption,\n-) (newEntityRef []byte, retError error) {\n-\treturn nil, serviceerror.NewUnimplemented(\"PollComponent is not yet supported\")\n+) (retRef []byte, retError error) {\n+\tdefer func() {\n+\t\tif errors.Is(retError, consts.ErrStaleState) {\n+\t\t\tretError = serviceerror.NewUnavailable(\"please retry\")\n+\t\t}\n+\t}()\n+\n+\tshardContext, executionLease, err := e.getExecutionLease(ctx, requestRef)\n+\tif err != nil {\n+\t\t// E.g. requestRef VT inconsistent with execution VT ('stale reference')\n+\t\treturn nil, err\n+\t}\n+\tdefer executionLease.GetReleaseFn()(nil)\n+\n+\t// At this point it's possible that execution VT < requestRef VT (getExecutionLease does not\n+\t// guarantee that returned execution state is non-stale w.r.t. requestRef).\n+\tsatisfiedRef, err := e.predicateSatisfied(ctx, monotonicPredicate, requestRef, executionLease)\n+\tif err != nil {\n+\t\treturn nil, err\n+\t}\n+\t// execution VT >= requestRef VT (enforced by predicateSatisfied)\n+\n+\tif satisfiedRef != nil {\n+\t\t// wait condition was satisfied\n+\t\treturn satisfiedRef, nil\n+\t}\n+\n+\t// Wait condition not satisfied; long-poll\n+\n+\tnamespaceRegistry, err := shardContext.GetNamespaceRegistry().GetNamespaceByID(\n+\t\tnamespace.ID(requestRef.EntityKey.NamespaceID),\n+\t)\n+\tif err != nil {\n+\t\treturn nil, err\n+\t}\n+\n+\tinternalLongPollTimeout := shardContext.GetConfig().LongPollExpirationInterval(namespaceRegistry.Name().String())\n+\tctx, cancel := context.WithTimeout(ctx, internalLongPollTimeout)\n+\tdefer cancel()\n+\n+\t// PollComponent subscribes to execution-level notifications. Suppose that an execution consists\n+\t// of one component A, and A has subcomponent B. Subscribers interested only in component B may\n+\t// be woken up unnecessarily (and thus evaluate the predicate unnecessarily) due to changes in\n+\t// parts of A that do not also belong to B.\n+\tch := e.notifier.Subscribe(requestRef.EntityKey)\n+\texecutionLease.GetReleaseFn()(nil)\n+\n+\tfor {\n+\t\tselect {\n+\t\t// It is possible that multiple state transitions (multiple notifications) occur between\n+\t\t// predicate checks, therefore the predicate must be monotonic: if it returns true at\n+\t\t// execution state transition s then it must return true at all transitions t > s.\n+\t\tcase <-ch:\n+\t\t\t_, executionLease, err := e.getExecutionLease(ctx, requestRef)\n+\t\t\tif err != nil {\n+\t\t\t\treturn nil, err\n+\t\t\t}\n+\t\t\tfunc() {","path":"service/history/chasm_engine.go","commit_id":"372cc0a17931bd461ec03349b8509b57820e36c2","original_commit_id":"59d749626d6a00c5fff76abe79a85eb627366521","user":{"login":"bergundy","id":52304,"node_id":"MDQ6VXNlcjUyMzA0","avatar_url":"https://avatars.githubusercontent.com/u/52304?v=4","gravatar_id":"","url":"https://api.github.com/users/bergundy","html_url":"https://github.com/bergundy","followers_url":"https://api.github.com/users/bergundy/followers","following_url":"https://api.github.com/users/bergundy/following{/other_user}","gists_url":"https://api.github.com/users/bergundy/gists{/gist_id}","starred_url":"https://api.github.com/users/bergundy/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/bergundy/subscriptions","organizations_url":"https://api.github.com/users/bergundy/orgs","repos_url":"https://api.github.com/users/bergundy/repos","events_url":"https://api.github.com/users/bergundy/events{/privacy}","received_events_url":"https://api.github.com/users/bergundy/received_events","type":"User","user_view_type":"public","site_admin":false},"body":"Maybe put this entire case branch in a separate function instead of adding an anonymous function in the middle here? Seems cleaner.","created_at":"2025-12-01T23:53:06Z","updated_at":"2025-12-02T00:31:36Z","html_url":"https://github.com/temporalio/temporal/pull/8563#discussion_r2579110212","pull_request_url":"https://api.github.com/repos/temporalio/temporal/pulls/8563","_links":{"self":{"href":"https://api.github.com/repos/temporalio/temporal/pulls/comments/2579110212"},"html":{"href":"https://github.com/temporalio/temporal/pull/8563#discussion_r2579110212"},"pull_request":{"href":"https://api.github.com/repos/temporalio/temporal/pulls/8563"}},"reactions":{"url":"https://api.github.com/repos/temporalio/temporal/pulls/comments/2579110212/reactions","total_count":0,"+1":0,"-1":0,"laugh":0,"hooray":0,"confused":0,"heart":0,"rocket":0,"eyes":0},"start_line":null,"original_start_line":null,"start_side":null,"line":null,"original_line":329,"side":"RIGHT","author_association":"MEMBER","original_position":145,"position":1,"subject_type":"line"},{"url":"https://api.github.com/repos/temporalio/temporal/pulls/comments/2579113526","pull_request_review_id":3526477399,"id":2579113526,"node_id":"PRRC_kwDODNqesM6ZuiY2","diff_hunk":"@@ -241,14 +256,137 @@ func (e *ChasmEngine) ReadComponent(\n \treturn readFn(chasmContext, component)\n }\n \n+// PollComponent waits until the supplied predicate is satisfied when evaluated against the\n+// component identified by the supplied component reference. If there is no error, it returns (ref,\n+// nil) where ref is a component reference identifying the state at which the predicate was\n+// satisfied. The predicate must be monotonic: if it returns true at execution state transition s it\n+// must return true at all transitions t > s. It is an error if execution transition history is\n+// (after reloading from persistence) behind the requested ref, or if the ref is inconsistent with\n+// execution transition history. Thus when the predicate function is evaluated, it is guaranteed\n+// that the execution VT >= requestRef VT. opts are currently ignored.\n func (e *ChasmEngine) PollComponent(\n \tctx context.Context,\n-\tentityRef chasm.ComponentRef,\n-\tpredicateFn func(chasm.Context, chasm.Component) (any, bool, error),\n-\toperationFn func(chasm.MutableContext, chasm.Component, any) error,\n+\trequestRef chasm.ComponentRef,\n+\tmonotonicPredicate func(chasm.Context, chasm.Component) (bool, error),\n \topts ...chasm.TransitionOption,\n-) (newEntityRef []byte, retError error) {\n-\treturn nil, serviceerror.NewUnimplemented(\"PollComponent is not yet supported\")\n+) (retRef []byte, retError error) {\n+\tdefer func() {\n+\t\tif errors.Is(retError, consts.ErrStaleState) {\n+\t\t\tretError = serviceerror.NewUnavailable(\"please retry\")\n+\t\t}\n+\t}()\n+\n+\tshardContext, executionLease, err := e.getExecutionLease(ctx, requestRef)\n+\tif err != nil {\n+\t\t// E.g. requestRef VT inconsistent with execution VT ('stale reference')\n+\t\treturn nil, err\n+\t}\n+\tdefer executionLease.GetReleaseFn()(nil)","path":"service/history/chasm_engine.go","commit_id":"372cc0a17931bd461ec03349b8509b57820e36c2","original_commit_id":"59d749626d6a00c5fff76abe79a85eb627366521","user":{"login":"bergundy","id":52304,"node_id":"MDQ6VXNlcjUyMzA0","avatar_url":"https://avatars.githubusercontent.com/u/52304?v=4","gravatar_id":"","url":"https://api.github.com/users/bergundy","html_url":"https://github.com/bergundy","followers_url":"https://api.github.com/users/bergundy/followers","following_url":"https://api.github.com/users/bergundy/following{/other_user}","gists_url":"https://api.github.com/users/bergundy/gists{/gist_id}","starred_url":"https://api.github.com/users/bergundy/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/bergundy/subscriptions","organizations_url":"https://api.github.com/users/bergundy/orgs","repos_url":"https://api.github.com/users/bergundy/repos","events_url":"https://api.github.com/users/bergundy/events{/privacy}","received_events_url":"https://api.github.com/users/bergundy/received_events","type":"User","user_view_type":"public","site_admin":false},"body":"Just verifying that it's safe to call this function twice.","created_at":"2025-12-01T23:55:26Z","updated_at":"2025-12-02T00:31:36Z","html_url":"https://github.com/temporalio/temporal/pull/8563#discussion_r2579113526","pull_request_url":"https://api.github.com/repos/temporalio/temporal/pulls/8563","_links":{"self":{"href":"https://api.github.com/repos/temporalio/temporal/pulls/comments/2579113526"},"html":{"href":"https://github.com/temporalio/temporal/pull/8563#discussion_r2579113526"},"pull_request":{"href":"https://api.github.com/repos/temporalio/temporal/pulls/8563"}},"reactions":{"url":"https://api.github.com/repos/temporalio/temporal/pulls/comments/2579113526/reactions","total_count":0,"+1":0,"-1":0,"laugh":0,"hooray":0,"confused":0,"heart":0,"rocket":0,"eyes":0},"start_line":null,"original_start_line":null,"start_side":null,"line":null,"original_line":284,"side":"RIGHT","author_association":"MEMBER","original_position":100,"position":1,"subject_type":"line"},{"url":"https://api.github.com/repos/temporalio/temporal/pulls/comments/2579116337","pull_request_review_id":3526477399,"id":2579116337,"node_id":"PRRC_kwDODNqesM6ZujEx","diff_hunk":"@@ -241,14 +256,137 @@ func (e *ChasmEngine) ReadComponent(\n \treturn readFn(chasmContext, component)\n }\n \n+// PollComponent waits until the supplied predicate is satisfied when evaluated against the\n+// component identified by the supplied component reference. If there is no error, it returns (ref,\n+// nil) where ref is a component reference identifying the state at which the predicate was\n+// satisfied. The predicate must be monotonic: if it returns true at execution state transition s it\n+// must return true at all transitions t > s. It is an error if execution transition history is\n+// (after reloading from persistence) behind the requested ref, or if the ref is inconsistent with\n+// execution transition history. Thus when the predicate function is evaluated, it is guaranteed\n+// that the execution VT >= requestRef VT. opts are currently ignored.\n func (e *ChasmEngine) PollComponent(\n \tctx context.Context,\n-\tentityRef chasm.ComponentRef,\n-\tpredicateFn func(chasm.Context, chasm.Component) (any, bool, error),\n-\toperationFn func(chasm.MutableContext, chasm.Component, any) error,\n+\trequestRef chasm.ComponentRef,\n+\tmonotonicPredicate func(chasm.Context, chasm.Component) (bool, error),\n \topts ...chasm.TransitionOption,\n-) (newEntityRef []byte, retError error) {\n-\treturn nil, serviceerror.NewUnimplemented(\"PollComponent is not yet supported\")\n+) (retRef []byte, retError error) {\n+\tdefer func() {\n+\t\tif errors.Is(retError, consts.ErrStaleState) {\n+\t\t\tretError = serviceerror.NewUnavailable(\"please retry\")\n+\t\t}\n+\t}()\n+\n+\tshardContext, executionLease, err := e.getExecutionLease(ctx, requestRef)\n+\tif err != nil {\n+\t\t// E.g. requestRef VT inconsistent with execution VT ('stale reference')\n+\t\treturn nil, err\n+\t}\n+\tdefer executionLease.GetReleaseFn()(nil)\n+\n+\t// At this point it's possible that execution VT < requestRef VT (getExecutionLease does not\n+\t// guarantee that returned execution state is non-stale w.r.t. requestRef).\n+\tsatisfiedRef, err := e.predicateSatisfied(ctx, monotonicPredicate, requestRef, executionLease)\n+\tif err != nil {\n+\t\treturn nil, err\n+\t}\n+\t// execution VT >= requestRef VT (enforced by predicateSatisfied)\n+\n+\tif satisfiedRef != nil {\n+\t\t// wait condition was satisfied\n+\t\treturn satisfiedRef, nil\n+\t}\n+\n+\t// Wait condition not satisfied; long-poll\n+\n+\tnamespaceRegistry, err := shardContext.GetNamespaceRegistry().GetNamespaceByID(\n+\t\tnamespace.ID(requestRef.EntityKey.NamespaceID),\n+\t)\n+\tif err != nil {\n+\t\treturn nil, err\n+\t}\n+\n+\tinternalLongPollTimeout := shardContext.GetConfig().LongPollExpirationInterval(namespaceRegistry.Name().String())\n+\tctx, cancel := context.WithTimeout(ctx, internalLongPollTimeout)\n+\tdefer cancel()\n+\n+\t// PollComponent subscribes to execution-level notifications. Suppose that an execution consists\n+\t// of one component A, and A has subcomponent B. Subscribers interested only in component B may\n+\t// be woken up unnecessarily (and thus evaluate the predicate unnecessarily) due to changes in\n+\t// parts of A that do not also belong to B.\n+\tch := e.notifier.Subscribe(requestRef.EntityKey)\n+\texecutionLease.GetReleaseFn()(nil)\n+\n+\tfor {\n+\t\tselect {\n+\t\t// It is possible that multiple state transitions (multiple notifications) occur between\n+\t\t// predicate checks, therefore the predicate must be monotonic: if it returns true at\n+\t\t// execution state transition s then it must return true at all transitions t > s.\n+\t\tcase <-ch:\n+\t\t\t_, executionLease, err := e.getExecutionLease(ctx, requestRef)\n+\t\t\tif err != nil {\n+\t\t\t\treturn nil, err\n+\t\t\t}\n+\t\t\tfunc() {","path":"service/history/chasm_engine.go","commit_id":"372cc0a17931bd461ec03349b8509b57820e36c2","original_commit_id":"59d749626d6a00c5fff76abe79a85eb627366521","user":{"login":"bergundy","id":52304,"node_id":"MDQ6VXNlcjUyMzA0","avatar_url":"https://avatars.githubusercontent.com/u/52304?v=4","gravatar_id":"","url":"https://api.github.com/users/bergundy","html_url":"https://github.com/bergundy","followers_url":"https://api.github.com/users/bergundy/followers","following_url":"https://api.github.com/users/bergundy/following{/other_user}","gists_url":"https://api.github.com/users/bergundy/gists{/gist_id}","starred_url":"https://api.github.com/users/bergundy/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/bergundy/subscriptions","organizations_url":"https://api.github.com/users/bergundy/orgs","repos_url":"https://api.github.com/users/bergundy/repos","events_url":"https://api.github.com/users/bergundy/events{/privacy}","received_events_url":"https://api.github.com/users/bergundy/received_events","type":"User","user_view_type":"public","site_admin":false},"body":"Seems like both here and above, just before the select statement, you want to subscribe if the predicate isn't satisfied and you always want to release as soon as you've subscribed or resolved the predicate.","created_at":"2025-12-01T23:57:26Z","updated_at":"2025-12-02T00:31:37Z","html_url":"https://github.com/temporalio/temporal/pull/8563#discussion_r2579116337","pull_request_url":"https://api.github.com/repos/temporalio/temporal/pulls/8563","_links":{"self":{"href":"https://api.github.com/repos/temporalio/temporal/pulls/comments/2579116337"},"html":{"href":"https://github.com/temporalio/temporal/pull/8563#discussion_r2579116337"},"pull_request":{"href":"https://api.github.com/repos/temporalio/temporal/pulls/8563"}},"reactions":{"url":"https://api.github.com/repos/temporalio/temporal/pulls/comments/2579116337/reactions","total_count":0,"+1":0,"-1":0,"laugh":0,"hooray":0,"confused":0,"heart":0,"rocket":0,"eyes":0},"start_line":null,"original_start_line":null,"start_side":null,"line":null,"original_line":329,"side":"RIGHT","in_reply_to_id":2579110212,"author_association":"MEMBER","original_position":145,"position":1,"subject_type":"line"},{"url":"https://api.github.com/repos/temporalio/temporal/pulls/comments/2579118993","pull_request_review_id":3526477399,"id":2579118993,"node_id":"PRRC_kwDODNqesM6ZujuR","diff_hunk":"@@ -241,14 +256,137 @@ func (e *ChasmEngine) ReadComponent(\n \treturn readFn(chasmContext, component)\n }\n \n+// PollComponent waits until the supplied predicate is satisfied when evaluated against the\n+// component identified by the supplied component reference. If there is no error, it returns (ref,\n+// nil) where ref is a component reference identifying the state at which the predicate was\n+// satisfied. The predicate must be monotonic: if it returns true at execution state transition s it\n+// must return true at all transitions t > s. It is an error if execution transition history is\n+// (after reloading from persistence) behind the requested ref, or if the ref is inconsistent with\n+// execution transition history. Thus when the predicate function is evaluated, it is guaranteed\n+// that the execution VT >= requestRef VT. opts are currently ignored.\n func (e *ChasmEngine) PollComponent(\n \tctx context.Context,\n-\tentityRef chasm.ComponentRef,\n-\tpredicateFn func(chasm.Context, chasm.Component) (any, bool, error),\n-\toperationFn func(chasm.MutableContext, chasm.Component, any) error,\n+\trequestRef chasm.ComponentRef,\n+\tmonotonicPredicate func(chasm.Context, chasm.Component) (bool, error),\n \topts ...chasm.TransitionOption,\n-) (newEntityRef []byte, retError error) {\n-\treturn nil, serviceerror.NewUnimplemented(\"PollComponent is not yet supported\")\n+) (retRef []byte, retError error) {\n+\tdefer func() {\n+\t\tif errors.Is(retError, consts.ErrStaleState) {\n+\t\t\tretError = serviceerror.NewUnavailable(\"please retry\")\n+\t\t}\n+\t}()\n+\n+\tshardContext, executionLease, err := e.getExecutionLease(ctx, requestRef)\n+\tif err != nil {\n+\t\t// E.g. requestRef VT inconsistent with execution VT ('stale reference')\n+\t\treturn nil, err\n+\t}\n+\tdefer executionLease.GetReleaseFn()(nil)\n+\n+\t// At this point it's possible that execution VT < requestRef VT (getExecutionLease does not\n+\t// guarantee that returned execution state is non-stale w.r.t. requestRef).\n+\tsatisfiedRef, err := e.predicateSatisfied(ctx, monotonicPredicate, requestRef, executionLease)\n+\tif err != nil {\n+\t\treturn nil, err\n+\t}\n+\t// execution VT >= requestRef VT (enforced by predicateSatisfied)\n+\n+\tif satisfiedRef != nil {\n+\t\t// wait condition was satisfied\n+\t\treturn satisfiedRef, nil\n+\t}\n+\n+\t// Wait condition not satisfied; long-poll\n+\n+\tnamespaceRegistry, err := shardContext.GetNamespaceRegistry().GetNamespaceByID(\n+\t\tnamespace.ID(requestRef.EntityKey.NamespaceID),\n+\t)\n+\tif err != nil {\n+\t\treturn nil, err\n+\t}\n+\n+\tinternalLongPollTimeout := shardContext.GetConfig().LongPollExpirationInterval(namespaceRegistry.Name().String())\n+\tctx, cancel := context.WithTimeout(ctx, internalLongPollTimeout)\n+\tdefer cancel()\n+\n+\t// PollComponent subscribes to execution-level notifications. Suppose that an execution consists\n+\t// of one component A, and A has subcomponent B. Subscribers interested only in component B may\n+\t// be woken up unnecessarily (and thus evaluate the predicate unnecessarily) due to changes in\n+\t// parts of A that do not also belong to B.\n+\tch := e.notifier.Subscribe(requestRef.EntityKey)\n+\texecutionLease.GetReleaseFn()(nil)\n+\n+\tfor {\n+\t\tselect {\n+\t\t// It is possible that multiple state transitions (multiple notifications) occur between\n+\t\t// predicate checks, therefore the predicate must be monotonic: if it returns true at\n+\t\t// execution state transition s then it must return true at all transitions t > s.\n+\t\tcase <-ch:\n+\t\t\t_, executionLease, err := e.getExecutionLease(ctx, requestRef)\n+\t\t\tif err != nil {\n+\t\t\t\treturn nil, err\n+\t\t\t}\n+\t\t\tfunc() {\n+\t\t\t\tdefer executionLease.GetReleaseFn()(nil)\n+\t\t\t\tsatisfiedRef, err = e.predicateSatisfied(ctx, monotonicPredicate, requestRef, executionLease)\n+\t\t\t\tif err == nil && satisfiedRef == nil {\n+\t\t\t\t\tch = e.notifier.Subscribe(requestRef.EntityKey)\n+\t\t\t\t}\n+\t\t\t}()\n+\t\t\tif err != nil {\n+\t\t\t\treturn nil, err\n+\t\t\t}\n+\t\t\tif satisfiedRef != nil {\n+\t\t\t\treturn satisfiedRef, nil\n+\t\t\t}\n+\t\tcase <-ctx.Done():\n+\t\t\treturn nil, ctx.Err()\n+\t\t}\n+\t}\n+}\n+\n+// predicateSatisfied is a helper function for PollComponent. It returns (ref, err) where ref is non-nil\n+// iff there's no error and predicate evaluates to true.\n+func (e *ChasmEngine) predicateSatisfied(\n+\tctx context.Context,\n+\tpredicate func(chasm.Context, chasm.Component) (bool, error),\n+\tref chasm.ComponentRef,\n+\texecutionLease api.WorkflowLease,\n+) ([]byte, error) {\n+\tchasmTree, ok := executionLease.GetMutableState().ChasmTree().(*chasm.Node)\n+\tif !ok {\n+\t\treturn nil, serviceerror.NewInternalf(\n+\t\t\t\"CHASM tree implementation not properly wired up, encountered type: %T, expected type: %T\",\n+\t\t\texecutionLease.GetMutableState().ChasmTree(),\n+\t\t\t&chasm.Node{},\n+\t\t)\n+\t}\n+\n+\t// It is not acceptable to declare the predicate to be satisfied against execution state that is\n+\t// behind the requested reference. However, getExecutionLease does not currently guarantee that\n+\t// execution VT >= ref VT, therefore we call IsStale() again here and return any error (which at\n+\t// this point must be ErrStaleState; ErrStaleReference has already been eliminated).\n+\terr := chasmTree.IsStale(ref)\n+\tif err != nil {\n+\t\t// ErrStaleState\n+\t\t// TODO(dan): this should be retryable if it is the failover version that is stale","path":"service/history/chasm_engine.go","commit_id":"1d59e66d0ce5d91819f92c428ef5ab4c4efca1fb","original_commit_id":"59d749626d6a00c5fff76abe79a85eb627366521","user":{"login":"bergundy","id":52304,"node_id":"MDQ6VXNlcjUyMzA0","avatar_url":"https://avatars.githubusercontent.com/u/52304?v=4","gravatar_id":"","url":"https://api.github.com/users/bergundy","html_url":"https://github.com/bergundy","followers_url":"https://api.github.com/users/bergundy/followers","following_url":"https://api.github.com/users/bergundy/following{/other_user}","gists_url":"https://api.github.com/users/bergundy/gists{/gist_id}","starred_url":"https://api.github.com/users/bergundy/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/bergundy/subscriptions","organizations_url":"https://api.github.com/users/bergundy/orgs","repos_url":"https://api.github.com/users/bergundy/repos","events_url":"https://api.github.com/users/bergundy/events{/privacy}","received_events_url":"https://api.github.com/users/bergundy/received_events","type":"User","user_view_type":"public","site_admin":false},"body":"Shouldn't it always be retryable? Seems like we should return unavailable errors in this case assuming that we've refreshed the state.","created_at":"2025-12-01T23:59:09Z","updated_at":"2025-12-02T00:31:37Z","html_url":"https://github.com/temporalio/temporal/pull/8563#discussion_r2579118993","pull_request_url":"https://api.github.com/repos/temporalio/temporal/pulls/8563","_links":{"self":{"href":"https://api.github.com/repos/temporalio/temporal/pulls/comments/2579118993"},"html":{"href":"https://github.com/temporalio/temporal/pull/8563#discussion_r2579118993"},"pull_request":{"href":"https://api.github.com/repos/temporalio/temporal/pulls/8563"}},"reactions":{"url":"https://api.github.com/repos/temporalio/temporal/pulls/comments/2579118993/reactions","total_count":0,"+1":0,"-1":0,"laugh":0,"hooray":0,"confused":0,"heart":0,"rocket":0,"eyes":0},"start_line":null,"original_start_line":null,"start_side":null,"line":354,"original_line":372,"side":"RIGHT","author_association":"MEMBER","original_position":188,"position":166,"subject_type":"line"},{"url":"https://api.github.com/repos/temporalio/temporal/pulls/comments/2579132729","pull_request_review_id":3526477399,"id":2579132729,"node_id":"PRRC_kwDODNqesM6ZunE5","diff_hunk":"","path":"service/history/chasm_notifier.go","commit_id":"1d59e66d0ce5d91819f92c428ef5ab4c4efca1fb","original_commit_id":"59d749626d6a00c5fff76abe79a85eb627366521","user":{"login":"bergundy","id":52304,"node_id":"MDQ6VXNlcjUyMzA0","avatar_url":"https://avatars.githubusercontent.com/u/52304?v=4","gravatar_id":"","url":"https://api.github.com/users/bergundy","html_url":"https://github.com/bergundy","followers_url":"https://api.github.com/users/bergundy/followers","following_url":"https://api.github.com/users/bergundy/following{/other_user}","gists_url":"https://api.github.com/users/bergundy/gists{/gist_id}","starred_url":"https://api.github.com/users/bergundy/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/bergundy/subscriptions","organizations_url":"https://api.github.com/users/bergundy/orgs","repos_url":"https://api.github.com/users/bergundy/repos","events_url":"https://api.github.com/users/bergundy/events{/privacy}","received_events_url":"https://api.github.com/users/bergundy/received_events","type":"User","user_view_type":"public","site_admin":false},"body":"You will want to just document the semantics where subscribe only gives you one notification and that you will need to evaluate a condition and resubscribe while holding a lock on the execution.","created_at":"2025-12-02T00:08:18Z","updated_at":"2025-12-02T00:31:37Z","html_url":"https://github.com/temporalio/temporal/pull/8563#discussion_r2579132729","pull_request_url":"https://api.github.com/repos/temporalio/temporal/pulls/8563","_links":{"self":{"href":"https://api.github.com/repos/temporalio/temporal/pulls/comments/2579132729"},"html":{"href":"https://github.com/temporalio/temporal/pull/8563#discussion_r2579132729"},"pull_request":{"href":"https://api.github.com/repos/temporalio/temporal/pulls/8563"}},"reactions":{"url":"https://api.github.com/repos/temporalio/temporal/pulls/comments/2579132729/reactions","total_count":0,"+1":0,"-1":0,"laugh":0,"hooray":0,"confused":0,"heart":0,"rocket":0,"eyes":0},"start_line":null,"original_start_line":null,"start_side":null,"line":1,"original_line":1,"side":"RIGHT","author_association":"MEMBER","original_position":1,"position":1,"subject_type":"file"},{"url":"https://api.github.com/repos/temporalio/temporal/pulls/comments/2579139461","pull_request_review_id":3526477399,"id":2579139461,"node_id":"PRRC_kwDODNqesM6ZuouF","diff_hunk":"@@ -0,0 +1,46 @@\n+package history\n+\n+import (\n+\t\"sync\"\n+\n+\t\"go.temporal.io/server/chasm\"\n+\t\"go.temporal.io/server/common/metrics\"\n+)\n+\n+type (\n+\t// ChasmNotifier allows subscribers to receive notifications relating to a CHASM execution.\n+\tChasmNotifier struct {\n+\t\texecutions map[chasm.EntityKey]chan struct{}\n+\t\tlock       sync.Mutex","path":"service/history/chasm_notifier.go","commit_id":"ba38880058f288839d9fd74d46b7ac8dbc549f5c","original_commit_id":"59d749626d6a00c5fff76abe79a85eb627366521","user":{"login":"bergundy","id":52304,"node_id":"MDQ6VXNlcjUyMzA0","avatar_url":"https://avatars.githubusercontent.com/u/52304?v=4","gravatar_id":"","url":"https://api.github.com/users/bergundy","html_url":"https://github.com/bergundy","followers_url":"https://api.github.com/users/bergundy/followers","following_url":"https://api.github.com/users/bergundy/following{/other_user}","gists_url":"https://api.github.com/users/bergundy/gists{/gist_id}","starred_url":"https://api.github.com/users/bergundy/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/bergundy/subscriptions","organizations_url":"https://api.github.com/users/bergundy/orgs","repos_url":"https://api.github.com/users/bergundy/repos","events_url":"https://api.github.com/users/bergundy/events{/privacy}","received_events_url":"https://api.github.com/users/bergundy/received_events","type":"User","user_view_type":"public","site_admin":false},"body":"Might make more sense to use an `RWMutex` here depending on the access pattern but I'm not convinced that's required. You can also use the sharded concurrent hashmap that the previous implementation used to reduce lock contention.","created_at":"2025-12-02T00:12:56Z","updated_at":"2025-12-02T00:31:37Z","html_url":"https://github.com/temporalio/temporal/pull/8563#discussion_r2579139461","pull_request_url":"https://api.github.com/repos/temporalio/temporal/pulls/8563","_links":{"self":{"href":"https://api.github.com/repos/temporalio/temporal/pulls/comments/2579139461"},"html":{"href":"https://github.com/temporalio/temporal/pull/8563#discussion_r2579139461"},"pull_request":{"href":"https://api.github.com/repos/temporalio/temporal/pulls/8563"}},"reactions":{"url":"https://api.github.com/repos/temporalio/temporal/pulls/comments/2579139461/reactions","total_count":0,"+1":0,"-1":0,"laugh":0,"hooray":0,"confused":0,"heart":0,"rocket":0,"eyes":0},"start_line":null,"original_start_line":null,"start_side":null,"line":null,"original_line":14,"side":"RIGHT","author_association":"MEMBER","original_position":14,"position":1,"subject_type":"line"},{"url":"https://api.github.com/repos/temporalio/temporal/pulls/comments/2579141090","pull_request_review_id":3526477399,"id":2579141090,"node_id":"PRRC_kwDODNqesM6ZupHi","diff_hunk":"@@ -0,0 +1,46 @@\n+package history\n+\n+import (\n+\t\"sync\"\n+\n+\t\"go.temporal.io/server/chasm\"\n+\t\"go.temporal.io/server/common/metrics\"\n+)\n+\n+type (\n+\t// ChasmNotifier allows subscribers to receive notifications relating to a CHASM execution.\n+\tChasmNotifier struct {\n+\t\texecutions map[chasm.EntityKey]chan struct{}\n+\t\tlock       sync.Mutex\n+\t}\n+)\n+\n+// NewChasmNotifier creates a new instance of ChasmNotifier.\n+func NewChasmNotifier(metricsHandler metrics.Handler) *ChasmNotifier {\n+\treturn &ChasmNotifier{\n+\t\texecutions: make(map[chasm.EntityKey]chan struct{}),\n+\t}\n+}\n+\n+// Subscribe returns a channel that will be closed when there is a notification relating to the\n+// execution. No data will be written to the channel.\n+func (n *ChasmNotifier) Subscribe(key chasm.EntityKey) <-chan struct{} {","path":"service/history/chasm_notifier.go","commit_id":"372cc0a17931bd461ec03349b8509b57820e36c2","original_commit_id":"59d749626d6a00c5fff76abe79a85eb627366521","user":{"login":"bergundy","id":52304,"node_id":"MDQ6VXNlcjUyMzA0","avatar_url":"https://avatars.githubusercontent.com/u/52304?v=4","gravatar_id":"","url":"https://api.github.com/users/bergundy","html_url":"https://github.com/bergundy","followers_url":"https://api.github.com/users/bergundy/followers","following_url":"https://api.github.com/users/bergundy/following{/other_user}","gists_url":"https://api.github.com/users/bergundy/gists{/gist_id}","starred_url":"https://api.github.com/users/bergundy/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/bergundy/subscriptions","organizations_url":"https://api.github.com/users/bergundy/orgs","repos_url":"https://api.github.com/users/bergundy/repos","events_url":"https://api.github.com/users/bergundy/events{/privacy}","received_events_url":"https://api.github.com/users/bergundy/received_events","type":"User","user_view_type":"public","site_admin":false},"body":"You are going to want an `Unsubscribe` function too in case the notification never comes in.\nFor that you're going to need a waiter count per key to know if you can delete the key from the map and you should only delete if the channel hasn't been updated in the map.\n\n```go\ntype subscriptionTracker struct {\n\tch chan struct{}\n\tnumWaiters int\n}\n```\n\n\n```suggestion\nfunc (n *ChasmNotifier) Subscribe(key chasm.EntityKey) (<-chan struct{}, func()) {\n```","created_at":"2025-12-02T00:13:55Z","updated_at":"2025-12-02T00:31:37Z","html_url":"https://github.com/temporalio/temporal/pull/8563#discussion_r2579141090","pull_request_url":"https://api.github.com/repos/temporalio/temporal/pulls/8563","_links":{"self":{"href":"https://api.github.com/repos/temporalio/temporal/pulls/comments/2579141090"},"html":{"href":"https://github.com/temporalio/temporal/pull/8563#discussion_r2579141090"},"pull_request":{"href":"https://api.github.com/repos/temporalio/temporal/pulls/8563"}},"reactions":{"url":"https://api.github.com/repos/temporalio/temporal/pulls/comments/2579141090/reactions","total_count":1,"+1":1,"-1":0,"laugh":0,"hooray":0,"confused":0,"heart":0,"rocket":0,"eyes":0},"start_line":null,"original_start_line":null,"start_side":null,"line":null,"original_line":27,"side":"RIGHT","author_association":"MEMBER","original_position":27,"position":1,"subject_type":"line"},{"url":"https://api.github.com/repos/temporalio/temporal/pulls/comments/2579142861","pull_request_review_id":3526477399,"id":2579142861,"node_id":"PRRC_kwDODNqesM6ZupjN","diff_hunk":"@@ -838,6 +842,21 @@ func (e *historyEngineImpl) NotifyNewHistoryEvent(\n \te.eventNotifier.NotifyNewHistoryEvent(notification)\n }\n \n+func (e *historyEngineImpl) GetChasmEngine() chasm.Engine {","path":"service/history/history_engine.go","commit_id":"7bf19dc271aec2f2f649077fac915077fc6028fe","original_commit_id":"59d749626d6a00c5fff76abe79a85eb627366521","user":{"login":"bergundy","id":52304,"node_id":"MDQ6VXNlcjUyMzA0","avatar_url":"https://avatars.githubusercontent.com/u/52304?v=4","gravatar_id":"","url":"https://api.github.com/users/bergundy","html_url":"https://github.com/bergundy","followers_url":"https://api.github.com/users/bergundy/followers","following_url":"https://api.github.com/users/bergundy/following{/other_user}","gists_url":"https://api.github.com/users/bergundy/gists{/gist_id}","starred_url":"https://api.github.com/users/bergundy/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/bergundy/subscriptions","organizations_url":"https://api.github.com/users/bergundy/orgs","repos_url":"https://api.github.com/users/bergundy/repos","events_url":"https://api.github.com/users/bergundy/events{/privacy}","received_events_url":"https://api.github.com/users/bergundy/received_events","type":"User","user_view_type":"public","site_admin":false},"body":"Can we call this `ChasmEngine`? Go doesn't like using `Get` for getters and we've been trying to consistently avoid naming them this way for new code.","created_at":"2025-12-02T00:15:26Z","updated_at":"2025-12-02T00:31:37Z","html_url":"https://github.com/temporalio/temporal/pull/8563#discussion_r2579142861","pull_request_url":"https://api.github.com/repos/temporalio/temporal/pulls/8563","_links":{"self":{"href":"https://api.github.com/repos/temporalio/temporal/pulls/comments/2579142861"},"html":{"href":"https://github.com/temporalio/temporal/pull/8563#discussion_r2579142861"},"pull_request":{"href":"https://api.github.com/repos/temporalio/temporal/pulls/8563"}},"reactions":{"url":"https://api.github.com/repos/temporalio/temporal/pulls/comments/2579142861/reactions","total_count":1,"+1":1,"-1":0,"laugh":0,"hooray":0,"confused":0,"heart":0,"rocket":0,"eyes":0},"start_line":null,"original_start_line":null,"start_side":null,"line":null,"original_line":845,"side":"RIGHT","author_association":"MEMBER","original_position":36,"position":1,"subject_type":"line"},{"url":"https://api.github.com/repos/temporalio/temporal/pulls/comments/2579143853","pull_request_review_id":3526477399,"id":2579143853,"node_id":"PRRC_kwDODNqesM6Zupyt","diff_hunk":"@@ -838,6 +842,21 @@ func (e *historyEngineImpl) NotifyNewHistoryEvent(\n \te.eventNotifier.NotifyNewHistoryEvent(notification)\n }\n \n+func (e *historyEngineImpl) GetChasmEngine() chasm.Engine {\n+\treturn e.chasmEngine\n+}\n+\n+func (e *historyEngineImpl) NotifyChasmExecution(executionKey chasm.EntityKey, componentRef []byte) {\n+\tif e.chasmEngine == nil {\n+\t\treturn\n+\t}\n+\tif chasmEngine, ok := e.chasmEngine.(*ChasmEngine); ok && chasmEngine != nil {","path":"service/history/history_engine.go","commit_id":"7bf19dc271aec2f2f649077fac915077fc6028fe","original_commit_id":"59d749626d6a00c5fff76abe79a85eb627366521","user":{"login":"bergundy","id":52304,"node_id":"MDQ6VXNlcjUyMzA0","avatar_url":"https://avatars.githubusercontent.com/u/52304?v=4","gravatar_id":"","url":"https://api.github.com/users/bergundy","html_url":"https://github.com/bergundy","followers_url":"https://api.github.com/users/bergundy/followers","following_url":"https://api.github.com/users/bergundy/following{/other_user}","gists_url":"https://api.github.com/users/bergundy/gists{/gist_id}","starred_url":"https://api.github.com/users/bergundy/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/bergundy/subscriptions","organizations_url":"https://api.github.com/users/bergundy/orgs","repos_url":"https://api.github.com/users/bergundy/repos","events_url":"https://api.github.com/users/bergundy/events{/privacy}","received_events_url":"https://api.github.com/users/bergundy/received_events","type":"User","user_view_type":"public","site_admin":false},"body":"Why would the engine not be a `ChasmEngine`, either make `NewEngineWithShardContext` accept a `ChasmEngine` or  add this method to the `chasm.Engine` interface.","created_at":"2025-12-02T00:16:14Z","updated_at":"2025-12-02T00:31:37Z","html_url":"https://github.com/temporalio/temporal/pull/8563#discussion_r2579143853","pull_request_url":"https://api.github.com/repos/temporalio/temporal/pulls/8563","_links":{"self":{"href":"https://api.github.com/repos/temporalio/temporal/pulls/comments/2579143853"},"html":{"href":"https://github.com/temporalio/temporal/pull/8563#discussion_r2579143853"},"pull_request":{"href":"https://api.github.com/repos/temporalio/temporal/pulls/8563"}},"reactions":{"url":"https://api.github.com/repos/temporalio/temporal/pulls/comments/2579143853/reactions","total_count":0,"+1":0,"-1":0,"laugh":0,"hooray":0,"confused":0,"heart":0,"rocket":0,"eyes":0},"start_line":null,"original_start_line":null,"start_side":null,"line":null,"original_line":853,"side":"RIGHT","author_association":"MEMBER","original_position":44,"position":1,"subject_type":"line"},{"url":"https://api.github.com/repos/temporalio/temporal/pulls/comments/2579160362","pull_request_review_id":3526477399,"id":2579160362,"node_id":"PRRC_kwDODNqesM6Zut0q","diff_hunk":"@@ -5,45 +5,66 @@ import (\n \t\"testing\"\n \t\"time\"\n \n-\t\"github.com/google/uuid\"\n \t\"github.com/stretchr/testify/require\"\n \t\"github.com/stretchr/testify/suite\"\n \tactivitypb \"go.temporal.io/api/activity/v1\"\n \tcommonpb \"go.temporal.io/api/common/v1\"\n \tenumspb \"go.temporal.io/api/enums/v1\"\n+\t\"go.temporal.io/api/serviceerror\"\n \ttaskqueuepb \"go.temporal.io/api/taskqueue/v1\"\n \t\"go.temporal.io/api/workflowservice/v1\"\n \t\"go.temporal.io/server/common/dynamicconfig\"\n+\t\"go.temporal.io/server/common/testing/protorequire\"\n+\t\"go.temporal.io/server/common/testing/testvars\"\n \t\"go.temporal.io/server/tests/testcore\"\n+\t\"google.golang.org/grpc/codes\"\n \t\"google.golang.org/protobuf/proto\"\n \t\"google.golang.org/protobuf/types/known/durationpb\"\n )\n \n+var (\n+\tdefaultInput = &commonpb.Payloads{","path":"tests/standalone_activity_test.go","commit_id":"ba38880058f288839d9fd74d46b7ac8dbc549f5c","original_commit_id":"59d749626d6a00c5fff76abe79a85eb627366521","user":{"login":"bergundy","id":52304,"node_id":"MDQ6VXNlcjUyMzA0","avatar_url":"https://avatars.githubusercontent.com/u/52304?v=4","gravatar_id":"","url":"https://api.github.com/users/bergundy","html_url":"https://github.com/bergundy","followers_url":"https://api.github.com/users/bergundy/followers","following_url":"https://api.github.com/users/bergundy/following{/other_user}","gists_url":"https://api.github.com/users/bergundy/gists{/gist_id}","starred_url":"https://api.github.com/users/bergundy/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/bergundy/subscriptions","organizations_url":"https://api.github.com/users/bergundy/orgs","repos_url":"https://api.github.com/users/bergundy/repos","events_url":"https://api.github.com/users/bergundy/events{/privacy}","received_events_url":"https://api.github.com/users/bergundy/received_events","type":"User","user_view_type":"public","site_admin":false},"body":"As mentioned on @fretz12's PRs, there's a utility to encode payloads in the server codebase that is preferable to fully defining them. `common/payloads.EncodeString`","created_at":"2025-12-02T00:28:22Z","updated_at":"2025-12-02T00:31:37Z","html_url":"https://github.com/temporalio/temporal/pull/8563#discussion_r2579160362","pull_request_url":"https://api.github.com/repos/temporalio/temporal/pulls/8563","_links":{"self":{"href":"https://api.github.com/repos/temporalio/temporal/pulls/comments/2579160362"},"html":{"href":"https://github.com/temporalio/temporal/pull/8563#discussion_r2579160362"},"pull_request":{"href":"https://api.github.com/repos/temporalio/temporal/pulls/8563"}},"reactions":{"url":"https://api.github.com/repos/temporalio/temporal/pulls/comments/2579160362/reactions","total_count":0,"+1":0,"-1":0,"laugh":0,"hooray":0,"confused":0,"heart":0,"rocket":0,"eyes":0},"start_line":null,"original_start_line":null,"start_side":null,"line":null,"original_line":26,"side":"RIGHT","author_association":"MEMBER","original_position":23,"position":1,"subject_type":"line"},{"url":"https://api.github.com/repos/temporalio/temporal/pulls/comments/2579161439","pull_request_review_id":3526477399,"id":2579161439,"node_id":"PRRC_kwDODNqesM6ZuuFf","diff_hunk":"@@ -78,17 +99,112 @@ func (s *standaloneActivityTestSuite) TestStartActivityExecution() {\n \trequire.True(t, proto.Equal(input, pollResp.GetInput()))\n }\n \n-func (s *standaloneActivityTestSuite) TestScheduleToStartShouldTimeout() {\n-\t// TODO implement when we have PollActivityExecution. Make sure we check the attempt vs. outcome failure population.\n-\ts.T().Skip(\"Temporarily disabled\")\n-}\n+// TestStartToCloseTimeout tests that a start-to-close timeout is recorded after the activity is\n+// started. It also verifies that PollActivityExecution can be used to poll for a TimedOut state\n+// change caused by execution of a timer task.\n+func (s *standaloneActivityTestSuite) TestStartToCloseTimeout() {\n+\tt := s.T()\n \n-func (s *standaloneActivityTestSuite) TestScheduleToCloseShouldTimeout() {\n-\t// TODO implement when we have PollActivityExecution. Make sure we check the attempt vs. outcome failure population.\n-\ts.T().Skip(\"Temporarily disabled\")\n+\tctx, cancel := context.WithTimeout(t.Context(), 30*time.Second)\n+\tdefer cancel()\n+\n+\tactivityID := testcore.RandomizeStr(t.Name())\n+\ttaskQueue := testcore.RandomizeStr(t.Name())\n+\n+\tstartResp, err := s.FrontendClient().StartActivityExecution(ctx, &workflowservice.StartActivityExecutionRequest{\n+\t\tNamespace:  s.Namespace().String(),\n+\t\tActivityId: activityID,\n+\t\tActivityType: &commonpb.ActivityType{\n+\t\t\tName: \"test-activity-type\",\n+\t\t},\n+\t\tInput: defaultInput,\n+\t\tOptions: &activitypb.ActivityOptions{\n+\t\t\tTaskQueue: &taskqueuepb.TaskQueue{\n+\t\t\t\tName: taskQueue,\n+\t\t\t},\n+\t\t\tStartToCloseTimeout: durationpb.New(1 * time.Second),\n+\t\t},\n+\t\tRequestId: \"test-request-id\",\n+\t})\n+\trequire.NoError(t, err)\n+\n+\t// First poll: activity has not started yet\n+\tpollResp, err := s.FrontendClient().PollActivityExecution(ctx, &workflowservice.PollActivityExecutionRequest{\n+\t\tNamespace:   s.Namespace().String(),\n+\t\tActivityId:  activityID,\n+\t\tRunId:       startResp.RunId,\n+\t\tIncludeInfo: true,\n+\t})\n+\trequire.NoError(t, err)\n+\trequire.NotNil(t, pollResp)\n+\trequire.NotNil(t, pollResp.GetInfo())\n+\trequire.Equal(t, enumspb.ACTIVITY_EXECUTION_STATUS_RUNNING, pollResp.GetInfo().GetStatus())\n+\trequire.Equal(t, enumspb.PENDING_ACTIVITY_STATE_SCHEDULED, pollResp.GetInfo().GetRunState())\n+\n+\t// Worker poll to start the activity\n+\tpollTaskResp, err := s.FrontendClient().PollActivityTaskQueue(ctx, &workflowservice.PollActivityTaskQueueRequest{\n+\t\tNamespace: s.Namespace().String(),\n+\t\tTaskQueue: &taskqueuepb.TaskQueue{\n+\t\t\tName: taskQueue,\n+\t\t},\n+\t\tIdentity: s.tv.WorkerIdentity(),\n+\t})\n+\trequire.NoError(t, err)\n+\trequire.NotNil(t, pollTaskResp)\n+\trequire.NotEmpty(t, pollTaskResp.TaskToken)\n+\n+\t// Second poll: activity has started\n+\tpollResp, err = s.FrontendClient().PollActivityExecution(ctx, &workflowservice.PollActivityExecutionRequest{\n+\t\tNamespace:   s.Namespace().String(),\n+\t\tActivityId:  activityID,\n+\t\tRunId:       startResp.RunId,\n+\t\tIncludeInfo: true,\n+\t\tWaitPolicy: &workflowservice.PollActivityExecutionRequest_WaitAnyStateChange{\n+\t\t\tWaitAnyStateChange: &workflowservice.PollActivityExecutionRequest_StateChangeWaitOptions{\n+\t\t\t\tLongPollToken: pollResp.StateChangeLongPollToken,\n+\t\t\t},\n+\t\t},\n+\t})\n+\trequire.NoError(t, err)\n+\trequire.NotNil(t, pollResp)\n+\trequire.NotNil(t, pollResp.GetInfo())","path":"tests/standalone_activity_test.go","commit_id":"1d59e66d0ce5d91819f92c428ef5ab4c4efca1fb","original_commit_id":"59d749626d6a00c5fff76abe79a85eb627366521","user":{"login":"bergundy","id":52304,"node_id":"MDQ6VXNlcjUyMzA0","avatar_url":"https://avatars.githubusercontent.com/u/52304?v=4","gravatar_id":"","url":"https://api.github.com/users/bergundy","html_url":"https://github.com/bergundy","followers_url":"https://api.github.com/users/bergundy/followers","following_url":"https://api.github.com/users/bergundy/following{/other_user}","gists_url":"https://api.github.com/users/bergundy/gists{/gist_id}","starred_url":"https://api.github.com/users/bergundy/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/bergundy/subscriptions","organizations_url":"https://api.github.com/users/bergundy/orgs","repos_url":"https://api.github.com/users/bergundy/repos","events_url":"https://api.github.com/users/bergundy/events{/privacy}","received_events_url":"https://api.github.com/users/bergundy/received_events","type":"User","user_view_type":"public","site_admin":false},"body":"Redundant IMHO","created_at":"2025-12-02T00:29:08Z","updated_at":"2025-12-02T00:31:37Z","html_url":"https://github.com/temporalio/temporal/pull/8563#discussion_r2579161439","pull_request_url":"https://api.github.com/repos/temporalio/temporal/pulls/8563","_links":{"self":{"href":"https://api.github.com/repos/temporalio/temporal/pulls/comments/2579161439"},"html":{"href":"https://github.com/temporalio/temporal/pull/8563#discussion_r2579161439"},"pull_request":{"href":"https://api.github.com/repos/temporalio/temporal/pulls/8563"}},"reactions":{"url":"https://api.github.com/repos/temporalio/temporal/pulls/comments/2579161439/reactions","total_count":0,"+1":0,"-1":0,"laugh":0,"hooray":0,"confused":0,"heart":0,"rocket":0,"eyes":0},"start_line":160,"original_start_line":169,"start_side":"RIGHT","line":161,"original_line":170,"side":"RIGHT","author_association":"MEMBER","original_position":153,"position":141,"subject_type":"line"},{"url":"https://api.github.com/repos/temporalio/temporal/pulls/comments/2579164008","pull_request_review_id":3526477399,"id":2579164008,"node_id":"PRRC_kwDODNqesM6Zuuto","diff_hunk":"@@ -105,3 +221,553 @@ func createDefaultInput() *commonpb.Payloads {\n \t\t},\n \t}\n }\n+\n+func (s *standaloneActivityTestSuite) TestPollActivityExecution_NoWait() {\n+\tt := s.T()\n+\tctx, cancel := context.WithTimeout(t.Context(), 10*time.Second)\n+\tdefer cancel()\n+\tactivityID := testcore.RandomizeStr(t.Name())\n+\ttaskQueue := testcore.RandomizeStr(t.Name())\n+\n+\tstartResp, err := s.startActivity(ctx, activityID, taskQueue)\n+\trequire.NoError(t, err)\n+\n+\tt.Run(\"MinimalResponse\", func(t *testing.T) {\n+\t\tpollResp, err := s.FrontendClient().PollActivityExecution(ctx, &workflowservice.PollActivityExecutionRequest{\n+\t\t\tNamespace:  s.Namespace().String(),\n+\t\t\tActivityId: activityID,\n+\t\t\t// Omit RunID to verify that latest run will be used\n+\t\t\tIncludeInfo:    false,\n+\t\t\tIncludeInput:   false,\n+\t\t\tIncludeOutcome: false,\n+\t\t})\n+\t\trequire.NoError(t, err)\n+\t\trequire.NotNil(t, pollResp.StateChangeLongPollToken)\n+\t\trequire.Equal(t, startResp.RunId, pollResp.RunId)\n+\t\trequire.Nil(t, pollResp.Info)\n+\t\trequire.Nil(t, pollResp.Input)\n+\t\trequire.Nil(t, pollResp.GetResult())\n+\t\trequire.Nil(t, pollResp.GetFailure())\n+\t})\n+\n+\tt.Run(\"FullResponse\", func(t *testing.T) {\n+\t\tpollResp, err := s.FrontendClient().PollActivityExecution(ctx, &workflowservice.PollActivityExecutionRequest{\n+\t\t\tNamespace:      s.Namespace().String(),\n+\t\t\tActivityId:     activityID,\n+\t\t\tRunId:          startResp.RunId,\n+\t\t\tIncludeInfo:    true,\n+\t\t\tIncludeInput:   true,\n+\t\t\tIncludeOutcome: true,\n+\t\t})\n+\t\trequire.NoError(t, err)\n+\t\trequire.NotNil(t, pollResp.StateChangeLongPollToken)\n+\t\trequire.NotNil(t, pollResp.Info)\n+\t\ts.assertActivityExecutionInfo(\n+\t\t\tt,\n+\t\t\tpollResp.Info,\n+\t\t\tactivityID,\n+\t\t\tstartResp.RunId,\n+\t\t\tenumspb.PENDING_ACTIVITY_STATE_SCHEDULED,\n+\t\t)\n+\t\trequire.NotNil(t, pollResp.Input)\n+\t\trequire.Equal(t, \"test-activity-input\", string(pollResp.Input.Payloads[0].Data))\n+\n+\t\t// Activity is scheduled but not completed, so no outcome yet\n+\t\trequire.Nil(t, pollResp.GetResult())\n+\t\trequire.Nil(t, pollResp.GetFailure())\n+\t})\n+}\n+\n+func (s *standaloneActivityTestSuite) TestPollActivityExecution_WaitAnyStateChange() {\n+\t// Long poll for any state change. PollActivityTaskQueue is used to cause a state change.\n+\tt := s.T()\n+\tctx, cancel := context.WithTimeout(t.Context(), 10*time.Second)\n+\tdefer cancel()\n+\tactivityID := testcore.RandomizeStr(t.Name())\n+\ttaskQueue := testcore.RandomizeStr(t.Name())\n+\n+\tstartResp, err := s.startActivity(ctx, activityID, taskQueue)\n+\trequire.NoError(t, err)\n+\n+\t// First poll lacks token and therefore responds immediately, returning a token\n+\tfirstPollResp, err := s.FrontendClient().PollActivityExecution(ctx, &workflowservice.PollActivityExecutionRequest{\n+\t\tNamespace:  s.Namespace().String(),\n+\t\tActivityId: activityID,\n+\t\tRunId:      startResp.RunId, // RunID is now required by validation\n+\t\tWaitPolicy: &workflowservice.PollActivityExecutionRequest_WaitAnyStateChange{\n+\t\t\tWaitAnyStateChange: &workflowservice.PollActivityExecutionRequest_StateChangeWaitOptions{},\n+\t\t},\n+\t\tIncludeInfo:  true,\n+\t\tIncludeInput: true,\n+\t})\n+\trequire.NoError(t, err)\n+\trequire.NotNil(t, firstPollResp.StateChangeLongPollToken)\n+\trequire.NotNil(t, firstPollResp.Info)\n+\trequire.Equal(t, firstPollResp.RunId, startResp.RunId)\n+\ts.assertActivityExecutionInfo(\n+\t\tt,\n+\t\tfirstPollResp.Info,\n+\t\tactivityID,\n+\t\tstartResp.RunId,\n+\t\tenumspb.PENDING_ACTIVITY_STATE_SCHEDULED,\n+\t)\n+\n+\ttaskQueuePollErr := make(chan error, 1)\n+\tactivityPollDone := make(chan struct{})\n+\tvar activityPollResp *workflowservice.PollActivityExecutionResponse\n+\tvar activityPollErr error\n+\n+\tgo func() {\n+\t\tdefer close(activityPollDone)\n+\t\t// Second poll uses token and therefore waits for a state transition\n+\t\tactivityPollResp, activityPollErr = s.FrontendClient().PollActivityExecution(ctx, &workflowservice.PollActivityExecutionRequest{\n+\t\t\tNamespace:    s.Namespace().String(),\n+\t\t\tActivityId:   activityID,\n+\t\t\tRunId:        startResp.RunId,\n+\t\t\tIncludeInfo:  true,\n+\t\t\tIncludeInput: true,\n+\t\t\tWaitPolicy: &workflowservice.PollActivityExecutionRequest_WaitAnyStateChange{\n+\t\t\t\tWaitAnyStateChange: &workflowservice.PollActivityExecutionRequest_StateChangeWaitOptions{\n+\t\t\t\t\tLongPollToken: firstPollResp.StateChangeLongPollToken,\n+\t\t\t\t},\n+\t\t\t},\n+\t\t})\n+\t}()\n+\n+\t// TODO(dan): race here: subscription might not be established yet\n+\n+\t// Worker picks up activity task, triggering transition (via RecordActivityTaskStarted)\n+\tgo func() {\n+\t\t_, err := s.pollActivityTaskQueue(ctx, taskQueue)\n+\t\ttaskQueuePollErr <- err\n+\t}()","path":"tests/standalone_activity_test.go","commit_id":"1d59e66d0ce5d91819f92c428ef5ab4c4efca1fb","original_commit_id":"59d749626d6a00c5fff76abe79a85eb627366521","user":{"login":"bergundy","id":52304,"node_id":"MDQ6VXNlcjUyMzA0","avatar_url":"https://avatars.githubusercontent.com/u/52304?v=4","gravatar_id":"","url":"https://api.github.com/users/bergundy","html_url":"https://github.com/bergundy","followers_url":"https://api.github.com/users/bergundy/followers","following_url":"https://api.github.com/users/bergundy/following{/other_user}","gists_url":"https://api.github.com/users/bergundy/gists{/gist_id}","starred_url":"https://api.github.com/users/bergundy/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/bergundy/subscriptions","organizations_url":"https://api.github.com/users/bergundy/orgs","repos_url":"https://api.github.com/users/bergundy/repos","events_url":"https://api.github.com/users/bergundy/events{/privacy}","received_events_url":"https://api.github.com/users/bergundy/received_events","type":"User","user_view_type":"public","site_admin":false},"body":"You are complicating this for no good reason. Just run `pollActivityTaskQueue` and then `PollActivityExecution` with no goroutines.","created_at":"2025-12-02T00:30:54Z","updated_at":"2025-12-02T00:31:37Z","html_url":"https://github.com/temporalio/temporal/pull/8563#discussion_r2579164008","pull_request_url":"https://api.github.com/repos/temporalio/temporal/pulls/8563","_links":{"self":{"href":"https://api.github.com/repos/temporalio/temporal/pulls/comments/2579164008"},"html":{"href":"https://github.com/temporalio/temporal/pull/8563#discussion_r2579164008"},"pull_request":{"href":"https://api.github.com/repos/temporalio/temporal/pulls/8563"}},"reactions":{"url":"https://api.github.com/repos/temporalio/temporal/pulls/comments/2579164008/reactions","total_count":0,"+1":0,"-1":0,"laugh":0,"hooray":0,"confused":0,"heart":0,"rocket":0,"eyes":0},"start_line":298,"original_start_line":320,"start_side":"RIGHT","line":321,"original_line":343,"side":"RIGHT","author_association":"MEMBER","original_position":318,"position":305,"subject_type":"line"},{"url":"https://api.github.com/repos/temporalio/temporal/pulls/comments/2579164693","pull_request_review_id":3526477399,"id":2579164693,"node_id":"PRRC_kwDODNqesM6Zuu4V","diff_hunk":"@@ -105,3 +221,553 @@ func createDefaultInput() *commonpb.Payloads {\n \t\t},\n \t}\n }\n+\n+func (s *standaloneActivityTestSuite) TestPollActivityExecution_NoWait() {\n+\tt := s.T()\n+\tctx, cancel := context.WithTimeout(t.Context(), 10*time.Second)\n+\tdefer cancel()\n+\tactivityID := testcore.RandomizeStr(t.Name())\n+\ttaskQueue := testcore.RandomizeStr(t.Name())\n+\n+\tstartResp, err := s.startActivity(ctx, activityID, taskQueue)\n+\trequire.NoError(t, err)\n+\n+\tt.Run(\"MinimalResponse\", func(t *testing.T) {\n+\t\tpollResp, err := s.FrontendClient().PollActivityExecution(ctx, &workflowservice.PollActivityExecutionRequest{\n+\t\t\tNamespace:  s.Namespace().String(),\n+\t\t\tActivityId: activityID,\n+\t\t\t// Omit RunID to verify that latest run will be used\n+\t\t\tIncludeInfo:    false,\n+\t\t\tIncludeInput:   false,\n+\t\t\tIncludeOutcome: false,\n+\t\t})\n+\t\trequire.NoError(t, err)\n+\t\trequire.NotNil(t, pollResp.StateChangeLongPollToken)\n+\t\trequire.Equal(t, startResp.RunId, pollResp.RunId)\n+\t\trequire.Nil(t, pollResp.Info)\n+\t\trequire.Nil(t, pollResp.Input)\n+\t\trequire.Nil(t, pollResp.GetResult())\n+\t\trequire.Nil(t, pollResp.GetFailure())\n+\t})\n+\n+\tt.Run(\"FullResponse\", func(t *testing.T) {\n+\t\tpollResp, err := s.FrontendClient().PollActivityExecution(ctx, &workflowservice.PollActivityExecutionRequest{\n+\t\t\tNamespace:      s.Namespace().String(),\n+\t\t\tActivityId:     activityID,\n+\t\t\tRunId:          startResp.RunId,\n+\t\t\tIncludeInfo:    true,\n+\t\t\tIncludeInput:   true,\n+\t\t\tIncludeOutcome: true,\n+\t\t})\n+\t\trequire.NoError(t, err)\n+\t\trequire.NotNil(t, pollResp.StateChangeLongPollToken)\n+\t\trequire.NotNil(t, pollResp.Info)\n+\t\ts.assertActivityExecutionInfo(\n+\t\t\tt,\n+\t\t\tpollResp.Info,\n+\t\t\tactivityID,\n+\t\t\tstartResp.RunId,\n+\t\t\tenumspb.PENDING_ACTIVITY_STATE_SCHEDULED,\n+\t\t)\n+\t\trequire.NotNil(t, pollResp.Input)\n+\t\trequire.Equal(t, \"test-activity-input\", string(pollResp.Input.Payloads[0].Data))\n+\n+\t\t// Activity is scheduled but not completed, so no outcome yet\n+\t\trequire.Nil(t, pollResp.GetResult())\n+\t\trequire.Nil(t, pollResp.GetFailure())\n+\t})\n+}\n+\n+func (s *standaloneActivityTestSuite) TestPollActivityExecution_WaitAnyStateChange() {\n+\t// Long poll for any state change. PollActivityTaskQueue is used to cause a state change.\n+\tt := s.T()\n+\tctx, cancel := context.WithTimeout(t.Context(), 10*time.Second)\n+\tdefer cancel()\n+\tactivityID := testcore.RandomizeStr(t.Name())\n+\ttaskQueue := testcore.RandomizeStr(t.Name())\n+\n+\tstartResp, err := s.startActivity(ctx, activityID, taskQueue)\n+\trequire.NoError(t, err)\n+\n+\t// First poll lacks token and therefore responds immediately, returning a token\n+\tfirstPollResp, err := s.FrontendClient().PollActivityExecution(ctx, &workflowservice.PollActivityExecutionRequest{\n+\t\tNamespace:  s.Namespace().String(),\n+\t\tActivityId: activityID,\n+\t\tRunId:      startResp.RunId, // RunID is now required by validation\n+\t\tWaitPolicy: &workflowservice.PollActivityExecutionRequest_WaitAnyStateChange{\n+\t\t\tWaitAnyStateChange: &workflowservice.PollActivityExecutionRequest_StateChangeWaitOptions{},\n+\t\t},\n+\t\tIncludeInfo:  true,\n+\t\tIncludeInput: true,\n+\t})\n+\trequire.NoError(t, err)\n+\trequire.NotNil(t, firstPollResp.StateChangeLongPollToken)\n+\trequire.NotNil(t, firstPollResp.Info)\n+\trequire.Equal(t, firstPollResp.RunId, startResp.RunId)\n+\ts.assertActivityExecutionInfo(\n+\t\tt,\n+\t\tfirstPollResp.Info,\n+\t\tactivityID,\n+\t\tstartResp.RunId,\n+\t\tenumspb.PENDING_ACTIVITY_STATE_SCHEDULED,\n+\t)\n+\n+\ttaskQueuePollErr := make(chan error, 1)\n+\tactivityPollDone := make(chan struct{})\n+\tvar activityPollResp *workflowservice.PollActivityExecutionResponse\n+\tvar activityPollErr error\n+\n+\tgo func() {\n+\t\tdefer close(activityPollDone)\n+\t\t// Second poll uses token and therefore waits for a state transition\n+\t\tactivityPollResp, activityPollErr = s.FrontendClient().PollActivityExecution(ctx, &workflowservice.PollActivityExecutionRequest{\n+\t\t\tNamespace:    s.Namespace().String(),\n+\t\t\tActivityId:   activityID,\n+\t\t\tRunId:        startResp.RunId,\n+\t\t\tIncludeInfo:  true,\n+\t\t\tIncludeInput: true,\n+\t\t\tWaitPolicy: &workflowservice.PollActivityExecutionRequest_WaitAnyStateChange{\n+\t\t\t\tWaitAnyStateChange: &workflowservice.PollActivityExecutionRequest_StateChangeWaitOptions{\n+\t\t\t\t\tLongPollToken: firstPollResp.StateChangeLongPollToken,\n+\t\t\t\t},\n+\t\t\t},\n+\t\t})\n+\t}()\n+\n+\t// TODO(dan): race here: subscription might not be established yet\n+\n+\t// Worker picks up activity task, triggering transition (via RecordActivityTaskStarted)\n+\tgo func() {\n+\t\t_, err := s.pollActivityTaskQueue(ctx, taskQueue)\n+\t\ttaskQueuePollErr <- err\n+\t}()\n+\n+\tselect {\n+\tcase <-activityPollDone:\n+\t\trequire.NoError(t, activityPollErr)\n+\t\trequire.NotNil(t, activityPollResp)\n+\t\trequire.NotNil(t, activityPollResp.Info)\n+\t\ts.assertActivityExecutionInfo(\n+\t\t\tt,\n+\t\t\tactivityPollResp.Info,\n+\t\t\tactivityID,\n+\t\t\tstartResp.RunId,\n+\t\t\tenumspb.PENDING_ACTIVITY_STATE_STARTED,\n+\t\t)\n+\t\trequire.NotNil(t, activityPollResp.Input)\n+\t\trequire.Equal(t, \"test-activity-input\", string(activityPollResp.Input.Payloads[0].Data))\n+\n+\tcase <-ctx.Done():\n+\t\tt.Fatal(\"PollActivityExecution timed out\")\n+\t}\n+\n+\terr = <-taskQueuePollErr\n+\trequire.NoError(t, err)\n+}\n+\n+func (s *standaloneActivityTestSuite) TestPollActivityExecution_WaitCompletion() {\n+\tt := s.T()\n+\tt.Skip(\"TODO(dan): implement test when RecordActivityTaskCompleted is implemented\")\n+}\n+\n+// TODO(dan): add tests that PollActivityExecution can wait for deletion, termination, cancellation etc\n+\n+func (s *standaloneActivityTestSuite) TestPollActivityExecution_DeadlineExceeded() {\n+\tt := s.T()\n+\toriginalCtx := testcore.NewContext()\n+\n+\t// Start an activity and get initial long-poll state token\n+\tactivityID := \"test-activity-\" + t.Name()\n+\ttaskQueue := \"test-task-queue-\" + t.Name()\n+\tstartResp, err := s.startActivity(originalCtx, activityID, taskQueue)\n+\trequire.NoError(t, err)\n+\tpollResp, err := s.FrontendClient().PollActivityExecution(originalCtx, &workflowservice.PollActivityExecutionRequest{\n+\t\tNamespace:  s.Namespace().String(),\n+\t\tActivityId: activityID,\n+\t\tRunId:      startResp.RunId,\n+\t\tWaitPolicy: &workflowservice.PollActivityExecutionRequest_WaitAnyStateChange{\n+\t\t\tWaitAnyStateChange: &workflowservice.PollActivityExecutionRequest_StateChangeWaitOptions{},\n+\t\t},\n+\t})\n+\trequire.NoError(t, err)\n+\n+\t// The PollActivityExecution calls below use a long-poll token and will necessarily time out,\n+\t// because the activity undergoes no further state transitions. There are two ways in which they\n+\t// can time out:\n+\t// Case 1: due to the caller's deadline expiring (caller gets DeadlineExceeded error)\n+\t// Case 2: due to the internal long-poll timeout (caller does not get an error).\n+\n+\t// We first verify case 1. To do so the caller must set a deadline that comes before the\n+\t// internal deadline, so we override the internal long-poll timeout to something large, and poll\n+\t// with a short caller deadline.\n+\tcleanup := s.OverrideDynamicConfig(\n+\t\tdynamicconfig.HistoryLongPollExpirationInterval,\n+\t\t9999*time.Millisecond,\n+\t)\n+\tdefer cleanup()\n+\tctx, cancel := context.WithTimeout(originalCtx, 10*time.Millisecond)\n+\tdefer cancel()\n+\t_, err = s.FrontendClient().PollActivityExecution(ctx, &workflowservice.PollActivityExecutionRequest{\n+\t\tNamespace:  s.Namespace().String(),\n+\t\tActivityId: activityID,\n+\t\tRunId:      startResp.RunId,\n+\t\tWaitPolicy: &workflowservice.PollActivityExecutionRequest_WaitAnyStateChange{\n+\t\t\tWaitAnyStateChange: &workflowservice.PollActivityExecutionRequest_StateChangeWaitOptions{\n+\t\t\t\tLongPollToken: pollResp.StateChangeLongPollToken,\n+\t\t\t},\n+\t\t},\n+\t})\n+\trequire.Error(t, err)\n+\tstatusErr := serviceerror.ToStatus(err)\n+\trequire.NotNil(t, statusErr)\n+\trequire.Equal(t, codes.DeadlineExceeded, statusErr.Code())\n+\n+\t// Next we verify case 2. We set the internal long-poll timeout to something small and poll with\n+\t// a large caller deadline.\n+\tcleanup = s.OverrideDynamicConfig(\n+\t\tdynamicconfig.HistoryLongPollExpirationInterval,\n+\t\t10*time.Millisecond,\n+\t)\n+\tdefer cleanup()\n+\tctx, cancel = context.WithTimeout(originalCtx, 9999*time.Millisecond)\n+\tdefer cancel()\n+\tpollResp, err = s.FrontendClient().PollActivityExecution(ctx, &workflowservice.PollActivityExecutionRequest{\n+\t\tNamespace:   s.Namespace().String(),\n+\t\tActivityId:  activityID,\n+\t\tRunId:       startResp.RunId,\n+\t\tIncludeInfo: true,\n+\t\tWaitPolicy: &workflowservice.PollActivityExecutionRequest_WaitAnyStateChange{\n+\t\t\tWaitAnyStateChange: &workflowservice.PollActivityExecutionRequest_StateChangeWaitOptions{\n+\t\t\t\tLongPollToken: pollResp.StateChangeLongPollToken,\n+\t\t\t},\n+\t\t},\n+\t})\n+\t// The server uses an empty non-error response to indicate to the caller that it should resubmit\n+\t// its long-poll.\n+\trequire.NoError(t, err)\n+\trequire.Empty(t, pollResp.GetInfo())\n+}\n+\n+func (s *standaloneActivityTestSuite) TestPollActivityExecution_NotFound() {\n+\tt := s.T()\n+\tctx := testcore.NewContext()\n+\n+\texistingActivityID := testcore.RandomizeStr(t.Name())\n+\ttq := testcore.RandomizeStr(t.Name())\n+\tstartResp, err := s.startActivity(ctx, existingActivityID, tq)\n+\trequire.NoError(t, err)\n+\texistingRunID := startResp.RunId\n+\trequire.NotEmpty(t, existingRunID)\n+\texistingNamespace := s.Namespace().String()\n+\n+\tvar notFoundErr *serviceerror.NotFound\n+\tvar namespaceNotFoundErr *serviceerror.NamespaceNotFound\n+\n+\ttestCases := []struct {\n+\t\tname           string\n+\t\trequest        *workflowservice.PollActivityExecutionRequest\n+\t\texpectedErr    error\n+\t\texpectedErrMsg string\n+\t}{\n+\t\t{\n+\t\t\tname: \"NonExistentNamespace\",\n+\t\t\trequest: &workflowservice.PollActivityExecutionRequest{\n+\t\t\t\tNamespace:  \"non-existent-namespace\",\n+\t\t\t\tActivityId: existingActivityID,\n+\t\t\t\tRunId:      existingRunID,\n+\t\t\t},\n+\t\t\texpectedErr:    namespaceNotFoundErr,\n+\t\t\texpectedErrMsg: \"Namespace non-existent-namespace is not found.\",\n+\t\t},\n+\t\t{\n+\t\t\tname: \"NonExistentActivityID\",\n+\t\t\trequest: &workflowservice.PollActivityExecutionRequest{\n+\t\t\t\tNamespace:  existingNamespace,\n+\t\t\t\tActivityId: \"non-existent-activity\",\n+\t\t\t\tRunId:      existingRunID,\n+\t\t\t},\n+\t\t\texpectedErr:    notFoundErr,\n+\t\t\texpectedErrMsg: \"activity execution not found\",\n+\t\t},\n+\t\t{\n+\t\t\tname: \"NonExistentRunID\",\n+\t\t\trequest: &workflowservice.PollActivityExecutionRequest{\n+\t\t\t\tNamespace:  existingNamespace,\n+\t\t\t\tActivityId: existingActivityID,\n+\t\t\t\tRunId:      \"11111111-2222-3333-4444-555555555555\",\n+\t\t\t},\n+\t\t\texpectedErr:    notFoundErr,\n+\t\t\texpectedErrMsg: \"activity execution not found\",\n+\t\t},\n+\t}\n+\n+\tfor _, tc := range testCases {\n+\t\tt.Run(tc.name, func(t *testing.T) {\n+\t\t\t_, err := s.FrontendClient().PollActivityExecution(ctx, tc.request)\n+\t\t\trequire.ErrorAs(t, err, &tc.expectedErr)\n+\t\t\trequire.Equal(t, tc.expectedErrMsg, tc.expectedErr.Error())\n+\t\t})\n+\t}\n+\n+\tt.Run(\"LongPollNonExistentActivity\", func(t *testing.T) {\n+\t\t// Poll to get a token\n+\t\tvalidPollResp, err := s.FrontendClient().PollActivityExecution(ctx, &workflowservice.PollActivityExecutionRequest{\n+\t\t\tNamespace:  existingNamespace,\n+\t\t\tActivityId: existingActivityID,\n+\t\t\tRunId:      existingRunID,\n+\t\t\tWaitPolicy: &workflowservice.PollActivityExecutionRequest_WaitAnyStateChange{\n+\t\t\t\tWaitAnyStateChange: &workflowservice.PollActivityExecutionRequest_StateChangeWaitOptions{\n+\t\t\t\t\tLongPollToken: nil,\n+\t\t\t\t},\n+\t\t\t},\n+\t\t})\n+\t\trequire.NoError(t, err)\n+\n+\t\t// Use the token with a non-existent activity\n+\t\t_, err = s.FrontendClient().PollActivityExecution(ctx, &workflowservice.PollActivityExecutionRequest{\n+\t\t\tNamespace:  existingNamespace,\n+\t\t\tActivityId: \"non-existent-activity\",\n+\t\t\tRunId:      existingRunID,\n+\t\t\tWaitPolicy: &workflowservice.PollActivityExecutionRequest_WaitAnyStateChange{\n+\t\t\t\tWaitAnyStateChange: &workflowservice.PollActivityExecutionRequest_StateChangeWaitOptions{\n+\t\t\t\t\tLongPollToken: validPollResp.StateChangeLongPollToken,\n+\t\t\t\t},\n+\t\t\t},\n+\t\t})\n+\t\tvar notFoundErr *serviceerror.NotFound\n+\t\trequire.ErrorAs(t, err, &notFoundErr)\n+\t\trequire.Equal(t, \"activity execution not found\", notFoundErr.Message)\n+\t})\n+}\n+\n+func (s *standaloneActivityTestSuite) TestPollActivityExecution_InvalidArgument() {\n+\n+\tt := s.T()\n+\tctx := testcore.NewContext()\n+\n+\texistingActivityID := testcore.RandomizeStr(t.Name())\n+\ttq := testcore.RandomizeStr(t.Name())\n+\tstartResp, err := s.startActivity(ctx, existingActivityID, tq)\n+\trequire.NoError(t, err)\n+\texistingRunID := startResp.RunId\n+\trequire.NotEmpty(t, existingRunID)\n+\texistingNamespace := s.Namespace().String()\n+\n+\tvalidActivityID := \"activity-id\"\n+\tvalidRunID := \"11111111-2222-3333-4444-555555555555\"\n+\n+\ttestCases := []struct {\n+\t\tname        string\n+\t\trequest     *workflowservice.PollActivityExecutionRequest\n+\t\texpectedErr string\n+\t}{\n+\t\t{\n+\t\t\tname: \"EmptyNamespace\",\n+\t\t\trequest: &workflowservice.PollActivityExecutionRequest{\n+\t\t\t\tNamespace:  \"\",\n+\t\t\t\tActivityId: validActivityID,\n+\t\t\t\tRunId:      validRunID,\n+\t\t\t},\n+\t\t\texpectedErr: \"Namespace is empty\",\n+\t\t},\n+\t\t{\n+\t\t\tname: \"EmptyActivityID\",\n+\t\t\trequest: &workflowservice.PollActivityExecutionRequest{\n+\t\t\t\tNamespace:  existingNamespace,\n+\t\t\t\tActivityId: \"\",\n+\t\t\t\tRunId:      validRunID,\n+\t\t\t},\n+\t\t\texpectedErr: \"activity ID is required\",\n+\t\t},\n+\t\t{\n+\t\t\tname: \"ActivityIDTooLong\",\n+\t\t\trequest: &workflowservice.PollActivityExecutionRequest{\n+\t\t\t\tNamespace:  existingNamespace,\n+\t\t\t\tActivityId: string(make([]byte, 2000)),\n+\t\t\t\tRunId:      validRunID,\n+\t\t\t},\n+\t\t\texpectedErr: \"activity ID exceeds length limit\",\n+\t\t},\n+\t\t{\n+\t\t\tname: \"InvalidRunID\",\n+\t\t\trequest: &workflowservice.PollActivityExecutionRequest{\n+\t\t\t\tNamespace:  existingNamespace,\n+\t\t\t\tActivityId: validActivityID,\n+\t\t\t\tRunId:      \"invalid-uuid\",\n+\t\t\t},\n+\t\t\texpectedErr: \"invalid run id\",\n+\t\t},\n+\t\t{\n+\t\t\tname: \"RunIdNotRequiredWhenWaitPolicyAbsent\",\n+\t\t\trequest: &workflowservice.PollActivityExecutionRequest{\n+\t\t\t\tNamespace:  existingNamespace,\n+\t\t\t\tActivityId: existingActivityID,\n+\t\t\t\tRunId:      \"\",\n+\t\t\t},\n+\t\t\texpectedErr: \"\",\n+\t\t},\n+\t\t{\n+\t\t\tname: \"RunIdNotRequiredWhenLongPollTokenAbsent\",\n+\t\t\trequest: &workflowservice.PollActivityExecutionRequest{\n+\t\t\t\tNamespace:  existingNamespace,\n+\t\t\t\tActivityId: existingActivityID,\n+\t\t\t\tRunId:      \"\",\n+\t\t\t\tWaitPolicy: &workflowservice.PollActivityExecutionRequest_WaitAnyStateChange{\n+\t\t\t\t\tWaitAnyStateChange: &workflowservice.PollActivityExecutionRequest_StateChangeWaitOptions{\n+\t\t\t\t\t\tLongPollToken: nil,\n+\t\t\t\t\t},\n+\t\t\t\t},\n+\t\t\t},\n+\t\t\texpectedErr: \"\",\n+\t\t},\n+\t\t{\n+\t\t\tname: \"RunIdRequiredWhenLongPollTokenPresent\",\n+\t\t\trequest: &workflowservice.PollActivityExecutionRequest{\n+\t\t\t\tNamespace:  existingNamespace,\n+\t\t\t\tActivityId: validActivityID,\n+\t\t\t\tRunId:      \"\",\n+\t\t\t\tWaitPolicy: &workflowservice.PollActivityExecutionRequest_WaitAnyStateChange{\n+\t\t\t\t\tWaitAnyStateChange: &workflowservice.PollActivityExecutionRequest_StateChangeWaitOptions{\n+\t\t\t\t\t\tLongPollToken: []byte(\"valid-token\"),\n+\t\t\t\t\t},\n+\t\t\t\t},\n+\t\t\t},\n+\t\t\texpectedErr: \"run id is required\",\n+\t\t},\n+\t\t{\n+\t\t\tname: \"MalformedLongPollToken\",\n+\t\t\trequest: &workflowservice.PollActivityExecutionRequest{\n+\t\t\t\tNamespace:  existingNamespace,\n+\t\t\t\tActivityId: existingActivityID,\n+\t\t\t\tRunId:      existingRunID,\n+\t\t\t\tWaitPolicy: &workflowservice.PollActivityExecutionRequest_WaitAnyStateChange{\n+\t\t\t\t\tWaitAnyStateChange: &workflowservice.PollActivityExecutionRequest_StateChangeWaitOptions{\n+\t\t\t\t\t\tLongPollToken: []byte(\"invalid-token\"),\n+\t\t\t\t\t},\n+\t\t\t\t},\n+\t\t\t},\n+\t\t\texpectedErr: \"invalid long poll token\",\n+\t\t},\n+\t}\n+\n+\tfor _, tc := range testCases {\n+\t\tt.Run(tc.name, func(t *testing.T) {\n+\t\t\t_, err := s.FrontendClient().PollActivityExecution(ctx, tc.request)\n+\t\t\tif tc.expectedErr == \"\" {\n+\t\t\t\trequire.NoError(t, err)\n+\t\t\t\treturn\n+\t\t\t}\n+\t\t\tvar invalidArgErr *serviceerror.InvalidArgument\n+\t\t\trequire.ErrorAs(t, err, &invalidArgErr)\n+\t\t\trequire.Contains(t, invalidArgErr.Message, tc.expectedErr)\n+\t\t})\n+\t}\n+\n+\tt.Run(\"LongPollTokenFromWrongExecution\", func(t *testing.T) {\n+","path":"tests/standalone_activity_test.go","commit_id":"9902b0db32abbc57347b99cdb0e99c7bb02cdedc","original_commit_id":"59d749626d6a00c5fff76abe79a85eb627366521","user":{"login":"bergundy","id":52304,"node_id":"MDQ6VXNlcjUyMzA0","avatar_url":"https://avatars.githubusercontent.com/u/52304?v=4","gravatar_id":"","url":"https://api.github.com/users/bergundy","html_url":"https://github.com/bergundy","followers_url":"https://api.github.com/users/bergundy/followers","following_url":"https://api.github.com/users/bergundy/following{/other_user}","gists_url":"https://api.github.com/users/bergundy/gists{/gist_id}","starred_url":"https://api.github.com/users/bergundy/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/bergundy/subscriptions","organizations_url":"https://api.github.com/users/bergundy/orgs","repos_url":"https://api.github.com/users/bergundy/repos","events_url":"https://api.github.com/users/bergundy/events{/privacy}","received_events_url":"https://api.github.com/users/bergundy/received_events","type":"User","user_view_type":"public","site_admin":false},"body":"nit\n\n```suggestion\n```","created_at":"2025-12-02T00:31:24Z","updated_at":"2025-12-02T00:31:37Z","html_url":"https://github.com/temporalio/temporal/pull/8563#discussion_r2579164693","pull_request_url":"https://api.github.com/repos/temporalio/temporal/pulls/8563","_links":{"self":{"href":"https://api.github.com/repos/temporalio/temporal/pulls/comments/2579164693"},"html":{"href":"https://github.com/temporalio/temporal/pull/8563#discussion_r2579164693"},"pull_request":{"href":"https://api.github.com/repos/temporalio/temporal/pulls/8563"}},"reactions":{"url":"https://api.github.com/repos/temporalio/temporal/pulls/comments/2579164693/reactions","total_count":0,"+1":0,"-1":0,"laugh":0,"hooray":0,"confused":0,"heart":0,"rocket":0,"eyes":0},"start_line":null,"original_start_line":null,"start_side":null,"line":null,"original_line":667,"side":"RIGHT","author_association":"MEMBER","original_position":642,"position":1,"subject_type":"line"},{"url":"https://api.github.com/repos/temporalio/temporal/pulls/comments/2579290348","pull_request_review_id":3527793536,"id":2579290348,"node_id":"PRRC_kwDODNqesM6ZvNjs","diff_hunk":"@@ -53,3 +56,115 @@ func (h *handler) StartActivityExecution(ctx context.Context, req *activitypb.St\n \t\tFrontendResponse: response,\n \t}, nil\n }\n+\n+// PollActivityExecution handles PollActivityExecutionRequest from frontend. This method supports\n+// querying current activity state, optionally as a long-poll that waits for certain state changes.\n+// It is used by clients to poll for activity state and/or result.\n+func (h *handler) PollActivityExecution(\n+\tctx context.Context,\n+\treq *activitypb.PollActivityExecutionRequest,\n+) (response *activitypb.PollActivityExecutionResponse, err error) {\n+\tref := chasm.NewComponentRef[*Activity](chasm.EntityKey{\n+\t\tNamespaceID: req.GetNamespaceId(),\n+\t\tBusinessID:  req.GetFrontendRequest().GetActivityId(),\n+\t\tEntityID:    req.GetFrontendRequest().GetRunId(),\n+\t})\n+\tdefer func() {\n+\t\tvar notFound *serviceerror.NotFound\n+\t\tif errors.As(err, &notFound) {\n+\t\t\t// TODO(dan): include execution key in error message; we may do this at the CHASM\n+\t\t\t// framework level.\n+\t\t\t// cf. \"workflow execution not found for workflow ID XXX and run ID YYY\"\n+\t\t\terr = serviceerror.NewNotFound(\"activity execution not found\")\n+\t\t}\n+\t}()\n+\n+\twaitPolicy := req.GetFrontendRequest().GetWaitPolicy()\n+\n+\tif waitPolicy == nil {\n+\t\treturn chasm.ReadComponent(ctx, ref, (*Activity).buildPollActivityExecutionResponse, req, nil)\n+\t}\n+\n+\t// Do not allow long-poll to use all remaining time\n+\tchildCtx := ctx\n+\tif deadline, ok := ctx.Deadline(); ok {\n+\t\tvar cancel context.CancelFunc\n+\t\tchildCtx, cancel = context.WithDeadline(ctx, deadline.Add(-time.Second))\n+\t\tdefer cancel()\n+\t}\n+\n+\tswitch waitPolicy.(type) {\n+\tcase *workflowservice.PollActivityExecutionRequest_WaitAnyStateChange:\n+\t\ttoken := req.GetFrontendRequest().\n+\t\t\tGetWaitPolicy().(*workflowservice.PollActivityExecutionRequest_WaitAnyStateChange).\n+\t\t\tWaitAnyStateChange.GetLongPollToken()\n+\t\tif len(token) == 0 {\n+\t\t\treturn chasm.ReadComponent(ctx, ref, (*Activity).buildPollActivityExecutionResponse, req, nil)\n+\t\t}\n+\t\tresponse, _, err = chasm.PollComponent(childCtx, ref, func(\n+\t\t\ta *Activity,\n+\t\t\tctx chasm.Context,\n+\t\t\treq *activitypb.PollActivityExecutionRequest,\n+\t\t) (*activitypb.PollActivityExecutionResponse, bool, error) {\n+\t\t\tchanged, err := chasm.ExecutionStateChanged(a, ctx, token)\n+\t\t\tif err != nil {\n+\t\t\t\tif errors.Is(err, chasm.ErrMalformedComponentRef) {\n+\t\t\t\t\treturn nil, false, serviceerror.NewInvalidArgument(\"invalid long poll token\")\n+\t\t\t\t}\n+\t\t\t\tif errors.Is(err, chasm.ErrInvalidComponentRef) {\n+\t\t\t\t\treturn nil, false, serviceerror.NewInvalidArgument(\"long poll token does not match execution\")\n+\t\t\t\t}\n+\t\t\t\treturn nil, false, err\n+\t\t\t}\n+\t\t\tif changed {\n+\t\t\t\tresponse, err := a.buildPollActivityExecutionResponse(ctx, req)\n+\t\t\t\treturn response, true, err\n+\t\t\t} else {\n+\t\t\t\treturn nil, false, nil\n+\t\t\t}\n+\t\t}, req)\n+\tcase *workflowservice.PollActivityExecutionRequest_WaitCompletion:\n+\t\t// TODO(dan): add functional test when RecordActivityTaskCompleted is implemented\n+\t\tresponse, _, err = chasm.PollComponent(childCtx, ref, func(\n+\t\t\ta *Activity,\n+\t\t\tctx chasm.Context,\n+\t\t\treq *activitypb.PollActivityExecutionRequest,\n+\t\t) (*activitypb.PollActivityExecutionResponse, bool, error) {\n+\t\t\t// TODO(dan): check for terminal activity states\n+\t\t\tpanic(\"pollActivityExecutionWaitCompletion is not implemented\")\n+\t\t\tcompleted := false\n+\t\t\tif completed {\n+\t\t\t\tresponse, err := a.buildPollActivityExecutionResponse(ctx, req)\n+\t\t\t\tif err != nil {\n+\t\t\t\t\treturn nil, true, err\n+\t\t\t\t}\n+\t\t\t\treturn response, true, nil\n+\t\t\t}\n+\t\t\treturn nil, false, nil\n+\t\t}, req)\n+\tdefault:\n+\t\treturn nil, serviceerror.NewInvalidArgumentf(\"unexpected wait policy type: %T\", waitPolicy)\n+\t}\n+\n+\tif childCtx.Err() != nil {","path":"chasm/lib/activity/handler.go","commit_id":"59d749626d6a00c5fff76abe79a85eb627366521","original_commit_id":"59d749626d6a00c5fff76abe79a85eb627366521","user":{"login":"dandavison","id":52205,"node_id":"MDQ6VXNlcjUyMjA1","avatar_url":"https://avatars.githubusercontent.com/u/52205?v=4","gravatar_id":"","url":"https://api.github.com/users/dandavison","html_url":"https://github.com/dandavison","followers_url":"https://api.github.com/users/dandavison/followers","following_url":"https://api.github.com/users/dandavison/following{/other_user}","gists_url":"https://api.github.com/users/dandavison/gists{/gist_id}","starred_url":"https://api.github.com/users/dandavison/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/dandavison/subscriptions","organizations_url":"https://api.github.com/users/dandavison/orgs","repos_url":"https://api.github.com/users/dandavison/repos","events_url":"https://api.github.com/users/dandavison/events{/privacy}","received_events_url":"https://api.github.com/users/dandavison/received_events","type":"User","user_view_type":"public","site_admin":false},"body":"Can you explain the bug with reference to the test `TestPollActivityExecution_DeadlineExceeded` please?","created_at":"2025-12-02T01:44:06Z","updated_at":"2025-12-02T01:44:06Z","html_url":"https://github.com/temporalio/temporal/pull/8563#discussion_r2579290348","pull_request_url":"https://api.github.com/repos/temporalio/temporal/pulls/8563","_links":{"self":{"href":"https://api.github.com/repos/temporalio/temporal/pulls/comments/2579290348"},"html":{"href":"https://github.com/temporalio/temporal/pull/8563#discussion_r2579290348"},"pull_request":{"href":"https://api.github.com/repos/temporalio/temporal/pulls/8563"}},"reactions":{"url":"https://api.github.com/repos/temporalio/temporal/pulls/comments/2579290348/reactions","total_count":0,"+1":0,"-1":0,"laugh":0,"hooray":0,"confused":0,"heart":0,"rocket":0,"eyes":0},"start_line":null,"original_start_line":null,"start_side":null,"line":null,"original_line":149,"side":"RIGHT","in_reply_to_id":2579102749,"author_association":"MEMBER","original_position":105,"position":1,"subject_type":"line"},{"url":"https://api.github.com/repos/temporalio/temporal/pulls/comments/2586023728","pull_request_review_id":3536180777,"id":2586023728,"node_id":"PRRC_kwDODNqesM6aI5cw","diff_hunk":"@@ -51,3 +54,115 @@ func (h *handler) StartActivityExecution(ctx context.Context, req *activitypb.St\n \t\tFrontendResponse: response,\n \t}, nil\n }\n+\n+// PollActivityExecution handles PollActivityExecutionRequest from frontend. This method supports\n+// querying current activity state, optionally as a long-poll that waits for certain state changes.\n+// It is used by clients to poll for activity state and/or result.\n+func (h *handler) PollActivityExecution(\n+\tctx context.Context,\n+\treq *activitypb.PollActivityExecutionRequest,\n+) (response *activitypb.PollActivityExecutionResponse, err error) {\n+\tref := chasm.NewComponentRef[*Activity](chasm.EntityKey{\n+\t\tNamespaceID: req.GetNamespaceId(),\n+\t\tBusinessID:  req.GetFrontendRequest().GetActivityId(),\n+\t\tEntityID:    req.GetFrontendRequest().GetRunId(),\n+\t})\n+\tdefer func() {\n+\t\tvar notFound *serviceerror.NotFound\n+\t\tif errors.As(err, &notFound) {\n+\t\t\t// TODO(dan): include execution key in error message; we may do this at the CHASM\n+\t\t\t// framework level.\n+\t\t\t// cf. \"workflow execution not found for workflow ID XXX and run ID YYY\"\n+\t\t\terr = serviceerror.NewNotFound(\"activity execution not found\")\n+\t\t}\n+\t}()\n+\n+\twaitPolicy := req.GetFrontendRequest().GetWaitPolicy()\n+\n+\tif waitPolicy == nil {\n+\t\treturn chasm.ReadComponent(ctx, ref, (*Activity).buildPollActivityExecutionResponse, req, nil)\n+\t}\n+\n+\t// Do not allow long-poll to use all remaining time\n+\tchildCtx := ctx\n+\tif deadline, ok := ctx.Deadline(); ok {","path":"chasm/lib/activity/handler.go","commit_id":"59d749626d6a00c5fff76abe79a85eb627366521","original_commit_id":"98f5e1321791f6942a3341e0ed54e5117b7d2a08","user":{"login":"dandavison","id":52205,"node_id":"MDQ6VXNlcjUyMjA1","avatar_url":"https://avatars.githubusercontent.com/u/52205?v=4","gravatar_id":"","url":"https://api.github.com/users/dandavison","html_url":"https://github.com/dandavison","followers_url":"https://api.github.com/users/dandavison/followers","following_url":"https://api.github.com/users/dandavison/following{/other_user}","gists_url":"https://api.github.com/users/dandavison/gists{/gist_id}","starred_url":"https://api.github.com/users/dandavison/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/dandavison/subscriptions","organizations_url":"https://api.github.com/users/dandavison/orgs","repos_url":"https://api.github.com/users/dandavison/repos","events_url":"https://api.github.com/users/dandavison/events{/privacy}","received_events_url":"https://api.github.com/users/dandavison/received_events","type":"User","user_view_type":"public","site_admin":false},"body":"We discussed this offline; all deadline logic should now be correct. ","created_at":"2025-12-03T17:31:18Z","updated_at":"2025-12-04T02:13:23Z","html_url":"https://github.com/temporalio/temporal/pull/8563#discussion_r2586023728","pull_request_url":"https://api.github.com/repos/temporalio/temporal/pulls/8563","_links":{"self":{"href":"https://api.github.com/repos/temporalio/temporal/pulls/comments/2586023728"},"html":{"href":"https://github.com/temporalio/temporal/pull/8563#discussion_r2586023728"},"pull_request":{"href":"https://api.github.com/repos/temporalio/temporal/pulls/8563"}},"reactions":{"url":"https://api.github.com/repos/temporalio/temporal/pulls/comments/2586023728/reactions","total_count":0,"+1":0,"-1":0,"laugh":0,"hooray":0,"confused":0,"heart":0,"rocket":0,"eyes":0},"start_line":null,"original_start_line":null,"start_side":null,"line":null,"original_line":88,"side":"RIGHT","in_reply_to_id":2567023825,"author_association":"MEMBER","original_position":46,"position":1,"subject_type":"line"},{"url":"https://api.github.com/repos/temporalio/temporal/pulls/comments/2586024117","pull_request_review_id":3536180777,"id":2586024117,"node_id":"PRRC_kwDODNqesM6aI5i1","diff_hunk":"@@ -53,3 +56,115 @@ func (h *handler) StartActivityExecution(ctx context.Context, req *activitypb.St\n \t\tFrontendResponse: response,\n \t}, nil\n }\n+\n+// PollActivityExecution handles PollActivityExecutionRequest from frontend. This method supports\n+// querying current activity state, optionally as a long-poll that waits for certain state changes.\n+// It is used by clients to poll for activity state and/or result.\n+func (h *handler) PollActivityExecution(\n+\tctx context.Context,\n+\treq *activitypb.PollActivityExecutionRequest,\n+) (response *activitypb.PollActivityExecutionResponse, err error) {\n+\tref := chasm.NewComponentRef[*Activity](chasm.EntityKey{\n+\t\tNamespaceID: req.GetNamespaceId(),\n+\t\tBusinessID:  req.GetFrontendRequest().GetActivityId(),\n+\t\tEntityID:    req.GetFrontendRequest().GetRunId(),\n+\t})\n+\tdefer func() {\n+\t\tvar notFound *serviceerror.NotFound\n+\t\tif errors.As(err, &notFound) {\n+\t\t\t// TODO(dan): include execution key in error message; we may do this at the CHASM\n+\t\t\t// framework level.\n+\t\t\t// cf. \"workflow execution not found for workflow ID XXX and run ID YYY\"\n+\t\t\terr = serviceerror.NewNotFound(\"activity execution not found\")\n+\t\t}\n+\t}()\n+\n+\twaitPolicy := req.GetFrontendRequest().GetWaitPolicy()\n+\n+\tif waitPolicy == nil {\n+\t\treturn chasm.ReadComponent(ctx, ref, (*Activity).buildPollActivityExecutionResponse, req, nil)\n+\t}\n+\n+\t// Do not allow long-poll to use all remaining time\n+\tchildCtx := ctx\n+\tif deadline, ok := ctx.Deadline(); ok {\n+\t\tvar cancel context.CancelFunc\n+\t\tchildCtx, cancel = context.WithDeadline(ctx, deadline.Add(-time.Second))","path":"chasm/lib/activity/handler.go","commit_id":"59d749626d6a00c5fff76abe79a85eb627366521","original_commit_id":"f3115e38e18a1ba16dc583d8ef987c679a7e9683","user":{"login":"dandavison","id":52205,"node_id":"MDQ6VXNlcjUyMjA1","avatar_url":"https://avatars.githubusercontent.com/u/52205?v=4","gravatar_id":"","url":"https://api.github.com/users/dandavison","html_url":"https://github.com/dandavison","followers_url":"https://api.github.com/users/dandavison/followers","following_url":"https://api.github.com/users/dandavison/following{/other_user}","gists_url":"https://api.github.com/users/dandavison/gists{/gist_id}","starred_url":"https://api.github.com/users/dandavison/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/dandavison/subscriptions","organizations_url":"https://api.github.com/users/dandavison/orgs","repos_url":"https://api.github.com/users/dandavison/repos","events_url":"https://api.github.com/users/dandavison/events{/privacy}","received_events_url":"https://api.github.com/users/dandavison/received_events","type":"User","user_view_type":"public","site_admin":false},"body":"We discussed this offline; all deadline logic should now be correct.","created_at":"2025-12-03T17:31:26Z","updated_at":"2025-12-04T02:13:23Z","html_url":"https://github.com/temporalio/temporal/pull/8563#discussion_r2586024117","pull_request_url":"https://api.github.com/repos/temporalio/temporal/pulls/8563","_links":{"self":{"href":"https://api.github.com/repos/temporalio/temporal/pulls/comments/2586024117"},"html":{"href":"https://github.com/temporalio/temporal/pull/8563#discussion_r2586024117"},"pull_request":{"href":"https://api.github.com/repos/temporalio/temporal/pulls/8563"}},"reactions":{"url":"https://api.github.com/repos/temporalio/temporal/pulls/comments/2586024117/reactions","total_count":0,"+1":0,"-1":0,"laugh":0,"hooray":0,"confused":0,"heart":0,"rocket":0,"eyes":0},"start_line":null,"original_start_line":null,"start_side":null,"line":null,"original_line":92,"side":"RIGHT","in_reply_to_id":2567037755,"author_association":"MEMBER","original_position":48,"position":1,"subject_type":"line"},{"url":"https://api.github.com/repos/temporalio/temporal/pulls/comments/2586024468","pull_request_review_id":3536180777,"id":2586024468,"node_id":"PRRC_kwDODNqesM6aI5oU","diff_hunk":"@@ -53,3 +56,115 @@ func (h *handler) StartActivityExecution(ctx context.Context, req *activitypb.St\n \t\tFrontendResponse: response,\n \t}, nil\n }\n+\n+// PollActivityExecution handles PollActivityExecutionRequest from frontend. This method supports\n+// querying current activity state, optionally as a long-poll that waits for certain state changes.\n+// It is used by clients to poll for activity state and/or result.\n+func (h *handler) PollActivityExecution(\n+\tctx context.Context,\n+\treq *activitypb.PollActivityExecutionRequest,\n+) (response *activitypb.PollActivityExecutionResponse, err error) {\n+\tref := chasm.NewComponentRef[*Activity](chasm.EntityKey{\n+\t\tNamespaceID: req.GetNamespaceId(),\n+\t\tBusinessID:  req.GetFrontendRequest().GetActivityId(),\n+\t\tEntityID:    req.GetFrontendRequest().GetRunId(),\n+\t})\n+\tdefer func() {\n+\t\tvar notFound *serviceerror.NotFound\n+\t\tif errors.As(err, &notFound) {\n+\t\t\t// TODO(dan): include execution key in error message; we may do this at the CHASM\n+\t\t\t// framework level.\n+\t\t\t// cf. \"workflow execution not found for workflow ID XXX and run ID YYY\"\n+\t\t\terr = serviceerror.NewNotFound(\"activity execution not found\")\n+\t\t}\n+\t}()\n+\n+\twaitPolicy := req.GetFrontendRequest().GetWaitPolicy()\n+\n+\tif waitPolicy == nil {\n+\t\treturn chasm.ReadComponent(ctx, ref, (*Activity).buildPollActivityExecutionResponse, req, nil)\n+\t}\n+\n+\t// Do not allow long-poll to use all remaining time\n+\tchildCtx := ctx\n+\tif deadline, ok := ctx.Deadline(); ok {\n+\t\tvar cancel context.CancelFunc\n+\t\tchildCtx, cancel = context.WithDeadline(ctx, deadline.Add(-time.Second))\n+\t\tdefer cancel()\n+\t}\n+\n+\tswitch waitPolicy.(type) {\n+\tcase *workflowservice.PollActivityExecutionRequest_WaitAnyStateChange:\n+\t\ttoken := req.GetFrontendRequest().\n+\t\t\tGetWaitPolicy().(*workflowservice.PollActivityExecutionRequest_WaitAnyStateChange).\n+\t\t\tWaitAnyStateChange.GetLongPollToken()\n+\t\tif len(token) == 0 {\n+\t\t\treturn chasm.ReadComponent(ctx, ref, (*Activity).buildPollActivityExecutionResponse, req, nil)\n+\t\t}\n+\t\tresponse, _, err = chasm.PollComponent(childCtx, ref, func(\n+\t\t\ta *Activity,\n+\t\t\tctx chasm.Context,\n+\t\t\treq *activitypb.PollActivityExecutionRequest,\n+\t\t) (*activitypb.PollActivityExecutionResponse, bool, error) {\n+\t\t\tchanged, err := chasm.ExecutionStateChanged(a, ctx, token)\n+\t\t\tif err != nil {\n+\t\t\t\tif errors.Is(err, chasm.ErrMalformedComponentRef) {\n+\t\t\t\t\treturn nil, false, serviceerror.NewInvalidArgument(\"invalid long poll token\")\n+\t\t\t\t}\n+\t\t\t\tif errors.Is(err, chasm.ErrInvalidComponentRef) {\n+\t\t\t\t\treturn nil, false, serviceerror.NewInvalidArgument(\"long poll token does not match execution\")\n+\t\t\t\t}\n+\t\t\t\treturn nil, false, err\n+\t\t\t}\n+\t\t\tif changed {\n+\t\t\t\tresponse, err := a.buildPollActivityExecutionResponse(ctx, req)\n+\t\t\t\treturn response, true, err\n+\t\t\t} else {\n+\t\t\t\treturn nil, false, nil\n+\t\t\t}\n+\t\t}, req)\n+\tcase *workflowservice.PollActivityExecutionRequest_WaitCompletion:\n+\t\t// TODO(dan): add functional test when RecordActivityTaskCompleted is implemented\n+\t\tresponse, _, err = chasm.PollComponent(childCtx, ref, func(\n+\t\t\ta *Activity,\n+\t\t\tctx chasm.Context,\n+\t\t\treq *activitypb.PollActivityExecutionRequest,\n+\t\t) (*activitypb.PollActivityExecutionResponse, bool, error) {\n+\t\t\t// TODO(dan): check for terminal activity states\n+\t\t\tpanic(\"pollActivityExecutionWaitCompletion is not implemented\")\n+\t\t\tcompleted := false\n+\t\t\tif completed {\n+\t\t\t\tresponse, err := a.buildPollActivityExecutionResponse(ctx, req)\n+\t\t\t\tif err != nil {\n+\t\t\t\t\treturn nil, true, err\n+\t\t\t\t}\n+\t\t\t\treturn response, true, nil\n+\t\t\t}\n+\t\t\treturn nil, false, nil\n+\t\t}, req)\n+\tdefault:\n+\t\treturn nil, serviceerror.NewInvalidArgumentf(\"unexpected wait policy type: %T\", waitPolicy)\n+\t}\n+\n+\tif childCtx.Err() != nil {","path":"chasm/lib/activity/handler.go","commit_id":"59d749626d6a00c5fff76abe79a85eb627366521","original_commit_id":"59d749626d6a00c5fff76abe79a85eb627366521","user":{"login":"dandavison","id":52205,"node_id":"MDQ6VXNlcjUyMjA1","avatar_url":"https://avatars.githubusercontent.com/u/52205?v=4","gravatar_id":"","url":"https://api.github.com/users/dandavison","html_url":"https://github.com/dandavison","followers_url":"https://api.github.com/users/dandavison/followers","following_url":"https://api.github.com/users/dandavison/following{/other_user}","gists_url":"https://api.github.com/users/dandavison/gists{/gist_id}","starred_url":"https://api.github.com/users/dandavison/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/dandavison/subscriptions","organizations_url":"https://api.github.com/users/dandavison/orgs","repos_url":"https://api.github.com/users/dandavison/repos","events_url":"https://api.github.com/users/dandavison/events{/privacy}","received_events_url":"https://api.github.com/users/dandavison/received_events","type":"User","user_view_type":"public","site_admin":false},"body":"We discussed this offline; all deadline logic should now be correct.","created_at":"2025-12-03T17:31:33Z","updated_at":"2025-12-04T02:13:23Z","html_url":"https://github.com/temporalio/temporal/pull/8563#discussion_r2586024468","pull_request_url":"https://api.github.com/repos/temporalio/temporal/pulls/8563","_links":{"self":{"href":"https://api.github.com/repos/temporalio/temporal/pulls/comments/2586024468"},"html":{"href":"https://github.com/temporalio/temporal/pull/8563#discussion_r2586024468"},"pull_request":{"href":"https://api.github.com/repos/temporalio/temporal/pulls/8563"}},"reactions":{"url":"https://api.github.com/repos/temporalio/temporal/pulls/comments/2586024468/reactions","total_count":0,"+1":0,"-1":0,"laugh":0,"hooray":0,"confused":0,"heart":0,"rocket":0,"eyes":0},"start_line":null,"original_start_line":null,"start_side":null,"line":null,"original_line":149,"side":"RIGHT","in_reply_to_id":2579102749,"author_association":"MEMBER","original_position":105,"position":1,"subject_type":"line"},{"url":"https://api.github.com/repos/temporalio/temporal/pulls/comments/2586024691","pull_request_review_id":3536180777,"id":2586024691,"node_id":"PRRC_kwDODNqesM6aI5rz","diff_hunk":"@@ -53,3 +56,115 @@ func (h *handler) StartActivityExecution(ctx context.Context, req *activitypb.St\n \t\tFrontendResponse: response,\n \t}, nil\n }\n+\n+// PollActivityExecution handles PollActivityExecutionRequest from frontend. This method supports\n+// querying current activity state, optionally as a long-poll that waits for certain state changes.\n+// It is used by clients to poll for activity state and/or result.\n+func (h *handler) PollActivityExecution(\n+\tctx context.Context,\n+\treq *activitypb.PollActivityExecutionRequest,\n+) (response *activitypb.PollActivityExecutionResponse, err error) {\n+\tref := chasm.NewComponentRef[*Activity](chasm.EntityKey{\n+\t\tNamespaceID: req.GetNamespaceId(),\n+\t\tBusinessID:  req.GetFrontendRequest().GetActivityId(),\n+\t\tEntityID:    req.GetFrontendRequest().GetRunId(),\n+\t})\n+\tdefer func() {\n+\t\tvar notFound *serviceerror.NotFound\n+\t\tif errors.As(err, &notFound) {\n+\t\t\t// TODO(dan): include execution key in error message; we may do this at the CHASM\n+\t\t\t// framework level.\n+\t\t\t// cf. \"workflow execution not found for workflow ID XXX and run ID YYY\"\n+\t\t\terr = serviceerror.NewNotFound(\"activity execution not found\")\n+\t\t}\n+\t}()\n+\n+\twaitPolicy := req.GetFrontendRequest().GetWaitPolicy()\n+\n+\tif waitPolicy == nil {\n+\t\treturn chasm.ReadComponent(ctx, ref, (*Activity).buildPollActivityExecutionResponse, req, nil)\n+\t}\n+\n+\t// Do not allow long-poll to use all remaining time\n+\tchildCtx := ctx\n+\tif deadline, ok := ctx.Deadline(); ok {\n+\t\tvar cancel context.CancelFunc\n+\t\tchildCtx, cancel = context.WithDeadline(ctx, deadline.Add(-time.Second))\n+\t\tdefer cancel()\n+\t}\n+\n+\tswitch waitPolicy.(type) {\n+\tcase *workflowservice.PollActivityExecutionRequest_WaitAnyStateChange:\n+\t\ttoken := req.GetFrontendRequest().\n+\t\t\tGetWaitPolicy().(*workflowservice.PollActivityExecutionRequest_WaitAnyStateChange).\n+\t\t\tWaitAnyStateChange.GetLongPollToken()\n+\t\tif len(token) == 0 {\n+\t\t\treturn chasm.ReadComponent(ctx, ref, (*Activity).buildPollActivityExecutionResponse, req, nil)\n+\t\t}\n+\t\tresponse, _, err = chasm.PollComponent(childCtx, ref, func(\n+\t\t\ta *Activity,\n+\t\t\tctx chasm.Context,\n+\t\t\treq *activitypb.PollActivityExecutionRequest,\n+\t\t) (*activitypb.PollActivityExecutionResponse, bool, error) {\n+\t\t\tchanged, err := chasm.ExecutionStateChanged(a, ctx, token)\n+\t\t\tif err != nil {\n+\t\t\t\tif errors.Is(err, chasm.ErrMalformedComponentRef) {\n+\t\t\t\t\treturn nil, false, serviceerror.NewInvalidArgument(\"invalid long poll token\")\n+\t\t\t\t}\n+\t\t\t\tif errors.Is(err, chasm.ErrInvalidComponentRef) {\n+\t\t\t\t\treturn nil, false, serviceerror.NewInvalidArgument(\"long poll token does not match execution\")\n+\t\t\t\t}\n+\t\t\t\treturn nil, false, err\n+\t\t\t}\n+\t\t\tif changed {\n+\t\t\t\tresponse, err := a.buildPollActivityExecutionResponse(ctx, req)\n+\t\t\t\treturn response, true, err\n+\t\t\t} else {\n+\t\t\t\treturn nil, false, nil\n+\t\t\t}\n+\t\t}, req)\n+\tcase *workflowservice.PollActivityExecutionRequest_WaitCompletion:\n+\t\t// TODO(dan): add functional test when RecordActivityTaskCompleted is implemented\n+\t\tresponse, _, err = chasm.PollComponent(childCtx, ref, func(\n+\t\t\ta *Activity,\n+\t\t\tctx chasm.Context,\n+\t\t\treq *activitypb.PollActivityExecutionRequest,\n+\t\t) (*activitypb.PollActivityExecutionResponse, bool, error) {\n+\t\t\t// TODO(dan): check for terminal activity states\n+\t\t\tpanic(\"pollActivityExecutionWaitCompletion is not implemented\")\n+\t\t\tcompleted := false\n+\t\t\tif completed {\n+\t\t\t\tresponse, err := a.buildPollActivityExecutionResponse(ctx, req)\n+\t\t\t\tif err != nil {\n+\t\t\t\t\treturn nil, true, err\n+\t\t\t\t}\n+\t\t\t\treturn response, true, nil\n+\t\t\t}\n+\t\t\treturn nil, false, nil\n+\t\t}, req)\n+\tdefault:\n+\t\treturn nil, serviceerror.NewInvalidArgumentf(\"unexpected wait policy type: %T\", waitPolicy)\n+\t}\n+\n+\tif childCtx.Err() != nil {\n+\t\t// Caller deadline exceeded\n+\t\treturn nil, childCtx.Err()\n+\t}\n+\tif errors.Is(err, context.DeadlineExceeded) {","path":"chasm/lib/activity/handler.go","commit_id":"59d749626d6a00c5fff76abe79a85eb627366521","original_commit_id":"f3115e38e18a1ba16dc583d8ef987c679a7e9683","user":{"login":"dandavison","id":52205,"node_id":"MDQ6VXNlcjUyMjA1","avatar_url":"https://avatars.githubusercontent.com/u/52205?v=4","gravatar_id":"","url":"https://api.github.com/users/dandavison","html_url":"https://github.com/dandavison","followers_url":"https://api.github.com/users/dandavison/followers","following_url":"https://api.github.com/users/dandavison/following{/other_user}","gists_url":"https://api.github.com/users/dandavison/gists{/gist_id}","starred_url":"https://api.github.com/users/dandavison/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/dandavison/subscriptions","organizations_url":"https://api.github.com/users/dandavison/orgs","repos_url":"https://api.github.com/users/dandavison/repos","events_url":"https://api.github.com/users/dandavison/events{/privacy}","received_events_url":"https://api.github.com/users/dandavison/received_events","type":"User","user_view_type":"public","site_admin":false},"body":"We discussed this offline; all deadline logic should now be correct.","created_at":"2025-12-03T17:31:37Z","updated_at":"2025-12-04T02:13:23Z","html_url":"https://github.com/temporalio/temporal/pull/8563#discussion_r2586024691","pull_request_url":"https://api.github.com/repos/temporalio/temporal/pulls/8563","_links":{"self":{"href":"https://api.github.com/repos/temporalio/temporal/pulls/comments/2586024691"},"html":{"href":"https://github.com/temporalio/temporal/pull/8563#discussion_r2586024691"},"pull_request":{"href":"https://api.github.com/repos/temporalio/temporal/pulls/8563"}},"reactions":{"url":"https://api.github.com/repos/temporalio/temporal/pulls/comments/2586024691/reactions","total_count":0,"+1":0,"-1":0,"laugh":0,"hooray":0,"confused":0,"heart":0,"rocket":0,"eyes":0},"start_line":null,"original_start_line":151,"start_side":"RIGHT","line":null,"original_line":153,"side":"RIGHT","in_reply_to_id":2567038615,"author_association":"MEMBER","original_position":109,"position":1,"subject_type":"line"},{"url":"https://api.github.com/repos/temporalio/temporal/pulls/comments/2586057472","pull_request_review_id":3536220194,"id":2586057472,"node_id":"PRRC_kwDODNqesM6aJBsA","diff_hunk":"@@ -241,14 +256,126 @@ func (e *ChasmEngine) ReadComponent(\n \treturn readFn(chasmContext, component)\n }\n \n+// PollComponent waits until the supplied predicate is satisfied when evaluated against the\n+// component identified by the supplied component reference. If there is no error, it returns (ref,\n+// nil) where ref is a component reference identifying the state at which the predicate was\n+// satisfied. The predicate must be monotonic: if it returns true at execution state transition s it\n+// must return true at all transitions t > s. It is an error if execution transition history is\n+// (after reloading from persistence) behind the requested ref, or if the ref is inconsistent with\n+// execution transition history. Thus when the predicate function is evaluated, it is guaranteed\n+// that the execution VT >= requestRef VT. opts are currently ignored.\n func (e *ChasmEngine) PollComponent(\n \tctx context.Context,\n-\tentityRef chasm.ComponentRef,\n-\tpredicateFn func(chasm.Context, chasm.Component) (any, bool, error),\n-\toperationFn func(chasm.MutableContext, chasm.Component, any) error,\n+\trequestRef chasm.ComponentRef,\n+\tmonotonicPredicate func(chasm.Context, chasm.Component) (bool, error),\n \topts ...chasm.TransitionOption,\n-) (newEntityRef []byte, retError error) {\n-\treturn nil, serviceerror.NewUnimplemented(\"PollComponent is not yet supported\")\n+) (retRef []byte, retError error) {\n+\tdefer func() {\n+\t\tif errors.Is(retError, consts.ErrStaleState) {\n+\t\t\tretError = serviceerror.NewUnavailable(\"please retry\")\n+\t\t}\n+\t}()\n+\n+\t_, executionLease, err := e.getExecutionLease(ctx, requestRef)\n+\tif err != nil {\n+\t\t// E.g. requestRef VT inconsistent with execution VT ('stale reference')\n+\t\treturn nil, err\n+\t}\n+\tdefer executionLease.GetReleaseFn()(nil)\n+\n+\t// At this point it's possible that execution VT < requestRef VT (getExecutionLease does not\n+\t// guarantee that returned execution state is non-stale w.r.t. requestRef).\n+\tsatisfiedRef, err := e.predicateSatisfied(ctx, monotonicPredicate, requestRef, executionLease)\n+\tif err != nil {\n+\t\treturn nil, err\n+\t}\n+\t// execution VT >= requestRef VT (enforced by predicateSatisfied)\n+\n+\tif satisfiedRef != nil {\n+\t\t// wait condition was satisfied\n+\t\treturn satisfiedRef, nil\n+\t}\n+\n+\t// Wait condition not satisfied; long-poll\n+\n+\t// PollComponent subscribes to execution-level notifications. Suppose that an execution consists\n+\t// of one component A, and A has subcomponent B. Subscribers interested only in component B may\n+\t// be woken up unnecessarily (and thus evaluate the predicate unnecessarily) due to changes in\n+\t// parts of A that do not also belong to B.\n+\tch := e.notifier.Subscribe(requestRef.EntityKey)\n+\texecutionLease.GetReleaseFn()(nil)","path":"service/history/chasm_engine.go","commit_id":"372cc0a17931bd461ec03349b8509b57820e36c2","original_commit_id":"40e66e38fede50e752ab5e4e37955618c1d037c6","user":{"login":"cursor[bot]","id":206951365,"node_id":"BOT_kgDODFXTxQ","avatar_url":"https://avatars.githubusercontent.com/in/1210556?v=4","gravatar_id":"","url":"https://api.github.com/users/cursor%5Bbot%5D","html_url":"https://github.com/apps/cursor","followers_url":"https://api.github.com/users/cursor%5Bbot%5D/followers","following_url":"https://api.github.com/users/cursor%5Bbot%5D/following{/other_user}","gists_url":"https://api.github.com/users/cursor%5Bbot%5D/gists{/gist_id}","starred_url":"https://api.github.com/users/cursor%5Bbot%5D/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/cursor%5Bbot%5D/subscriptions","organizations_url":"https://api.github.com/users/cursor%5Bbot%5D/orgs","repos_url":"https://api.github.com/users/cursor%5Bbot%5D/repos","events_url":"https://api.github.com/users/cursor%5Bbot%5D/events{/privacy}","received_events_url":"https://api.github.com/users/cursor%5Bbot%5D/received_events","type":"Bot","user_view_type":"public","site_admin":false},"body":"### Bug: Double release of execution lease in PollComponent\n\n<!-- **High Severity** -->\n\n<!-- DESCRIPTION START -->\nThe initial `executionLease` is released twice: once explicitly at line 306 before entering the long-poll loop (`executionLease.GetReleaseFn()(nil)`), and again via the `defer` at line 284 when the function eventually returns. The defer captures the initial lease and will execute regardless of which return path is taken. This double-release of the workflow context lock could cause undefined behavior or panics.\n<!-- DESCRIPTION END -->\n\n<!-- LOCATIONS START\nservice/history/chasm_engine.go#L283-L306\nLOCATIONS END -->\n<a href=\"https://cursor.com/open?data=eyJhbGciOiJSUzI1NiIsInR5cCI6IkpXVCIsImtpZCI6ImJ1Z2JvdC12MSJ9.eyJ2ZXJzaW9uIjoxLCJ0eXBlIjoiQlVHQk9UX0ZJWF9JTl9DVVJTT1IiLCJkYXRhIjp7InJlZGlzS2V5IjoiYnVnYm90OmI5MTQyNzc4LTgwN2ItNGUxYy04ZjMxLTFkMjI5ZWRmZmJiYSIsImVuY3J5cHRpb25LZXkiOiI4R3pXamZjNk1JSEp6SDVqOWJLaENzLWZEako4YmtQaTBWeVBsZ2drQ3hjIiwiYnJhbmNoIjoicG9sbC1jb21wb25lbnQifSwiaWF0IjoxNzY0NzgzNzI0LCJleHAiOjE3NjUzODg1MjR9.HJ8U411q2BbdctkHe_NRBHsU2wyAkEMYfj2qxqnhd_w4bZeVHb5D6D1OeRmb7HKVl3mffDGZw0qlhnB90IxE8NNuu1oIN0TqgfzWYESJ9JCSaHT7NqttqFM9m0h98kyVRmqXe_TwpeH0SRmeZd4aIhDLrUnyPOehNjrO4rNt1b7NYwP5yPpncd0Mqb49ar710QoAIr8UIxB0UxN4hOhxReTDzNb1Z1KXxmbts00rjBvLSPB1nVxdWUfFbf6e7ZpFsFh95UC8H22riYOPSd5GXINr1h4XBPBIguUbneFE5-9DvVGqECeVW0zHYtZRI6K_qqMudbggMNzfNflM_bsAmQ\"><picture><source media=\"(prefers-color-scheme: dark)\" srcset=\"https://cursor.com/fix-in-cursor-dark.svg\"><source media=\"(prefers-color-scheme: light)\" srcset=\"https://cursor.com/fix-in-cursor-light.svg\"><img alt=\"Fix in Cursor\" src=\"https://cursor.com/fix-in-cursor.svg\"></picture></a>&nbsp;<a href=\"https://cursor.com/agents?data=eyJhbGciOiJSUzI1NiIsInR5cCI6IkpXVCIsImtpZCI6ImJ1Z2JvdC12MSJ9.eyJ2ZXJzaW9uIjoxLCJ0eXBlIjoiQlVHQk9UX0ZJWF9JTl9XRUIiLCJkYXRhIjp7InJlZGlzS2V5IjoiYnVnYm90OmI5MTQyNzc4LTgwN2ItNGUxYy04ZjMxLTFkMjI5ZWRmZmJiYSIsImVuY3J5cHRpb25LZXkiOiI4R3pXamZjNk1JSEp6SDVqOWJLaENzLWZEako4YmtQaTBWeVBsZ2drQ3hjIiwiYnJhbmNoIjoicG9sbC1jb21wb25lbnQiLCJyZXBvT3duZXIiOiJ0ZW1wb3JhbGlvIiwicmVwb05hbWUiOiJ0ZW1wb3JhbCIsInByTnVtYmVyIjo4NTYzLCJjb21taXRTaGEiOiI0MGU2NmUzOGZlZGU1MGU3NTJhYjVlNGUzNzk1NTYxOGMxZDAzN2M2IiwicHJvdmlkZXIiOiJnaXRodWIifSwiaWF0IjoxNzY0NzgzNzI0LCJleHAiOjE3NjUzODg1MjR9.P3Zn6i15PFwyfHlvAwWgIth_rfRcYJUdhPY6JJOaKs6PnEXb3bMPlUWHn1B2senNfks6PeblJ_QhFNw2WcPt9zftOFrIWsRFXV7dwk3VWQ6WLJJWxxx8nZmktyM9a2HDwsuY7LA2U0qwe6CP3RR8cT5abTBg52tOzL3nHrgX8vmEg8lMJEPPoPwXcuZpq7xkMwoOaIn1fFlgKOOElBH7eP6qJh4guZ0UoNhXUndLXLlE8DUOkG1wer0CYR3yV4XbY9TLGfr_E_ITxYxjfETnVHPrJyFj_QsjLYojS14K1p5P5-_-3OcOFLqR-DyOVrZj2hqpVvL_9DYTDym3JyN9gg\"><picture><source media=\"(prefers-color-scheme: dark)\" srcset=\"https://cursor.com/fix-in-web-dark.svg\"><source media=\"(prefers-color-scheme: light)\" srcset=\"https://cursor.com/fix-in-web-light.svg\"><img alt=\"Fix in Web\" src=\"https://cursor.com/fix-in-web.svg\"></picture></a>\n\n","created_at":"2025-12-03T17:42:04Z","updated_at":"2025-12-03T17:42:05Z","html_url":"https://github.com/temporalio/temporal/pull/8563#discussion_r2586057472","pull_request_url":"https://api.github.com/repos/temporalio/temporal/pulls/8563","_links":{"self":{"href":"https://api.github.com/repos/temporalio/temporal/pulls/comments/2586057472"},"html":{"href":"https://github.com/temporalio/temporal/pull/8563#discussion_r2586057472"},"pull_request":{"href":"https://api.github.com/repos/temporalio/temporal/pulls/8563"}},"reactions":{"url":"https://api.github.com/repos/temporalio/temporal/pulls/comments/2586057472/reactions","total_count":0,"+1":0,"-1":0,"laugh":0,"hooray":0,"confused":0,"heart":0,"rocket":0,"eyes":0},"start_line":null,"original_start_line":null,"start_side":null,"line":null,"original_line":306,"side":"RIGHT","author_association":"NONE","original_position":122,"position":1,"subject_type":"line"},{"url":"https://api.github.com/repos/temporalio/temporal/pulls/comments/2586091783","pull_request_review_id":3536180777,"id":2586091783,"node_id":"PRRC_kwDODNqesM6aJKEH","diff_hunk":"@@ -0,0 +1,47 @@\n+package chasm\n+\n+import (\n+\t\"go.temporal.io/api/serviceerror\"\n+\t\"go.temporal.io/server/common/persistence/transitionhistory\"\n+\t\"go.temporal.io/server/service/history/consts\"\n+)\n+\n+// ErrMalformedComponentRef is returned when the provided component ref cannot be deserialized.\n+var ErrMalformedComponentRef = serviceerror.NewInternal(\"malformed component ref\")\n+\n+// ErrInvalidComponentRef is returned when the provided component ref does not match the target execution.\n+var ErrInvalidComponentRef = serviceerror.NewInvalidArgument(\"invalid component ref\")\n+\n+// ExecutionStateChanged returns true if execution state has advanced beyond the state encoded in\n+// refBytes.\n+func ExecutionStateChanged(c Component, ctx Context, refBytes []byte) (bool, error) {\n+\tref, err := DeserializeComponentRef(refBytes)\n+\tif err != nil {\n+\t\treturn false, ErrMalformedComponentRef","path":"chasm/transition_history.go","commit_id":"37c5f7fa3194434813e3df63aa07231df81d239b","original_commit_id":"59d749626d6a00c5fff76abe79a85eb627366521","user":{"login":"dandavison","id":52205,"node_id":"MDQ6VXNlcjUyMjA1","avatar_url":"https://avatars.githubusercontent.com/u/52205?v=4","gravatar_id":"","url":"https://api.github.com/users/dandavison","html_url":"https://github.com/dandavison","followers_url":"https://api.github.com/users/dandavison/followers","following_url":"https://api.github.com/users/dandavison/following{/other_user}","gists_url":"https://api.github.com/users/dandavison/gists{/gist_id}","starred_url":"https://api.github.com/users/dandavison/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/dandavison/subscriptions","organizations_url":"https://api.github.com/users/dandavison/orgs","repos_url":"https://api.github.com/users/dandavison/repos","events_url":"https://api.github.com/users/dandavison/events{/privacy}","received_events_url":"https://api.github.com/users/dandavison/received_events","type":"User","user_view_type":"public","site_admin":false},"body":"I am using sentinel non-`serviceerror` errors in this code because it is a CHASM framework API and we shouldn't assume that the caller has passed user request data.\r\n\r\nI've added comments explaining that the sentinel errors are there so that upstream callers can commute the errors to become an appropriate type for a response. \r\n\r\nPlease see 5f9a597e9 ","created_at":"2025-12-03T17:52:57Z","updated_at":"2025-12-04T02:13:23Z","html_url":"https://github.com/temporalio/temporal/pull/8563#discussion_r2586091783","pull_request_url":"https://api.github.com/repos/temporalio/temporal/pulls/8563","_links":{"self":{"href":"https://api.github.com/repos/temporalio/temporal/pulls/comments/2586091783"},"html":{"href":"https://github.com/temporalio/temporal/pull/8563#discussion_r2586091783"},"pull_request":{"href":"https://api.github.com/repos/temporalio/temporal/pulls/8563"}},"reactions":{"url":"https://api.github.com/repos/temporalio/temporal/pulls/comments/2586091783/reactions","total_count":0,"+1":0,"-1":0,"laugh":0,"hooray":0,"confused":0,"heart":0,"rocket":0,"eyes":0},"start_line":null,"original_start_line":null,"start_side":null,"line":14,"original_line":20,"side":"RIGHT","in_reply_to_id":2578239317,"author_association":"MEMBER","original_position":20,"position":1,"subject_type":"line"},{"url":"https://api.github.com/repos/temporalio/temporal/pulls/comments/2586136052","pull_request_review_id":3536312613,"id":2586136052,"node_id":"PRRC_kwDODNqesM6aJU30","diff_hunk":"@@ -101,3 +101,46 @@ func (c *ActivityServiceLayeredClient) StartActivityExecution(\n \t}\n \treturn backoff.ThrottleRetryContextWithReturn(ctx, call, c.retryPolicy, common.IsServiceClientTransientError)\n }\n+func (c *ActivityServiceLayeredClient) callPollActivityExecutionNoRetry(\n+\tctx context.Context,\n+\trequest *PollActivityExecutionRequest,\n+\topts ...grpc.CallOption,\n+) (*PollActivityExecutionResponse, error) {\n+\tvar response *PollActivityExecutionResponse\n+\tvar err error\n+\tstartTime := time.Now().UTC()\n+\t// the caller is a namespace, hence the tag below.\n+\tcaller := headers.GetCallerInfo(ctx).CallerName\n+\tmetricsHandler := c.metricsHandler.WithTags(\n+\t\tmetrics.OperationTag(\"ActivityService.PollActivityExecution\"),\n+\t\tmetrics.NamespaceTag(caller),\n+\t\tmetrics.ServiceRoleTag(metrics.HistoryRoleTagValue),\n+\t)\n+\tmetrics.ClientRequests.With(metricsHandler).Record(1)\n+\tdefer func() {\n+\t\tif err != nil {\n+\t\t\tmetrics.ClientFailures.With(metricsHandler).Record(1, metrics.ServiceErrorTypeTag(err))\n+\t\t}\n+\t\tmetrics.ClientLatency.With(metricsHandler).Record(time.Since(startTime))\n+\t}()\n+\tshardID := common.WorkflowIDToHistoryShard(request.GetNamespaceId(), request.GetFrontendRequest().GetActivityId(), c.numShards)\n+\top := func(ctx context.Context, client ActivityServiceClient) error {\n+\t\tvar err error\n+\t\tctx, cancel := context.WithTimeout(ctx, history.DefaultTimeout)\n+\t\tdefer cancel()","path":"chasm/lib/activity/gen/activitypb/v1/service_client.pb.go","commit_id":"1d59e66d0ce5d91819f92c428ef5ab4c4efca1fb","original_commit_id":"5f9a597e9bd7c7385dfa0d068fccf04333860856","user":{"login":"cursor[bot]","id":206951365,"node_id":"BOT_kgDODFXTxQ","avatar_url":"https://avatars.githubusercontent.com/in/1210556?v=4","gravatar_id":"","url":"https://api.github.com/users/cursor%5Bbot%5D","html_url":"https://github.com/apps/cursor","followers_url":"https://api.github.com/users/cursor%5Bbot%5D/followers","following_url":"https://api.github.com/users/cursor%5Bbot%5D/following{/other_user}","gists_url":"https://api.github.com/users/cursor%5Bbot%5D/gists{/gist_id}","starred_url":"https://api.github.com/users/cursor%5Bbot%5D/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/cursor%5Bbot%5D/subscriptions","organizations_url":"https://api.github.com/users/cursor%5Bbot%5D/orgs","repos_url":"https://api.github.com/users/cursor%5Bbot%5D/repos","events_url":"https://api.github.com/users/cursor%5Bbot%5D/events{/privacy}","received_events_url":"https://api.github.com/users/cursor%5Bbot%5D/received_events","type":"Bot","user_view_type":"public","site_admin":false},"body":"### Bug: Long-poll timeout capped by client's shorter default timeout\n\n<!-- **Medium Severity** -->\n\n<!-- DESCRIPTION START -->\nThe generated client for `PollActivityExecution` applies `history.DefaultTimeout` (30 seconds) to the context in `callPollActivityExecutionNoRetry`. This timeout caps any long-poll operation regardless of the configured `LongPollTimeout`. If `LongPollTimeout` is configured higher than 30 seconds, the history client will timeout the request before the handler's long-poll logic completes. Unlike regular RPC operations, long-poll operations need special timeout handling or should inherit the caller's deadline without an additional cap.\n<!-- DESCRIPTION END -->\n\n<!-- LOCATIONS START\nchasm/lib/activity/gen/activitypb/v1/service_client.pb.go#L128-L130\nLOCATIONS END -->\n<a href=\"https://cursor.com/open?data=eyJhbGciOiJSUzI1NiIsInR5cCI6IkpXVCIsImtpZCI6ImJ1Z2JvdC12MSJ9.eyJ2ZXJzaW9uIjoxLCJ0eXBlIjoiQlVHQk9UX0ZJWF9JTl9DVVJTT1IiLCJkYXRhIjp7InJlZGlzS2V5IjoiYnVnYm90Ojk3OWVhODljLTI1ZDItNDNhMy04YjAyLWFlMDg0M2E1ZTYzNiIsImVuY3J5cHRpb25LZXkiOiJSS1g0TElJYnZPb3RxVzRJTy1mT0JCM005OF81ZXAtR0VtNm82ZkR5amVBIiwiYnJhbmNoIjoicG9sbC1jb21wb25lbnQifSwiaWF0IjoxNzY0Nzg1MzEzLCJleHAiOjE3NjUzOTAxMTN9.I1-qQ9Y6evuyG80hUhsqp4XFFdbEh3eIK1ghlKgtRmz5-hNgLrHP_yULCLEt9N8Au6-8yxDHX9Q9e1z5y_TBm9H3Abu87NY5Baqj8YnLrZ1ZsiH6GU26oPqK6DH7BOGRh-MWDCmGPXattRma63WYCd0d3VlKritTj2B2UtTYrK71TLX_FuzPuKDPlekakkoD4FsQwx1Ayk_GMIXyw4ujzYAcFcZXWl8wEQPqJTouBBDFa2jrAJdcH1CKB6VXkZfXnv_e26i8RizjWdK5zDeZzAfEOzxUIRra1HASjNmBdPn2XXWsqTntArAdzkHnVF18oHkPzGWTkVNJMO7IyO2NQA\"><picture><source media=\"(prefers-color-scheme: dark)\" srcset=\"https://cursor.com/fix-in-cursor-dark.svg\"><source media=\"(prefers-color-scheme: light)\" srcset=\"https://cursor.com/fix-in-cursor-light.svg\"><img alt=\"Fix in Cursor\" src=\"https://cursor.com/fix-in-cursor.svg\"></picture></a>&nbsp;<a href=\"https://cursor.com/agents?data=eyJhbGciOiJSUzI1NiIsInR5cCI6IkpXVCIsImtpZCI6ImJ1Z2JvdC12MSJ9.eyJ2ZXJzaW9uIjoxLCJ0eXBlIjoiQlVHQk9UX0ZJWF9JTl9XRUIiLCJkYXRhIjp7InJlZGlzS2V5IjoiYnVnYm90Ojk3OWVhODljLTI1ZDItNDNhMy04YjAyLWFlMDg0M2E1ZTYzNiIsImVuY3J5cHRpb25LZXkiOiJSS1g0TElJYnZPb3RxVzRJTy1mT0JCM005OF81ZXAtR0VtNm82ZkR5amVBIiwiYnJhbmNoIjoicG9sbC1jb21wb25lbnQiLCJyZXBvT3duZXIiOiJ0ZW1wb3JhbGlvIiwicmVwb05hbWUiOiJ0ZW1wb3JhbCIsInByTnVtYmVyIjo4NTYzLCJjb21taXRTaGEiOiI1ZjlhNTk3ZTliZDdjNzM4NWRmYTBkMDY4ZmNjZjA0MzMzODYwODU2IiwicHJvdmlkZXIiOiJnaXRodWIifSwiaWF0IjoxNzY0Nzg1MzEzLCJleHAiOjE3NjUzOTAxMTN9.m8Q76BHf6sIcx8gE_smrudNCzpt8DwVI96iaGFrwELpp29XSyomUjuOPPY68ptMbIRmhGn8wHtGqGOjbMi1xboIdt9iVf17y4V6tu3QVbYfxJzWsm1rz8THabdZyTJ79eY0yMynXujwLGzbA7tNEMSb2WVtHF0UbCCuQtYXXTm0BajO6fLGcOKJqGr99dKvSiVK3CBooXBg5LWgwiPMaaAeqOJmW1_ROaCAsbAsQAjPlRXkMpuHnLUizNMhJIaFylgsVvNcNOlmNrvpa09zx66G13NsAeDJg8GZLfHbjKbPBHiAjyxFM1OewDQo5INqO6FCyfjGtrrJOthzn4Kdx7Q\"><picture><source media=\"(prefers-color-scheme: dark)\" srcset=\"https://cursor.com/fix-in-web-dark.svg\"><source media=\"(prefers-color-scheme: light)\" srcset=\"https://cursor.com/fix-in-web-light.svg\"><img alt=\"Fix in Web\" src=\"https://cursor.com/fix-in-web.svg\"></picture></a>\n\n","created_at":"2025-12-03T18:08:34Z","updated_at":"2025-12-03T18:08:34Z","html_url":"https://github.com/temporalio/temporal/pull/8563#discussion_r2586136052","pull_request_url":"https://api.github.com/repos/temporalio/temporal/pulls/8563","_links":{"self":{"href":"https://api.github.com/repos/temporalio/temporal/pulls/comments/2586136052"},"html":{"href":"https://github.com/temporalio/temporal/pull/8563#discussion_r2586136052"},"pull_request":{"href":"https://api.github.com/repos/temporalio/temporal/pulls/8563"}},"reactions":{"url":"https://api.github.com/repos/temporalio/temporal/pulls/comments/2586136052/reactions","total_count":0,"+1":0,"-1":0,"laugh":0,"hooray":0,"confused":0,"heart":0,"rocket":0,"eyes":0},"start_line":null,"original_start_line":null,"start_side":null,"line":130,"original_line":130,"side":"RIGHT","author_association":"NONE","original_position":30,"position":30,"subject_type":"line"},{"url":"https://api.github.com/repos/temporalio/temporal/pulls/comments/2586161273","pull_request_review_id":3536180777,"id":2586161273,"node_id":"PRRC_kwDODNqesM6aJbB5","diff_hunk":"@@ -0,0 +1,47 @@\n+package chasm\n+\n+import (\n+\t\"go.temporal.io/api/serviceerror\"\n+\t\"go.temporal.io/server/common/persistence/transitionhistory\"\n+\t\"go.temporal.io/server/service/history/consts\"\n+)\n+\n+// ErrMalformedComponentRef is returned when the provided component ref cannot be deserialized.\n+var ErrMalformedComponentRef = serviceerror.NewInternal(\"malformed component ref\")\n+\n+// ErrInvalidComponentRef is returned when the provided component ref does not match the target execution.\n+var ErrInvalidComponentRef = serviceerror.NewInvalidArgument(\"invalid component ref\")\n+\n+// ExecutionStateChanged returns true if execution state has advanced beyond the state encoded in\n+// refBytes.\n+func ExecutionStateChanged(c Component, ctx Context, refBytes []byte) (bool, error) {\n+\tref, err := DeserializeComponentRef(refBytes)\n+\tif err != nil {\n+\t\treturn false, ErrMalformedComponentRef\n+\t}\n+\tcurrentRefBytes, err := ctx.Ref(c)\n+\tif err != nil {\n+\t\treturn false, err\n+\t}\n+\tcurrentRef, err := DeserializeComponentRef(currentRefBytes)","path":"chasm/transition_history.go","commit_id":"5f9a597e9bd7c7385dfa0d068fccf04333860856","original_commit_id":"59d749626d6a00c5fff76abe79a85eb627366521","user":{"login":"dandavison","id":52205,"node_id":"MDQ6VXNlcjUyMjA1","avatar_url":"https://avatars.githubusercontent.com/u/52205?v=4","gravatar_id":"","url":"https://api.github.com/users/dandavison","html_url":"https://github.com/dandavison","followers_url":"https://api.github.com/users/dandavison/followers","following_url":"https://api.github.com/users/dandavison/following{/other_user}","gists_url":"https://api.github.com/users/dandavison/gists{/gist_id}","starred_url":"https://api.github.com/users/dandavison/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/dandavison/subscriptions","organizations_url":"https://api.github.com/users/dandavison/orgs","repos_url":"https://api.github.com/users/dandavison/repos","events_url":"https://api.github.com/users/dandavison/events{/privacy}","received_events_url":"https://api.github.com/users/dandavison/received_events","type":"User","user_view_type":"public","site_admin":false},"body":"I agree, done. See 37c5f7fa3194434813e3df63aa07231df81d239b","created_at":"2025-12-03T18:16:48Z","updated_at":"2025-12-04T02:13:23Z","html_url":"https://github.com/temporalio/temporal/pull/8563#discussion_r2586161273","pull_request_url":"https://api.github.com/repos/temporalio/temporal/pulls/8563","_links":{"self":{"href":"https://api.github.com/repos/temporalio/temporal/pulls/comments/2586161273"},"html":{"href":"https://github.com/temporalio/temporal/pull/8563#discussion_r2586161273"},"pull_request":{"href":"https://api.github.com/repos/temporalio/temporal/pulls/8563"}},"reactions":{"url":"https://api.github.com/repos/temporalio/temporal/pulls/comments/2586161273/reactions","total_count":0,"+1":0,"-1":0,"laugh":0,"hooray":0,"confused":0,"heart":0,"rocket":0,"eyes":0},"start_line":null,"original_start_line":22,"start_side":"RIGHT","line":null,"original_line":26,"side":"RIGHT","in_reply_to_id":2578267576,"author_association":"MEMBER","original_position":26,"position":1,"subject_type":"line"},{"url":"https://api.github.com/repos/temporalio/temporal/pulls/comments/2586171338","pull_request_review_id":3536180777,"id":2586171338,"node_id":"PRRC_kwDODNqesM6aJdfK","diff_hunk":"@@ -241,14 +256,137 @@ func (e *ChasmEngine) ReadComponent(\n \treturn readFn(chasmContext, component)\n }\n \n+// PollComponent waits until the supplied predicate is satisfied when evaluated against the\n+// component identified by the supplied component reference. If there is no error, it returns (ref,\n+// nil) where ref is a component reference identifying the state at which the predicate was\n+// satisfied. The predicate must be monotonic: if it returns true at execution state transition s it\n+// must return true at all transitions t > s. It is an error if execution transition history is\n+// (after reloading from persistence) behind the requested ref, or if the ref is inconsistent with\n+// execution transition history. Thus when the predicate function is evaluated, it is guaranteed\n+// that the execution VT >= requestRef VT. opts are currently ignored.\n func (e *ChasmEngine) PollComponent(\n \tctx context.Context,\n-\tentityRef chasm.ComponentRef,\n-\tpredicateFn func(chasm.Context, chasm.Component) (any, bool, error),\n-\toperationFn func(chasm.MutableContext, chasm.Component, any) error,\n+\trequestRef chasm.ComponentRef,\n+\tmonotonicPredicate func(chasm.Context, chasm.Component) (bool, error),\n \topts ...chasm.TransitionOption,\n-) (newEntityRef []byte, retError error) {\n-\treturn nil, serviceerror.NewUnimplemented(\"PollComponent is not yet supported\")\n+) (retRef []byte, retError error) {\n+\tdefer func() {\n+\t\tif errors.Is(retError, consts.ErrStaleState) {\n+\t\t\tretError = serviceerror.NewUnavailable(\"please retry\")\n+\t\t}\n+\t}()\n+\n+\tshardContext, executionLease, err := e.getExecutionLease(ctx, requestRef)\n+\tif err != nil {\n+\t\t// E.g. requestRef VT inconsistent with execution VT ('stale reference')\n+\t\treturn nil, err\n+\t}\n+\tdefer executionLease.GetReleaseFn()(nil)\n+\n+\t// At this point it's possible that execution VT < requestRef VT (getExecutionLease does not\n+\t// guarantee that returned execution state is non-stale w.r.t. requestRef).\n+\tsatisfiedRef, err := e.predicateSatisfied(ctx, monotonicPredicate, requestRef, executionLease)\n+\tif err != nil {\n+\t\treturn nil, err\n+\t}\n+\t// execution VT >= requestRef VT (enforced by predicateSatisfied)\n+\n+\tif satisfiedRef != nil {\n+\t\t// wait condition was satisfied\n+\t\treturn satisfiedRef, nil\n+\t}\n+\n+\t// Wait condition not satisfied; long-poll\n+\n+\tnamespaceRegistry, err := shardContext.GetNamespaceRegistry().GetNamespaceByID(\n+\t\tnamespace.ID(requestRef.EntityKey.NamespaceID),\n+\t)\n+\tif err != nil {\n+\t\treturn nil, err\n+\t}\n+\n+\tinternalLongPollTimeout := shardContext.GetConfig().LongPollExpirationInterval(namespaceRegistry.Name().String())\n+\tctx, cancel := context.WithTimeout(ctx, internalLongPollTimeout)\n+\tdefer cancel()\n+\n+\t// PollComponent subscribes to execution-level notifications. Suppose that an execution consists\n+\t// of one component A, and A has subcomponent B. Subscribers interested only in component B may\n+\t// be woken up unnecessarily (and thus evaluate the predicate unnecessarily) due to changes in\n+\t// parts of A that do not also belong to B.\n+\tch := e.notifier.Subscribe(requestRef.EntityKey)\n+\texecutionLease.GetReleaseFn()(nil)\n+\n+\tfor {\n+\t\tselect {\n+\t\t// It is possible that multiple state transitions (multiple notifications) occur between\n+\t\t// predicate checks, therefore the predicate must be monotonic: if it returns true at\n+\t\t// execution state transition s then it must return true at all transitions t > s.\n+\t\tcase <-ch:\n+\t\t\t_, executionLease, err := e.getExecutionLease(ctx, requestRef)\n+\t\t\tif err != nil {\n+\t\t\t\treturn nil, err\n+\t\t\t}\n+\t\t\tfunc() {\n+\t\t\t\tdefer executionLease.GetReleaseFn()(nil)\n+\t\t\t\tsatisfiedRef, err = e.predicateSatisfied(ctx, monotonicPredicate, requestRef, executionLease)\n+\t\t\t\tif err == nil && satisfiedRef == nil {\n+\t\t\t\t\tch = e.notifier.Subscribe(requestRef.EntityKey)\n+\t\t\t\t}\n+\t\t\t}()\n+\t\t\tif err != nil {\n+\t\t\t\treturn nil, err\n+\t\t\t}\n+\t\t\tif satisfiedRef != nil {\n+\t\t\t\treturn satisfiedRef, nil\n+\t\t\t}\n+\t\tcase <-ctx.Done():\n+\t\t\treturn nil, ctx.Err()\n+\t\t}\n+\t}\n+}\n+\n+// predicateSatisfied is a helper function for PollComponent. It returns (ref, err) where ref is non-nil\n+// iff there's no error and predicate evaluates to true.\n+func (e *ChasmEngine) predicateSatisfied(\n+\tctx context.Context,\n+\tpredicate func(chasm.Context, chasm.Component) (bool, error),\n+\tref chasm.ComponentRef,\n+\texecutionLease api.WorkflowLease,\n+) ([]byte, error) {\n+\tchasmTree, ok := executionLease.GetMutableState().ChasmTree().(*chasm.Node)\n+\tif !ok {\n+\t\treturn nil, serviceerror.NewInternalf(\n+\t\t\t\"CHASM tree implementation not properly wired up, encountered type: %T, expected type: %T\",\n+\t\t\texecutionLease.GetMutableState().ChasmTree(),\n+\t\t\t&chasm.Node{},\n+\t\t)\n+\t}\n+\n+\t// It is not acceptable to declare the predicate to be satisfied against execution state that is\n+\t// behind the requested reference. However, getExecutionLease does not currently guarantee that\n+\t// execution VT >= ref VT, therefore we call IsStale() again here and return any error (which at\n+\t// this point must be ErrStaleState; ErrStaleReference has already been eliminated).\n+\terr := chasmTree.IsStale(ref)\n+\tif err != nil {\n+\t\t// ErrStaleState\n+\t\t// TODO(dan): this should be retryable if it is the failover version that is stale","path":"service/history/chasm_engine.go","commit_id":"1d59e66d0ce5d91819f92c428ef5ab4c4efca1fb","original_commit_id":"59d749626d6a00c5fff76abe79a85eb627366521","user":{"login":"dandavison","id":52205,"node_id":"MDQ6VXNlcjUyMjA1","avatar_url":"https://avatars.githubusercontent.com/u/52205?v=4","gravatar_id":"","url":"https://api.github.com/users/dandavison","html_url":"https://github.com/dandavison","followers_url":"https://api.github.com/users/dandavison/followers","following_url":"https://api.github.com/users/dandavison/following{/other_user}","gists_url":"https://api.github.com/users/dandavison/gists{/gist_id}","starred_url":"https://api.github.com/users/dandavison/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/dandavison/subscriptions","organizations_url":"https://api.github.com/users/dandavison/orgs","repos_url":"https://api.github.com/users/dandavison/repos","events_url":"https://api.github.com/users/dandavison/events{/privacy}","received_events_url":"https://api.github.com/users/dandavison/received_events","type":"User","user_view_type":"public","site_admin":false},"body":"There's a ticket tracking this work; I've discussed it with @yycptt (but it's possible I described it inaccurately). If the comment is sufficiently accurate then we're done for this PR.","created_at":"2025-12-03T18:20:34Z","updated_at":"2025-12-04T02:13:23Z","html_url":"https://github.com/temporalio/temporal/pull/8563#discussion_r2586171338","pull_request_url":"https://api.github.com/repos/temporalio/temporal/pulls/8563","_links":{"self":{"href":"https://api.github.com/repos/temporalio/temporal/pulls/comments/2586171338"},"html":{"href":"https://github.com/temporalio/temporal/pull/8563#discussion_r2586171338"},"pull_request":{"href":"https://api.github.com/repos/temporalio/temporal/pulls/8563"}},"reactions":{"url":"https://api.github.com/repos/temporalio/temporal/pulls/comments/2586171338/reactions","total_count":0,"+1":0,"-1":0,"laugh":0,"hooray":0,"confused":0,"heart":0,"rocket":0,"eyes":0},"start_line":null,"original_start_line":null,"start_side":null,"line":354,"original_line":372,"side":"RIGHT","in_reply_to_id":2579118993,"author_association":"MEMBER","original_position":188,"position":166,"subject_type":"line"},{"url":"https://api.github.com/repos/temporalio/temporal/pulls/comments/2586271714","pull_request_review_id":3536180777,"id":2586271714,"node_id":"PRRC_kwDODNqesM6aJ1_i","diff_hunk":"@@ -187,9 +188,34 @@ func (t *TransactionImpl) UpdateWorkflowExecution(\n \t\t},\n \t\tisWorkflow,\n \t)\n+\n \tif persistence.OperationPossiblySucceeded(err) {\n \t\tNotifyWorkflowMutationTasks(engine, currentWorkflowMutation)\n \t\tNotifyWorkflowSnapshotTasks(engine, newWorkflowSnapshot)\n+\n+\t\tif persistence.OperationPossiblySucceeded(err) {\n+\t\t\tNotifyWorkflowMutationTasks(engine, currentWorkflowMutation)\n+\t\t\tNotifyWorkflowSnapshotTasks(engine, newWorkflowSnapshot)\n+\n+\t\t\t// Notify for current workflow if it has CHASM updates\n+\t\t\tif len(currentWorkflowMutation.UpsertChasmNodes) > 0 ||\n+\t\t\t\tlen(currentWorkflowMutation.DeleteChasmNodes) > 0 {\n+\t\t\t\tengine.NotifyChasmExecution(chasm.EntityKey{\n+\t\t\t\t\tNamespaceID: currentWorkflowMutation.ExecutionInfo.NamespaceId,\n+\t\t\t\t\tBusinessID:  currentWorkflowMutation.ExecutionInfo.WorkflowId,\n+\t\t\t\t\tEntityID:    currentWorkflowMutation.ExecutionState.RunId,\n+\t\t\t\t}, nil)\n+\t\t\t}\n+\n+\t\t\t// Notify for new workflow if it has CHASM nodes\n+\t\t\tif newWorkflowSnapshot != nil && len(newWorkflowSnapshot.ChasmNodes) > 0 {\n+\t\t\t\tengine.NotifyChasmExecution(chasm.EntityKey{\n+\t\t\t\t\tNamespaceID: newWorkflowSnapshot.ExecutionInfo.NamespaceId,\n+\t\t\t\t\tBusinessID:  newWorkflowSnapshot.ExecutionInfo.WorkflowId,\n+\t\t\t\t\tEntityID:    newWorkflowSnapshot.ExecutionState.RunId,\n+\t\t\t\t}, nil)\n+\t\t\t}\n+\t\t}","path":"service/history/workflow/transaction_impl.go","commit_id":"1d59e66d0ce5d91819f92c428ef5ab4c4efca1fb","original_commit_id":"e95ab0ad0ba0c42c1e0e125042367ada0583ea76","user":{"login":"dandavison","id":52205,"node_id":"MDQ6VXNlcjUyMjA1","avatar_url":"https://avatars.githubusercontent.com/u/52205?v=4","gravatar_id":"","url":"https://api.github.com/users/dandavison","html_url":"https://github.com/dandavison","followers_url":"https://api.github.com/users/dandavison/followers","following_url":"https://api.github.com/users/dandavison/following{/other_user}","gists_url":"https://api.github.com/users/dandavison/gists{/gist_id}","starred_url":"https://api.github.com/users/dandavison/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/dandavison/subscriptions","organizations_url":"https://api.github.com/users/dandavison/orgs","repos_url":"https://api.github.com/users/dandavison/repos","events_url":"https://api.github.com/users/dandavison/events{/privacy}","received_events_url":"https://api.github.com/users/dandavison/received_events","type":"User","user_view_type":"public","site_admin":false},"body":"stale","created_at":"2025-12-03T18:58:44Z","updated_at":"2025-12-04T02:13:23Z","html_url":"https://github.com/temporalio/temporal/pull/8563#discussion_r2586271714","pull_request_url":"https://api.github.com/repos/temporalio/temporal/pulls/8563","_links":{"self":{"href":"https://api.github.com/repos/temporalio/temporal/pulls/comments/2586271714"},"html":{"href":"https://github.com/temporalio/temporal/pull/8563#discussion_r2586271714"},"pull_request":{"href":"https://api.github.com/repos/temporalio/temporal/pulls/8563"}},"reactions":{"url":"https://api.github.com/repos/temporalio/temporal/pulls/comments/2586271714/reactions","total_count":0,"+1":0,"-1":0,"laugh":0,"hooray":0,"confused":0,"heart":0,"rocket":0,"eyes":0},"start_line":null,"original_start_line":null,"start_side":null,"line":214,"original_line":218,"side":"RIGHT","in_reply_to_id":2557405619,"author_association":"MEMBER","original_position":39,"position":32,"subject_type":"line"},{"url":"https://api.github.com/repos/temporalio/temporal/pulls/comments/2586302053","pull_request_review_id":3536180777,"id":2586302053,"node_id":"PRRC_kwDODNqesM6aJ9Zl","diff_hunk":"@@ -314,3 +315,145 @@ func (a *Activity) RecordHeartbeat(ctx chasm.MutableContext, details *commonpb.P\n \t})\n \treturn nil, nil\n }\n+\n+func (a *Activity) buildActivityExecutionInfo(ctx chasm.Context) (*activity.ActivityExecutionInfo, error) {\n+\tif a.ActivityState == nil {\n+\t\treturn nil, errors.New(\"activity state is nil\")","path":"chasm/lib/activity/activity.go","commit_id":"37c5f7fa3194434813e3df63aa07231df81d239b","original_commit_id":"59d749626d6a00c5fff76abe79a85eb627366521","user":{"login":"dandavison","id":52205,"node_id":"MDQ6VXNlcjUyMjA1","avatar_url":"https://avatars.githubusercontent.com/u/52205?v=4","gravatar_id":"","url":"https://api.github.com/users/dandavison","html_url":"https://github.com/dandavison","followers_url":"https://api.github.com/users/dandavison/followers","following_url":"https://api.github.com/users/dandavison/following{/other_user}","gists_url":"https://api.github.com/users/dandavison/gists{/gist_id}","starred_url":"https://api.github.com/users/dandavison/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/dandavison/subscriptions","organizations_url":"https://api.github.com/users/dandavison/orgs","repos_url":"https://api.github.com/users/dandavison/repos","events_url":"https://api.github.com/users/dandavison/events{/privacy}","received_events_url":"https://api.github.com/users/dandavison/received_events","type":"User","user_view_type":"public","site_admin":false},"body":"Thanks, that shouldn't have been there.","created_at":"2025-12-03T19:09:40Z","updated_at":"2025-12-04T02:13:23Z","html_url":"https://github.com/temporalio/temporal/pull/8563#discussion_r2586302053","pull_request_url":"https://api.github.com/repos/temporalio/temporal/pulls/8563","_links":{"self":{"href":"https://api.github.com/repos/temporalio/temporal/pulls/comments/2586302053"},"html":{"href":"https://github.com/temporalio/temporal/pull/8563#discussion_r2586302053"},"pull_request":{"href":"https://api.github.com/repos/temporalio/temporal/pulls/8563"}},"reactions":{"url":"https://api.github.com/repos/temporalio/temporal/pulls/comments/2586302053/reactions","total_count":0,"+1":0,"-1":0,"laugh":0,"hooray":0,"confused":0,"heart":0,"rocket":0,"eyes":0},"start_line":null,"original_start_line":null,"start_side":null,"line":null,"original_line":321,"side":"RIGHT","in_reply_to_id":2578224109,"author_association":"MEMBER","original_position":40,"position":1,"subject_type":"line"},{"url":"https://api.github.com/repos/temporalio/temporal/pulls/comments/2586396488","pull_request_review_id":3536180777,"id":2586396488,"node_id":"PRRC_kwDODNqesM6aKUdI","diff_hunk":"@@ -131,6 +131,9 @@ func (r *ComponentRef) Serialize(\n // DeserializeComponentRef deserializes a byte slice into a ComponentRef.\n // Provides caller the access to information including EntityKey, Archetype, and ShardingKey.\n func DeserializeComponentRef(data []byte) (ComponentRef, error) {\n+\tif len(data) == 0 {","path":"chasm/ref.go","commit_id":"1d59e66d0ce5d91819f92c428ef5ab4c4efca1fb","original_commit_id":"59d749626d6a00c5fff76abe79a85eb627366521","user":{"login":"dandavison","id":52205,"node_id":"MDQ6VXNlcjUyMjA1","avatar_url":"https://avatars.githubusercontent.com/u/52205?v=4","gravatar_id":"","url":"https://api.github.com/users/dandavison","html_url":"https://github.com/dandavison","followers_url":"https://api.github.com/users/dandavison/followers","following_url":"https://api.github.com/users/dandavison/following{/other_user}","gists_url":"https://api.github.com/users/dandavison/gists{/gist_id}","starred_url":"https://api.github.com/users/dandavison/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/dandavison/subscriptions","organizations_url":"https://api.github.com/users/dandavison/orgs","repos_url":"https://api.github.com/users/dandavison/repos","events_url":"https://api.github.com/users/dandavison/events{/privacy}","received_events_url":"https://api.github.com/users/dandavison/received_events","type":"User","user_view_type":"public","site_admin":false},"body":"Done. Please see 542313b38","created_at":"2025-12-03T19:44:38Z","updated_at":"2025-12-04T02:13:23Z","html_url":"https://github.com/temporalio/temporal/pull/8563#discussion_r2586396488","pull_request_url":"https://api.github.com/repos/temporalio/temporal/pulls/8563","_links":{"self":{"href":"https://api.github.com/repos/temporalio/temporal/pulls/comments/2586396488"},"html":{"href":"https://github.com/temporalio/temporal/pull/8563#discussion_r2586396488"},"pull_request":{"href":"https://api.github.com/repos/temporalio/temporal/pulls/8563"}},"reactions":{"url":"https://api.github.com/repos/temporalio/temporal/pulls/comments/2586396488/reactions","total_count":0,"+1":0,"-1":0,"laugh":0,"hooray":0,"confused":0,"heart":0,"rocket":0,"eyes":0},"start_line":null,"original_start_line":null,"start_side":null,"line":138,"original_line":134,"side":"RIGHT","in_reply_to_id":2578233172,"author_association":"MEMBER","original_position":23,"position":21,"subject_type":"line"},{"url":"https://api.github.com/repos/temporalio/temporal/pulls/comments/2586415480","pull_request_review_id":3536675842,"id":2586415480,"node_id":"PRRC_kwDODNqesM6aKZF4","diff_hunk":"@@ -131,12 +136,19 @@ func (r *ComponentRef) Serialize(\n // DeserializeComponentRef deserializes a byte slice into a ComponentRef.\n // Provides caller the access to information including EntityKey, Archetype, and ShardingKey.\n func DeserializeComponentRef(data []byte) (ComponentRef, error) {\n+\tif len(data) == 0 {\n+\t\treturn ComponentRef{}, ErrInvalidComponentRef\n+\t}\n \tvar pRef persistencespb.ChasmComponentRef\n \tif err := pRef.Unmarshal(data); err != nil {\n \t\treturn ComponentRef{}, err\n \t}\n \n-\treturn ProtoRefToComponentRef(&pRef), nil\n+\tref := ProtoRefToComponentRef(&pRef)","path":"chasm/ref.go","commit_id":"1d59e66d0ce5d91819f92c428ef5ab4c4efca1fb","original_commit_id":"542313b38e46b86f6f8db1f0e42aba8e551609c9","user":{"login":"cursor[bot]","id":206951365,"node_id":"BOT_kgDODFXTxQ","avatar_url":"https://avatars.githubusercontent.com/in/1210556?v=4","gravatar_id":"","url":"https://api.github.com/users/cursor%5Bbot%5D","html_url":"https://github.com/apps/cursor","followers_url":"https://api.github.com/users/cursor%5Bbot%5D/followers","following_url":"https://api.github.com/users/cursor%5Bbot%5D/following{/other_user}","gists_url":"https://api.github.com/users/cursor%5Bbot%5D/gists{/gist_id}","starred_url":"https://api.github.com/users/cursor%5Bbot%5D/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/cursor%5Bbot%5D/subscriptions","organizations_url":"https://api.github.com/users/cursor%5Bbot%5D/orgs","repos_url":"https://api.github.com/users/cursor%5Bbot%5D/repos","events_url":"https://api.github.com/users/cursor%5Bbot%5D/events{/privacy}","received_events_url":"https://api.github.com/users/cursor%5Bbot%5D/received_events","type":"Bot","user_view_type":"public","site_admin":false},"body":"### Bug: Unmarshal error not wrapped as ErrMalformedComponentRef\n\n<!-- **Medium Severity** -->\n\n<!-- DESCRIPTION START -->\nWhen `pRef.Unmarshal(data)` fails in `DeserializeComponentRef`, the raw protobuf error is returned instead of wrapping it with `ErrMalformedComponentRef`. In `handler.go`, the check `errors.Is(err, chasm.ErrMalformedComponentRef)` will never match for actual malformed tokens, causing users to receive an internal error instead of the intended \"invalid long poll token\" user-facing error. The error should be wrapped, e.g., `return ComponentRef{}, fmt.Errorf(\"%w: %v\", ErrMalformedComponentRef, err)`.\n<!-- DESCRIPTION END -->\n\n<!-- LOCATIONS START\nchasm/ref.go#L142-L144\nchasm/lib/activity/handler.go#L122-L124\nLOCATIONS END -->\n<details>\n<summary>Additional Locations (1)</summary>\n\n- [`chasm/lib/activity/handler.go#L122-L124`](https://github.com/temporalio/temporal/blob/542313b38e46b86f6f8db1f0e42aba8e551609c9/chasm/lib/activity/handler.go#L122-L124)\n\n</details>\n\n<a href=\"https://cursor.com/open?data=eyJhbGciOiJSUzI1NiIsInR5cCI6IkpXVCIsImtpZCI6ImJ1Z2JvdC12MSJ9.eyJ2ZXJzaW9uIjoxLCJ0eXBlIjoiQlVHQk9UX0ZJWF9JTl9DVVJTT1IiLCJkYXRhIjp7InJlZGlzS2V5IjoiYnVnYm90OmZjZGRhMTY0LWVlNTItNDc4Ni05MzM1LTJmYmVjYmZjN2M2YyIsImVuY3J5cHRpb25LZXkiOiJja2FhZTUtYTlpd1RhbVRvZnA1ck1ZTWluelY4NE5IV2NxNkxWanJZc0tZIiwiYnJhbmNoIjoicG9sbC1jb21wb25lbnQifSwiaWF0IjoxNzY0NzkxNTA0LCJleHAiOjE3NjUzOTYzMDR9.KAnwYDJlcFwzAbEjxpg7KPE1hTjkU7p_rXJEO8LhKa1n86HMiP6CA7GsTwQ7v8l8bKf6FxrHWgvkaonbHHy_304d_CRmuEPhJnKJqQfLlDBhL_QmTUXeanFkicm9Iez5diWc5kC8XRc2fzwiabrHjTKDeu6UDb-Nhs5r79uYGpECj_WaY686Qy7hC25XzcG_N_qAIJ5IZHGUaEFn0LbkN0QlmL1TvCa2QGQ-qQcfr05tpPKeP2pbfW2ekoR0NHjeQjq4Hzb8B1SkIu4a6-IA47lcW7Y6PJ3m9Z-Gk1iLh98o4PL1J_jPv_sxLM5qp6gxT2Xg_EQUraPRHAou8OKJyA\"><picture><source media=\"(prefers-color-scheme: dark)\" srcset=\"https://cursor.com/fix-in-cursor-dark.svg\"><source media=\"(prefers-color-scheme: light)\" srcset=\"https://cursor.com/fix-in-cursor-light.svg\"><img alt=\"Fix in Cursor\" src=\"https://cursor.com/fix-in-cursor.svg\"></picture></a>&nbsp;<a href=\"https://cursor.com/agents?data=eyJhbGciOiJSUzI1NiIsInR5cCI6IkpXVCIsImtpZCI6ImJ1Z2JvdC12MSJ9.eyJ2ZXJzaW9uIjoxLCJ0eXBlIjoiQlVHQk9UX0ZJWF9JTl9XRUIiLCJkYXRhIjp7InJlZGlzS2V5IjoiYnVnYm90OmZjZGRhMTY0LWVlNTItNDc4Ni05MzM1LTJmYmVjYmZjN2M2YyIsImVuY3J5cHRpb25LZXkiOiJja2FhZTUtYTlpd1RhbVRvZnA1ck1ZTWluelY4NE5IV2NxNkxWanJZc0tZIiwiYnJhbmNoIjoicG9sbC1jb21wb25lbnQiLCJyZXBvT3duZXIiOiJ0ZW1wb3JhbGlvIiwicmVwb05hbWUiOiJ0ZW1wb3JhbCIsInByTnVtYmVyIjo4NTYzLCJjb21taXRTaGEiOiI1NDIzMTNiMzhlNDZiODZmNmY4ZGIxZjBlNDJhYmE4ZTU1MTYwOWM5IiwicHJvdmlkZXIiOiJnaXRodWIifSwiaWF0IjoxNzY0NzkxNTA0LCJleHAiOjE3NjUzOTYzMDR9.neHrGNAjP0iJQaej8D8XhQqYQ9_MnC18UCwWh6lyx8Q0h3SHWpdSYS9_Y5MMZTgeOii-IlSvzzbU5CxOqsLRQapCTHImeDkDoDQdFe5OSoS6T1ImL0cbVfWckNMbENqzCLj6V_NRSFBlKNSWOBqjxD6t44HljmoNfXN35HPOUeCazsTSknVU5pN5mCfu49sfPltbk9GzWYf9tndEkgsFq3yjnOGXzCaJw7SnTUzWxB0K77Nn7NN1WVAADpfRqNUBzKRzGRDnexO_c5mKR0P0Qia3zADeVVAg8k3i8ZQ1KHSld3rE4fgUh4UkrgPhlxW-TBqMGw1BftLPmvgiZfZArw\"><picture><source media=\"(prefers-color-scheme: dark)\" srcset=\"https://cursor.com/fix-in-web-dark.svg\"><source media=\"(prefers-color-scheme: light)\" srcset=\"https://cursor.com/fix-in-web-light.svg\"><img alt=\"Fix in Web\" src=\"https://cursor.com/fix-in-web.svg\"></picture></a>\n\n","created_at":"2025-12-03T19:51:45Z","updated_at":"2025-12-03T19:51:45Z","html_url":"https://github.com/temporalio/temporal/pull/8563#discussion_r2586415480","pull_request_url":"https://api.github.com/repos/temporalio/temporal/pulls/8563","_links":{"self":{"href":"https://api.github.com/repos/temporalio/temporal/pulls/comments/2586415480"},"html":{"href":"https://github.com/temporalio/temporal/pull/8563#discussion_r2586415480"},"pull_request":{"href":"https://api.github.com/repos/temporalio/temporal/pulls/8563"}},"reactions":{"url":"https://api.github.com/repos/temporalio/temporal/pulls/comments/2586415480/reactions","total_count":0,"+1":0,"-1":0,"laugh":0,"hooray":0,"confused":0,"heart":0,"rocket":0,"eyes":0},"start_line":null,"original_start_line":null,"start_side":null,"line":146,"original_line":147,"side":"RIGHT","author_association":"NONE","original_position":37,"position":31,"subject_type":"line"},{"url":"https://api.github.com/repos/temporalio/temporal/pulls/comments/2586415486","pull_request_review_id":3536675842,"id":2586415486,"node_id":"PRRC_kwDODNqesM6aKZF-","diff_hunk":"@@ -241,14 +256,126 @@ func (e *ChasmEngine) ReadComponent(\n \treturn readFn(chasmContext, component)\n }\n \n+// PollComponent waits until the supplied predicate is satisfied when evaluated against the\n+// component identified by the supplied component reference. If there is no error, it returns (ref,\n+// nil) where ref is a component reference identifying the state at which the predicate was\n+// satisfied. The predicate must be monotonic: if it returns true at execution state transition s it\n+// must return true at all transitions t > s. It is an error if execution transition history is\n+// (after reloading from persistence) behind the requested ref, or if the ref is inconsistent with\n+// execution transition history. Thus when the predicate function is evaluated, it is guaranteed\n+// that the execution VT >= requestRef VT. opts are currently ignored.\n func (e *ChasmEngine) PollComponent(\n \tctx context.Context,\n-\tentityRef chasm.ComponentRef,\n-\tpredicateFn func(chasm.Context, chasm.Component) (any, bool, error),\n-\toperationFn func(chasm.MutableContext, chasm.Component, any) error,\n+\trequestRef chasm.ComponentRef,\n+\tmonotonicPredicate func(chasm.Context, chasm.Component) (bool, error),\n \topts ...chasm.TransitionOption,\n-) (newEntityRef []byte, retError error) {\n-\treturn nil, serviceerror.NewUnimplemented(\"PollComponent is not yet supported\")\n+) (retRef []byte, retError error) {\n+\tdefer func() {\n+\t\tif errors.Is(retError, consts.ErrStaleState) {\n+\t\t\tretError = serviceerror.NewUnavailable(\"please retry\")\n+\t\t}\n+\t}()\n+\n+\t_, executionLease, err := e.getExecutionLease(ctx, requestRef)\n+\tif err != nil {\n+\t\t// E.g. requestRef VT inconsistent with execution VT ('stale reference')\n+\t\treturn nil, err\n+\t}\n+\tdefer executionLease.GetReleaseFn()(nil)\n+\n+\t// At this point it's possible that execution VT < requestRef VT (getExecutionLease does not\n+\t// guarantee that returned execution state is non-stale w.r.t. requestRef).\n+\tsatisfiedRef, err := e.predicateSatisfied(ctx, monotonicPredicate, requestRef, executionLease)\n+\tif err != nil {\n+\t\treturn nil, err\n+\t}\n+\t// execution VT >= requestRef VT (enforced by predicateSatisfied)\n+\n+\tif satisfiedRef != nil {\n+\t\t// wait condition was satisfied\n+\t\treturn satisfiedRef, nil\n+\t}\n+\n+\t// Wait condition not satisfied; long-poll\n+\n+\t// PollComponent subscribes to execution-level notifications. Suppose that an execution consists\n+\t// of one component A, and A has subcomponent B. Subscribers interested only in component B may\n+\t// be woken up unnecessarily (and thus evaluate the predicate unnecessarily) due to changes in\n+\t// parts of A that do not also belong to B.\n+\tch := e.notifier.Subscribe(requestRef.EntityKey)\n+\texecutionLease.GetReleaseFn()(nil)","path":"service/history/chasm_engine.go","commit_id":"372cc0a17931bd461ec03349b8509b57820e36c2","original_commit_id":"542313b38e46b86f6f8db1f0e42aba8e551609c9","user":{"login":"cursor[bot]","id":206951365,"node_id":"BOT_kgDODFXTxQ","avatar_url":"https://avatars.githubusercontent.com/in/1210556?v=4","gravatar_id":"","url":"https://api.github.com/users/cursor%5Bbot%5D","html_url":"https://github.com/apps/cursor","followers_url":"https://api.github.com/users/cursor%5Bbot%5D/followers","following_url":"https://api.github.com/users/cursor%5Bbot%5D/following{/other_user}","gists_url":"https://api.github.com/users/cursor%5Bbot%5D/gists{/gist_id}","starred_url":"https://api.github.com/users/cursor%5Bbot%5D/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/cursor%5Bbot%5D/subscriptions","organizations_url":"https://api.github.com/users/cursor%5Bbot%5D/orgs","repos_url":"https://api.github.com/users/cursor%5Bbot%5D/repos","events_url":"https://api.github.com/users/cursor%5Bbot%5D/events{/privacy}","received_events_url":"https://api.github.com/users/cursor%5Bbot%5D/received_events","type":"Bot","user_view_type":"public","site_admin":false},"body":"### Bug: Double-release of execution lease in PollComponent\n\n<!-- **High Severity** -->\n\n<!-- DESCRIPTION START -->\nIn `PollComponent`, the first execution lease is released twice. A deferred release is registered at line 284 for the first lease. Then before entering the long-poll loop, the same lease is explicitly released at line 306. Inside the loop, a new `executionLease` variable shadows the outer one (using `:=` at line 314), but the outer defer still holds the release function of the first lease. When the function returns from inside the loop, the outer defer fires and attempts to release the first lease again. This double-release could cause issues if the release function decrements a reference count or is not idempotent.\n<!-- DESCRIPTION END -->\n\n<!-- LOCATIONS START\nservice/history/chasm_engine.go#L283-L306\nLOCATIONS END -->\n<a href=\"https://cursor.com/open?data=eyJhbGciOiJSUzI1NiIsInR5cCI6IkpXVCIsImtpZCI6ImJ1Z2JvdC12MSJ9.eyJ2ZXJzaW9uIjoxLCJ0eXBlIjoiQlVHQk9UX0ZJWF9JTl9DVVJTT1IiLCJkYXRhIjp7InJlZGlzS2V5IjoiYnVnYm90OjRhNWYxYWE0LWQxYjktNDM1Yi05MmEyLWYzNTg0NWQxNmJiOCIsImVuY3J5cHRpb25LZXkiOiJNa2MwSzVURFVFbzVLc2xPcUJ1RmdJeVZ6clhDM2pVeUlYN3BVT1pCR1M0IiwiYnJhbmNoIjoicG9sbC1jb21wb25lbnQifSwiaWF0IjoxNzY0NzkxNTA0LCJleHAiOjE3NjUzOTYzMDR9.Cbvn4OWS-FpZfhKqMfz-14tgHrUElHVsBdw9G40Sn29GeXO2z4yShdkvpIiO7f8dZFdT0ORecoABA29KapF8m5uagZSOx9oOsSxWRt4thvwTMoeIGvSj6aOrfzw5LzRxvTixzS3kY4tOzEyOV_FT_JkgQuQRNJAqbolRUPxcG1mSLvXHDktXuBhXl_tr-1S3A1KZFl7tr3AT8CEc5tUWPeGqLIQpd57XVhm2VagCXMx11gOA21qrlQ_GbOTlPnrrPuFTeYKO8hP3ipBl1gQrzlq4SEODaqXLhg_qYmfwV6cAjk4Cg_GDhBDxRFKJmf-7zGeqanO_S7-D9Ddu3VdmIw\"><picture><source media=\"(prefers-color-scheme: dark)\" srcset=\"https://cursor.com/fix-in-cursor-dark.svg\"><source media=\"(prefers-color-scheme: light)\" srcset=\"https://cursor.com/fix-in-cursor-light.svg\"><img alt=\"Fix in Cursor\" src=\"https://cursor.com/fix-in-cursor.svg\"></picture></a>&nbsp;<a href=\"https://cursor.com/agents?data=eyJhbGciOiJSUzI1NiIsInR5cCI6IkpXVCIsImtpZCI6ImJ1Z2JvdC12MSJ9.eyJ2ZXJzaW9uIjoxLCJ0eXBlIjoiQlVHQk9UX0ZJWF9JTl9XRUIiLCJkYXRhIjp7InJlZGlzS2V5IjoiYnVnYm90OjRhNWYxYWE0LWQxYjktNDM1Yi05MmEyLWYzNTg0NWQxNmJiOCIsImVuY3J5cHRpb25LZXkiOiJNa2MwSzVURFVFbzVLc2xPcUJ1RmdJeVZ6clhDM2pVeUlYN3BVT1pCR1M0IiwiYnJhbmNoIjoicG9sbC1jb21wb25lbnQiLCJyZXBvT3duZXIiOiJ0ZW1wb3JhbGlvIiwicmVwb05hbWUiOiJ0ZW1wb3JhbCIsInByTnVtYmVyIjo4NTYzLCJjb21taXRTaGEiOiI1NDIzMTNiMzhlNDZiODZmNmY4ZGIxZjBlNDJhYmE4ZTU1MTYwOWM5IiwicHJvdmlkZXIiOiJnaXRodWIifSwiaWF0IjoxNzY0NzkxNTA0LCJleHAiOjE3NjUzOTYzMDR9.KoFrF4ZYBYBKArLsAokRQ7lYqiQ03E6M0nc0SwDKeQNRRJscvvsZ5bUjiSaAQD_CJm0rer5Tzlj6iR1YYMrAviYxy-QGzbu7CrZurCV3fj2m8Myaeg_r5mQg2I9He-B-M1xdPiRV8IPY3OXqDgeaguP14KJi4EiTcxcYKn6Ht5cUqV90n0fhyF8eMXV4CngAC4rPBgemdFLGI-cdnI8CKelB6YZmx1zpatJm2YC07-uSKe3vnrRDAaDONFVVLvM-hZ37axXgSVUYP8I9gO7aV94GTcIkW1g42Qa3Vhx4IA9rMUAW5hU5WtgRuLmG2zI1TgVexsgXVzfrN19qiNR5sQ\"><picture><source media=\"(prefers-color-scheme: dark)\" srcset=\"https://cursor.com/fix-in-web-dark.svg\"><source media=\"(prefers-color-scheme: light)\" srcset=\"https://cursor.com/fix-in-web-light.svg\"><img alt=\"Fix in Web\" src=\"https://cursor.com/fix-in-web.svg\"></picture></a>\n\n","created_at":"2025-12-03T19:51:45Z","updated_at":"2025-12-03T19:51:45Z","html_url":"https://github.com/temporalio/temporal/pull/8563#discussion_r2586415486","pull_request_url":"https://api.github.com/repos/temporalio/temporal/pulls/8563","_links":{"self":{"href":"https://api.github.com/repos/temporalio/temporal/pulls/comments/2586415486"},"html":{"href":"https://github.com/temporalio/temporal/pull/8563#discussion_r2586415486"},"pull_request":{"href":"https://api.github.com/repos/temporalio/temporal/pulls/8563"}},"reactions":{"url":"https://api.github.com/repos/temporalio/temporal/pulls/comments/2586415486/reactions","total_count":0,"+1":0,"-1":0,"laugh":0,"hooray":0,"confused":0,"heart":0,"rocket":0,"eyes":0},"start_line":null,"original_start_line":null,"start_side":null,"line":null,"original_line":306,"side":"RIGHT","author_association":"NONE","original_position":122,"position":1,"subject_type":"line"},{"url":"https://api.github.com/repos/temporalio/temporal/pulls/comments/2586594640","pull_request_review_id":3536908990,"id":2586594640,"node_id":"PRRC_kwDODNqesM6aLE1Q","diff_hunk":"@@ -131,12 +136,19 @@ func (r *ComponentRef) Serialize(\n // DeserializeComponentRef deserializes a byte slice into a ComponentRef.\n // Provides caller the access to information including EntityKey, Archetype, and ShardingKey.\n func DeserializeComponentRef(data []byte) (ComponentRef, error) {\n+\tif len(data) == 0 {\n+\t\treturn ComponentRef{}, ErrInvalidComponentRef\n+\t}\n \tvar pRef persistencespb.ChasmComponentRef\n \tif err := pRef.Unmarshal(data); err != nil {\n \t\treturn ComponentRef{}, err\n \t}\n \n-\treturn ProtoRefToComponentRef(&pRef), nil\n+\tref := ProtoRefToComponentRef(&pRef)","path":"chasm/ref.go","commit_id":"1d59e66d0ce5d91819f92c428ef5ab4c4efca1fb","original_commit_id":"372cc0a17931bd461ec03349b8509b57820e36c2","user":{"login":"cursor[bot]","id":206951365,"node_id":"BOT_kgDODFXTxQ","avatar_url":"https://avatars.githubusercontent.com/in/1210556?v=4","gravatar_id":"","url":"https://api.github.com/users/cursor%5Bbot%5D","html_url":"https://github.com/apps/cursor","followers_url":"https://api.github.com/users/cursor%5Bbot%5D/followers","following_url":"https://api.github.com/users/cursor%5Bbot%5D/following{/other_user}","gists_url":"https://api.github.com/users/cursor%5Bbot%5D/gists{/gist_id}","starred_url":"https://api.github.com/users/cursor%5Bbot%5D/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/cursor%5Bbot%5D/subscriptions","organizations_url":"https://api.github.com/users/cursor%5Bbot%5D/orgs","repos_url":"https://api.github.com/users/cursor%5Bbot%5D/repos","events_url":"https://api.github.com/users/cursor%5Bbot%5D/events{/privacy}","received_events_url":"https://api.github.com/users/cursor%5Bbot%5D/received_events","type":"Bot","user_view_type":"public","site_admin":false},"body":"### Bug: Malformed component ref error never returned, check fails\n\n<!-- **Medium Severity** -->\n\n<!-- DESCRIPTION START -->\n`DeserializeComponentRef` returns the raw protobuf unmarshal error when deserialization fails, but `ErrMalformedComponentRef` is never actually used. In `handler.go`, the check `errors.Is(err, chasm.ErrMalformedComponentRef)` will never match because the error from `pRef.Unmarshal()` is not wrapped with `ErrMalformedComponentRef`. This causes malformed long poll tokens to produce generic errors instead of the intended \"invalid long poll token\" message.\n<!-- DESCRIPTION END -->\n\n<!-- LOCATIONS START\nchasm/ref.go#L142-L144\nchasm/lib/activity/handler.go#L122-L124\nLOCATIONS END -->\n<details>\n<summary>Additional Locations (1)</summary>\n\n- [`chasm/lib/activity/handler.go#L122-L124`](https://github.com/temporalio/temporal/blob/372cc0a17931bd461ec03349b8509b57820e36c2/chasm/lib/activity/handler.go#L122-L124)\n\n</details>\n\n<a href=\"https://cursor.com/open?data=eyJhbGciOiJSUzI1NiIsInR5cCI6IkpXVCIsImtpZCI6ImJ1Z2JvdC12MSJ9.eyJ2ZXJzaW9uIjoxLCJ0eXBlIjoiQlVHQk9UX0ZJWF9JTl9DVVJTT1IiLCJkYXRhIjp7InJlZGlzS2V5IjoiYnVnYm90OjUwNzc0MzE3LTAzNDAtNGFjNC1iNDg5LTYyMTgwNTIxZTlhOSIsImVuY3J5cHRpb25LZXkiOiJyZlBkOENHc0JteHRYV2ZFNFdRakNMbEhHQWVfa0lXRTRVTklPZkd1ZXpBIiwiYnJhbmNoIjoicG9sbC1jb21wb25lbnQifSwiaWF0IjoxNzY0Nzk1NTc4LCJleHAiOjE3NjU0MDAzNzh9.JnihQheZlhhaUwWV3xyDgEaGSX5s3hCRKN5i7AHjO_YcZbA5djMlkOGwhCeOXdq9QPU-nQ4tcEKy5GwCpXvQhyBvw3NiMzWSpXi5V3-imFwJoSeE-9y-gtkXEkQR2TWD9l4pO9PfyePO9OQ3oTWrTem49WOofJ_qZVvhNXtodIdUizYpYWp5GEQ1UnT_lFzwDrufzvLm4mkJGjvRurBGiwp5pMwqIt1d16PCAJqYmBFJf93ePt-EnnAeo7zbx0ZqQNi_hkUMECojA4534qVlBd9EUyMC4S09X6_gyqHz__JQV2CDz-JAfVG2qBd_ea2vl7Y0K9JP5-ol426VY3fFbQ\"><picture><source media=\"(prefers-color-scheme: dark)\" srcset=\"https://cursor.com/fix-in-cursor-dark.svg\"><source media=\"(prefers-color-scheme: light)\" srcset=\"https://cursor.com/fix-in-cursor-light.svg\"><img alt=\"Fix in Cursor\" src=\"https://cursor.com/fix-in-cursor.svg\"></picture></a>&nbsp;<a href=\"https://cursor.com/agents?data=eyJhbGciOiJSUzI1NiIsInR5cCI6IkpXVCIsImtpZCI6ImJ1Z2JvdC12MSJ9.eyJ2ZXJzaW9uIjoxLCJ0eXBlIjoiQlVHQk9UX0ZJWF9JTl9XRUIiLCJkYXRhIjp7InJlZGlzS2V5IjoiYnVnYm90OjUwNzc0MzE3LTAzNDAtNGFjNC1iNDg5LTYyMTgwNTIxZTlhOSIsImVuY3J5cHRpb25LZXkiOiJyZlBkOENHc0JteHRYV2ZFNFdRakNMbEhHQWVfa0lXRTRVTklPZkd1ZXpBIiwiYnJhbmNoIjoicG9sbC1jb21wb25lbnQiLCJyZXBvT3duZXIiOiJ0ZW1wb3JhbGlvIiwicmVwb05hbWUiOiJ0ZW1wb3JhbCIsInByTnVtYmVyIjo4NTYzLCJjb21taXRTaGEiOiIzNzJjYzBhMTc5MzFiZDQ2MWVjMDMzNDliODUwOWI1NzgyMGUzNmMyIiwicHJvdmlkZXIiOiJnaXRodWIifSwiaWF0IjoxNzY0Nzk1NTc4LCJleHAiOjE3NjU0MDAzNzh9.jWNIyyj3SI1OzidVtYxFSvzl4YdqFj-y32yp4gcefti1zkdePzsLJMYypuZazJOfndo81cc6OZY33TX8ZqvyiOo1UE7C53282zCBqsF6ey0sM6MgASnMCT3BaoqxofffNLG-Fs7u7DNfm5SwAXBPnMN4VMxX77EHaaXVzUvIiToxC8Jf050Ko3Ot1a7iBcMUMy7kpmVLIHAmo3U0yugkNQs26pxuzP3GVBqv1qGpJci5KSD7b3wSoT3pAGswZsssJKmDpyXbOd9UrSPnZ_5fRGkGxcms7uQQ66cJ56RZ4L-VcZ0BdQud6z4Th47MNPubX87KkSn5V2Pg7Pyrsmx5Dg\"><picture><source media=\"(prefers-color-scheme: dark)\" srcset=\"https://cursor.com/fix-in-web-dark.svg\"><source media=\"(prefers-color-scheme: light)\" srcset=\"https://cursor.com/fix-in-web-light.svg\"><img alt=\"Fix in Web\" src=\"https://cursor.com/fix-in-web.svg\"></picture></a>\n\n","created_at":"2025-12-03T20:59:38Z","updated_at":"2025-12-03T20:59:39Z","html_url":"https://github.com/temporalio/temporal/pull/8563#discussion_r2586594640","pull_request_url":"https://api.github.com/repos/temporalio/temporal/pulls/8563","_links":{"self":{"href":"https://api.github.com/repos/temporalio/temporal/pulls/comments/2586594640"},"html":{"href":"https://github.com/temporalio/temporal/pull/8563#discussion_r2586594640"},"pull_request":{"href":"https://api.github.com/repos/temporalio/temporal/pulls/8563"}},"reactions":{"url":"https://api.github.com/repos/temporalio/temporal/pulls/comments/2586594640/reactions","total_count":0,"+1":0,"-1":0,"laugh":0,"hooray":0,"confused":0,"heart":0,"rocket":0,"eyes":0},"start_line":null,"original_start_line":null,"start_side":null,"line":146,"original_line":147,"side":"RIGHT","author_association":"NONE","original_position":37,"position":31,"subject_type":"line"},{"url":"https://api.github.com/repos/temporalio/temporal/pulls/comments/2586897490","pull_request_review_id":3536180777,"id":2586897490,"node_id":"PRRC_kwDODNqesM6aMOxS","diff_hunk":"@@ -241,14 +256,126 @@ func (e *ChasmEngine) ReadComponent(\n \treturn readFn(chasmContext, component)\n }\n \n+// PollComponent waits until the supplied predicate is satisfied when evaluated against the\n+// component identified by the supplied component reference. If there is no error, it returns (ref,\n+// nil) where ref is a component reference identifying the state at which the predicate was\n+// satisfied. The predicate must be monotonic: if it returns true at execution state transition s it\n+// must return true at all transitions t > s. It is an error if execution transition history is\n+// (after reloading from persistence) behind the requested ref, or if the ref is inconsistent with\n+// execution transition history. Thus when the predicate function is evaluated, it is guaranteed\n+// that the execution VT >= requestRef VT. opts are currently ignored.\n func (e *ChasmEngine) PollComponent(\n \tctx context.Context,\n-\tentityRef chasm.ComponentRef,\n-\tpredicateFn func(chasm.Context, chasm.Component) (any, bool, error),\n-\toperationFn func(chasm.MutableContext, chasm.Component, any) error,\n+\trequestRef chasm.ComponentRef,\n+\tmonotonicPredicate func(chasm.Context, chasm.Component) (bool, error),\n \topts ...chasm.TransitionOption,\n-) (newEntityRef []byte, retError error) {\n-\treturn nil, serviceerror.NewUnimplemented(\"PollComponent is not yet supported\")\n+) (retRef []byte, retError error) {\n+\tdefer func() {\n+\t\tif errors.Is(retError, consts.ErrStaleState) {\n+\t\t\tretError = serviceerror.NewUnavailable(\"please retry\")\n+\t\t}\n+\t}()\n+\n+\t_, executionLease, err := e.getExecutionLease(ctx, requestRef)\n+\tif err != nil {\n+\t\t// E.g. requestRef VT inconsistent with execution VT ('stale reference')\n+\t\treturn nil, err\n+\t}\n+\tdefer executionLease.GetReleaseFn()(nil)\n+\n+\t// At this point it's possible that execution VT < requestRef VT (getExecutionLease does not\n+\t// guarantee that returned execution state is non-stale w.r.t. requestRef).\n+\tsatisfiedRef, err := e.predicateSatisfied(ctx, monotonicPredicate, requestRef, executionLease)\n+\tif err != nil {\n+\t\treturn nil, err\n+\t}\n+\t// execution VT >= requestRef VT (enforced by predicateSatisfied)\n+\n+\tif satisfiedRef != nil {\n+\t\t// wait condition was satisfied\n+\t\treturn satisfiedRef, nil\n+\t}\n+\n+\t// Wait condition not satisfied; long-poll\n+\n+\t// PollComponent subscribes to execution-level notifications. Suppose that an execution consists\n+\t// of one component A, and A has subcomponent B. Subscribers interested only in component B may\n+\t// be woken up unnecessarily (and thus evaluate the predicate unnecessarily) due to changes in\n+\t// parts of A that do not also belong to B.\n+\tch := e.notifier.Subscribe(requestRef.EntityKey)\n+\texecutionLease.GetReleaseFn()(nil)","path":"service/history/chasm_engine.go","commit_id":"372cc0a17931bd461ec03349b8509b57820e36c2","original_commit_id":"542313b38e46b86f6f8db1f0e42aba8e551609c9","user":{"login":"dandavison","id":52205,"node_id":"MDQ6VXNlcjUyMjA1","avatar_url":"https://avatars.githubusercontent.com/u/52205?v=4","gravatar_id":"","url":"https://api.github.com/users/dandavison","html_url":"https://github.com/dandavison","followers_url":"https://api.github.com/users/dandavison/followers","following_url":"https://api.github.com/users/dandavison/following{/other_user}","gists_url":"https://api.github.com/users/dandavison/gists{/gist_id}","starred_url":"https://api.github.com/users/dandavison/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/dandavison/subscriptions","organizations_url":"https://api.github.com/users/dandavison/orgs","repos_url":"https://api.github.com/users/dandavison/repos","events_url":"https://api.github.com/users/dandavison/events{/privacy}","received_events_url":"https://api.github.com/users/dandavison/received_events","type":"User","user_view_type":"public","site_admin":false},"body":"It's OK","created_at":"2025-12-03T23:10:54Z","updated_at":"2025-12-04T02:13:23Z","html_url":"https://github.com/temporalio/temporal/pull/8563#discussion_r2586897490","pull_request_url":"https://api.github.com/repos/temporalio/temporal/pulls/8563","_links":{"self":{"href":"https://api.github.com/repos/temporalio/temporal/pulls/comments/2586897490"},"html":{"href":"https://github.com/temporalio/temporal/pull/8563#discussion_r2586897490"},"pull_request":{"href":"https://api.github.com/repos/temporalio/temporal/pulls/8563"}},"reactions":{"url":"https://api.github.com/repos/temporalio/temporal/pulls/comments/2586897490/reactions","total_count":0,"+1":0,"-1":0,"laugh":0,"hooray":0,"confused":0,"heart":0,"rocket":0,"eyes":0},"start_line":null,"original_start_line":null,"start_side":null,"line":null,"original_line":306,"side":"RIGHT","in_reply_to_id":2586415486,"author_association":"MEMBER","original_position":122,"position":1,"subject_type":"line"},{"url":"https://api.github.com/repos/temporalio/temporal/pulls/comments/2586899880","pull_request_review_id":3536180777,"id":2586899880,"node_id":"PRRC_kwDODNqesM6aMPWo","diff_hunk":"@@ -241,14 +256,137 @@ func (e *ChasmEngine) ReadComponent(\n \treturn readFn(chasmContext, component)\n }\n \n+// PollComponent waits until the supplied predicate is satisfied when evaluated against the\n+// component identified by the supplied component reference. If there is no error, it returns (ref,\n+// nil) where ref is a component reference identifying the state at which the predicate was\n+// satisfied. The predicate must be monotonic: if it returns true at execution state transition s it\n+// must return true at all transitions t > s. It is an error if execution transition history is\n+// (after reloading from persistence) behind the requested ref, or if the ref is inconsistent with\n+// execution transition history. Thus when the predicate function is evaluated, it is guaranteed\n+// that the execution VT >= requestRef VT. opts are currently ignored.\n func (e *ChasmEngine) PollComponent(\n \tctx context.Context,\n-\tentityRef chasm.ComponentRef,\n-\tpredicateFn func(chasm.Context, chasm.Component) (any, bool, error),\n-\toperationFn func(chasm.MutableContext, chasm.Component, any) error,\n+\trequestRef chasm.ComponentRef,\n+\tmonotonicPredicate func(chasm.Context, chasm.Component) (bool, error),\n \topts ...chasm.TransitionOption,\n-) (newEntityRef []byte, retError error) {\n-\treturn nil, serviceerror.NewUnimplemented(\"PollComponent is not yet supported\")\n+) (retRef []byte, retError error) {\n+\tdefer func() {\n+\t\tif errors.Is(retError, consts.ErrStaleState) {\n+\t\t\tretError = serviceerror.NewUnavailable(\"please retry\")\n+\t\t}\n+\t}()\n+\n+\tshardContext, executionLease, err := e.getExecutionLease(ctx, requestRef)\n+\tif err != nil {\n+\t\t// E.g. requestRef VT inconsistent with execution VT ('stale reference')\n+\t\treturn nil, err\n+\t}\n+\tdefer executionLease.GetReleaseFn()(nil)","path":"service/history/chasm_engine.go","commit_id":"372cc0a17931bd461ec03349b8509b57820e36c2","original_commit_id":"59d749626d6a00c5fff76abe79a85eb627366521","user":{"login":"dandavison","id":52205,"node_id":"MDQ6VXNlcjUyMjA1","avatar_url":"https://avatars.githubusercontent.com/u/52205?v=4","gravatar_id":"","url":"https://api.github.com/users/dandavison","html_url":"https://github.com/dandavison","followers_url":"https://api.github.com/users/dandavison/followers","following_url":"https://api.github.com/users/dandavison/following{/other_user}","gists_url":"https://api.github.com/users/dandavison/gists{/gist_id}","starred_url":"https://api.github.com/users/dandavison/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/dandavison/subscriptions","organizations_url":"https://api.github.com/users/dandavison/orgs","repos_url":"https://api.github.com/users/dandavison/repos","events_url":"https://api.github.com/users/dandavison/events{/privacy}","received_events_url":"https://api.github.com/users/dandavison/received_events","type":"User","user_view_type":"public","site_admin":false},"body":"Yes, I had checked this. It is OK https://github.com/temporalio/temporal/blob/poll-component/service/history/workflow/cache/cache.go#L353","created_at":"2025-12-03T23:12:22Z","updated_at":"2025-12-04T02:13:23Z","html_url":"https://github.com/temporalio/temporal/pull/8563#discussion_r2586899880","pull_request_url":"https://api.github.com/repos/temporalio/temporal/pulls/8563","_links":{"self":{"href":"https://api.github.com/repos/temporalio/temporal/pulls/comments/2586899880"},"html":{"href":"https://github.com/temporalio/temporal/pull/8563#discussion_r2586899880"},"pull_request":{"href":"https://api.github.com/repos/temporalio/temporal/pulls/8563"}},"reactions":{"url":"https://api.github.com/repos/temporalio/temporal/pulls/comments/2586899880/reactions","total_count":0,"+1":0,"-1":0,"laugh":0,"hooray":0,"confused":0,"heart":0,"rocket":0,"eyes":0},"start_line":null,"original_start_line":null,"start_side":null,"line":null,"original_line":284,"side":"RIGHT","in_reply_to_id":2579113526,"author_association":"MEMBER","original_position":100,"position":1,"subject_type":"line"},{"url":"https://api.github.com/repos/temporalio/temporal/pulls/comments/2586951281","pull_request_review_id":3536180777,"id":2586951281,"node_id":"PRRC_kwDODNqesM6aMb5x","diff_hunk":"@@ -241,14 +256,137 @@ func (e *ChasmEngine) ReadComponent(\n \treturn readFn(chasmContext, component)\n }\n \n+// PollComponent waits until the supplied predicate is satisfied when evaluated against the\n+// component identified by the supplied component reference. If there is no error, it returns (ref,\n+// nil) where ref is a component reference identifying the state at which the predicate was\n+// satisfied. The predicate must be monotonic: if it returns true at execution state transition s it\n+// must return true at all transitions t > s. It is an error if execution transition history is\n+// (after reloading from persistence) behind the requested ref, or if the ref is inconsistent with\n+// execution transition history. Thus when the predicate function is evaluated, it is guaranteed\n+// that the execution VT >= requestRef VT. opts are currently ignored.\n func (e *ChasmEngine) PollComponent(\n \tctx context.Context,\n-\tentityRef chasm.ComponentRef,\n-\tpredicateFn func(chasm.Context, chasm.Component) (any, bool, error),\n-\toperationFn func(chasm.MutableContext, chasm.Component, any) error,\n+\trequestRef chasm.ComponentRef,\n+\tmonotonicPredicate func(chasm.Context, chasm.Component) (bool, error),\n \topts ...chasm.TransitionOption,\n-) (newEntityRef []byte, retError error) {\n-\treturn nil, serviceerror.NewUnimplemented(\"PollComponent is not yet supported\")\n+) (retRef []byte, retError error) {\n+\tdefer func() {\n+\t\tif errors.Is(retError, consts.ErrStaleState) {\n+\t\t\tretError = serviceerror.NewUnavailable(\"please retry\")\n+\t\t}\n+\t}()\n+\n+\tshardContext, executionLease, err := e.getExecutionLease(ctx, requestRef)\n+\tif err != nil {\n+\t\t// E.g. requestRef VT inconsistent with execution VT ('stale reference')\n+\t\treturn nil, err\n+\t}\n+\tdefer executionLease.GetReleaseFn()(nil)\n+\n+\t// At this point it's possible that execution VT < requestRef VT (getExecutionLease does not\n+\t// guarantee that returned execution state is non-stale w.r.t. requestRef).\n+\tsatisfiedRef, err := e.predicateSatisfied(ctx, monotonicPredicate, requestRef, executionLease)\n+\tif err != nil {\n+\t\treturn nil, err\n+\t}\n+\t// execution VT >= requestRef VT (enforced by predicateSatisfied)\n+\n+\tif satisfiedRef != nil {\n+\t\t// wait condition was satisfied\n+\t\treturn satisfiedRef, nil\n+\t}\n+\n+\t// Wait condition not satisfied; long-poll\n+\n+\tnamespaceRegistry, err := shardContext.GetNamespaceRegistry().GetNamespaceByID(\n+\t\tnamespace.ID(requestRef.EntityKey.NamespaceID),\n+\t)\n+\tif err != nil {\n+\t\treturn nil, err\n+\t}\n+\n+\tinternalLongPollTimeout := shardContext.GetConfig().LongPollExpirationInterval(namespaceRegistry.Name().String())\n+\tctx, cancel := context.WithTimeout(ctx, internalLongPollTimeout)\n+\tdefer cancel()\n+\n+\t// PollComponent subscribes to execution-level notifications. Suppose that an execution consists\n+\t// of one component A, and A has subcomponent B. Subscribers interested only in component B may\n+\t// be woken up unnecessarily (and thus evaluate the predicate unnecessarily) due to changes in\n+\t// parts of A that do not also belong to B.\n+\tch := e.notifier.Subscribe(requestRef.EntityKey)\n+\texecutionLease.GetReleaseFn()(nil)\n+\n+\tfor {\n+\t\tselect {\n+\t\t// It is possible that multiple state transitions (multiple notifications) occur between\n+\t\t// predicate checks, therefore the predicate must be monotonic: if it returns true at\n+\t\t// execution state transition s then it must return true at all transitions t > s.\n+\t\tcase <-ch:\n+\t\t\t_, executionLease, err := e.getExecutionLease(ctx, requestRef)\n+\t\t\tif err != nil {\n+\t\t\t\treturn nil, err\n+\t\t\t}\n+\t\t\tfunc() {","path":"service/history/chasm_engine.go","commit_id":"372cc0a17931bd461ec03349b8509b57820e36c2","original_commit_id":"59d749626d6a00c5fff76abe79a85eb627366521","user":{"login":"dandavison","id":52205,"node_id":"MDQ6VXNlcjUyMjA1","avatar_url":"https://avatars.githubusercontent.com/u/52205?v=4","gravatar_id":"","url":"https://api.github.com/users/dandavison","html_url":"https://github.com/dandavison","followers_url":"https://api.github.com/users/dandavison/followers","following_url":"https://api.github.com/users/dandavison/following{/other_user}","gists_url":"https://api.github.com/users/dandavison/gists{/gist_id}","starred_url":"https://api.github.com/users/dandavison/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/dandavison/subscriptions","organizations_url":"https://api.github.com/users/dandavison/orgs","repos_url":"https://api.github.com/users/dandavison/repos","events_url":"https://api.github.com/users/dandavison/events{/privacy}","received_events_url":"https://api.github.com/users/dandavison/received_events","type":"User","user_view_type":"public","site_admin":false},"body":"Nice, I think you're right that this function can be refactored to reduce duplication and probably make it clearer. However the logic in this function is a bit delicate, so maybe let's not block on it right now.","created_at":"2025-12-03T23:44:25Z","updated_at":"2025-12-04T02:13:23Z","html_url":"https://github.com/temporalio/temporal/pull/8563#discussion_r2586951281","pull_request_url":"https://api.github.com/repos/temporalio/temporal/pulls/8563","_links":{"self":{"href":"https://api.github.com/repos/temporalio/temporal/pulls/comments/2586951281"},"html":{"href":"https://github.com/temporalio/temporal/pull/8563#discussion_r2586951281"},"pull_request":{"href":"https://api.github.com/repos/temporalio/temporal/pulls/8563"}},"reactions":{"url":"https://api.github.com/repos/temporalio/temporal/pulls/comments/2586951281/reactions","total_count":0,"+1":0,"-1":0,"laugh":0,"hooray":0,"confused":0,"heart":0,"rocket":0,"eyes":0},"start_line":null,"original_start_line":null,"start_side":null,"line":null,"original_line":329,"side":"RIGHT","in_reply_to_id":2579110212,"author_association":"MEMBER","original_position":145,"position":1,"subject_type":"line"},{"url":"https://api.github.com/repos/temporalio/temporal/pulls/comments/2587049516","pull_request_review_id":3537452100,"id":2587049516,"node_id":"PRRC_kwDODNqesM6aMz4s","diff_hunk":"@@ -53,3 +59,118 @@ func (h *handler) StartActivityExecution(ctx context.Context, req *activitypb.St\n \t\tFrontendResponse: response,\n \t}, nil\n }\n+\n+// PollActivityExecution handles PollActivityExecutionRequest from frontend. This method supports\n+// querying current activity state, optionally as a long-poll that waits for certain state changes.\n+// It is used by clients to poll for activity state and/or result. When used to long-poll, it\n+// returns an empty non-error response on context deadline expiry, to indicate that the state being\n+// waited for was not reached. Callers should interpret this as an invitation to resubmit their\n+// long-poll request. This response is sent before the caller's deadline (see\n+// chasm.activity.longPollBuffer) so that it is likely that the caller does indeed receive the\n+// non-error response.\n+func (h *handler) PollActivityExecution(\n+\tctx context.Context,\n+\treq *activitypb.PollActivityExecutionRequest,\n+) (response *activitypb.PollActivityExecutionResponse, err error) {\n+\tref := chasm.NewComponentRef[*Activity](chasm.EntityKey{\n+\t\tNamespaceID: req.GetNamespaceId(),\n+\t\tBusinessID:  req.GetFrontendRequest().GetActivityId(),\n+\t\tEntityID:    req.GetFrontendRequest().GetRunId(),\n+\t})\n+\tdefer func() {\n+\t\tvar notFound *serviceerror.NotFound\n+\t\tif errors.As(err, &notFound) {\n+\t\t\t// TODO(dan): include execution key in error message; we may do this at the CHASM\n+\t\t\t// framework level.\n+\t\t\t// cf. \"workflow execution not found for workflow ID XXX and run ID YYY\"\n+\t\t\terr = serviceerror.NewNotFound(\"activity execution not found\")\n+\t\t}\n+\t}()\n+\n+\twaitPolicy := req.GetFrontendRequest().GetWaitPolicy()\n+\n+\tif waitPolicy == nil {\n+\t\treturn chasm.ReadComponent(ctx, ref, (*Activity).buildPollActivityExecutionResponse, req, nil)\n+\t}\n+\n+\t// Below, we send an empty non-error response on context deadline expiry. Here we compute a\n+\t// deadline that causes us to send that response before the caller's own deadline (see\n+\t// chasm.activity.longPollBuffer). We also cap the caller's deadline at\n+\t// chasm.activity.longPollTimeout.\n+\tnamespace := req.GetFrontendRequest().GetNamespace()\n+\tctx, cancel := contextutil.WithDeadlineBuffer(\n+\t\tctx,\n+\t\th.config.LongPollTimeout(namespace),\n+\t\th.config.LongPollBuffer(namespace),\n+\t)\n+\tdefer cancel()\n+\n+\tswitch waitPolicy.(type) {\n+\tcase *workflowservice.PollActivityExecutionRequest_WaitAnyStateChange:\n+\t\ttoken := req.GetFrontendRequest().\n+\t\t\tGetWaitPolicy().(*workflowservice.PollActivityExecutionRequest_WaitAnyStateChange).\n+\t\t\tWaitAnyStateChange.GetLongPollToken()\n+\t\tif len(token) == 0 {\n+\t\t\treturn chasm.ReadComponent(ctx, ref, (*Activity).buildPollActivityExecutionResponse, req, nil)\n+\t\t}\n+\t\tresponse, _, err = chasm.PollComponent(ctx, ref, func(\n+\t\t\ta *Activity,\n+\t\t\tctx chasm.Context,\n+\t\t\treq *activitypb.PollActivityExecutionRequest,\n+\t\t) (*activitypb.PollActivityExecutionResponse, bool, error) {\n+\t\t\tchanged, err := chasm.ExecutionStateChanged(a, ctx, token)\n+\t\t\tif err != nil {\n+\t\t\t\tif errors.Is(err, chasm.ErrMalformedComponentRef) {\n+\t\t\t\t\treturn nil, false, serviceerror.NewInvalidArgument(\"invalid long poll token\")\n+\t\t\t\t}\n+\t\t\t\tif errors.Is(err, chasm.ErrInvalidComponentRef) {\n+\t\t\t\t\treturn nil, false, serviceerror.NewInvalidArgument(\"long poll token does not match execution\")\n+\t\t\t\t}\n+\t\t\t\treturn nil, false, err\n+\t\t\t}\n+\t\t\tif changed {\n+\t\t\t\tresponse, err := a.buildPollActivityExecutionResponse(ctx, req)\n+\t\t\t\treturn response, true, err\n+\t\t\t} else {\n+\t\t\t\treturn nil, false, nil\n+\t\t\t}\n+\t\t}, req)\n+\tcase *workflowservice.PollActivityExecutionRequest_WaitCompletion:\n+\t\t// TODO(dan): add functional test when RecordActivityTaskCompleted is implemented\n+\t\tresponse, _, err = chasm.PollComponent(ctx, ref, func(\n+\t\t\ta *Activity,\n+\t\t\tctx chasm.Context,\n+\t\t\treq *activitypb.PollActivityExecutionRequest,\n+\t\t) (*activitypb.PollActivityExecutionResponse, bool, error) {\n+\t\t\t// TODO(dan): check for terminal activity states\n+\t\t\tpanic(\"pollActivityExecutionWaitCompletion is not implemented\")\n+\t\t\tcompleted := false\n+\t\t\tif completed {\n+\t\t\t\tresponse, err := a.buildPollActivityExecutionResponse(ctx, req)\n+\t\t\t\tif err != nil {\n+\t\t\t\t\treturn nil, true, err\n+\t\t\t\t}\n+\t\t\t\treturn response, true, nil\n+\t\t\t}\n+\t\t\treturn nil, false, nil\n+\t\t}, req)\n+\tdefault:\n+\t\treturn nil, serviceerror.NewInvalidArgumentf(\"unexpected wait policy type: %T\", waitPolicy)\n+\t}\n+\n+\tif ctx.Err() != nil {\n+\t\t// We send an empty non-error response on deadline expiry as an invitation to the caller to\n+\t\t// resubmit their long-poll.\n+\n+\t\t// TODO(dan): the definition of \"empty\" is unclear, since callers can currently choose to\n+\t\t// exclude info, outcome, and input from the result. Currently, a caller can infer that the\n+\t\t// long-poll timed out due to a server-imposed timeout from the absence of the long-poll\n+\t\t// token. However, this is not a clear API. We are considering splitting the public API into\n+\t\t// two methods: one that returns info (optionally with input), and one that returns result,\n+\t\t// both with long-poll options. An empty response will then be more obvious to the caller.\n+\t\treturn &activitypb.PollActivityExecutionResponse{\n+\t\t\tFrontendResponse: &workflowservice.PollActivityExecutionResponse{},\n+\t\t}, nil\n+\t}","path":"chasm/lib/activity/handler.go","commit_id":"1d59e66d0ce5d91819f92c428ef5ab4c4efca1fb","original_commit_id":"4a8b8417884580e27819b1b1215b4cd7551e70d8","user":{"login":"cursor[bot]","id":206951365,"node_id":"BOT_kgDODFXTxQ","avatar_url":"https://avatars.githubusercontent.com/in/1210556?v=4","gravatar_id":"","url":"https://api.github.com/users/cursor%5Bbot%5D","html_url":"https://github.com/apps/cursor","followers_url":"https://api.github.com/users/cursor%5Bbot%5D/followers","following_url":"https://api.github.com/users/cursor%5Bbot%5D/following{/other_user}","gists_url":"https://api.github.com/users/cursor%5Bbot%5D/gists{/gist_id}","starred_url":"https://api.github.com/users/cursor%5Bbot%5D/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/cursor%5Bbot%5D/subscriptions","organizations_url":"https://api.github.com/users/cursor%5Bbot%5D/orgs","repos_url":"https://api.github.com/users/cursor%5Bbot%5D/repos","events_url":"https://api.github.com/users/cursor%5Bbot%5D/events{/privacy}","received_events_url":"https://api.github.com/users/cursor%5Bbot%5D/received_events","type":"Bot","user_view_type":"public","site_admin":false},"body":"### Bug: Context check may swallow errors or discard valid responses\n\n<!-- **Medium Severity** -->\n\n<!-- DESCRIPTION START -->\nThe error handling after `chasm.PollComponent` checks `ctx.Err()` instead of the returned `err` value. This causes two problems: (1) if `PollComponent` returns successfully but the context expires between the return and line 161 due to a timing race, the valid response is discarded and replaced with an empty response; (2) if `PollComponent` returns with a non-context error and the context also happens to be expired, the actual error is swallowed. The check should be based on the returned `err` value (checking if it's `context.DeadlineExceeded` or `context.Canceled`) rather than polling `ctx.Err()` directly.\n<!-- DESCRIPTION END -->\n\n<!-- LOCATIONS START\nchasm/lib/activity/handler.go#L160-L174\nLOCATIONS END -->\n<a href=\"https://cursor.com/open?data=eyJhbGciOiJSUzI1NiIsInR5cCI6IkpXVCIsImtpZCI6ImJ1Z2JvdC12MSJ9.eyJ2ZXJzaW9uIjoxLCJ0eXBlIjoiQlVHQk9UX0ZJWF9JTl9DVVJTT1IiLCJkYXRhIjp7InJlZGlzS2V5IjoiYnVnYm90OjU3NjAyMDBjLTFiZjYtNDUwNS05NzJlLTg5OWJiYzU0YjgxYyIsImVuY3J5cHRpb25LZXkiOiJvZlVmbG1XRmh3a0N3dVZ2S1dzZHVYYzRCUDQyV1BiZVZUYVpLUk02WklVIiwiYnJhbmNoIjoicG9sbC1jb21wb25lbnQifSwiaWF0IjoxNzY0ODA5NzA4LCJleHAiOjE3NjU0MTQ1MDh9.PExd1RaihVmN2EXVACtyHm07Cunc0mVL_4SNpImHYEgdyDJSk9JFAkpR7CDJMd41KHUaSigdK9DzT-X8NW1jBewCSQKpAlqDUNeJCHI7XGgo8CtacRZMsIQtIwOfzi4RaAqKQabCHtqsRWZIkBE6bURAPLRDf5EfTBmaO4txFR6phrEfLtEkXFL_32ddXL8bNkU5GPxAI1gz2UMOeF7mQfWoIvuqbodmuFVWXMwUxgqoRK7zNnO-U6ptp2zxq-6ZuYzas8J8gol1PnhJKyf5npYIid5Ok_pL47y19CjZb3XQntgzp80lrEYxPTrhtoIceI8LpPfiEUt68OpjNlm7GQ\"><picture><source media=\"(prefers-color-scheme: dark)\" srcset=\"https://cursor.com/fix-in-cursor-dark.svg\"><source media=\"(prefers-color-scheme: light)\" srcset=\"https://cursor.com/fix-in-cursor-light.svg\"><img alt=\"Fix in Cursor\" src=\"https://cursor.com/fix-in-cursor.svg\"></picture></a>&nbsp;<a href=\"https://cursor.com/agents?data=eyJhbGciOiJSUzI1NiIsInR5cCI6IkpXVCIsImtpZCI6ImJ1Z2JvdC12MSJ9.eyJ2ZXJzaW9uIjoxLCJ0eXBlIjoiQlVHQk9UX0ZJWF9JTl9XRUIiLCJkYXRhIjp7InJlZGlzS2V5IjoiYnVnYm90OjU3NjAyMDBjLTFiZjYtNDUwNS05NzJlLTg5OWJiYzU0YjgxYyIsImVuY3J5cHRpb25LZXkiOiJvZlVmbG1XRmh3a0N3dVZ2S1dzZHVYYzRCUDQyV1BiZVZUYVpLUk02WklVIiwiYnJhbmNoIjoicG9sbC1jb21wb25lbnQiLCJyZXBvT3duZXIiOiJ0ZW1wb3JhbGlvIiwicmVwb05hbWUiOiJ0ZW1wb3JhbCIsInByTnVtYmVyIjo4NTYzLCJjb21taXRTaGEiOiI0YThiODQxNzg4NDU4MGUyNzgxOWIxYjEyMTViNGNkNzU1MWU3MGQ4IiwicHJvdmlkZXIiOiJnaXRodWIifSwiaWF0IjoxNzY0ODA5NzA4LCJleHAiOjE3NjU0MTQ1MDh9.B64UOGjZUy5YXmWV0NeA5KaOcLHqtyN9noj-sSpylK3D5BqGXiYZhxxlJuufN3dKd7OtQfbFQrK2qeEFVyWjHjug0mq_Vir84ox8Xdu3K-0svBAderEq7jvnTmVq_wJTHWgN3008hZYx7Yu_TLWgxLVqSUNHsrh-s9luv0nCSR07xsfGG7OB4lp0yoeRY15x_O2e59uv9t270G6yKuueclK8i2eb2ibRe7P_HEtd3iFOOenE-5_Awh9hOBOaNu5XvBcAIYPN0Ot2yC5SQZKQKK4FBOEd9fv0Iw4gE4rP8F80Qmn9k3lqsofsz0H85pFhqkxv25HO50C5QwafMUCqnA\"><picture><source media=\"(prefers-color-scheme: dark)\" srcset=\"https://cursor.com/fix-in-web-dark.svg\"><source media=\"(prefers-color-scheme: light)\" srcset=\"https://cursor.com/fix-in-web-light.svg\"><img alt=\"Fix in Web\" src=\"https://cursor.com/fix-in-web.svg\"></picture></a>\n\n","created_at":"2025-12-04T00:55:08Z","updated_at":"2025-12-04T00:55:08Z","html_url":"https://github.com/temporalio/temporal/pull/8563#discussion_r2587049516","pull_request_url":"https://api.github.com/repos/temporalio/temporal/pulls/8563","_links":{"self":{"href":"https://api.github.com/repos/temporalio/temporal/pulls/comments/2587049516"},"html":{"href":"https://github.com/temporalio/temporal/pull/8563#discussion_r2587049516"},"pull_request":{"href":"https://api.github.com/repos/temporalio/temporal/pulls/8563"}},"reactions":{"url":"https://api.github.com/repos/temporalio/temporal/pulls/comments/2587049516/reactions","total_count":0,"+1":0,"-1":0,"laugh":0,"hooray":0,"confused":0,"heart":0,"rocket":0,"eyes":0},"start_line":null,"original_start_line":null,"start_side":null,"line":170,"original_line":174,"side":"RIGHT","author_association":"NONE","original_position":143,"position":139,"subject_type":"line"},{"url":"https://api.github.com/repos/temporalio/temporal/pulls/comments/2587131700","pull_request_review_id":3536180777,"id":2587131700,"node_id":"PRRC_kwDODNqesM6aNH80","diff_hunk":"@@ -76,6 +76,11 @@ func (s *componentRefSuite) TestShardingKey() {\n }\n \n func (s *componentRefSuite) TestSerializeDeserialize() {\n+\t_, err := DeserializeComponentRef(nil)\n+\ts.Error(err)","path":"chasm/ref_test.go","commit_id":"66fabe0d082c4981de3eaca9daf97fbe262d9b1b","original_commit_id":"59d749626d6a00c5fff76abe79a85eb627366521","user":{"login":"dandavison","id":52205,"node_id":"MDQ6VXNlcjUyMjA1","avatar_url":"https://avatars.githubusercontent.com/u/52205?v=4","gravatar_id":"","url":"https://api.github.com/users/dandavison","html_url":"https://github.com/dandavison","followers_url":"https://api.github.com/users/dandavison/followers","following_url":"https://api.github.com/users/dandavison/following{/other_user}","gists_url":"https://api.github.com/users/dandavison/gists{/gist_id}","starred_url":"https://api.github.com/users/dandavison/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/dandavison/subscriptions","organizations_url":"https://api.github.com/users/dandavison/orgs","repos_url":"https://api.github.com/users/dandavison/repos","events_url":"https://api.github.com/users/dandavison/events{/privacy}","received_events_url":"https://api.github.com/users/dandavison/received_events","type":"User","user_view_type":"public","site_admin":false},"body":"Thanks, done.","created_at":"2025-12-04T01:40:37Z","updated_at":"2025-12-04T02:13:23Z","html_url":"https://github.com/temporalio/temporal/pull/8563#discussion_r2587131700","pull_request_url":"https://api.github.com/repos/temporalio/temporal/pulls/8563","_links":{"self":{"href":"https://api.github.com/repos/temporalio/temporal/pulls/comments/2587131700"},"html":{"href":"https://github.com/temporalio/temporal/pull/8563#discussion_r2587131700"},"pull_request":{"href":"https://api.github.com/repos/temporalio/temporal/pulls/8563"}},"reactions":{"url":"https://api.github.com/repos/temporalio/temporal/pulls/comments/2587131700/reactions","total_count":0,"+1":0,"-1":0,"laugh":0,"hooray":0,"confused":0,"heart":0,"rocket":0,"eyes":0},"start_line":null,"original_start_line":null,"start_side":null,"line":null,"original_line":80,"side":"RIGHT","in_reply_to_id":2578234377,"author_association":"MEMBER","original_position":5,"position":1,"subject_type":"line"},{"url":"https://api.github.com/repos/temporalio/temporal/pulls/comments/2587144264","pull_request_review_id":3536180777,"id":2587144264,"node_id":"PRRC_kwDODNqesM6aNLBI","diff_hunk":"","path":"service/history/chasm_notifier.go","commit_id":"1d59e66d0ce5d91819f92c428ef5ab4c4efca1fb","original_commit_id":"59d749626d6a00c5fff76abe79a85eb627366521","user":{"login":"dandavison","id":52205,"node_id":"MDQ6VXNlcjUyMjA1","avatar_url":"https://avatars.githubusercontent.com/u/52205?v=4","gravatar_id":"","url":"https://api.github.com/users/dandavison","html_url":"https://github.com/dandavison","followers_url":"https://api.github.com/users/dandavison/followers","following_url":"https://api.github.com/users/dandavison/following{/other_user}","gists_url":"https://api.github.com/users/dandavison/gists{/gist_id}","starred_url":"https://api.github.com/users/dandavison/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/dandavison/subscriptions","organizations_url":"https://api.github.com/users/dandavison/orgs","repos_url":"https://api.github.com/users/dandavison/repos","events_url":"https://api.github.com/users/dandavison/events{/privacy}","received_events_url":"https://api.github.com/users/dandavison/received_events","type":"User","user_view_type":"public","site_admin":false},"body":"Thanks, done","created_at":"2025-12-04T01:47:58Z","updated_at":"2025-12-04T02:13:23Z","html_url":"https://github.com/temporalio/temporal/pull/8563#discussion_r2587144264","pull_request_url":"https://api.github.com/repos/temporalio/temporal/pulls/8563","_links":{"self":{"href":"https://api.github.com/repos/temporalio/temporal/pulls/comments/2587144264"},"html":{"href":"https://github.com/temporalio/temporal/pull/8563#discussion_r2587144264"},"pull_request":{"href":"https://api.github.com/repos/temporalio/temporal/pulls/8563"}},"reactions":{"url":"https://api.github.com/repos/temporalio/temporal/pulls/comments/2587144264/reactions","total_count":0,"+1":0,"-1":0,"laugh":0,"hooray":0,"confused":0,"heart":0,"rocket":0,"eyes":0},"start_line":null,"original_start_line":null,"start_side":null,"line":1,"original_line":1,"side":"RIGHT","in_reply_to_id":2579132729,"author_association":"MEMBER","original_position":1,"position":1,"subject_type":"file"},{"url":"https://api.github.com/repos/temporalio/temporal/pulls/comments/2587145397","pull_request_review_id":3536180777,"id":2587145397,"node_id":"PRRC_kwDODNqesM6aNLS1","diff_hunk":"@@ -0,0 +1,46 @@\n+package history\n+\n+import (\n+\t\"sync\"\n+\n+\t\"go.temporal.io/server/chasm\"\n+\t\"go.temporal.io/server/common/metrics\"\n+)\n+\n+type (\n+\t// ChasmNotifier allows subscribers to receive notifications relating to a CHASM execution.\n+\tChasmNotifier struct {\n+\t\texecutions map[chasm.EntityKey]chan struct{}\n+\t\tlock       sync.Mutex","path":"service/history/chasm_notifier.go","commit_id":"ba38880058f288839d9fd74d46b7ac8dbc549f5c","original_commit_id":"59d749626d6a00c5fff76abe79a85eb627366521","user":{"login":"dandavison","id":52205,"node_id":"MDQ6VXNlcjUyMjA1","avatar_url":"https://avatars.githubusercontent.com/u/52205?v=4","gravatar_id":"","url":"https://api.github.com/users/dandavison","html_url":"https://github.com/dandavison","followers_url":"https://api.github.com/users/dandavison/followers","following_url":"https://api.github.com/users/dandavison/following{/other_user}","gists_url":"https://api.github.com/users/dandavison/gists{/gist_id}","starred_url":"https://api.github.com/users/dandavison/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/dandavison/subscriptions","organizations_url":"https://api.github.com/users/dandavison/orgs","repos_url":"https://api.github.com/users/dandavison/repos","events_url":"https://api.github.com/users/dandavison/events{/privacy}","received_events_url":"https://api.github.com/users/dandavison/received_events","type":"User","user_view_type":"public","site_admin":false},"body":"Let's track this?","created_at":"2025-12-04T01:48:46Z","updated_at":"2025-12-04T02:13:23Z","html_url":"https://github.com/temporalio/temporal/pull/8563#discussion_r2587145397","pull_request_url":"https://api.github.com/repos/temporalio/temporal/pulls/8563","_links":{"self":{"href":"https://api.github.com/repos/temporalio/temporal/pulls/comments/2587145397"},"html":{"href":"https://github.com/temporalio/temporal/pull/8563#discussion_r2587145397"},"pull_request":{"href":"https://api.github.com/repos/temporalio/temporal/pulls/8563"}},"reactions":{"url":"https://api.github.com/repos/temporalio/temporal/pulls/comments/2587145397/reactions","total_count":0,"+1":0,"-1":0,"laugh":0,"hooray":0,"confused":0,"heart":0,"rocket":0,"eyes":0},"start_line":null,"original_start_line":null,"start_side":null,"line":null,"original_line":14,"side":"RIGHT","in_reply_to_id":2579139461,"author_association":"MEMBER","original_position":14,"position":1,"subject_type":"line"},{"url":"https://api.github.com/repos/temporalio/temporal/pulls/comments/2587149771","pull_request_review_id":3536180777,"id":2587149771,"node_id":"PRRC_kwDODNqesM6aNMXL","diff_hunk":"@@ -838,6 +842,21 @@ func (e *historyEngineImpl) NotifyNewHistoryEvent(\n \te.eventNotifier.NotifyNewHistoryEvent(notification)\n }\n \n+func (e *historyEngineImpl) GetChasmEngine() chasm.Engine {","path":"service/history/history_engine.go","commit_id":"7bf19dc271aec2f2f649077fac915077fc6028fe","original_commit_id":"59d749626d6a00c5fff76abe79a85eb627366521","user":{"login":"dandavison","id":52205,"node_id":"MDQ6VXNlcjUyMjA1","avatar_url":"https://avatars.githubusercontent.com/u/52205?v=4","gravatar_id":"","url":"https://api.github.com/users/dandavison","html_url":"https://github.com/dandavison","followers_url":"https://api.github.com/users/dandavison/followers","following_url":"https://api.github.com/users/dandavison/following{/other_user}","gists_url":"https://api.github.com/users/dandavison/gists{/gist_id}","starred_url":"https://api.github.com/users/dandavison/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/dandavison/subscriptions","organizations_url":"https://api.github.com/users/dandavison/orgs","repos_url":"https://api.github.com/users/dandavison/repos","events_url":"https://api.github.com/users/dandavison/events{/privacy}","received_events_url":"https://api.github.com/users/dandavison/received_events","type":"User","user_view_type":"public","site_admin":false},"body":"Done","created_at":"2025-12-04T01:51:44Z","updated_at":"2025-12-04T02:13:23Z","html_url":"https://github.com/temporalio/temporal/pull/8563#discussion_r2587149771","pull_request_url":"https://api.github.com/repos/temporalio/temporal/pulls/8563","_links":{"self":{"href":"https://api.github.com/repos/temporalio/temporal/pulls/comments/2587149771"},"html":{"href":"https://github.com/temporalio/temporal/pull/8563#discussion_r2587149771"},"pull_request":{"href":"https://api.github.com/repos/temporalio/temporal/pulls/8563"}},"reactions":{"url":"https://api.github.com/repos/temporalio/temporal/pulls/comments/2587149771/reactions","total_count":0,"+1":0,"-1":0,"laugh":0,"hooray":0,"confused":0,"heart":0,"rocket":0,"eyes":0},"start_line":null,"original_start_line":null,"start_side":null,"line":null,"original_line":845,"side":"RIGHT","in_reply_to_id":2579142861,"author_association":"MEMBER","original_position":36,"position":1,"subject_type":"line"},{"url":"https://api.github.com/repos/temporalio/temporal/pulls/comments/2587239034","pull_request_review_id":3537686819,"id":2587239034,"node_id":"PRRC_kwDODNqesM6aNiJ6","diff_hunk":"@@ -241,14 +256,125 @@ func (e *ChasmEngine) ReadComponent(\n \treturn readFn(chasmContext, component)\n }\n \n+// PollComponent waits until the supplied predicate is satisfied when evaluated against the\n+// component identified by the supplied component reference. If there is no error, it returns (ref,\n+// nil) where ref is a component reference identifying the state at which the predicate was\n+// satisfied. It's possible that multiple state transitions (multiple notifications) occur between\n+// predicate checks, therefore the predicate must be monotonic: if it returns true at execution\n+// state transition s it must return true at all transitions t > s. It is an error if execution\n+// transition history is (after reloading from persistence) behind the requested ref, or if the ref\n+// is inconsistent with execution transition history. Thus when the predicate function is evaluated,\n+// it is guaranteed that the execution VT >= requestRef VT. opts are currently ignored.\n+// PollComponent subscribes to execution-level notifications. Suppose that an execution consists of\n+// one component A, and A has subcomponent B. Subscribers interested only in component B may be\n+// woken up unnecessarily (and thus evaluate the predicate unnecessarily) due to changes in parts of\n+// A that do not also belong to B.\n func (e *ChasmEngine) PollComponent(\n \tctx context.Context,\n-\tentityRef chasm.ComponentRef,\n-\tpredicateFn func(chasm.Context, chasm.Component) (any, bool, error),\n-\toperationFn func(chasm.MutableContext, chasm.Component, any) error,\n+\trequestRef chasm.ComponentRef,\n+\tmonotonicPredicate func(chasm.Context, chasm.Component) (bool, error),\n \topts ...chasm.TransitionOption,\n-) (newEntityRef []byte, retError error) {\n-\treturn nil, serviceerror.NewUnimplemented(\"PollComponent is not yet supported\")\n+) (retRef []byte, retError error) {\n+\n+\tvar ch <-chan struct{}\n+\tvar unsubscribe func()\n+\tdefer func() {\n+\t\tif unsubscribe != nil {\n+\t\t\tunsubscribe()\n+\t\t}\n+\t}()\n+\n+\tcheckPredicateOrSubscribe := func() ([]byte, error) {\n+\t\t_, executionLease, err := e.getExecutionLease(ctx, requestRef)\n+\t\tif err != nil {\n+\t\t\treturn nil, err\n+\t\t}\n+\t\tdefer executionLease.GetReleaseFn()(nil)\n+\n+\t\tref, err := e.predicateSatisfied(ctx, monotonicPredicate, requestRef, executionLease)\n+\t\tif err != nil {\n+\t\t\tif errors.Is(err, consts.ErrStaleState) {\n+\t\t\t\terr = serviceerror.NewUnavailable(\"please retry\")","path":"service/history/chasm_engine.go","commit_id":"1d59e66d0ce5d91819f92c428ef5ab4c4efca1fb","original_commit_id":"1b821f3ffeea2a4aecc83d05866554dbfc460a87","user":{"login":"dandavison","id":52205,"node_id":"MDQ6VXNlcjUyMjA1","avatar_url":"https://avatars.githubusercontent.com/u/52205?v=4","gravatar_id":"","url":"https://api.github.com/users/dandavison","html_url":"https://github.com/dandavison","followers_url":"https://api.github.com/users/dandavison/followers","following_url":"https://api.github.com/users/dandavison/following{/other_user}","gists_url":"https://api.github.com/users/dandavison/gists{/gist_id}","starred_url":"https://api.github.com/users/dandavison/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/dandavison/subscriptions","organizations_url":"https://api.github.com/users/dandavison/orgs","repos_url":"https://api.github.com/users/dandavison/repos","events_url":"https://api.github.com/users/dandavison/events{/privacy}","received_events_url":"https://api.github.com/users/dandavison/received_events","type":"User","user_view_type":"public","site_admin":false},"body":"I need a better error message here, but I haven't decided what.\r\n> \"request data ahead of persisted data\"\r\n\r\n?\r\n\r\nAlso, should it be `PollActivityExecution` that converts this to `serviceerror`?","created_at":"2025-12-04T02:35:54Z","updated_at":"2025-12-04T02:37:54Z","html_url":"https://github.com/temporalio/temporal/pull/8563#discussion_r2587239034","pull_request_url":"https://api.github.com/repos/temporalio/temporal/pulls/8563","_links":{"self":{"href":"https://api.github.com/repos/temporalio/temporal/pulls/comments/2587239034"},"html":{"href":"https://github.com/temporalio/temporal/pull/8563#discussion_r2587239034"},"pull_request":{"href":"https://api.github.com/repos/temporalio/temporal/pulls/8563"}},"reactions":{"url":"https://api.github.com/repos/temporalio/temporal/pulls/comments/2587239034/reactions","total_count":0,"+1":0,"-1":0,"laugh":0,"hooray":0,"confused":0,"heart":0,"rocket":0,"eyes":0},"start_line":null,"original_start_line":null,"start_side":null,"line":297,"original_line":297,"side":"RIGHT","author_association":"MEMBER","original_position":113,"position":109,"subject_type":"line"},{"url":"https://api.github.com/repos/temporalio/temporal/pulls/comments/2591003057","pull_request_review_id":3542631651,"id":2591003057,"node_id":"PRRC_kwDODNqesM6ab5Gx","diff_hunk":"@@ -0,0 +1,35 @@\n+package activity\n+\n+import (\n+\t\"time\"\n+\n+\t\"go.temporal.io/server/common/dynamicconfig\"\n+)\n+\n+var (\n+\tLongPollTimeout = dynamicconfig.NewNamespaceDurationSetting(\n+\t\t\"chasm.activity.longPollTimeout\",","path":"chasm/lib/activity/config.go","commit_id":"1d59e66d0ce5d91819f92c428ef5ab4c4efca1fb","original_commit_id":"8aa718931afd6a83e7694ad3b97cec208dcf61e1","user":{"login":"bergundy","id":52304,"node_id":"MDQ6VXNlcjUyMzA0","avatar_url":"https://avatars.githubusercontent.com/u/52304?v=4","gravatar_id":"","url":"https://api.github.com/users/bergundy","html_url":"https://github.com/bergundy","followers_url":"https://api.github.com/users/bergundy/followers","following_url":"https://api.github.com/users/bergundy/following{/other_user}","gists_url":"https://api.github.com/users/bergundy/gists{/gist_id}","starred_url":"https://api.github.com/users/bergundy/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/bergundy/subscriptions","organizations_url":"https://api.github.com/users/bergundy/orgs","repos_url":"https://api.github.com/users/bergundy/repos","events_url":"https://api.github.com/users/bergundy/events{/privacy}","received_events_url":"https://api.github.com/users/bergundy/received_events","type":"User","user_view_type":"public","site_admin":false},"body":"Not blocking this PR but I don't think putting `chasm.` as a prefix for user configs is good practice. We will likely want to change this across all libraries though.","created_at":"2025-12-05T00:14:45Z","updated_at":"2025-12-05T00:14:45Z","html_url":"https://github.com/temporalio/temporal/pull/8563#discussion_r2591003057","pull_request_url":"https://api.github.com/repos/temporalio/temporal/pulls/8563","_links":{"self":{"href":"https://api.github.com/repos/temporalio/temporal/pulls/comments/2591003057"},"html":{"href":"https://github.com/temporalio/temporal/pull/8563#discussion_r2591003057"},"pull_request":{"href":"https://api.github.com/repos/temporalio/temporal/pulls/8563"}},"reactions":{"url":"https://api.github.com/repos/temporalio/temporal/pulls/comments/2591003057/reactions","total_count":1,"+1":1,"-1":0,"laugh":0,"hooray":0,"confused":0,"heart":0,"rocket":0,"eyes":0},"start_line":null,"original_start_line":null,"start_side":null,"line":11,"original_line":11,"side":"RIGHT","author_association":"MEMBER","original_position":11,"position":11,"subject_type":"line"},{"url":"https://api.github.com/repos/temporalio/temporal/pulls/comments/2591003482","pull_request_review_id":3542632205,"id":2591003482,"node_id":"PRRC_kwDODNqesM6ab5Na","diff_hunk":"@@ -0,0 +1,35 @@\n+package activity\n+\n+import (\n+\t\"time\"\n+\n+\t\"go.temporal.io/server/common/dynamicconfig\"\n+)\n+\n+var (\n+\tLongPollTimeout = dynamicconfig.NewNamespaceDurationSetting(\n+\t\t\"chasm.activity.longPollTimeout\",\n+\t\t20*time.Second,\n+\t\t`LongPollTimeout is a timeout for activity long-poll requests.`,","path":"chasm/lib/activity/config.go","commit_id":"f12d710e24b3dd4077c442ef9097b70e2fce948f","original_commit_id":"8aa718931afd6a83e7694ad3b97cec208dcf61e1","user":{"login":"bergundy","id":52304,"node_id":"MDQ6VXNlcjUyMzA0","avatar_url":"https://avatars.githubusercontent.com/u/52304?v=4","gravatar_id":"","url":"https://api.github.com/users/bergundy","html_url":"https://github.com/bergundy","followers_url":"https://api.github.com/users/bergundy/followers","following_url":"https://api.github.com/users/bergundy/following{/other_user}","gists_url":"https://api.github.com/users/bergundy/gists{/gist_id}","starred_url":"https://api.github.com/users/bergundy/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/bergundy/subscriptions","organizations_url":"https://api.github.com/users/bergundy/orgs","repos_url":"https://api.github.com/users/bergundy/repos","events_url":"https://api.github.com/users/bergundy/events{/privacy}","received_events_url":"https://api.github.com/users/bergundy/received_events","type":"User","user_view_type":"public","site_admin":false},"body":"```suggestion\n\t\t`Timeout for activity long-poll requests.`,\n```","created_at":"2025-12-05T00:15:07Z","updated_at":"2025-12-05T00:40:47Z","html_url":"https://github.com/temporalio/temporal/pull/8563#discussion_r2591003482","pull_request_url":"https://api.github.com/repos/temporalio/temporal/pulls/8563","_links":{"self":{"href":"https://api.github.com/repos/temporalio/temporal/pulls/comments/2591003482"},"html":{"href":"https://github.com/temporalio/temporal/pull/8563#discussion_r2591003482"},"pull_request":{"href":"https://api.github.com/repos/temporalio/temporal/pulls/8563"}},"reactions":{"url":"https://api.github.com/repos/temporalio/temporal/pulls/comments/2591003482/reactions","total_count":0,"+1":0,"-1":0,"laugh":0,"hooray":0,"confused":0,"heart":0,"rocket":0,"eyes":0},"start_line":null,"original_start_line":null,"start_side":null,"line":null,"original_line":13,"side":"RIGHT","author_association":"MEMBER","original_position":13,"position":1,"subject_type":"line"},{"url":"https://api.github.com/repos/temporalio/temporal/pulls/comments/2591004417","pull_request_review_id":3542632205,"id":2591004417,"node_id":"PRRC_kwDODNqesM6ab5cB","diff_hunk":"@@ -0,0 +1,35 @@\n+package activity\n+\n+import (\n+\t\"time\"\n+\n+\t\"go.temporal.io/server/common/dynamicconfig\"\n+)\n+\n+var (\n+\tLongPollTimeout = dynamicconfig.NewNamespaceDurationSetting(\n+\t\t\"chasm.activity.longPollTimeout\",\n+\t\t20*time.Second,\n+\t\t`LongPollTimeout is a timeout for activity long-poll requests.`,\n+\t)\n+\n+\tLongPollBuffer = dynamicconfig.NewNamespaceDurationSetting(\n+\t\t\"chasm.activity.longPollBuffer\",\n+\t\ttime.Second,\n+\t\t`LongPollBuffer is used to adjust theactivity long-poll timeouts.","path":"chasm/lib/activity/config.go","commit_id":"8aa718931afd6a83e7694ad3b97cec208dcf61e1","original_commit_id":"8aa718931afd6a83e7694ad3b97cec208dcf61e1","user":{"login":"bergundy","id":52304,"node_id":"MDQ6VXNlcjUyMzA0","avatar_url":"https://avatars.githubusercontent.com/u/52304?v=4","gravatar_id":"","url":"https://api.github.com/users/bergundy","html_url":"https://github.com/bergundy","followers_url":"https://api.github.com/users/bergundy/followers","following_url":"https://api.github.com/users/bergundy/following{/other_user}","gists_url":"https://api.github.com/users/bergundy/gists{/gist_id}","starred_url":"https://api.github.com/users/bergundy/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/bergundy/subscriptions","organizations_url":"https://api.github.com/users/bergundy/orgs","repos_url":"https://api.github.com/users/bergundy/repos","events_url":"https://api.github.com/users/bergundy/events{/privacy}","received_events_url":"https://api.github.com/users/bergundy/received_events","type":"User","user_view_type":"public","site_admin":false},"body":"```suggestion\n\t\t`A buffer used to adjust the activity long-poll timeouts.\n```","created_at":"2025-12-05T00:15:35Z","updated_at":"2025-12-05T00:40:47Z","html_url":"https://github.com/temporalio/temporal/pull/8563#discussion_r2591004417","pull_request_url":"https://api.github.com/repos/temporalio/temporal/pulls/8563","_links":{"self":{"href":"https://api.github.com/repos/temporalio/temporal/pulls/comments/2591004417"},"html":{"href":"https://github.com/temporalio/temporal/pull/8563#discussion_r2591004417"},"pull_request":{"href":"https://api.github.com/repos/temporalio/temporal/pulls/8563"}},"reactions":{"url":"https://api.github.com/repos/temporalio/temporal/pulls/comments/2591004417/reactions","total_count":0,"+1":0,"-1":0,"laugh":0,"hooray":0,"confused":0,"heart":0,"rocket":0,"eyes":0},"start_line":null,"original_start_line":null,"start_side":null,"line":null,"original_line":19,"side":"RIGHT","author_association":"MEMBER","original_position":19,"position":1,"subject_type":"line"},{"url":"https://api.github.com/repos/temporalio/temporal/pulls/comments/2591005926","pull_request_review_id":3542632205,"id":2591005926,"node_id":"PRRC_kwDODNqesM6ab5zm","diff_hunk":"@@ -0,0 +1,35 @@\n+package activity\n+\n+import (\n+\t\"time\"\n+\n+\t\"go.temporal.io/server/common/dynamicconfig\"\n+)\n+\n+var (\n+\tLongPollTimeout = dynamicconfig.NewNamespaceDurationSetting(\n+\t\t\"chasm.activity.longPollTimeout\",\n+\t\t20*time.Second,\n+\t\t`LongPollTimeout is a timeout for activity long-poll requests.`,\n+\t)\n+\n+\tLongPollBuffer = dynamicconfig.NewNamespaceDurationSetting(\n+\t\t\"chasm.activity.longPollBuffer\",\n+\t\ttime.Second,\n+\t\t`LongPollBuffer is used to adjust theactivity long-poll timeouts.\n+ Specifically, activity long-poll requests are timed out at a time which leaves at least LongPollBuffer","path":"chasm/lib/activity/config.go","commit_id":"101822827ec6f0ce5eb6c86421c7162b8ba21321","original_commit_id":"8aa718931afd6a83e7694ad3b97cec208dcf61e1","user":{"login":"bergundy","id":52304,"node_id":"MDQ6VXNlcjUyMzA0","avatar_url":"https://avatars.githubusercontent.com/u/52304?v=4","gravatar_id":"","url":"https://api.github.com/users/bergundy","html_url":"https://github.com/bergundy","followers_url":"https://api.github.com/users/bergundy/followers","following_url":"https://api.github.com/users/bergundy/following{/other_user}","gists_url":"https://api.github.com/users/bergundy/gists{/gist_id}","starred_url":"https://api.github.com/users/bergundy/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/bergundy/subscriptions","organizations_url":"https://api.github.com/users/bergundy/orgs","repos_url":"https://api.github.com/users/bergundy/repos","events_url":"https://api.github.com/users/bergundy/events{/privacy}","received_events_url":"https://api.github.com/users/bergundy/received_events","type":"User","user_view_type":"public","site_admin":false},"body":"```suggestion\n Specifically, activity long-poll requests are timed out at a time which leaves at least the buffer's duration\n```","created_at":"2025-12-05T00:16:42Z","updated_at":"2025-12-05T00:40:47Z","html_url":"https://github.com/temporalio/temporal/pull/8563#discussion_r2591005926","pull_request_url":"https://api.github.com/repos/temporalio/temporal/pulls/8563","_links":{"self":{"href":"https://api.github.com/repos/temporalio/temporal/pulls/comments/2591005926"},"html":{"href":"https://github.com/temporalio/temporal/pull/8563#discussion_r2591005926"},"pull_request":{"href":"https://api.github.com/repos/temporalio/temporal/pulls/8563"}},"reactions":{"url":"https://api.github.com/repos/temporalio/temporal/pulls/comments/2591005926/reactions","total_count":0,"+1":0,"-1":0,"laugh":0,"hooray":0,"confused":0,"heart":0,"rocket":0,"eyes":0},"start_line":null,"original_start_line":null,"start_side":null,"line":null,"original_line":20,"side":"RIGHT","author_association":"MEMBER","original_position":20,"position":1,"subject_type":"line"},{"url":"https://api.github.com/repos/temporalio/temporal/pulls/comments/2591007095","pull_request_review_id":3542632205,"id":2591007095,"node_id":"PRRC_kwDODNqesM6ab6F3","diff_hunk":"@@ -53,3 +59,118 @@ func (h *handler) StartActivityExecution(ctx context.Context, req *activitypb.St\n \t\tFrontendResponse: response,\n \t}, nil\n }\n+\n+// PollActivityExecution handles PollActivityExecutionRequest from frontend. This method supports\n+// querying current activity state, optionally as a long-poll that waits for certain state changes.\n+// It is used by clients to poll for activity state and/or result. When used to long-poll, it\n+// returns an empty non-error response on context deadline expiry, to indicate that the state being\n+// waited for was not reached. Callers should interpret this as an invitation to resubmit their\n+// long-poll request. This response is sent before the caller's deadline (see\n+// chasm.activity.longPollBuffer) so that it is likely that the caller does indeed receive the\n+// non-error response.\n+func (h *handler) PollActivityExecution(\n+\tctx context.Context,\n+\treq *activitypb.PollActivityExecutionRequest,\n+) (response *activitypb.PollActivityExecutionResponse, err error) {\n+\tref := chasm.NewComponentRef[*Activity](chasm.EntityKey{\n+\t\tNamespaceID: req.GetNamespaceId(),\n+\t\tBusinessID:  req.GetFrontendRequest().GetActivityId(),\n+\t\tEntityID:    req.GetFrontendRequest().GetRunId(),\n+\t})\n+\tdefer func() {\n+\t\tvar notFound *serviceerror.NotFound\n+\t\tif errors.As(err, &notFound) {\n+\t\t\t// TODO(dan): include execution key in error message; we may do this at the CHASM\n+\t\t\t// framework level.","path":"chasm/lib/activity/handler.go","commit_id":"34b3f8a7f60cc35efeeb40e6870798011c42c1ab","original_commit_id":"8aa718931afd6a83e7694ad3b97cec208dcf61e1","user":{"login":"bergundy","id":52304,"node_id":"MDQ6VXNlcjUyMzA0","avatar_url":"https://avatars.githubusercontent.com/u/52304?v=4","gravatar_id":"","url":"https://api.github.com/users/bergundy","html_url":"https://github.com/bergundy","followers_url":"https://api.github.com/users/bergundy/followers","following_url":"https://api.github.com/users/bergundy/following{/other_user}","gists_url":"https://api.github.com/users/bergundy/gists{/gist_id}","starred_url":"https://api.github.com/users/bergundy/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/bergundy/subscriptions","organizations_url":"https://api.github.com/users/bergundy/orgs","repos_url":"https://api.github.com/users/bergundy/repos","events_url":"https://api.github.com/users/bergundy/events{/privacy}","received_events_url":"https://api.github.com/users/bergundy/received_events","type":"User","user_view_type":"public","site_admin":false},"body":"TBH I don't think this is needed. Not blocking the PR.","created_at":"2025-12-05T00:17:39Z","updated_at":"2025-12-05T00:40:47Z","html_url":"https://github.com/temporalio/temporal/pull/8563#discussion_r2591007095","pull_request_url":"https://api.github.com/repos/temporalio/temporal/pulls/8563","_links":{"self":{"href":"https://api.github.com/repos/temporalio/temporal/pulls/comments/2591007095"},"html":{"href":"https://github.com/temporalio/temporal/pull/8563#discussion_r2591007095"},"pull_request":{"href":"https://api.github.com/repos/temporalio/temporal/pulls/8563"}},"reactions":{"url":"https://api.github.com/repos/temporalio/temporal/pulls/comments/2591007095/reactions","total_count":0,"+1":0,"-1":0,"laugh":0,"hooray":0,"confused":0,"heart":0,"rocket":0,"eyes":0},"start_line":null,"original_start_line":83,"start_side":"RIGHT","line":null,"original_line":84,"side":"RIGHT","author_association":"MEMBER","original_position":53,"position":1,"subject_type":"line"},{"url":"https://api.github.com/repos/temporalio/temporal/pulls/comments/2591011364","pull_request_review_id":3542632205,"id":2591011364,"node_id":"PRRC_kwDODNqesM6ab7Ik","diff_hunk":"@@ -53,3 +59,118 @@ func (h *handler) StartActivityExecution(ctx context.Context, req *activitypb.St\n \t\tFrontendResponse: response,\n \t}, nil\n }\n+\n+// PollActivityExecution handles PollActivityExecutionRequest from frontend. This method supports\n+// querying current activity state, optionally as a long-poll that waits for certain state changes.\n+// It is used by clients to poll for activity state and/or result. When used to long-poll, it\n+// returns an empty non-error response on context deadline expiry, to indicate that the state being\n+// waited for was not reached. Callers should interpret this as an invitation to resubmit their\n+// long-poll request. This response is sent before the caller's deadline (see\n+// chasm.activity.longPollBuffer) so that it is likely that the caller does indeed receive the\n+// non-error response.\n+func (h *handler) PollActivityExecution(\n+\tctx context.Context,\n+\treq *activitypb.PollActivityExecutionRequest,\n+) (response *activitypb.PollActivityExecutionResponse, err error) {\n+\tref := chasm.NewComponentRef[*Activity](chasm.EntityKey{\n+\t\tNamespaceID: req.GetNamespaceId(),\n+\t\tBusinessID:  req.GetFrontendRequest().GetActivityId(),\n+\t\tEntityID:    req.GetFrontendRequest().GetRunId(),\n+\t})\n+\tdefer func() {\n+\t\tvar notFound *serviceerror.NotFound\n+\t\tif errors.As(err, &notFound) {\n+\t\t\t// TODO(dan): include execution key in error message; we may do this at the CHASM\n+\t\t\t// framework level.\n+\t\t\t// cf. \"workflow execution not found for workflow ID XXX and run ID YYY\"\n+\t\t\terr = serviceerror.NewNotFound(\"activity execution not found\")\n+\t\t}\n+\t}()\n+\n+\twaitPolicy := req.GetFrontendRequest().GetWaitPolicy()\n+\n+\tif waitPolicy == nil {\n+\t\treturn chasm.ReadComponent(ctx, ref, (*Activity).buildPollActivityExecutionResponse, req, nil)\n+\t}\n+\n+\t// Below, we send an empty non-error response on context deadline expiry. Here we compute a\n+\t// deadline that causes us to send that response before the caller's own deadline (see\n+\t// chasm.activity.longPollBuffer). We also cap the caller's deadline at\n+\t// chasm.activity.longPollTimeout.\n+\tnamespace := req.GetFrontendRequest().GetNamespace()\n+\tctx, cancel := contextutil.WithDeadlineBuffer(\n+\t\tctx,\n+\t\th.config.LongPollTimeout(namespace),\n+\t\th.config.LongPollBuffer(namespace),\n+\t)\n+\tdefer cancel()\n+\n+\tswitch waitPolicy.(type) {\n+\tcase *workflowservice.PollActivityExecutionRequest_WaitAnyStateChange:\n+\t\ttoken := req.GetFrontendRequest().\n+\t\t\tGetWaitPolicy().(*workflowservice.PollActivityExecutionRequest_WaitAnyStateChange).\n+\t\t\tWaitAnyStateChange.GetLongPollToken()\n+\t\tif len(token) == 0 {\n+\t\t\treturn chasm.ReadComponent(ctx, ref, (*Activity).buildPollActivityExecutionResponse, req, nil)\n+\t\t}","path":"chasm/lib/activity/handler.go","commit_id":"1d59e66d0ce5d91819f92c428ef5ab4c4efca1fb","original_commit_id":"8aa718931afd6a83e7694ad3b97cec208dcf61e1","user":{"login":"bergundy","id":52304,"node_id":"MDQ6VXNlcjUyMzA0","avatar_url":"https://avatars.githubusercontent.com/u/52304?v=4","gravatar_id":"","url":"https://api.github.com/users/bergundy","html_url":"https://github.com/bergundy","followers_url":"https://api.github.com/users/bergundy/followers","following_url":"https://api.github.com/users/bergundy/following{/other_user}","gists_url":"https://api.github.com/users/bergundy/gists{/gist_id}","starred_url":"https://api.github.com/users/bergundy/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/bergundy/subscriptions","organizations_url":"https://api.github.com/users/bergundy/orgs","repos_url":"https://api.github.com/users/bergundy/repos","events_url":"https://api.github.com/users/bergundy/events{/privacy}","received_events_url":"https://api.github.com/users/bergundy/received_events","type":"User","user_view_type":"public","site_admin":false},"body":"This seems more like an invalid argument to me.","created_at":"2025-12-05T00:19:52Z","updated_at":"2025-12-05T00:40:47Z","html_url":"https://github.com/temporalio/temporal/pull/8563#discussion_r2591011364","pull_request_url":"https://api.github.com/repos/temporalio/temporal/pulls/8563","_links":{"self":{"href":"https://api.github.com/repos/temporalio/temporal/pulls/comments/2591011364"},"html":{"href":"https://github.com/temporalio/temporal/pull/8563#discussion_r2591011364"},"pull_request":{"href":"https://api.github.com/repos/temporalio/temporal/pulls/8563"}},"reactions":{"url":"https://api.github.com/repos/temporalio/temporal/pulls/comments/2591011364/reactions","total_count":0,"+1":0,"-1":0,"laugh":0,"hooray":0,"confused":0,"heart":0,"rocket":0,"eyes":0},"start_line":110,"original_start_line":113,"start_side":"RIGHT","line":112,"original_line":115,"side":"RIGHT","author_association":"MEMBER","original_position":84,"position":81,"subject_type":"line"},{"url":"https://api.github.com/repos/temporalio/temporal/pulls/comments/2591014557","pull_request_review_id":3542632205,"id":2591014557,"node_id":"PRRC_kwDODNqesM6ab76d","diff_hunk":"@@ -53,3 +59,118 @@ func (h *handler) StartActivityExecution(ctx context.Context, req *activitypb.St\n \t\tFrontendResponse: response,\n \t}, nil\n }\n+\n+// PollActivityExecution handles PollActivityExecutionRequest from frontend. This method supports\n+// querying current activity state, optionally as a long-poll that waits for certain state changes.\n+// It is used by clients to poll for activity state and/or result. When used to long-poll, it\n+// returns an empty non-error response on context deadline expiry, to indicate that the state being\n+// waited for was not reached. Callers should interpret this as an invitation to resubmit their\n+// long-poll request. This response is sent before the caller's deadline (see\n+// chasm.activity.longPollBuffer) so that it is likely that the caller does indeed receive the\n+// non-error response.\n+func (h *handler) PollActivityExecution(\n+\tctx context.Context,\n+\treq *activitypb.PollActivityExecutionRequest,\n+) (response *activitypb.PollActivityExecutionResponse, err error) {\n+\tref := chasm.NewComponentRef[*Activity](chasm.EntityKey{\n+\t\tNamespaceID: req.GetNamespaceId(),\n+\t\tBusinessID:  req.GetFrontendRequest().GetActivityId(),\n+\t\tEntityID:    req.GetFrontendRequest().GetRunId(),\n+\t})\n+\tdefer func() {\n+\t\tvar notFound *serviceerror.NotFound\n+\t\tif errors.As(err, &notFound) {\n+\t\t\t// TODO(dan): include execution key in error message; we may do this at the CHASM\n+\t\t\t// framework level.\n+\t\t\t// cf. \"workflow execution not found for workflow ID XXX and run ID YYY\"\n+\t\t\terr = serviceerror.NewNotFound(\"activity execution not found\")\n+\t\t}\n+\t}()\n+\n+\twaitPolicy := req.GetFrontendRequest().GetWaitPolicy()\n+\n+\tif waitPolicy == nil {\n+\t\treturn chasm.ReadComponent(ctx, ref, (*Activity).buildPollActivityExecutionResponse, req, nil)\n+\t}\n+\n+\t// Below, we send an empty non-error response on context deadline expiry. Here we compute a\n+\t// deadline that causes us to send that response before the caller's own deadline (see\n+\t// chasm.activity.longPollBuffer). We also cap the caller's deadline at\n+\t// chasm.activity.longPollTimeout.\n+\tnamespace := req.GetFrontendRequest().GetNamespace()\n+\tctx, cancel := contextutil.WithDeadlineBuffer(\n+\t\tctx,\n+\t\th.config.LongPollTimeout(namespace),\n+\t\th.config.LongPollBuffer(namespace),\n+\t)\n+\tdefer cancel()\n+\n+\tswitch waitPolicy.(type) {","path":"chasm/lib/activity/handler.go","commit_id":"34b3f8a7f60cc35efeeb40e6870798011c42c1ab","original_commit_id":"8aa718931afd6a83e7694ad3b97cec208dcf61e1","user":{"login":"bergundy","id":52304,"node_id":"MDQ6VXNlcjUyMzA0","avatar_url":"https://avatars.githubusercontent.com/u/52304?v=4","gravatar_id":"","url":"https://api.github.com/users/bergundy","html_url":"https://github.com/bergundy","followers_url":"https://api.github.com/users/bergundy/followers","following_url":"https://api.github.com/users/bergundy/following{/other_user}","gists_url":"https://api.github.com/users/bergundy/gists{/gist_id}","starred_url":"https://api.github.com/users/bergundy/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/bergundy/subscriptions","organizations_url":"https://api.github.com/users/bergundy/orgs","repos_url":"https://api.github.com/users/bergundy/repos","events_url":"https://api.github.com/users/bergundy/events{/privacy}","received_events_url":"https://api.github.com/users/bergundy/received_events","type":"User","user_view_type":"public","site_admin":false},"body":"nitpicking since we are getting rid of this but you can save the casts below with this:\n\n```suggestion\n\tswitch waitPolicyType := waitPolicy.(type) {\n```","created_at":"2025-12-05T00:21:53Z","updated_at":"2025-12-05T00:40:47Z","html_url":"https://github.com/temporalio/temporal/pull/8563#discussion_r2591014557","pull_request_url":"https://api.github.com/repos/temporalio/temporal/pulls/8563","_links":{"self":{"href":"https://api.github.com/repos/temporalio/temporal/pulls/comments/2591014557"},"html":{"href":"https://github.com/temporalio/temporal/pull/8563#discussion_r2591014557"},"pull_request":{"href":"https://api.github.com/repos/temporalio/temporal/pulls/8563"}},"reactions":{"url":"https://api.github.com/repos/temporalio/temporal/pulls/comments/2591014557/reactions","total_count":1,"+1":1,"-1":0,"laugh":0,"hooray":0,"confused":0,"heart":0,"rocket":0,"eyes":0},"start_line":null,"original_start_line":null,"start_side":null,"line":null,"original_line":108,"side":"RIGHT","author_association":"MEMBER","original_position":77,"position":1,"subject_type":"line"},{"url":"https://api.github.com/repos/temporalio/temporal/pulls/comments/2591017777","pull_request_review_id":3542632205,"id":2591017777,"node_id":"PRRC_kwDODNqesM6ab8sx","diff_hunk":"@@ -234,18 +241,18 @@ func ReadComponent[C Component, R []byte | ComponentRef, I any, O any](\n \treturn output, err\n }\n \n-type PollComponentRequest[C Component, I any, O any] struct {\n-\tRef         ComponentRef\n-\tPredicateFn func(C, Context, I) bool\n-\tOperationFn func(C, MutableContext, I) (O, error)\n-\tInput       I\n-}\n-\n-func PollComponent[C Component, R []byte | ComponentRef, I any, O any, T any](\n+// PollComponent waits until the predicate is true when evaluated against the component identified\n+// by the supplied component reference. If this times out due to a server-imposed long-poll timeout\n+// then it returns (nil, nil, nil), as an indication that the caller should continue long-polling.\n+// Otherwise it returns (output, ref, err), where output is the output of the predicate function,\n+// and ref is a component reference identifying the state at which the predicate was satisfied. The\n+// predicate must be monotonic: if it returns true at execution state transition s then it must\n+// return true at all transitions t > s. If the predicate is true at the outset then PollComponent\n+// returns immediately. opts are currently ignored.\n+func PollComponent[C Component, R []byte | ComponentRef, I any, O any](\n \tctx context.Context,\n \tr R,\n-\tpredicateFn func(C, Context, I) (T, bool, error),\n-\toperationFn func(C, MutableContext, I, T) (O, error),\n+\tmonotonicPredicate func(C, Context, I) (O, bool, error),\n \tinput I,\n \topts ...TransitionOption,","path":"chasm/engine.go","commit_id":"1d59e66d0ce5d91819f92c428ef5ab4c4efca1fb","original_commit_id":"8aa718931afd6a83e7694ad3b97cec208dcf61e1","user":{"login":"bergundy","id":52304,"node_id":"MDQ6VXNlcjUyMzA0","avatar_url":"https://avatars.githubusercontent.com/u/52304?v=4","gravatar_id":"","url":"https://api.github.com/users/bergundy","html_url":"https://github.com/bergundy","followers_url":"https://api.github.com/users/bergundy/followers","following_url":"https://api.github.com/users/bergundy/following{/other_user}","gists_url":"https://api.github.com/users/bergundy/gists{/gist_id}","starred_url":"https://api.github.com/users/bergundy/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/bergundy/subscriptions","organizations_url":"https://api.github.com/users/bergundy/orgs","repos_url":"https://api.github.com/users/bergundy/repos","events_url":"https://api.github.com/users/bergundy/events{/privacy}","received_events_url":"https://api.github.com/users/bergundy/received_events","type":"User","user_view_type":"public","site_admin":false},"body":"We can get rid of the transition options right?","created_at":"2025-12-05T00:24:18Z","updated_at":"2025-12-05T00:40:47Z","html_url":"https://github.com/temporalio/temporal/pull/8563#discussion_r2591017777","pull_request_url":"https://api.github.com/repos/temporalio/temporal/pulls/8563","_links":{"self":{"href":"https://api.github.com/repos/temporalio/temporal/pulls/comments/2591017777"},"html":{"href":"https://github.com/temporalio/temporal/pull/8563#discussion_r2591017777"},"pull_request":{"href":"https://api.github.com/repos/temporalio/temporal/pulls/8563"}},"reactions":{"url":"https://api.github.com/repos/temporalio/temporal/pulls/comments/2591017777/reactions","total_count":0,"+1":0,"-1":0,"laugh":0,"hooray":0,"confused":0,"heart":0,"rocket":0,"eyes":0},"start_line":null,"original_start_line":null,"start_side":null,"line":257,"original_line":257,"side":"RIGHT","author_association":"MEMBER","original_position":61,"position":61,"subject_type":"line"},{"url":"https://api.github.com/repos/temporalio/temporal/pulls/comments/2591022326","pull_request_review_id":3542632205,"id":2591022326,"node_id":"PRRC_kwDODNqesM6ab9z2","diff_hunk":"@@ -56,9 +57,10 @@ var defaultTransitionOptions = chasm.TransitionOptions{\n }\n \n var ChasmEngineModule = fx.Options(\n+\tfx.Provide(NewChasmNotifier),\n \tfx.Provide(newChasmEngine),\n \tfx.Provide(func(impl *ChasmEngine) chasm.Engine { return impl }),\n-\tfx.Invoke(func(impl *ChasmEngine, shardController shard.Controller) {\n+\tfx.Invoke(func(lc fx.Lifecycle, impl *ChasmEngine, shardController shard.Controller) {","path":"service/history/chasm_engine.go","commit_id":"ba38880058f288839d9fd74d46b7ac8dbc549f5c","original_commit_id":"8aa718931afd6a83e7694ad3b97cec208dcf61e1","user":{"login":"bergundy","id":52304,"node_id":"MDQ6VXNlcjUyMzA0","avatar_url":"https://avatars.githubusercontent.com/u/52304?v=4","gravatar_id":"","url":"https://api.github.com/users/bergundy","html_url":"https://github.com/bergundy","followers_url":"https://api.github.com/users/bergundy/followers","following_url":"https://api.github.com/users/bergundy/following{/other_user}","gists_url":"https://api.github.com/users/bergundy/gists{/gist_id}","starred_url":"https://api.github.com/users/bergundy/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/bergundy/subscriptions","organizations_url":"https://api.github.com/users/bergundy/orgs","repos_url":"https://api.github.com/users/bergundy/repos","events_url":"https://api.github.com/users/bergundy/events{/privacy}","received_events_url":"https://api.github.com/users/bergundy/received_events","type":"User","user_view_type":"public","site_admin":false},"body":"Doesn't seem like you need `lc` anymore.","created_at":"2025-12-05T00:27:14Z","updated_at":"2025-12-05T00:40:47Z","html_url":"https://github.com/temporalio/temporal/pull/8563#discussion_r2591022326","pull_request_url":"https://api.github.com/repos/temporalio/temporal/pulls/8563","_links":{"self":{"href":"https://api.github.com/repos/temporalio/temporal/pulls/comments/2591022326"},"html":{"href":"https://github.com/temporalio/temporal/pull/8563#discussion_r2591022326"},"pull_request":{"href":"https://api.github.com/repos/temporalio/temporal/pulls/8563"}},"reactions":{"url":"https://api.github.com/repos/temporalio/temporal/pulls/comments/2591022326/reactions","total_count":0,"+1":0,"-1":0,"laugh":0,"hooray":0,"confused":0,"heart":0,"rocket":0,"eyes":0},"start_line":null,"original_start_line":null,"start_side":null,"line":null,"original_line":63,"side":"RIGHT","author_association":"MEMBER","original_position":16,"position":1,"subject_type":"line"},{"url":"https://api.github.com/repos/temporalio/temporal/pulls/comments/2591025082","pull_request_review_id":3542632205,"id":2591025082,"node_id":"PRRC_kwDODNqesM6ab-e6","diff_hunk":"@@ -241,14 +256,122 @@ func (e *ChasmEngine) ReadComponent(\n \treturn readFn(chasmContext, component)\n }\n \n+// PollComponent waits until the supplied predicate is satisfied when evaluated against the\n+// component identified by the supplied component reference. If there is no error, it returns (ref,\n+// nil) where ref is a component reference identifying the state at which the predicate was\n+// satisfied. It's possible that multiple state transitions (multiple notifications) occur between\n+// predicate checks, therefore the predicate must be monotonic: if it returns true at execution\n+// state transition s it must return true at all transitions t > s. It is an error if execution\n+// transition history is (after reloading from persistence) behind the requested ref, or if the ref\n+// is inconsistent with execution transition history. Thus when the predicate function is evaluated,\n+// it is guaranteed that the execution VT >= requestRef VT. opts are currently ignored.\n+// PollComponent subscribes to execution-level notifications. Suppose that an execution consists of\n+// one component A, and A has subcomponent B. Subscribers interested only in component B may be\n+// woken up unnecessarily (and thus evaluate the predicate unnecessarily) due to changes in parts of\n+// A that do not also belong to B.\n func (e *ChasmEngine) PollComponent(\n \tctx context.Context,\n-\tentityRef chasm.ComponentRef,\n-\tpredicateFn func(chasm.Context, chasm.Component) (any, bool, error),\n-\toperationFn func(chasm.MutableContext, chasm.Component, any) error,\n+\trequestRef chasm.ComponentRef,\n+\tmonotonicPredicate func(chasm.Context, chasm.Component) (bool, error),\n \topts ...chasm.TransitionOption,\n-) (newEntityRef []byte, retError error) {\n-\treturn nil, serviceerror.NewUnimplemented(\"PollComponent is not yet supported\")\n+) (retRef []byte, retError error) {\n+\n+\tvar ch <-chan struct{}\n+\tvar unsubscribe func()\n+\tdefer func() {\n+\t\tif unsubscribe != nil {\n+\t\t\tunsubscribe()\n+\t\t}\n+\t}()\n+\n+\tcheckPredicateOrSubscribe := func() ([]byte, error) {\n+\t\t_, executionLease, err := e.getExecutionLease(ctx, requestRef)\n+\t\tif err != nil {\n+\t\t\treturn nil, err\n+\t\t}\n+\t\tdefer executionLease.GetReleaseFn()(nil)\n+\n+\t\tref, err := e.predicateSatisfied(ctx, monotonicPredicate, requestRef, executionLease)\n+\t\tif err != nil {\n+\t\t\tif errors.Is(err, consts.ErrStaleState) {\n+\t\t\t\terr = serviceerror.NewUnavailable(\"please retry\")\n+\t\t\t}\n+\t\t\treturn nil, err\n+\t\t}\n+\t\tif ref != nil {\n+\t\t\treturn ref, nil\n+\t\t}\n+\t\t// Predicate not satisfied; subscribe before releasing the lock.\n+\t\tch, unsubscribe = e.notifier.Subscribe(requestRef.EntityKey)\n+\t\treturn nil, nil\n+\t}\n+\n+\tref, err := checkPredicateOrSubscribe()\n+\tif err != nil {\n+\t\treturn nil, err\n+\t}\n+\tif ref != nil {\n+\t\treturn ref, nil\n+\t}","path":"service/history/chasm_engine.go","commit_id":"4a3e8c304826f22c266c8a1e4c32f59b7d0e51a5","original_commit_id":"8aa718931afd6a83e7694ad3b97cec208dcf61e1","user":{"login":"bergundy","id":52304,"node_id":"MDQ6VXNlcjUyMzA0","avatar_url":"https://avatars.githubusercontent.com/u/52304?v=4","gravatar_id":"","url":"https://api.github.com/users/bergundy","html_url":"https://github.com/bergundy","followers_url":"https://api.github.com/users/bergundy/followers","following_url":"https://api.github.com/users/bergundy/following{/other_user}","gists_url":"https://api.github.com/users/bergundy/gists{/gist_id}","starred_url":"https://api.github.com/users/bergundy/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/bergundy/subscriptions","organizations_url":"https://api.github.com/users/bergundy/orgs","repos_url":"https://api.github.com/users/bergundy/repos","events_url":"https://api.github.com/users/bergundy/events{/privacy}","received_events_url":"https://api.github.com/users/bergundy/received_events","type":"User","user_view_type":"public","site_admin":false},"body":"```suggestion\n\tif err != nil || ref != nil {\n\t\treturn ref, err\n\t}\n```","created_at":"2025-12-05T00:29:16Z","updated_at":"2025-12-05T00:40:47Z","html_url":"https://github.com/temporalio/temporal/pull/8563#discussion_r2591025082","pull_request_url":"https://api.github.com/repos/temporalio/temporal/pulls/8563","_links":{"self":{"href":"https://api.github.com/repos/temporalio/temporal/pulls/comments/2591025082"},"html":{"href":"https://github.com/temporalio/temporal/pull/8563#discussion_r2591025082"},"pull_request":{"href":"https://api.github.com/repos/temporalio/temporal/pulls/8563"}},"reactions":{"url":"https://api.github.com/repos/temporalio/temporal/pulls/comments/2591025082/reactions","total_count":0,"+1":0,"-1":0,"laugh":0,"hooray":0,"confused":0,"heart":0,"rocket":0,"eyes":0},"start_line":null,"original_start_line":310,"start_side":"RIGHT","line":null,"original_line":315,"side":"RIGHT","author_association":"MEMBER","original_position":131,"position":1,"subject_type":"line"},{"url":"https://api.github.com/repos/temporalio/temporal/pulls/comments/2591026948","pull_request_review_id":3542658570,"id":2591026948,"node_id":"PRRC_kwDODNqesM6ab-8E","diff_hunk":"@@ -53,3 +59,118 @@ func (h *handler) StartActivityExecution(ctx context.Context, req *activitypb.St\n \t\tFrontendResponse: response,\n \t}, nil\n }\n+\n+// PollActivityExecution handles PollActivityExecutionRequest from frontend. This method supports\n+// querying current activity state, optionally as a long-poll that waits for certain state changes.\n+// It is used by clients to poll for activity state and/or result. When used to long-poll, it\n+// returns an empty non-error response on context deadline expiry, to indicate that the state being\n+// waited for was not reached. Callers should interpret this as an invitation to resubmit their\n+// long-poll request. This response is sent before the caller's deadline (see\n+// chasm.activity.longPollBuffer) so that it is likely that the caller does indeed receive the\n+// non-error response.\n+func (h *handler) PollActivityExecution(\n+\tctx context.Context,\n+\treq *activitypb.PollActivityExecutionRequest,\n+) (response *activitypb.PollActivityExecutionResponse, err error) {\n+\tref := chasm.NewComponentRef[*Activity](chasm.EntityKey{\n+\t\tNamespaceID: req.GetNamespaceId(),\n+\t\tBusinessID:  req.GetFrontendRequest().GetActivityId(),\n+\t\tEntityID:    req.GetFrontendRequest().GetRunId(),\n+\t})\n+\tdefer func() {\n+\t\tvar notFound *serviceerror.NotFound\n+\t\tif errors.As(err, &notFound) {\n+\t\t\t// TODO(dan): include execution key in error message; we may do this at the CHASM\n+\t\t\t// framework level.\n+\t\t\t// cf. \"workflow execution not found for workflow ID XXX and run ID YYY\"\n+\t\t\terr = serviceerror.NewNotFound(\"activity execution not found\")\n+\t\t}\n+\t}()\n+\n+\twaitPolicy := req.GetFrontendRequest().GetWaitPolicy()\n+\n+\tif waitPolicy == nil {\n+\t\treturn chasm.ReadComponent(ctx, ref, (*Activity).buildPollActivityExecutionResponse, req, nil)\n+\t}\n+\n+\t// Below, we send an empty non-error response on context deadline expiry. Here we compute a\n+\t// deadline that causes us to send that response before the caller's own deadline (see\n+\t// chasm.activity.longPollBuffer). We also cap the caller's deadline at\n+\t// chasm.activity.longPollTimeout.\n+\tnamespace := req.GetFrontendRequest().GetNamespace()\n+\tctx, cancel := contextutil.WithDeadlineBuffer(\n+\t\tctx,\n+\t\th.config.LongPollTimeout(namespace),\n+\t\th.config.LongPollBuffer(namespace),\n+\t)\n+\tdefer cancel()\n+\n+\tswitch waitPolicy.(type) {\n+\tcase *workflowservice.PollActivityExecutionRequest_WaitAnyStateChange:\n+\t\ttoken := req.GetFrontendRequest().\n+\t\t\tGetWaitPolicy().(*workflowservice.PollActivityExecutionRequest_WaitAnyStateChange).\n+\t\t\tWaitAnyStateChange.GetLongPollToken()\n+\t\tif len(token) == 0 {\n+\t\t\treturn chasm.ReadComponent(ctx, ref, (*Activity).buildPollActivityExecutionResponse, req, nil)\n+\t\t}\n+\t\tresponse, _, err = chasm.PollComponent(ctx, ref, func(\n+\t\t\ta *Activity,\n+\t\t\tctx chasm.Context,\n+\t\t\treq *activitypb.PollActivityExecutionRequest,\n+\t\t) (*activitypb.PollActivityExecutionResponse, bool, error) {\n+\t\t\tchanged, err := chasm.ExecutionStateChanged(a, ctx, token)\n+\t\t\tif err != nil {\n+\t\t\t\tif errors.Is(err, chasm.ErrMalformedComponentRef) {\n+\t\t\t\t\treturn nil, false, serviceerror.NewInvalidArgument(\"invalid long poll token\")\n+\t\t\t\t}\n+\t\t\t\tif errors.Is(err, chasm.ErrInvalidComponentRef) {\n+\t\t\t\t\treturn nil, false, serviceerror.NewInvalidArgument(\"long poll token does not match execution\")\n+\t\t\t\t}\n+\t\t\t\treturn nil, false, err\n+\t\t\t}\n+\t\t\tif changed {\n+\t\t\t\tresponse, err := a.buildPollActivityExecutionResponse(ctx, req)\n+\t\t\t\treturn response, true, err\n+\t\t\t} else {\n+\t\t\t\treturn nil, false, nil\n+\t\t\t}\n+\t\t}, req)\n+\tcase *workflowservice.PollActivityExecutionRequest_WaitCompletion:\n+\t\t// TODO(dan): add functional test when RecordActivityTaskCompleted is implemented\n+\t\tresponse, _, err = chasm.PollComponent(ctx, ref, func(\n+\t\t\ta *Activity,\n+\t\t\tctx chasm.Context,\n+\t\t\treq *activitypb.PollActivityExecutionRequest,\n+\t\t) (*activitypb.PollActivityExecutionResponse, bool, error) {\n+\t\t\t// TODO(dan): check for terminal activity states\n+\t\t\tpanic(\"pollActivityExecutionWaitCompletion is not implemented\")\n+\t\t\tcompleted := false\n+\t\t\tif completed {\n+\t\t\t\tresponse, err := a.buildPollActivityExecutionResponse(ctx, req)\n+\t\t\t\tif err != nil {\n+\t\t\t\t\treturn nil, true, err\n+\t\t\t\t}\n+\t\t\t\treturn response, true, nil\n+\t\t\t}\n+\t\t\treturn nil, false, nil\n+\t\t}, req)\n+\tdefault:\n+\t\treturn nil, serviceerror.NewInvalidArgumentf(\"unexpected wait policy type: %T\", waitPolicy)\n+\t}\n+\n+\tif ctx.Err() != nil {\n+\t\t// We send an empty non-error response on deadline expiry as an invitation to the caller to\n+\t\t// resubmit their long-poll.\n+\n+\t\t// TODO(dan): the definition of \"empty\" is unclear, since callers can currently choose to\n+\t\t// exclude info, outcome, and input from the result. Currently, a caller can infer that the\n+\t\t// long-poll timed out due to a server-imposed timeout from the absence of the long-poll\n+\t\t// token. However, this is not a clear API. We are considering splitting the public API into\n+\t\t// two methods: one that returns info (optionally with input), and one that returns result,\n+\t\t// both with long-poll options. An empty response will then be more obvious to the caller.\n+\t\treturn &activitypb.PollActivityExecutionResponse{\n+\t\t\tFrontendResponse: &workflowservice.PollActivityExecutionResponse{},\n+\t\t}, nil\n+\t}","path":"chasm/lib/activity/handler.go","commit_id":"1d59e66d0ce5d91819f92c428ef5ab4c4efca1fb","original_commit_id":"4a8b8417884580e27819b1b1215b4cd7551e70d8","user":{"login":"dandavison","id":52205,"node_id":"MDQ6VXNlcjUyMjA1","avatar_url":"https://avatars.githubusercontent.com/u/52205?v=4","gravatar_id":"","url":"https://api.github.com/users/dandavison","html_url":"https://github.com/dandavison","followers_url":"https://api.github.com/users/dandavison/followers","following_url":"https://api.github.com/users/dandavison/following{/other_user}","gists_url":"https://api.github.com/users/dandavison/gists{/gist_id}","starred_url":"https://api.github.com/users/dandavison/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/dandavison/subscriptions","organizations_url":"https://api.github.com/users/dandavison/orgs","repos_url":"https://api.github.com/users/dandavison/repos","events_url":"https://api.github.com/users/dandavison/events{/privacy}","received_events_url":"https://api.github.com/users/dandavison/received_events","type":"User","user_view_type":"public","site_admin":false},"body":"### (1)\r\nIt's a reasonable question to raise. `PollComponent` is (currently) read-only, so even if this does happen, the caller should resubmit and it will return their desired state on their next call. However, I'm interested to know whether @bergundy thinks `if response == nil && if ctx.Err() != nil` is better.\r\n\r\n### (2)\r\nYes, perhaps we should return non-nil `err` before checking `ctx.Err()`.\r\n\r\n> (checking if it's context.DeadlineExceeded or context.Canceled) rather than polling ctx.Err() directly.\r\n\r\nWe decided that we do not want to do that; the caller should not rely on the called function to return those errors; it can monitor the context it passes to the child itself. ","created_at":"2025-12-05T00:30:39Z","updated_at":"2025-12-05T00:30:39Z","html_url":"https://github.com/temporalio/temporal/pull/8563#discussion_r2591026948","pull_request_url":"https://api.github.com/repos/temporalio/temporal/pulls/8563","_links":{"self":{"href":"https://api.github.com/repos/temporalio/temporal/pulls/comments/2591026948"},"html":{"href":"https://github.com/temporalio/temporal/pull/8563#discussion_r2591026948"},"pull_request":{"href":"https://api.github.com/repos/temporalio/temporal/pulls/8563"}},"reactions":{"url":"https://api.github.com/repos/temporalio/temporal/pulls/comments/2591026948/reactions","total_count":0,"+1":0,"-1":0,"laugh":0,"hooray":0,"confused":0,"heart":0,"rocket":0,"eyes":0},"start_line":null,"original_start_line":null,"start_side":null,"line":170,"original_line":174,"side":"RIGHT","in_reply_to_id":2587049516,"author_association":"MEMBER","original_position":143,"position":139,"subject_type":"line"},{"url":"https://api.github.com/repos/temporalio/temporal/pulls/comments/2591028863","pull_request_review_id":3542632205,"id":2591028863,"node_id":"PRRC_kwDODNqesM6ab_Z_","diff_hunk":"@@ -0,0 +1,65 @@\n+package history\n+\n+import (\n+\t\"sync\"\n+\n+\t\"go.temporal.io/server/chasm\"\n+)\n+\n+type (\n+\t// ChasmNotifier allows subscribers to receive notifications relating to a CHASM execution.\n+\tChasmNotifier struct {\n+\t\texecutions map[chasm.EntityKey]*subscriptionTracker\n+\t\tlock       sync.Mutex\n+\t}\n+\n+\tsubscriptionTracker struct {\n+\t\tch             chan struct{}\n+\t\tnumSubscribers int\n+\t}\n+)","path":"service/history/chasm_notifier.go","commit_id":"ba38880058f288839d9fd74d46b7ac8dbc549f5c","original_commit_id":"8aa718931afd6a83e7694ad3b97cec208dcf61e1","user":{"login":"bergundy","id":52304,"node_id":"MDQ6VXNlcjUyMzA0","avatar_url":"https://avatars.githubusercontent.com/u/52304?v=4","gravatar_id":"","url":"https://api.github.com/users/bergundy","html_url":"https://github.com/bergundy","followers_url":"https://api.github.com/users/bergundy/followers","following_url":"https://api.github.com/users/bergundy/following{/other_user}","gists_url":"https://api.github.com/users/bergundy/gists{/gist_id}","starred_url":"https://api.github.com/users/bergundy/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/bergundy/subscriptions","organizations_url":"https://api.github.com/users/bergundy/orgs","repos_url":"https://api.github.com/users/bergundy/repos","events_url":"https://api.github.com/users/bergundy/events{/privacy}","received_events_url":"https://api.github.com/users/bergundy/received_events","type":"User","user_view_type":"public","site_admin":false},"body":"nit: Define each type separately and put its methods below it. That's standard in Go, not in this codebase unfortunately.","created_at":"2025-12-05T00:32:00Z","updated_at":"2025-12-05T00:40:47Z","html_url":"https://github.com/temporalio/temporal/pull/8563#discussion_r2591028863","pull_request_url":"https://api.github.com/repos/temporalio/temporal/pulls/8563","_links":{"self":{"href":"https://api.github.com/repos/temporalio/temporal/pulls/comments/2591028863"},"html":{"href":"https://github.com/temporalio/temporal/pull/8563#discussion_r2591028863"},"pull_request":{"href":"https://api.github.com/repos/temporalio/temporal/pulls/8563"}},"reactions":{"url":"https://api.github.com/repos/temporalio/temporal/pulls/comments/2591028863/reactions","total_count":0,"+1":0,"-1":0,"laugh":0,"hooray":0,"confused":0,"heart":0,"rocket":0,"eyes":0},"start_line":null,"original_start_line":9,"start_side":"RIGHT","line":null,"original_line":20,"side":"RIGHT","author_association":"MEMBER","original_position":20,"position":1,"subject_type":"line"},{"url":"https://api.github.com/repos/temporalio/temporal/pulls/comments/2591030815","pull_request_review_id":3542632205,"id":2591030815,"node_id":"PRRC_kwDODNqesM6ab_4f","diff_hunk":"@@ -0,0 +1,65 @@\n+package history\n+\n+import (\n+\t\"sync\"\n+\n+\t\"go.temporal.io/server/chasm\"\n+)\n+\n+type (\n+\t// ChasmNotifier allows subscribers to receive notifications relating to a CHASM execution.\n+\tChasmNotifier struct {\n+\t\texecutions map[chasm.EntityKey]*subscriptionTracker\n+\t\tlock       sync.Mutex\n+\t}\n+\n+\tsubscriptionTracker struct {\n+\t\tch             chan struct{}\n+\t\tnumSubscribers int\n+\t}\n+)\n+\n+// NewChasmNotifier creates a new instance of ChasmNotifier.\n+func NewChasmNotifier() *ChasmNotifier {\n+\treturn &ChasmNotifier{\n+\t\texecutions: make(map[chasm.EntityKey]*subscriptionTracker),\n+\t}\n+}\n+\n+// Subscribe returns a channel that will be closed when there is a notification relating to the\n+// execution, along with an unsubscribe function. No data will be written to the channel: on\n+// notification, the caller should determine whether the execution state they are waiting for has\n+// been reached and resubscribe if necessary, while holding a lock on the execution. The caller must\n+// arrange for the unsubscribe function to be called when they have finished monitoring the channel\n+// for notifications. It is safe to call the unsubscribe function multiple times and concurrently.\n+func (n *ChasmNotifier) Subscribe(key chasm.EntityKey) (<-chan struct{}, func()) {\n+\tn.lock.Lock()\n+\tdefer n.lock.Unlock()\n+\ts, ok := n.executions[key]\n+\tif !ok {\n+\t\ts = &subscriptionTracker{ch: make(chan struct{})}\n+\t}\n+\tn.executions[key] = s","path":"service/history/chasm_notifier.go","commit_id":"ba38880058f288839d9fd74d46b7ac8dbc549f5c","original_commit_id":"8aa718931afd6a83e7694ad3b97cec208dcf61e1","user":{"login":"bergundy","id":52304,"node_id":"MDQ6VXNlcjUyMzA0","avatar_url":"https://avatars.githubusercontent.com/u/52304?v=4","gravatar_id":"","url":"https://api.github.com/users/bergundy","html_url":"https://github.com/bergundy","followers_url":"https://api.github.com/users/bergundy/followers","following_url":"https://api.github.com/users/bergundy/following{/other_user}","gists_url":"https://api.github.com/users/bergundy/gists{/gist_id}","starred_url":"https://api.github.com/users/bergundy/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/bergundy/subscriptions","organizations_url":"https://api.github.com/users/bergundy/orgs","repos_url":"https://api.github.com/users/bergundy/repos","events_url":"https://api.github.com/users/bergundy/events{/privacy}","received_events_url":"https://api.github.com/users/bergundy/received_events","type":"User","user_view_type":"public","site_admin":false},"body":"```suggestion\n\tif !ok {\n\t\ts = &subscriptionTracker{ch: make(chan struct{})}\n\t\tn.executions[key] = s\n\t}\n```","created_at":"2025-12-05T00:33:25Z","updated_at":"2025-12-05T00:40:47Z","html_url":"https://github.com/temporalio/temporal/pull/8563#discussion_r2591030815","pull_request_url":"https://api.github.com/repos/temporalio/temporal/pulls/8563","_links":{"self":{"href":"https://api.github.com/repos/temporalio/temporal/pulls/comments/2591030815"},"html":{"href":"https://github.com/temporalio/temporal/pull/8563#discussion_r2591030815"},"pull_request":{"href":"https://api.github.com/repos/temporalio/temporal/pulls/8563"}},"reactions":{"url":"https://api.github.com/repos/temporalio/temporal/pulls/comments/2591030815/reactions","total_count":1,"+1":1,"-1":0,"laugh":0,"hooray":0,"confused":0,"heart":0,"rocket":0,"eyes":0},"start_line":null,"original_start_line":39,"start_side":"RIGHT","line":null,"original_line":42,"side":"RIGHT","author_association":"MEMBER","original_position":42,"position":1,"subject_type":"line"},{"url":"https://api.github.com/repos/temporalio/temporal/pulls/comments/2591033572","pull_request_review_id":3542632205,"id":2591033572,"node_id":"PRRC_kwDODNqesM6acAjk","diff_hunk":"@@ -0,0 +1,65 @@\n+package history\n+\n+import (\n+\t\"sync\"\n+\n+\t\"go.temporal.io/server/chasm\"\n+)\n+\n+type (\n+\t// ChasmNotifier allows subscribers to receive notifications relating to a CHASM execution.\n+\tChasmNotifier struct {\n+\t\texecutions map[chasm.EntityKey]*subscriptionTracker\n+\t\tlock       sync.Mutex\n+\t}\n+\n+\tsubscriptionTracker struct {\n+\t\tch             chan struct{}\n+\t\tnumSubscribers int\n+\t}\n+)\n+\n+// NewChasmNotifier creates a new instance of ChasmNotifier.\n+func NewChasmNotifier() *ChasmNotifier {\n+\treturn &ChasmNotifier{\n+\t\texecutions: make(map[chasm.EntityKey]*subscriptionTracker),\n+\t}\n+}\n+\n+// Subscribe returns a channel that will be closed when there is a notification relating to the\n+// execution, along with an unsubscribe function. No data will be written to the channel: on\n+// notification, the caller should determine whether the execution state they are waiting for has\n+// been reached and resubscribe if necessary, while holding a lock on the execution. The caller must\n+// arrange for the unsubscribe function to be called when they have finished monitoring the channel\n+// for notifications. It is safe to call the unsubscribe function multiple times and concurrently.\n+func (n *ChasmNotifier) Subscribe(key chasm.EntityKey) (<-chan struct{}, func()) {\n+\tn.lock.Lock()\n+\tdefer n.lock.Unlock()\n+\ts, ok := n.executions[key]\n+\tif !ok {\n+\t\ts = &subscriptionTracker{ch: make(chan struct{})}\n+\t}\n+\tn.executions[key] = s\n+\ts.numSubscribers++\n+\treturn s.ch, sync.OnceFunc(func() {\n+\t\tn.lock.Lock()\n+\t\tdefer n.lock.Unlock()\n+\t\tif n.executions[key] == s {\n+\t\t\ts.numSubscribers--\n+\t\t\tif s.numSubscribers == 0 {\n+\t\t\t\tclose(s.ch)","path":"service/history/chasm_notifier.go","commit_id":"ba38880058f288839d9fd74d46b7ac8dbc549f5c","original_commit_id":"8aa718931afd6a83e7694ad3b97cec208dcf61e1","user":{"login":"bergundy","id":52304,"node_id":"MDQ6VXNlcjUyMzA0","avatar_url":"https://avatars.githubusercontent.com/u/52304?v=4","gravatar_id":"","url":"https://api.github.com/users/bergundy","html_url":"https://github.com/bergundy","followers_url":"https://api.github.com/users/bergundy/followers","following_url":"https://api.github.com/users/bergundy/following{/other_user}","gists_url":"https://api.github.com/users/bergundy/gists{/gist_id}","starred_url":"https://api.github.com/users/bergundy/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/bergundy/subscriptions","organizations_url":"https://api.github.com/users/bergundy/orgs","repos_url":"https://api.github.com/users/bergundy/repos","events_url":"https://api.github.com/users/bergundy/events{/privacy}","received_events_url":"https://api.github.com/users/bergundy/received_events","type":"User","user_view_type":"public","site_admin":false},"body":"Redundant, the channel will just get GC'ed. I think what you have is slightly more expensive but  .","created_at":"2025-12-05T00:35:09Z","updated_at":"2025-12-05T00:40:47Z","html_url":"https://github.com/temporalio/temporal/pull/8563#discussion_r2591033572","pull_request_url":"https://api.github.com/repos/temporalio/temporal/pulls/8563","_links":{"self":{"href":"https://api.github.com/repos/temporalio/temporal/pulls/comments/2591033572"},"html":{"href":"https://github.com/temporalio/temporal/pull/8563#discussion_r2591033572"},"pull_request":{"href":"https://api.github.com/repos/temporalio/temporal/pulls/8563"}},"reactions":{"url":"https://api.github.com/repos/temporalio/temporal/pulls/comments/2591033572/reactions","total_count":0,"+1":0,"-1":0,"laugh":0,"hooray":0,"confused":0,"heart":0,"rocket":0,"eyes":0},"start_line":null,"original_start_line":null,"start_side":null,"line":null,"original_line":50,"side":"RIGHT","author_association":"MEMBER","original_position":50,"position":1,"subject_type":"line"},{"url":"https://api.github.com/repos/temporalio/temporal/pulls/comments/2591034303","pull_request_review_id":3542667509,"id":2591034303,"node_id":"PRRC_kwDODNqesM6acAu_","diff_hunk":"@@ -266,3 +267,30 @@ func validateAndNormalizeSearchAttributes(\n \n \treturn saValidator.ValidateSize(searchAttributes, namespaceName)\n }\n+\n+// ValidatePollActivityExecutionRequest validates the request for PollActivityExecution API.\n+func ValidatePollActivityExecutionRequest(\n+\treq *workflowservice.PollActivityExecutionRequest,\n+\tmaxIDLengthLimit int,\n+) error {\n+\tif req.GetActivityId() == \"\" {\n+\t\treturn serviceerror.NewInvalidArgument(\"activity ID is required\")\n+\t}\n+\tif len(req.GetActivityId()) > maxIDLengthLimit {\n+\t\treturn serviceerror.NewInvalidArgumentf(\"activity ID exceeds length limit. Length=%d Limit=%d\",\n+\t\t\tlen(req.GetActivityId()), maxIDLengthLimit)\n+\t}\n+\thasRunID := req.GetRunId() != \"\"\n+\thasLongPollToken := len(req.GetWaitAnyStateChange().GetLongPollToken()) > 0","path":"chasm/lib/activity/validator.go","commit_id":"1d59e66d0ce5d91819f92c428ef5ab4c4efca1fb","original_commit_id":"f414f2db4e832632683445eef479d54a2be90653","user":{"login":"dandavison","id":52205,"node_id":"MDQ6VXNlcjUyMjA1","avatar_url":"https://avatars.githubusercontent.com/u/52205?v=4","gravatar_id":"","url":"https://api.github.com/users/dandavison","html_url":"https://github.com/dandavison","followers_url":"https://api.github.com/users/dandavison/followers","following_url":"https://api.github.com/users/dandavison/following{/other_user}","gists_url":"https://api.github.com/users/dandavison/gists{/gist_id}","starred_url":"https://api.github.com/users/dandavison/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/dandavison/subscriptions","organizations_url":"https://api.github.com/users/dandavison/orgs","repos_url":"https://api.github.com/users/dandavison/repos","events_url":"https://api.github.com/users/dandavison/events{/privacy}","received_events_url":"https://api.github.com/users/dandavison/received_events","type":"User","user_view_type":"public","site_admin":false},"body":"That's not right. These generated getter methods are safe to call on `nil`.","created_at":"2025-12-05T00:35:39Z","updated_at":"2025-12-05T00:35:39Z","html_url":"https://github.com/temporalio/temporal/pull/8563#discussion_r2591034303","pull_request_url":"https://api.github.com/repos/temporalio/temporal/pulls/8563","_links":{"self":{"href":"https://api.github.com/repos/temporalio/temporal/pulls/comments/2591034303"},"html":{"href":"https://github.com/temporalio/temporal/pull/8563#discussion_r2591034303"},"pull_request":{"href":"https://api.github.com/repos/temporalio/temporal/pulls/8563"}},"reactions":{"url":"https://api.github.com/repos/temporalio/temporal/pulls/comments/2591034303/reactions","total_count":0,"+1":0,"-1":0,"laugh":0,"hooray":0,"confused":0,"heart":0,"rocket":0,"eyes":0},"start_line":null,"original_start_line":null,"start_side":null,"line":284,"original_line":284,"side":"RIGHT","in_reply_to_id":2565886881,"author_association":"MEMBER","original_position":26,"position":26,"subject_type":"line"},{"url":"https://api.github.com/repos/temporalio/temporal/pulls/comments/2591034875","pull_request_review_id":3542632205,"id":2591034875,"node_id":"PRRC_kwDODNqesM6acA37","diff_hunk":"@@ -0,0 +1,65 @@\n+package history\n+\n+import (\n+\t\"sync\"\n+\n+\t\"go.temporal.io/server/chasm\"\n+)\n+\n+type (\n+\t// ChasmNotifier allows subscribers to receive notifications relating to a CHASM execution.\n+\tChasmNotifier struct {\n+\t\texecutions map[chasm.EntityKey]*subscriptionTracker","path":"service/history/chasm_notifier.go","commit_id":"ba38880058f288839d9fd74d46b7ac8dbc549f5c","original_commit_id":"8aa718931afd6a83e7694ad3b97cec208dcf61e1","user":{"login":"bergundy","id":52304,"node_id":"MDQ6VXNlcjUyMzA0","avatar_url":"https://avatars.githubusercontent.com/u/52304?v=4","gravatar_id":"","url":"https://api.github.com/users/bergundy","html_url":"https://github.com/bergundy","followers_url":"https://api.github.com/users/bergundy/followers","following_url":"https://api.github.com/users/bergundy/following{/other_user}","gists_url":"https://api.github.com/users/bergundy/gists{/gist_id}","starred_url":"https://api.github.com/users/bergundy/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/bergundy/subscriptions","organizations_url":"https://api.github.com/users/bergundy/orgs","repos_url":"https://api.github.com/users/bergundy/repos","events_url":"https://api.github.com/users/bergundy/events{/privacy}","received_events_url":"https://api.github.com/users/bergundy/received_events","type":"User","user_view_type":"public","site_admin":false},"body":"Not blocking, but maybe put a TODO here to use the sharded map which will guarantee less lock contention?","created_at":"2025-12-05T00:36:09Z","updated_at":"2025-12-05T00:40:47Z","html_url":"https://github.com/temporalio/temporal/pull/8563#discussion_r2591034875","pull_request_url":"https://api.github.com/repos/temporalio/temporal/pulls/8563","_links":{"self":{"href":"https://api.github.com/repos/temporalio/temporal/pulls/comments/2591034875"},"html":{"href":"https://github.com/temporalio/temporal/pull/8563#discussion_r2591034875"},"pull_request":{"href":"https://api.github.com/repos/temporalio/temporal/pulls/8563"}},"reactions":{"url":"https://api.github.com/repos/temporalio/temporal/pulls/comments/2591034875/reactions","total_count":0,"+1":0,"-1":0,"laugh":0,"hooray":0,"confused":0,"heart":0,"rocket":0,"eyes":0},"start_line":null,"original_start_line":null,"start_side":null,"line":null,"original_line":12,"side":"RIGHT","author_association":"MEMBER","original_position":12,"position":1,"subject_type":"line"},{"url":"https://api.github.com/repos/temporalio/temporal/pulls/comments/2591037212","pull_request_review_id":3542632205,"id":2591037212,"node_id":"PRRC_kwDODNqesM6acBcc","diff_hunk":"@@ -838,6 +842,16 @@ func (e *historyEngineImpl) NotifyNewHistoryEvent(\n \te.eventNotifier.NotifyNewHistoryEvent(notification)\n }\n \n+func (e *historyEngineImpl) ChasmEngine() chasm.Engine {","path":"service/history/history_engine.go","commit_id":"083e3b013b3cad2ae65aefee701f4837a0cffd71","original_commit_id":"8aa718931afd6a83e7694ad3b97cec208dcf61e1","user":{"login":"bergundy","id":52304,"node_id":"MDQ6VXNlcjUyMzA0","avatar_url":"https://avatars.githubusercontent.com/u/52304?v=4","gravatar_id":"","url":"https://api.github.com/users/bergundy","html_url":"https://github.com/bergundy","followers_url":"https://api.github.com/users/bergundy/followers","following_url":"https://api.github.com/users/bergundy/following{/other_user}","gists_url":"https://api.github.com/users/bergundy/gists{/gist_id}","starred_url":"https://api.github.com/users/bergundy/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/bergundy/subscriptions","organizations_url":"https://api.github.com/users/bergundy/orgs","repos_url":"https://api.github.com/users/bergundy/repos","events_url":"https://api.github.com/users/bergundy/events{/privacy}","received_events_url":"https://api.github.com/users/bergundy/received_events","type":"User","user_view_type":"public","site_admin":false},"body":"Is this called anywhere? Maybe I missed it?","created_at":"2025-12-05T00:37:46Z","updated_at":"2025-12-05T00:40:47Z","html_url":"https://github.com/temporalio/temporal/pull/8563#discussion_r2591037212","pull_request_url":"https://api.github.com/repos/temporalio/temporal/pulls/8563","_links":{"self":{"href":"https://api.github.com/repos/temporalio/temporal/pulls/comments/2591037212"},"html":{"href":"https://github.com/temporalio/temporal/pull/8563#discussion_r2591037212"},"pull_request":{"href":"https://api.github.com/repos/temporalio/temporal/pulls/8563"}},"reactions":{"url":"https://api.github.com/repos/temporalio/temporal/pulls/comments/2591037212/reactions","total_count":0,"+1":0,"-1":0,"laugh":0,"hooray":0,"confused":0,"heart":0,"rocket":0,"eyes":0},"start_line":null,"original_start_line":null,"start_side":null,"line":null,"original_line":845,"side":"RIGHT","author_association":"MEMBER","original_position":36,"position":1,"subject_type":"line"},{"url":"https://api.github.com/repos/temporalio/temporal/pulls/comments/2591038529","pull_request_review_id":3542632205,"id":2591038529,"node_id":"PRRC_kwDODNqesM6acBxB","diff_hunk":"@@ -5,45 +5,66 @@ import (\n \t\"testing\"\n \t\"time\"\n \n-\t\"github.com/google/uuid\"\n \t\"github.com/stretchr/testify/require\"\n \t\"github.com/stretchr/testify/suite\"\n \tactivitypb \"go.temporal.io/api/activity/v1\"\n \tcommonpb \"go.temporal.io/api/common/v1\"\n \tenumspb \"go.temporal.io/api/enums/v1\"\n+\t\"go.temporal.io/api/serviceerror\"\n \ttaskqueuepb \"go.temporal.io/api/taskqueue/v1\"\n \t\"go.temporal.io/api/workflowservice/v1\"\n+\t\"go.temporal.io/server/chasm/lib/activity\"\n \t\"go.temporal.io/server/common/dynamicconfig\"\n+\t\"go.temporal.io/server/common/testing/protorequire\"\n+\t\"go.temporal.io/server/common/testing/testvars\"\n \t\"go.temporal.io/server/tests/testcore\"\n \t\"google.golang.org/protobuf/proto\"\n \t\"google.golang.org/protobuf/types/known/durationpb\"\n )\n \n+var (\n+\tdefaultInput = &commonpb.Payloads{","path":"tests/standalone_activity_test.go","commit_id":"ba38880058f288839d9fd74d46b7ac8dbc549f5c","original_commit_id":"8aa718931afd6a83e7694ad3b97cec208dcf61e1","user":{"login":"bergundy","id":52304,"node_id":"MDQ6VXNlcjUyMzA0","avatar_url":"https://avatars.githubusercontent.com/u/52304?v=4","gravatar_id":"","url":"https://api.github.com/users/bergundy","html_url":"https://github.com/bergundy","followers_url":"https://api.github.com/users/bergundy/followers","following_url":"https://api.github.com/users/bergundy/following{/other_user}","gists_url":"https://api.github.com/users/bergundy/gists{/gist_id}","starred_url":"https://api.github.com/users/bergundy/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/bergundy/subscriptions","organizations_url":"https://api.github.com/users/bergundy/orgs","repos_url":"https://api.github.com/users/bergundy/repos","events_url":"https://api.github.com/users/bergundy/events{/privacy}","received_events_url":"https://api.github.com/users/bergundy/received_events","type":"User","user_view_type":"public","site_admin":false},"body":"I mentioned this before I believe, use `payloads.EncodeString()` from `common`","created_at":"2025-12-05T00:38:40Z","updated_at":"2025-12-05T00:40:47Z","html_url":"https://github.com/temporalio/temporal/pull/8563#discussion_r2591038529","pull_request_url":"https://api.github.com/repos/temporalio/temporal/pulls/8563","_links":{"self":{"href":"https://api.github.com/repos/temporalio/temporal/pulls/comments/2591038529"},"html":{"href":"https://github.com/temporalio/temporal/pull/8563#discussion_r2591038529"},"pull_request":{"href":"https://api.github.com/repos/temporalio/temporal/pulls/8563"}},"reactions":{"url":"https://api.github.com/repos/temporalio/temporal/pulls/comments/2591038529/reactions","total_count":1,"+1":1,"-1":0,"laugh":0,"hooray":0,"confused":0,"heart":0,"rocket":0,"eyes":0},"start_line":null,"original_start_line":null,"start_side":null,"line":null,"original_line":26,"side":"RIGHT","author_association":"MEMBER","original_position":23,"position":1,"subject_type":"line"},{"url":"https://api.github.com/repos/temporalio/temporal/pulls/comments/2591039373","pull_request_review_id":3542632205,"id":2591039373,"node_id":"PRRC_kwDODNqesM6acB-N","diff_hunk":"@@ -5,45 +5,66 @@ import (\n \t\"testing\"\n \t\"time\"\n \n-\t\"github.com/google/uuid\"\n \t\"github.com/stretchr/testify/require\"\n \t\"github.com/stretchr/testify/suite\"\n \tactivitypb \"go.temporal.io/api/activity/v1\"\n \tcommonpb \"go.temporal.io/api/common/v1\"\n \tenumspb \"go.temporal.io/api/enums/v1\"\n+\t\"go.temporal.io/api/serviceerror\"\n \ttaskqueuepb \"go.temporal.io/api/taskqueue/v1\"\n \t\"go.temporal.io/api/workflowservice/v1\"\n+\t\"go.temporal.io/server/chasm/lib/activity\"\n \t\"go.temporal.io/server/common/dynamicconfig\"\n+\t\"go.temporal.io/server/common/testing/protorequire\"\n+\t\"go.temporal.io/server/common/testing/testvars\"\n \t\"go.temporal.io/server/tests/testcore\"\n \t\"google.golang.org/protobuf/proto\"\n \t\"google.golang.org/protobuf/types/known/durationpb\"\n )\n \n+var (\n+\tdefaultInput = &commonpb.Payloads{\n+\t\tPayloads: []*commonpb.Payload{\n+\t\t\t{\n+\t\t\t\tMetadata: map[string][]byte{\n+\t\t\t\t\t\"encoding\": []byte(\"json/plain\"),\n+\t\t\t\t},\n+\t\t\t\tData: []byte(\"test-activity-input\"),\n+\t\t\t},\n+\t\t},\n+\t}\n+)\n+\n type standaloneActivityTestSuite struct {\n \ttestcore.FunctionalTestBase\n+\ttv *testvars.TestVars\n }\n \n func TestStandaloneActivityTestSuite(t *testing.T) {\n \tt.Parallel()\n \tsuite.Run(t, new(standaloneActivityTestSuite))\n }\n \n-func (s *standaloneActivityTestSuite) TestStartActivityExecution() {\n-\tt := s.T()\n-\tctx, cancel := context.WithTimeout(t.Context(), 10*time.Second)\n-\tdefer cancel()\n-\n+func (s *standaloneActivityTestSuite) SetupSuite() {\n+\ts.FunctionalTestBase.SetupSuite()\n+\ts.tv = testvars.New(s.T())","path":"tests/standalone_activity_test.go","commit_id":"ba38880058f288839d9fd74d46b7ac8dbc549f5c","original_commit_id":"8aa718931afd6a83e7694ad3b97cec208dcf61e1","user":{"login":"bergundy","id":52304,"node_id":"MDQ6VXNlcjUyMzA0","avatar_url":"https://avatars.githubusercontent.com/u/52304?v=4","gravatar_id":"","url":"https://api.github.com/users/bergundy","html_url":"https://github.com/bergundy","followers_url":"https://api.github.com/users/bergundy/followers","following_url":"https://api.github.com/users/bergundy/following{/other_user}","gists_url":"https://api.github.com/users/bergundy/gists{/gist_id}","starred_url":"https://api.github.com/users/bergundy/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/bergundy/subscriptions","organizations_url":"https://api.github.com/users/bergundy/orgs","repos_url":"https://api.github.com/users/bergundy/repos","events_url":"https://api.github.com/users/bergundy/events{/privacy}","received_events_url":"https://api.github.com/users/bergundy/received_events","type":"User","user_view_type":"public","site_admin":false},"body":"I think this needs to be done in `SetupTest`","created_at":"2025-12-05T00:39:24Z","updated_at":"2025-12-05T00:40:47Z","html_url":"https://github.com/temporalio/temporal/pull/8563#discussion_r2591039373","pull_request_url":"https://api.github.com/repos/temporalio/temporal/pulls/8563","_links":{"self":{"href":"https://api.github.com/repos/temporalio/temporal/pulls/comments/2591039373"},"html":{"href":"https://github.com/temporalio/temporal/pull/8563#discussion_r2591039373"},"pull_request":{"href":"https://api.github.com/repos/temporalio/temporal/pulls/8563"}},"reactions":{"url":"https://api.github.com/repos/temporalio/temporal/pulls/comments/2591039373/reactions","total_count":0,"+1":0,"-1":0,"laugh":0,"hooray":0,"confused":0,"heart":0,"rocket":0,"eyes":0},"start_line":null,"original_start_line":null,"start_side":null,"line":null,"original_line":50,"side":"RIGHT","author_association":"MEMBER","original_position":52,"position":1,"subject_type":"line"},{"url":"https://api.github.com/repos/temporalio/temporal/pulls/comments/2591040058","pull_request_review_id":3542632205,"id":2591040058,"node_id":"PRRC_kwDODNqesM6acCI6","diff_hunk":"@@ -5,45 +5,66 @@ import (\n \t\"testing\"\n \t\"time\"\n \n-\t\"github.com/google/uuid\"\n \t\"github.com/stretchr/testify/require\"\n \t\"github.com/stretchr/testify/suite\"\n \tactivitypb \"go.temporal.io/api/activity/v1\"\n \tcommonpb \"go.temporal.io/api/common/v1\"\n \tenumspb \"go.temporal.io/api/enums/v1\"\n+\t\"go.temporal.io/api/serviceerror\"\n \ttaskqueuepb \"go.temporal.io/api/taskqueue/v1\"\n \t\"go.temporal.io/api/workflowservice/v1\"\n+\t\"go.temporal.io/server/chasm/lib/activity\"\n \t\"go.temporal.io/server/common/dynamicconfig\"\n+\t\"go.temporal.io/server/common/testing/protorequire\"\n+\t\"go.temporal.io/server/common/testing/testvars\"\n \t\"go.temporal.io/server/tests/testcore\"\n \t\"google.golang.org/protobuf/proto\"\n \t\"google.golang.org/protobuf/types/known/durationpb\"\n )\n \n+var (\n+\tdefaultInput = &commonpb.Payloads{\n+\t\tPayloads: []*commonpb.Payload{\n+\t\t\t{\n+\t\t\t\tMetadata: map[string][]byte{\n+\t\t\t\t\t\"encoding\": []byte(\"json/plain\"),\n+\t\t\t\t},\n+\t\t\t\tData: []byte(\"test-activity-input\"),\n+\t\t\t},\n+\t\t},\n+\t}\n+)\n+\n type standaloneActivityTestSuite struct {\n \ttestcore.FunctionalTestBase\n+\ttv *testvars.TestVars\n }\n \n func TestStandaloneActivityTestSuite(t *testing.T) {\n \tt.Parallel()\n \tsuite.Run(t, new(standaloneActivityTestSuite))\n }\n \n-func (s *standaloneActivityTestSuite) TestStartActivityExecution() {\n-\tt := s.T()\n-\tctx, cancel := context.WithTimeout(t.Context(), 10*time.Second)\n-\tdefer cancel()\n-\n+func (s *standaloneActivityTestSuite) SetupSuite() {\n+\ts.FunctionalTestBase.SetupSuite()\n+\ts.tv = testvars.New(s.T())\n \ts.OverrideDynamicConfig(\n \t\tdynamicconfig.EnableChasm,\n \t\ttrue,\n \t)\n+}\n+\n+func (s *standaloneActivityTestSuite) TestStartActivityExecution() {\n+\tt := s.T()\n+\tctx, cancel := context.WithTimeout(t.Context(), 10*time.Second)\n+\tdefer cancel()\n \n \tactivityID := testcore.RandomizeStr(t.Name())\n \tactivityType := &commonpb.ActivityType{\n \t\tName: \"test-activity-type\",\n \t}\n \tinput := createDefaultInput()\n-\ttaskQueue := uuid.New().String()\n+\ttaskQueue := testcore.RandomizeStr(t.Name())","path":"tests/standalone_activity_test.go","commit_id":"1d59e66d0ce5d91819f92c428ef5ab4c4efca1fb","original_commit_id":"8aa718931afd6a83e7694ad3b97cec208dcf61e1","user":{"login":"bergundy","id":52304,"node_id":"MDQ6VXNlcjUyMzA0","avatar_url":"https://avatars.githubusercontent.com/u/52304?v=4","gravatar_id":"","url":"https://api.github.com/users/bergundy","html_url":"https://github.com/bergundy","followers_url":"https://api.github.com/users/bergundy/followers","following_url":"https://api.github.com/users/bergundy/following{/other_user}","gists_url":"https://api.github.com/users/bergundy/gists{/gist_id}","starred_url":"https://api.github.com/users/bergundy/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/bergundy/subscriptions","organizations_url":"https://api.github.com/users/bergundy/orgs","repos_url":"https://api.github.com/users/bergundy/repos","events_url":"https://api.github.com/users/bergundy/events{/privacy}","received_events_url":"https://api.github.com/users/bergundy/received_events","type":"User","user_view_type":"public","site_admin":false},"body":"If you're already using testvars, might as well fully use it. IMHO that utility doesn't give us much but leaving it up to you.","created_at":"2025-12-05T00:39:54Z","updated_at":"2025-12-05T00:40:47Z","html_url":"https://github.com/temporalio/temporal/pull/8563#discussion_r2591040058","pull_request_url":"https://api.github.com/repos/temporalio/temporal/pulls/8563","_links":{"self":{"href":"https://api.github.com/repos/temporalio/temporal/pulls/comments/2591040058"},"html":{"href":"https://github.com/temporalio/temporal/pull/8563#discussion_r2591040058"},"pull_request":{"href":"https://api.github.com/repos/temporalio/temporal/pulls/8563"}},"reactions":{"url":"https://api.github.com/repos/temporalio/temporal/pulls/comments/2591040058/reactions","total_count":0,"+1":0,"-1":0,"laugh":0,"hooray":0,"confused":0,"heart":0,"rocket":0,"eyes":0},"start_line":null,"original_start_line":null,"start_side":null,"line":58,"original_line":67,"side":"RIGHT","author_association":"MEMBER","original_position":70,"position":62,"subject_type":"line"},{"url":"https://api.github.com/repos/temporalio/temporal/pulls/comments/2591050640","pull_request_review_id":3542686309,"id":2591050640,"node_id":"PRRC_kwDODNqesM6acEuQ","diff_hunk":"@@ -131,12 +136,19 @@ func (r *ComponentRef) Serialize(\n // DeserializeComponentRef deserializes a byte slice into a ComponentRef.\n // Provides caller the access to information including EntityKey, Archetype, and ShardingKey.\n func DeserializeComponentRef(data []byte) (ComponentRef, error) {\n+\tif len(data) == 0 {\n+\t\treturn ComponentRef{}, ErrInvalidComponentRef\n+\t}\n \tvar pRef persistencespb.ChasmComponentRef\n \tif err := pRef.Unmarshal(data); err != nil {\n \t\treturn ComponentRef{}, err","path":"chasm/ref.go","commit_id":"34b3f8a7f60cc35efeeb40e6870798011c42c1ab","original_commit_id":"101822827ec6f0ce5eb6c86421c7162b8ba21321","user":{"login":"yycptt","id":7754120,"node_id":"MDQ6VXNlcjc3NTQxMjA=","avatar_url":"https://avatars.githubusercontent.com/u/7754120?v=4","gravatar_id":"","url":"https://api.github.com/users/yycptt","html_url":"https://github.com/yycptt","followers_url":"https://api.github.com/users/yycptt/followers","following_url":"https://api.github.com/users/yycptt/following{/other_user}","gists_url":"https://api.github.com/users/yycptt/gists{/gist_id}","starred_url":"https://api.github.com/users/yycptt/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/yycptt/subscriptions","organizations_url":"https://api.github.com/users/yycptt/orgs","repos_url":"https://api.github.com/users/yycptt/repos","events_url":"https://api.github.com/users/yycptt/events{/privacy}","received_events_url":"https://api.github.com/users/yycptt/received_events","type":"User","user_view_type":"public","site_admin":false},"body":"`ErrMalformedComponentRef`?","created_at":"2025-12-05T00:47:43Z","updated_at":"2025-12-05T01:05:40Z","html_url":"https://github.com/temporalio/temporal/pull/8563#discussion_r2591050640","pull_request_url":"https://api.github.com/repos/temporalio/temporal/pulls/8563","_links":{"self":{"href":"https://api.github.com/repos/temporalio/temporal/pulls/comments/2591050640"},"html":{"href":"https://github.com/temporalio/temporal/pull/8563#discussion_r2591050640"},"pull_request":{"href":"https://api.github.com/repos/temporalio/temporal/pulls/8563"}},"reactions":{"url":"https://api.github.com/repos/temporalio/temporal/pulls/comments/2591050640/reactions","total_count":0,"+1":0,"-1":0,"laugh":0,"hooray":0,"confused":0,"heart":0,"rocket":0,"eyes":0},"start_line":null,"original_start_line":null,"start_side":null,"line":null,"original_line":144,"side":"RIGHT","author_association":"MEMBER","original_position":33,"position":1,"subject_type":"line"},{"url":"https://api.github.com/repos/temporalio/temporal/pulls/comments/2591051822","pull_request_review_id":3542686309,"id":2591051822,"node_id":"PRRC_kwDODNqesM6acFAu","diff_hunk":"@@ -1,15 +1,20 @@\n package chasm\n \n import (\n+\t\"errors\"\n \t\"reflect\"\n \n \t\"go.temporal.io/api/serviceerror\"\n \tpersistencespb \"go.temporal.io/server/api/persistence/v1\"\n )\n \n-var (\n-\tdefaultShardingFn = func(key EntityKey) string { return key.NamespaceID + \"_\" + key.BusinessID }\n-)\n+// ErrMalformedComponentRef is returned when component ref bytes cannot be deserialized.\n+var ErrMalformedComponentRef = errors.New(\"malformed component ref\")\n+\n+// ErrInvalidComponentRef is returned when component ref bytes deserialize to an invalid component ref.\n+var ErrInvalidComponentRef = errors.New(\"invalid component ref\")","path":"chasm/ref.go","commit_id":"34b3f8a7f60cc35efeeb40e6870798011c42c1ab","original_commit_id":"101822827ec6f0ce5eb6c86421c7162b8ba21321","user":{"login":"yycptt","id":7754120,"node_id":"MDQ6VXNlcjc3NTQxMjA=","avatar_url":"https://avatars.githubusercontent.com/u/7754120?v=4","gravatar_id":"","url":"https://api.github.com/users/yycptt","html_url":"https://github.com/yycptt","followers_url":"https://api.github.com/users/yycptt/followers","following_url":"https://api.github.com/users/yycptt/following{/other_user}","gists_url":"https://api.github.com/users/yycptt/gists{/gist_id}","starred_url":"https://api.github.com/users/yycptt/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/yycptt/subscriptions","organizations_url":"https://api.github.com/users/yycptt/orgs","repos_url":"https://api.github.com/users/yycptt/repos","events_url":"https://api.github.com/users/yycptt/events{/privacy}","received_events_url":"https://api.github.com/users/yycptt/received_events","type":"User","user_view_type":"public","site_admin":false},"body":"I'd return invalidRequest here unless we are sure all api handlers have proper error conversion logic.","created_at":"2025-12-05T00:48:30Z","updated_at":"2025-12-05T01:05:40Z","html_url":"https://github.com/temporalio/temporal/pull/8563#discussion_r2591051822","pull_request_url":"https://api.github.com/repos/temporalio/temporal/pulls/8563","_links":{"self":{"href":"https://api.github.com/repos/temporalio/temporal/pulls/comments/2591051822"},"html":{"href":"https://github.com/temporalio/temporal/pull/8563#discussion_r2591051822"},"pull_request":{"href":"https://api.github.com/repos/temporalio/temporal/pulls/8563"}},"reactions":{"url":"https://api.github.com/repos/temporalio/temporal/pulls/comments/2591051822/reactions","total_count":0,"+1":0,"-1":0,"laugh":0,"hooray":0,"confused":0,"heart":0,"rocket":0,"eyes":0},"start_line":null,"original_start_line":11,"start_side":"RIGHT","line":null,"original_line":15,"side":"RIGHT","author_association":"MEMBER","original_position":18,"position":1,"subject_type":"line"},{"url":"https://api.github.com/repos/temporalio/temporal/pulls/comments/2591052769","pull_request_review_id":3542686309,"id":2591052769,"node_id":"PRRC_kwDODNqesM6acFPh","diff_hunk":"@@ -98,6 +99,8 @@ type (\n \n \t\tNotifyNewHistoryEvent(event *events.Notification)\n \t\tNotifyNewTasks(tasks map[tasks.Category][]tasks.Task)\n+\t\tChasmEngine() chasm.Engine","path":"service/history/interfaces/engine.go","commit_id":"34b3f8a7f60cc35efeeb40e6870798011c42c1ab","original_commit_id":"101822827ec6f0ce5eb6c86421c7162b8ba21321","user":{"login":"yycptt","id":7754120,"node_id":"MDQ6VXNlcjc3NTQxMjA=","avatar_url":"https://avatars.githubusercontent.com/u/7754120?v=4","gravatar_id":"","url":"https://api.github.com/users/yycptt","html_url":"https://github.com/yycptt","followers_url":"https://api.github.com/users/yycptt/followers","following_url":"https://api.github.com/users/yycptt/following{/other_user}","gists_url":"https://api.github.com/users/yycptt/gists{/gist_id}","starred_url":"https://api.github.com/users/yycptt/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/yycptt/subscriptions","organizations_url":"https://api.github.com/users/yycptt/orgs","repos_url":"https://api.github.com/users/yycptt/repos","events_url":"https://api.github.com/users/yycptt/events{/privacy}","received_events_url":"https://api.github.com/users/yycptt/received_events","type":"User","user_view_type":"public","site_admin":false},"body":"nit: is this one required/used?","created_at":"2025-12-05T00:49:09Z","updated_at":"2025-12-05T01:05:40Z","html_url":"https://github.com/temporalio/temporal/pull/8563#discussion_r2591052769","pull_request_url":"https://api.github.com/repos/temporalio/temporal/pulls/8563","_links":{"self":{"href":"https://api.github.com/repos/temporalio/temporal/pulls/comments/2591052769"},"html":{"href":"https://github.com/temporalio/temporal/pull/8563#discussion_r2591052769"},"pull_request":{"href":"https://api.github.com/repos/temporalio/temporal/pulls/8563"}},"reactions":{"url":"https://api.github.com/repos/temporalio/temporal/pulls/comments/2591052769/reactions","total_count":0,"+1":0,"-1":0,"laugh":0,"hooray":0,"confused":0,"heart":0,"rocket":0,"eyes":0},"start_line":null,"original_start_line":null,"start_side":null,"line":null,"original_line":102,"side":"RIGHT","author_association":"MEMBER","original_position":12,"position":1,"subject_type":"line"},{"url":"https://api.github.com/repos/temporalio/temporal/pulls/comments/2591058499","pull_request_review_id":3542695108,"id":2591058499,"node_id":"PRRC_kwDODNqesM6acGpD","diff_hunk":"@@ -234,18 +241,18 @@ func ReadComponent[C Component, R []byte | ComponentRef, I any, O any](\n \treturn output, err\n }\n \n-type PollComponentRequest[C Component, I any, O any] struct {\n-\tRef         ComponentRef\n-\tPredicateFn func(C, Context, I) bool\n-\tOperationFn func(C, MutableContext, I) (O, error)\n-\tInput       I\n-}\n-\n-func PollComponent[C Component, R []byte | ComponentRef, I any, O any, T any](\n+// PollComponent waits until the predicate is true when evaluated against the component identified\n+// by the supplied component reference. If this times out due to a server-imposed long-poll timeout\n+// then it returns (nil, nil, nil), as an indication that the caller should continue long-polling.\n+// Otherwise it returns (output, ref, err), where output is the output of the predicate function,\n+// and ref is a component reference identifying the state at which the predicate was satisfied. The\n+// predicate must be monotonic: if it returns true at execution state transition s then it must\n+// return true at all transitions t > s. If the predicate is true at the outset then PollComponent\n+// returns immediately. opts are currently ignored.\n+func PollComponent[C Component, R []byte | ComponentRef, I any, O any](\n \tctx context.Context,\n \tr R,\n-\tpredicateFn func(C, Context, I) (T, bool, error),\n-\toperationFn func(C, MutableContext, I, T) (O, error),\n+\tmonotonicPredicate func(C, Context, I) (O, bool, error),\n \tinput I,\n \topts ...TransitionOption,","path":"chasm/engine.go","commit_id":"1d59e66d0ce5d91819f92c428ef5ab4c4efca1fb","original_commit_id":"8aa718931afd6a83e7694ad3b97cec208dcf61e1","user":{"login":"dandavison","id":52205,"node_id":"MDQ6VXNlcjUyMjA1","avatar_url":"https://avatars.githubusercontent.com/u/52205?v=4","gravatar_id":"","url":"https://api.github.com/users/dandavison","html_url":"https://github.com/dandavison","followers_url":"https://api.github.com/users/dandavison/followers","following_url":"https://api.github.com/users/dandavison/following{/other_user}","gists_url":"https://api.github.com/users/dandavison/gists{/gist_id}","starred_url":"https://api.github.com/users/dandavison/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/dandavison/subscriptions","organizations_url":"https://api.github.com/users/dandavison/orgs","repos_url":"https://api.github.com/users/dandavison/repos","events_url":"https://api.github.com/users/dandavison/events{/privacy}","received_events_url":"https://api.github.com/users/dandavison/received_events","type":"User","user_view_type":"public","site_admin":false},"body":"We can. `ReadComponent` and `UpdateComponent` also have unused `opts`. So let's remove them in a subsequent PR (if that's what @yycptt wants).","created_at":"2025-12-05T00:53:12Z","updated_at":"2025-12-05T01:19:17Z","html_url":"https://github.com/temporalio/temporal/pull/8563#discussion_r2591058499","pull_request_url":"https://api.github.com/repos/temporalio/temporal/pulls/8563","_links":{"self":{"href":"https://api.github.com/repos/temporalio/temporal/pulls/comments/2591058499"},"html":{"href":"https://github.com/temporalio/temporal/pull/8563#discussion_r2591058499"},"pull_request":{"href":"https://api.github.com/repos/temporalio/temporal/pulls/8563"}},"reactions":{"url":"https://api.github.com/repos/temporalio/temporal/pulls/comments/2591058499/reactions","total_count":0,"+1":0,"-1":0,"laugh":0,"hooray":0,"confused":0,"heart":0,"rocket":0,"eyes":0},"start_line":null,"original_start_line":null,"start_side":null,"line":257,"original_line":257,"side":"RIGHT","in_reply_to_id":2591017777,"author_association":"MEMBER","original_position":61,"position":61,"subject_type":"line"},{"url":"https://api.github.com/repos/temporalio/temporal/pulls/comments/2591059754","pull_request_review_id":3542696504,"id":2591059754,"node_id":"PRRC_kwDODNqesM6acG8q","diff_hunk":"@@ -53,3 +59,118 @@ func (h *handler) StartActivityExecution(ctx context.Context, req *activitypb.St\n \t\tFrontendResponse: response,\n \t}, nil\n }\n+\n+// PollActivityExecution handles PollActivityExecutionRequest from frontend. This method supports\n+// querying current activity state, optionally as a long-poll that waits for certain state changes.\n+// It is used by clients to poll for activity state and/or result. When used to long-poll, it\n+// returns an empty non-error response on context deadline expiry, to indicate that the state being\n+// waited for was not reached. Callers should interpret this as an invitation to resubmit their\n+// long-poll request. This response is sent before the caller's deadline (see\n+// chasm.activity.longPollBuffer) so that it is likely that the caller does indeed receive the\n+// non-error response.\n+func (h *handler) PollActivityExecution(\n+\tctx context.Context,\n+\treq *activitypb.PollActivityExecutionRequest,\n+) (response *activitypb.PollActivityExecutionResponse, err error) {\n+\tref := chasm.NewComponentRef[*Activity](chasm.EntityKey{\n+\t\tNamespaceID: req.GetNamespaceId(),\n+\t\tBusinessID:  req.GetFrontendRequest().GetActivityId(),\n+\t\tEntityID:    req.GetFrontendRequest().GetRunId(),\n+\t})\n+\tdefer func() {\n+\t\tvar notFound *serviceerror.NotFound\n+\t\tif errors.As(err, &notFound) {\n+\t\t\t// TODO(dan): include execution key in error message; we may do this at the CHASM\n+\t\t\t// framework level.\n+\t\t\t// cf. \"workflow execution not found for workflow ID XXX and run ID YYY\"\n+\t\t\terr = serviceerror.NewNotFound(\"activity execution not found\")\n+\t\t}\n+\t}()\n+\n+\twaitPolicy := req.GetFrontendRequest().GetWaitPolicy()\n+\n+\tif waitPolicy == nil {\n+\t\treturn chasm.ReadComponent(ctx, ref, (*Activity).buildPollActivityExecutionResponse, req, nil)\n+\t}\n+\n+\t// Below, we send an empty non-error response on context deadline expiry. Here we compute a\n+\t// deadline that causes us to send that response before the caller's own deadline (see\n+\t// chasm.activity.longPollBuffer). We also cap the caller's deadline at\n+\t// chasm.activity.longPollTimeout.\n+\tnamespace := req.GetFrontendRequest().GetNamespace()\n+\tctx, cancel := contextutil.WithDeadlineBuffer(\n+\t\tctx,\n+\t\th.config.LongPollTimeout(namespace),\n+\t\th.config.LongPollBuffer(namespace),\n+\t)\n+\tdefer cancel()\n+\n+\tswitch waitPolicy.(type) {\n+\tcase *workflowservice.PollActivityExecutionRequest_WaitAnyStateChange:\n+\t\ttoken := req.GetFrontendRequest().\n+\t\t\tGetWaitPolicy().(*workflowservice.PollActivityExecutionRequest_WaitAnyStateChange).\n+\t\t\tWaitAnyStateChange.GetLongPollToken()\n+\t\tif len(token) == 0 {\n+\t\t\treturn chasm.ReadComponent(ctx, ref, (*Activity).buildPollActivityExecutionResponse, req, nil)\n+\t\t}\n+\t\tresponse, _, err = chasm.PollComponent(ctx, ref, func(\n+\t\t\ta *Activity,\n+\t\t\tctx chasm.Context,\n+\t\t\treq *activitypb.PollActivityExecutionRequest,\n+\t\t) (*activitypb.PollActivityExecutionResponse, bool, error) {\n+\t\t\tchanged, err := chasm.ExecutionStateChanged(a, ctx, token)\n+\t\t\tif err != nil {\n+\t\t\t\tif errors.Is(err, chasm.ErrMalformedComponentRef) {\n+\t\t\t\t\treturn nil, false, serviceerror.NewInvalidArgument(\"invalid long poll token\")\n+\t\t\t\t}\n+\t\t\t\tif errors.Is(err, chasm.ErrInvalidComponentRef) {\n+\t\t\t\t\treturn nil, false, serviceerror.NewInvalidArgument(\"long poll token does not match execution\")\n+\t\t\t\t}\n+\t\t\t\treturn nil, false, err\n+\t\t\t}\n+\t\t\tif changed {\n+\t\t\t\tresponse, err := a.buildPollActivityExecutionResponse(ctx, req)\n+\t\t\t\treturn response, true, err\n+\t\t\t} else {\n+\t\t\t\treturn nil, false, nil\n+\t\t\t}\n+\t\t}, req)\n+\tcase *workflowservice.PollActivityExecutionRequest_WaitCompletion:\n+\t\t// TODO(dan): add functional test when RecordActivityTaskCompleted is implemented\n+\t\tresponse, _, err = chasm.PollComponent(ctx, ref, func(\n+\t\t\ta *Activity,\n+\t\t\tctx chasm.Context,\n+\t\t\treq *activitypb.PollActivityExecutionRequest,\n+\t\t) (*activitypb.PollActivityExecutionResponse, bool, error) {\n+\t\t\t// TODO(dan): check for terminal activity states\n+\t\t\tpanic(\"pollActivityExecutionWaitCompletion is not implemented\")\n+\t\t\tcompleted := false\n+\t\t\tif completed {\n+\t\t\t\tresponse, err := a.buildPollActivityExecutionResponse(ctx, req)\n+\t\t\t\tif err != nil {\n+\t\t\t\t\treturn nil, true, err\n+\t\t\t\t}\n+\t\t\t\treturn response, true, nil\n+\t\t\t}\n+\t\t\treturn nil, false, nil\n+\t\t}, req)\n+\tdefault:\n+\t\treturn nil, serviceerror.NewInvalidArgumentf(\"unexpected wait policy type: %T\", waitPolicy)\n+\t}\n+\n+\tif ctx.Err() != nil {\n+\t\t// We send an empty non-error response on deadline expiry as an invitation to the caller to\n+\t\t// resubmit their long-poll.\n+\n+\t\t// TODO(dan): the definition of \"empty\" is unclear, since callers can currently choose to\n+\t\t// exclude info, outcome, and input from the result. Currently, a caller can infer that the\n+\t\t// long-poll timed out due to a server-imposed timeout from the absence of the long-poll\n+\t\t// token. However, this is not a clear API. We are considering splitting the public API into\n+\t\t// two methods: one that returns info (optionally with input), and one that returns result,\n+\t\t// both with long-poll options. An empty response will then be more obvious to the caller.\n+\t\treturn &activitypb.PollActivityExecutionResponse{\n+\t\t\tFrontendResponse: &workflowservice.PollActivityExecutionResponse{},\n+\t\t}, nil\n+\t}","path":"chasm/lib/activity/handler.go","commit_id":"1d59e66d0ce5d91819f92c428ef5ab4c4efca1fb","original_commit_id":"4a8b8417884580e27819b1b1215b4cd7551e70d8","user":{"login":"bergundy","id":52304,"node_id":"MDQ6VXNlcjUyMzA0","avatar_url":"https://avatars.githubusercontent.com/u/52304?v=4","gravatar_id":"","url":"https://api.github.com/users/bergundy","html_url":"https://github.com/bergundy","followers_url":"https://api.github.com/users/bergundy/followers","following_url":"https://api.github.com/users/bergundy/following{/other_user}","gists_url":"https://api.github.com/users/bergundy/gists{/gist_id}","starred_url":"https://api.github.com/users/bergundy/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/bergundy/subscriptions","organizations_url":"https://api.github.com/users/bergundy/orgs","repos_url":"https://api.github.com/users/bergundy/repos","events_url":"https://api.github.com/users/bergundy/events{/privacy}","received_events_url":"https://api.github.com/users/bergundy/received_events","type":"User","user_view_type":"public","site_admin":false},"body":"I don't think it's worth changing anything.","created_at":"2025-12-05T00:54:19Z","updated_at":"2025-12-05T00:54:19Z","html_url":"https://github.com/temporalio/temporal/pull/8563#discussion_r2591059754","pull_request_url":"https://api.github.com/repos/temporalio/temporal/pulls/8563","_links":{"self":{"href":"https://api.github.com/repos/temporalio/temporal/pulls/comments/2591059754"},"html":{"href":"https://github.com/temporalio/temporal/pull/8563#discussion_r2591059754"},"pull_request":{"href":"https://api.github.com/repos/temporalio/temporal/pulls/8563"}},"reactions":{"url":"https://api.github.com/repos/temporalio/temporal/pulls/comments/2591059754/reactions","total_count":1,"+1":1,"-1":0,"laugh":0,"hooray":0,"confused":0,"heart":0,"rocket":0,"eyes":0},"start_line":null,"original_start_line":null,"start_side":null,"line":170,"original_line":174,"side":"RIGHT","in_reply_to_id":2587049516,"author_association":"MEMBER","original_position":143,"position":139,"subject_type":"line"},{"url":"https://api.github.com/repos/temporalio/temporal/pulls/comments/2591062791","pull_request_review_id":3542686309,"id":2591062791,"node_id":"PRRC_kwDODNqesM6acHsH","diff_hunk":"@@ -190,6 +191,27 @@ func (t *TransactionImpl) UpdateWorkflowExecution(\n \tif persistence.OperationPossiblySucceeded(err) {\n \t\tNotifyWorkflowMutationTasks(engine, currentWorkflowMutation)\n \t\tNotifyWorkflowSnapshotTasks(engine, newWorkflowSnapshot)\n+\n+\t\t// TODO(dan): there is no test coverage for on-delete or on-create CHASM notifications.\n+\n+\t\t// Notify for current workflow if it has CHASM updates\n+\t\tif len(currentWorkflowMutation.UpsertChasmNodes) > 0 ||\n+\t\t\tlen(currentWorkflowMutation.DeleteChasmNodes) > 0 {\n+\t\t\tengine.NotifyChasmExecution(chasm.EntityKey{","path":"service/history/workflow/transaction_impl.go","commit_id":"1d59e66d0ce5d91819f92c428ef5ab4c4efca1fb","original_commit_id":"101822827ec6f0ce5eb6c86421c7162b8ba21321","user":{"login":"yycptt","id":7754120,"node_id":"MDQ6VXNlcjc3NTQxMjA=","avatar_url":"https://avatars.githubusercontent.com/u/7754120?v=4","gravatar_id":"","url":"https://api.github.com/users/yycptt","html_url":"https://github.com/yycptt","followers_url":"https://api.github.com/users/yycptt/followers","following_url":"https://api.github.com/users/yycptt/following{/other_user}","gists_url":"https://api.github.com/users/yycptt/gists{/gist_id}","starred_url":"https://api.github.com/users/yycptt/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/yycptt/subscriptions","organizations_url":"https://api.github.com/users/yycptt/orgs","repos_url":"https://api.github.com/users/yycptt/repos","events_url":"https://api.github.com/users/yycptt/events{/privacy}","received_events_url":"https://api.github.com/users/yycptt/received_events","type":"User","user_view_type":"public","site_admin":false},"body":"let's do it in ConflictResolveExecution as well. Create execution is probably fine, I guess there won't be any poller before execution is created.","created_at":"2025-12-05T00:56:26Z","updated_at":"2025-12-05T01:05:40Z","html_url":"https://github.com/temporalio/temporal/pull/8563#discussion_r2591062791","pull_request_url":"https://api.github.com/repos/temporalio/temporal/pulls/8563","_links":{"self":{"href":"https://api.github.com/repos/temporalio/temporal/pulls/comments/2591062791"},"html":{"href":"https://github.com/temporalio/temporal/pull/8563#discussion_r2591062791"},"pull_request":{"href":"https://api.github.com/repos/temporalio/temporal/pulls/8563"}},"reactions":{"url":"https://api.github.com/repos/temporalio/temporal/pulls/comments/2591062791/reactions","total_count":0,"+1":0,"-1":0,"laugh":0,"hooray":0,"confused":0,"heart":0,"rocket":0,"eyes":0},"start_line":null,"original_start_line":null,"start_side":null,"line":200,"original_line":200,"side":"RIGHT","author_association":"MEMBER","original_position":18,"position":18,"subject_type":"line"},{"url":"https://api.github.com/repos/temporalio/temporal/pulls/comments/2591064304","pull_request_review_id":3542686309,"id":2591064304,"node_id":"PRRC_kwDODNqesM6acIDw","diff_hunk":"@@ -190,6 +191,27 @@ func (t *TransactionImpl) UpdateWorkflowExecution(\n \tif persistence.OperationPossiblySucceeded(err) {\n \t\tNotifyWorkflowMutationTasks(engine, currentWorkflowMutation)\n \t\tNotifyWorkflowSnapshotTasks(engine, newWorkflowSnapshot)\n+\n+\t\t// TODO(dan): there is no test coverage for on-delete or on-create CHASM notifications.\n+\n+\t\t// Notify for current workflow if it has CHASM updates\n+\t\tif len(currentWorkflowMutation.UpsertChasmNodes) > 0 ||\n+\t\t\tlen(currentWorkflowMutation.DeleteChasmNodes) > 0 {\n+\t\t\tengine.NotifyChasmExecution(chasm.EntityKey{","path":"service/history/workflow/transaction_impl.go","commit_id":"1d59e66d0ce5d91819f92c428ef5ab4c4efca1fb","original_commit_id":"101822827ec6f0ce5eb6c86421c7162b8ba21321","user":{"login":"yycptt","id":7754120,"node_id":"MDQ6VXNlcjc3NTQxMjA=","avatar_url":"https://avatars.githubusercontent.com/u/7754120?v=4","gravatar_id":"","url":"https://api.github.com/users/yycptt","html_url":"https://github.com/yycptt","followers_url":"https://api.github.com/users/yycptt/followers","following_url":"https://api.github.com/users/yycptt/following{/other_user}","gists_url":"https://api.github.com/users/yycptt/gists{/gist_id}","starred_url":"https://api.github.com/users/yycptt/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/yycptt/subscriptions","organizations_url":"https://api.github.com/users/yycptt/orgs","repos_url":"https://api.github.com/users/yycptt/repos","events_url":"https://api.github.com/users/yycptt/events{/privacy}","received_events_url":"https://api.github.com/users/yycptt/received_events","type":"User","user_view_type":"public","site_admin":false},"body":"hmm I haven't think through if it needs to be in OperationPossiblySucceeded. Can you elaborate your thoughts a bit here.","created_at":"2025-12-05T00:57:33Z","updated_at":"2025-12-05T01:05:40Z","html_url":"https://github.com/temporalio/temporal/pull/8563#discussion_r2591064304","pull_request_url":"https://api.github.com/repos/temporalio/temporal/pulls/8563","_links":{"self":{"href":"https://api.github.com/repos/temporalio/temporal/pulls/comments/2591064304"},"html":{"href":"https://github.com/temporalio/temporal/pull/8563#discussion_r2591064304"},"pull_request":{"href":"https://api.github.com/repos/temporalio/temporal/pulls/8563"}},"reactions":{"url":"https://api.github.com/repos/temporalio/temporal/pulls/comments/2591064304/reactions","total_count":0,"+1":0,"-1":0,"laugh":0,"hooray":0,"confused":0,"heart":0,"rocket":0,"eyes":0},"start_line":null,"original_start_line":null,"start_side":null,"line":200,"original_line":200,"side":"RIGHT","in_reply_to_id":2591062791,"author_association":"MEMBER","original_position":18,"position":18,"subject_type":"line"},{"url":"https://api.github.com/repos/temporalio/temporal/pulls/comments/2591067330","pull_request_review_id":3542695108,"id":2591067330,"node_id":"PRRC_kwDODNqesM6acIzC","diff_hunk":"@@ -53,3 +59,118 @@ func (h *handler) StartActivityExecution(ctx context.Context, req *activitypb.St\n \t\tFrontendResponse: response,\n \t}, nil\n }\n+\n+// PollActivityExecution handles PollActivityExecutionRequest from frontend. This method supports\n+// querying current activity state, optionally as a long-poll that waits for certain state changes.\n+// It is used by clients to poll for activity state and/or result. When used to long-poll, it\n+// returns an empty non-error response on context deadline expiry, to indicate that the state being\n+// waited for was not reached. Callers should interpret this as an invitation to resubmit their\n+// long-poll request. This response is sent before the caller's deadline (see\n+// chasm.activity.longPollBuffer) so that it is likely that the caller does indeed receive the\n+// non-error response.\n+func (h *handler) PollActivityExecution(\n+\tctx context.Context,\n+\treq *activitypb.PollActivityExecutionRequest,\n+) (response *activitypb.PollActivityExecutionResponse, err error) {\n+\tref := chasm.NewComponentRef[*Activity](chasm.EntityKey{\n+\t\tNamespaceID: req.GetNamespaceId(),\n+\t\tBusinessID:  req.GetFrontendRequest().GetActivityId(),\n+\t\tEntityID:    req.GetFrontendRequest().GetRunId(),\n+\t})\n+\tdefer func() {\n+\t\tvar notFound *serviceerror.NotFound\n+\t\tif errors.As(err, &notFound) {\n+\t\t\t// TODO(dan): include execution key in error message; we may do this at the CHASM\n+\t\t\t// framework level.\n+\t\t\t// cf. \"workflow execution not found for workflow ID XXX and run ID YYY\"\n+\t\t\terr = serviceerror.NewNotFound(\"activity execution not found\")\n+\t\t}\n+\t}()\n+\n+\twaitPolicy := req.GetFrontendRequest().GetWaitPolicy()\n+\n+\tif waitPolicy == nil {\n+\t\treturn chasm.ReadComponent(ctx, ref, (*Activity).buildPollActivityExecutionResponse, req, nil)\n+\t}\n+\n+\t// Below, we send an empty non-error response on context deadline expiry. Here we compute a\n+\t// deadline that causes us to send that response before the caller's own deadline (see\n+\t// chasm.activity.longPollBuffer). We also cap the caller's deadline at\n+\t// chasm.activity.longPollTimeout.\n+\tnamespace := req.GetFrontendRequest().GetNamespace()\n+\tctx, cancel := contextutil.WithDeadlineBuffer(\n+\t\tctx,\n+\t\th.config.LongPollTimeout(namespace),\n+\t\th.config.LongPollBuffer(namespace),\n+\t)\n+\tdefer cancel()\n+\n+\tswitch waitPolicy.(type) {","path":"chasm/lib/activity/handler.go","commit_id":"34b3f8a7f60cc35efeeb40e6870798011c42c1ab","original_commit_id":"8aa718931afd6a83e7694ad3b97cec208dcf61e1","user":{"login":"dandavison","id":52205,"node_id":"MDQ6VXNlcjUyMjA1","avatar_url":"https://avatars.githubusercontent.com/u/52205?v=4","gravatar_id":"","url":"https://api.github.com/users/dandavison","html_url":"https://github.com/dandavison","followers_url":"https://api.github.com/users/dandavison/followers","following_url":"https://api.github.com/users/dandavison/following{/other_user}","gists_url":"https://api.github.com/users/dandavison/gists{/gist_id}","starred_url":"https://api.github.com/users/dandavison/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/dandavison/subscriptions","organizations_url":"https://api.github.com/users/dandavison/orgs","repos_url":"https://api.github.com/users/dandavison/repos","events_url":"https://api.github.com/users/dandavison/events{/privacy}","received_events_url":"https://api.github.com/users/dandavison/received_events","type":"User","user_view_type":"public","site_admin":false},"body":"Thanks, taken","created_at":"2025-12-05T00:59:52Z","updated_at":"2025-12-05T01:19:17Z","html_url":"https://github.com/temporalio/temporal/pull/8563#discussion_r2591067330","pull_request_url":"https://api.github.com/repos/temporalio/temporal/pulls/8563","_links":{"self":{"href":"https://api.github.com/repos/temporalio/temporal/pulls/comments/2591067330"},"html":{"href":"https://github.com/temporalio/temporal/pull/8563#discussion_r2591067330"},"pull_request":{"href":"https://api.github.com/repos/temporalio/temporal/pulls/8563"}},"reactions":{"url":"https://api.github.com/repos/temporalio/temporal/pulls/comments/2591067330/reactions","total_count":0,"+1":0,"-1":0,"laugh":0,"hooray":0,"confused":0,"heart":0,"rocket":0,"eyes":0},"start_line":null,"original_start_line":null,"start_side":null,"line":null,"original_line":108,"side":"RIGHT","in_reply_to_id":2591014557,"author_association":"MEMBER","original_position":77,"position":1,"subject_type":"line"},{"url":"https://api.github.com/repos/temporalio/temporal/pulls/comments/2591067529","pull_request_review_id":3542686309,"id":2591067529,"node_id":"PRRC_kwDODNqesM6acI2J","diff_hunk":"@@ -241,14 +256,122 @@ func (e *ChasmEngine) ReadComponent(\n \treturn readFn(chasmContext, component)\n }\n \n+// PollComponent waits until the supplied predicate is satisfied when evaluated against the\n+// component identified by the supplied component reference. If there is no error, it returns (ref,\n+// nil) where ref is a component reference identifying the state at which the predicate was\n+// satisfied. It's possible that multiple state transitions (multiple notifications) occur between\n+// predicate checks, therefore the predicate must be monotonic: if it returns true at execution\n+// state transition s it must return true at all transitions t > s. It is an error if execution\n+// transition history is (after reloading from persistence) behind the requested ref, or if the ref\n+// is inconsistent with execution transition history. Thus when the predicate function is evaluated,\n+// it is guaranteed that the execution VT >= requestRef VT. opts are currently ignored.\n+// PollComponent subscribes to execution-level notifications. Suppose that an execution consists of\n+// one component A, and A has subcomponent B. Subscribers interested only in component B may be\n+// woken up unnecessarily (and thus evaluate the predicate unnecessarily) due to changes in parts of\n+// A that do not also belong to B.\n func (e *ChasmEngine) PollComponent(\n \tctx context.Context,\n-\tentityRef chasm.ComponentRef,\n-\tpredicateFn func(chasm.Context, chasm.Component) (any, bool, error),\n-\toperationFn func(chasm.MutableContext, chasm.Component, any) error,\n+\trequestRef chasm.ComponentRef,\n+\tmonotonicPredicate func(chasm.Context, chasm.Component) (bool, error),\n \topts ...chasm.TransitionOption,\n-) (newEntityRef []byte, retError error) {\n-\treturn nil, serviceerror.NewUnimplemented(\"PollComponent is not yet supported\")\n+) (retRef []byte, retError error) {\n+\n+\tvar ch <-chan struct{}\n+\tvar unsubscribe func()\n+\tdefer func() {\n+\t\tif unsubscribe != nil {\n+\t\t\tunsubscribe()\n+\t\t}\n+\t}()\n+\n+\tcheckPredicateOrSubscribe := func() ([]byte, error) {\n+\t\t_, executionLease, err := e.getExecutionLease(ctx, requestRef)\n+\t\tif err != nil {\n+\t\t\treturn nil, err\n+\t\t}\n+\t\tdefer executionLease.GetReleaseFn()(nil)\n+\n+\t\tref, err := e.predicateSatisfied(ctx, monotonicPredicate, requestRef, executionLease)\n+\t\tif err != nil {\n+\t\t\tif errors.Is(err, consts.ErrStaleState) {\n+\t\t\t\terr = serviceerror.NewUnavailable(\"please retry\")\n+\t\t\t}\n+\t\t\treturn nil, err\n+\t\t}\n+\t\tif ref != nil {\n+\t\t\treturn ref, nil\n+\t\t}\n+\t\t// Predicate not satisfied; subscribe before releasing the lock.\n+\t\tch, unsubscribe = e.notifier.Subscribe(requestRef.EntityKey)\n+\t\treturn nil, nil\n+\t}\n+\n+\tref, err := checkPredicateOrSubscribe()\n+\tif err != nil {\n+\t\treturn nil, err\n+\t}\n+\tif ref != nil {\n+\t\treturn ref, nil\n+\t}\n+\n+\tfor {\n+\t\tselect {\n+\t\tcase <-ch:\n+\t\t\tref, err := checkPredicateOrSubscribe()\n+\t\t\tif err != nil {\n+\t\t\t\treturn nil, err\n+\t\t\t}\n+\t\t\tif ref != nil {\n+\t\t\t\treturn ref, nil\n+\t\t\t}\n+\t\tcase <-ctx.Done():","path":"service/history/chasm_engine.go","commit_id":"1d59e66d0ce5d91819f92c428ef5ab4c4efca1fb","original_commit_id":"101822827ec6f0ce5eb6c86421c7162b8ba21321","user":{"login":"yycptt","id":7754120,"node_id":"MDQ6VXNlcjc3NTQxMjA=","avatar_url":"https://avatars.githubusercontent.com/u/7754120?v=4","gravatar_id":"","url":"https://api.github.com/users/yycptt","html_url":"https://github.com/yycptt","followers_url":"https://api.github.com/users/yycptt/followers","following_url":"https://api.github.com/users/yycptt/following{/other_user}","gists_url":"https://api.github.com/users/yycptt/gists{/gist_id}","starred_url":"https://api.github.com/users/yycptt/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/yycptt/subscriptions","organizations_url":"https://api.github.com/users/yycptt/orgs","repos_url":"https://api.github.com/users/yycptt/repos","events_url":"https://api.github.com/users/yycptt/events{/privacy}","received_events_url":"https://api.github.com/users/yycptt/received_events","type":"User","user_view_type":"public","site_admin":false},"body":"do we have some tail room here to return an empty response and avoid a timeout error?","created_at":"2025-12-05T00:59:58Z","updated_at":"2025-12-05T01:05:40Z","html_url":"https://github.com/temporalio/temporal/pull/8563#discussion_r2591067529","pull_request_url":"https://api.github.com/repos/temporalio/temporal/pulls/8563","_links":{"self":{"href":"https://api.github.com/repos/temporalio/temporal/pulls/comments/2591067529"},"html":{"href":"https://github.com/temporalio/temporal/pull/8563#discussion_r2591067529"},"pull_request":{"href":"https://api.github.com/repos/temporalio/temporal/pulls/8563"}},"reactions":{"url":"https://api.github.com/repos/temporalio/temporal/pulls/comments/2591067529/reactions","total_count":0,"+1":0,"-1":0,"laugh":0,"hooray":0,"confused":0,"heart":0,"rocket":0,"eyes":0},"start_line":null,"original_start_line":null,"start_side":null,"line":324,"original_line":327,"side":"RIGHT","author_association":"MEMBER","original_position":143,"position":136,"subject_type":"line"},{"url":"https://api.github.com/repos/temporalio/temporal/pulls/comments/2591068908","pull_request_review_id":3542695108,"id":2591068908,"node_id":"PRRC_kwDODNqesM6acJLs","diff_hunk":"@@ -53,3 +59,118 @@ func (h *handler) StartActivityExecution(ctx context.Context, req *activitypb.St\n \t\tFrontendResponse: response,\n \t}, nil\n }\n+\n+// PollActivityExecution handles PollActivityExecutionRequest from frontend. This method supports\n+// querying current activity state, optionally as a long-poll that waits for certain state changes.\n+// It is used by clients to poll for activity state and/or result. When used to long-poll, it\n+// returns an empty non-error response on context deadline expiry, to indicate that the state being\n+// waited for was not reached. Callers should interpret this as an invitation to resubmit their\n+// long-poll request. This response is sent before the caller's deadline (see\n+// chasm.activity.longPollBuffer) so that it is likely that the caller does indeed receive the\n+// non-error response.\n+func (h *handler) PollActivityExecution(\n+\tctx context.Context,\n+\treq *activitypb.PollActivityExecutionRequest,\n+) (response *activitypb.PollActivityExecutionResponse, err error) {\n+\tref := chasm.NewComponentRef[*Activity](chasm.EntityKey{\n+\t\tNamespaceID: req.GetNamespaceId(),\n+\t\tBusinessID:  req.GetFrontendRequest().GetActivityId(),\n+\t\tEntityID:    req.GetFrontendRequest().GetRunId(),\n+\t})\n+\tdefer func() {\n+\t\tvar notFound *serviceerror.NotFound\n+\t\tif errors.As(err, &notFound) {\n+\t\t\t// TODO(dan): include execution key in error message; we may do this at the CHASM\n+\t\t\t// framework level.\n+\t\t\t// cf. \"workflow execution not found for workflow ID XXX and run ID YYY\"\n+\t\t\terr = serviceerror.NewNotFound(\"activity execution not found\")\n+\t\t}\n+\t}()\n+\n+\twaitPolicy := req.GetFrontendRequest().GetWaitPolicy()\n+\n+\tif waitPolicy == nil {\n+\t\treturn chasm.ReadComponent(ctx, ref, (*Activity).buildPollActivityExecutionResponse, req, nil)\n+\t}\n+\n+\t// Below, we send an empty non-error response on context deadline expiry. Here we compute a\n+\t// deadline that causes us to send that response before the caller's own deadline (see\n+\t// chasm.activity.longPollBuffer). We also cap the caller's deadline at\n+\t// chasm.activity.longPollTimeout.\n+\tnamespace := req.GetFrontendRequest().GetNamespace()\n+\tctx, cancel := contextutil.WithDeadlineBuffer(\n+\t\tctx,\n+\t\th.config.LongPollTimeout(namespace),\n+\t\th.config.LongPollBuffer(namespace),\n+\t)\n+\tdefer cancel()\n+\n+\tswitch waitPolicy.(type) {\n+\tcase *workflowservice.PollActivityExecutionRequest_WaitAnyStateChange:\n+\t\ttoken := req.GetFrontendRequest().\n+\t\t\tGetWaitPolicy().(*workflowservice.PollActivityExecutionRequest_WaitAnyStateChange).\n+\t\t\tWaitAnyStateChange.GetLongPollToken()\n+\t\tif len(token) == 0 {\n+\t\t\treturn chasm.ReadComponent(ctx, ref, (*Activity).buildPollActivityExecutionResponse, req, nil)\n+\t\t}","path":"chasm/lib/activity/handler.go","commit_id":"1d59e66d0ce5d91819f92c428ef5ab4c4efca1fb","original_commit_id":"8aa718931afd6a83e7694ad3b97cec208dcf61e1","user":{"login":"dandavison","id":52205,"node_id":"MDQ6VXNlcjUyMjA1","avatar_url":"https://avatars.githubusercontent.com/u/52205?v=4","gravatar_id":"","url":"https://api.github.com/users/dandavison","html_url":"https://github.com/dandavison","followers_url":"https://api.github.com/users/dandavison/followers","following_url":"https://api.github.com/users/dandavison/following{/other_user}","gists_url":"https://api.github.com/users/dandavison/gists{/gist_id}","starred_url":"https://api.github.com/users/dandavison/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/dandavison/subscriptions","organizations_url":"https://api.github.com/users/dandavison/orgs","repos_url":"https://api.github.com/users/dandavison/repos","events_url":"https://api.github.com/users/dandavison/events{/privacy}","received_events_url":"https://api.github.com/users/dandavison/received_events","type":"User","user_view_type":"public","site_admin":false},"body":"OK, we will address when we split the API","created_at":"2025-12-05T01:01:03Z","updated_at":"2025-12-05T01:19:17Z","html_url":"https://github.com/temporalio/temporal/pull/8563#discussion_r2591068908","pull_request_url":"https://api.github.com/repos/temporalio/temporal/pulls/8563","_links":{"self":{"href":"https://api.github.com/repos/temporalio/temporal/pulls/comments/2591068908"},"html":{"href":"https://github.com/temporalio/temporal/pull/8563#discussion_r2591068908"},"pull_request":{"href":"https://api.github.com/repos/temporalio/temporal/pulls/8563"}},"reactions":{"url":"https://api.github.com/repos/temporalio/temporal/pulls/comments/2591068908/reactions","total_count":0,"+1":0,"-1":0,"laugh":0,"hooray":0,"confused":0,"heart":0,"rocket":0,"eyes":0},"start_line":110,"original_start_line":113,"start_side":"RIGHT","line":112,"original_line":115,"side":"RIGHT","in_reply_to_id":2591011364,"author_association":"MEMBER","original_position":84,"position":81,"subject_type":"line"},{"url":"https://api.github.com/repos/temporalio/temporal/pulls/comments/2591071579","pull_request_review_id":3542686309,"id":2591071579,"node_id":"PRRC_kwDODNqesM6acJ1b","diff_hunk":"@@ -241,14 +256,122 @@ func (e *ChasmEngine) ReadComponent(\n \treturn readFn(chasmContext, component)\n }\n \n+// PollComponent waits until the supplied predicate is satisfied when evaluated against the\n+// component identified by the supplied component reference. If there is no error, it returns (ref,\n+// nil) where ref is a component reference identifying the state at which the predicate was\n+// satisfied. It's possible that multiple state transitions (multiple notifications) occur between\n+// predicate checks, therefore the predicate must be monotonic: if it returns true at execution\n+// state transition s it must return true at all transitions t > s. It is an error if execution\n+// transition history is (after reloading from persistence) behind the requested ref, or if the ref\n+// is inconsistent with execution transition history. Thus when the predicate function is evaluated,\n+// it is guaranteed that the execution VT >= requestRef VT. opts are currently ignored.\n+// PollComponent subscribes to execution-level notifications. Suppose that an execution consists of\n+// one component A, and A has subcomponent B. Subscribers interested only in component B may be\n+// woken up unnecessarily (and thus evaluate the predicate unnecessarily) due to changes in parts of\n+// A that do not also belong to B.\n func (e *ChasmEngine) PollComponent(\n \tctx context.Context,\n-\tentityRef chasm.ComponentRef,\n-\tpredicateFn func(chasm.Context, chasm.Component) (any, bool, error),\n-\toperationFn func(chasm.MutableContext, chasm.Component, any) error,\n+\trequestRef chasm.ComponentRef,\n+\tmonotonicPredicate func(chasm.Context, chasm.Component) (bool, error),\n \topts ...chasm.TransitionOption,\n-) (newEntityRef []byte, retError error) {\n-\treturn nil, serviceerror.NewUnimplemented(\"PollComponent is not yet supported\")\n+) (retRef []byte, retError error) {\n+\n+\tvar ch <-chan struct{}\n+\tvar unsubscribe func()\n+\tdefer func() {\n+\t\tif unsubscribe != nil {\n+\t\t\tunsubscribe()\n+\t\t}\n+\t}()\n+\n+\tcheckPredicateOrSubscribe := func() ([]byte, error) {\n+\t\t_, executionLease, err := e.getExecutionLease(ctx, requestRef)\n+\t\tif err != nil {\n+\t\t\treturn nil, err\n+\t\t}\n+\t\tdefer executionLease.GetReleaseFn()(nil)\n+\n+\t\tref, err := e.predicateSatisfied(ctx, monotonicPredicate, requestRef, executionLease)\n+\t\tif err != nil {\n+\t\t\tif errors.Is(err, consts.ErrStaleState) {\n+\t\t\t\terr = serviceerror.NewUnavailable(\"please retry\")\n+\t\t\t}\n+\t\t\treturn nil, err\n+\t\t}\n+\t\tif ref != nil {\n+\t\t\treturn ref, nil\n+\t\t}\n+\t\t// Predicate not satisfied; subscribe before releasing the lock.\n+\t\tch, unsubscribe = e.notifier.Subscribe(requestRef.EntityKey)\n+\t\treturn nil, nil\n+\t}\n+\n+\tref, err := checkPredicateOrSubscribe()\n+\tif err != nil {\n+\t\treturn nil, err\n+\t}\n+\tif ref != nil {\n+\t\treturn ref, nil\n+\t}\n+\n+\tfor {\n+\t\tselect {\n+\t\tcase <-ch:\n+\t\t\tref, err := checkPredicateOrSubscribe()\n+\t\t\tif err != nil {\n+\t\t\t\treturn nil, err\n+\t\t\t}\n+\t\t\tif ref != nil {\n+\t\t\t\treturn ref, nil\n+\t\t\t}\n+\t\tcase <-ctx.Done():\n+\t\t\treturn nil, ctx.Err()\n+\t\t}\n+\t}\n+}\n+\n+// predicateSatisfied is a helper function for PollComponent. It returns (ref, err) where ref is non-nil\n+// iff there's no error and predicate evaluates to true.\n+func (e *ChasmEngine) predicateSatisfied(\n+\tctx context.Context,\n+\tpredicate func(chasm.Context, chasm.Component) (bool, error),\n+\tref chasm.ComponentRef,\n+\texecutionLease api.WorkflowLease,\n+) ([]byte, error) {\n+\tchasmTree, ok := executionLease.GetMutableState().ChasmTree().(*chasm.Node)\n+\tif !ok {\n+\t\treturn nil, serviceerror.NewInternalf(\n+\t\t\t\"CHASM tree implementation not properly wired up, encountered type: %T, expected type: %T\",\n+\t\t\texecutionLease.GetMutableState().ChasmTree(),\n+\t\t\t&chasm.Node{},\n+\t\t)\n+\t}\n+\n+\t// It is not acceptable to declare the predicate to be satisfied against execution state that is\n+\t// behind the requested reference. However, getExecutionLease does not currently guarantee that\n+\t// execution VT >= ref VT, therefore we call IsStale() again here and return any error (which at\n+\t// this point must be ErrStaleState; ErrStaleReference has already been eliminated).\n+\terr := chasmTree.IsStale(ref)","path":"service/history/chasm_engine.go","commit_id":"1d59e66d0ce5d91819f92c428ef5ab4c4efca1fb","original_commit_id":"101822827ec6f0ce5eb6c86421c7162b8ba21321","user":{"login":"yycptt","id":7754120,"node_id":"MDQ6VXNlcjc3NTQxMjA=","avatar_url":"https://avatars.githubusercontent.com/u/7754120?v=4","gravatar_id":"","url":"https://api.github.com/users/yycptt","html_url":"https://github.com/yycptt","followers_url":"https://api.github.com/users/yycptt/followers","following_url":"https://api.github.com/users/yycptt/following{/other_user}","gists_url":"https://api.github.com/users/yycptt/gists{/gist_id}","starred_url":"https://api.github.com/users/yycptt/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/yycptt/subscriptions","organizations_url":"https://api.github.com/users/yycptt/orgs","repos_url":"https://api.github.com/users/yycptt/repos","events_url":"https://api.github.com/users/yycptt/events{/privacy}","received_events_url":"https://api.github.com/users/yycptt/received_events","type":"User","user_view_type":"public","site_admin":false},"body":"this is already checked in getExecutionLease? or it's for fixing the bug we discussed before that getExecutionLease needs to do another stale check after reload?","created_at":"2025-12-05T01:03:08Z","updated_at":"2025-12-05T01:05:40Z","html_url":"https://github.com/temporalio/temporal/pull/8563#discussion_r2591071579","pull_request_url":"https://api.github.com/repos/temporalio/temporal/pulls/8563","_links":{"self":{"href":"https://api.github.com/repos/temporalio/temporal/pulls/comments/2591071579"},"html":{"href":"https://github.com/temporalio/temporal/pull/8563#discussion_r2591071579"},"pull_request":{"href":"https://api.github.com/repos/temporalio/temporal/pulls/8563"}},"reactions":{"url":"https://api.github.com/repos/temporalio/temporal/pulls/comments/2591071579/reactions","total_count":0,"+1":0,"-1":0,"laugh":0,"hooray":0,"confused":0,"heart":0,"rocket":0,"eyes":0},"start_line":null,"original_start_line":null,"start_side":null,"line":351,"original_line":354,"side":"RIGHT","author_association":"MEMBER","original_position":170,"position":163,"subject_type":"line"},{"url":"https://api.github.com/repos/temporalio/temporal/pulls/comments/2591088354","pull_request_review_id":3542695108,"id":2591088354,"node_id":"PRRC_kwDODNqesM6acN7i","diff_hunk":"@@ -241,14 +256,122 @@ func (e *ChasmEngine) ReadComponent(\n \treturn readFn(chasmContext, component)\n }\n \n+// PollComponent waits until the supplied predicate is satisfied when evaluated against the\n+// component identified by the supplied component reference. If there is no error, it returns (ref,\n+// nil) where ref is a component reference identifying the state at which the predicate was\n+// satisfied. It's possible that multiple state transitions (multiple notifications) occur between\n+// predicate checks, therefore the predicate must be monotonic: if it returns true at execution\n+// state transition s it must return true at all transitions t > s. It is an error if execution\n+// transition history is (after reloading from persistence) behind the requested ref, or if the ref\n+// is inconsistent with execution transition history. Thus when the predicate function is evaluated,\n+// it is guaranteed that the execution VT >= requestRef VT. opts are currently ignored.\n+// PollComponent subscribes to execution-level notifications. Suppose that an execution consists of\n+// one component A, and A has subcomponent B. Subscribers interested only in component B may be\n+// woken up unnecessarily (and thus evaluate the predicate unnecessarily) due to changes in parts of\n+// A that do not also belong to B.\n func (e *ChasmEngine) PollComponent(\n \tctx context.Context,\n-\tentityRef chasm.ComponentRef,\n-\tpredicateFn func(chasm.Context, chasm.Component) (any, bool, error),\n-\toperationFn func(chasm.MutableContext, chasm.Component, any) error,\n+\trequestRef chasm.ComponentRef,\n+\tmonotonicPredicate func(chasm.Context, chasm.Component) (bool, error),\n \topts ...chasm.TransitionOption,\n-) (newEntityRef []byte, retError error) {\n-\treturn nil, serviceerror.NewUnimplemented(\"PollComponent is not yet supported\")\n+) (retRef []byte, retError error) {\n+\n+\tvar ch <-chan struct{}\n+\tvar unsubscribe func()\n+\tdefer func() {\n+\t\tif unsubscribe != nil {\n+\t\t\tunsubscribe()\n+\t\t}\n+\t}()\n+\n+\tcheckPredicateOrSubscribe := func() ([]byte, error) {\n+\t\t_, executionLease, err := e.getExecutionLease(ctx, requestRef)\n+\t\tif err != nil {\n+\t\t\treturn nil, err\n+\t\t}\n+\t\tdefer executionLease.GetReleaseFn()(nil)\n+\n+\t\tref, err := e.predicateSatisfied(ctx, monotonicPredicate, requestRef, executionLease)\n+\t\tif err != nil {\n+\t\t\tif errors.Is(err, consts.ErrStaleState) {\n+\t\t\t\terr = serviceerror.NewUnavailable(\"please retry\")\n+\t\t\t}\n+\t\t\treturn nil, err\n+\t\t}\n+\t\tif ref != nil {\n+\t\t\treturn ref, nil\n+\t\t}\n+\t\t// Predicate not satisfied; subscribe before releasing the lock.\n+\t\tch, unsubscribe = e.notifier.Subscribe(requestRef.EntityKey)\n+\t\treturn nil, nil\n+\t}\n+\n+\tref, err := checkPredicateOrSubscribe()\n+\tif err != nil {\n+\t\treturn nil, err\n+\t}\n+\tif ref != nil {\n+\t\treturn ref, nil\n+\t}\n+\n+\tfor {\n+\t\tselect {\n+\t\tcase <-ch:\n+\t\t\tref, err := checkPredicateOrSubscribe()\n+\t\t\tif err != nil {\n+\t\t\t\treturn nil, err\n+\t\t\t}\n+\t\t\tif ref != nil {\n+\t\t\t\treturn ref, nil\n+\t\t\t}\n+\t\tcase <-ctx.Done():","path":"service/history/chasm_engine.go","commit_id":"1d59e66d0ce5d91819f92c428ef5ab4c4efca1fb","original_commit_id":"101822827ec6f0ce5eb6c86421c7162b8ba21321","user":{"login":"dandavison","id":52205,"node_id":"MDQ6VXNlcjUyMjA1","avatar_url":"https://avatars.githubusercontent.com/u/52205?v=4","gravatar_id":"","url":"https://api.github.com/users/dandavison","html_url":"https://github.com/dandavison","followers_url":"https://api.github.com/users/dandavison/followers","following_url":"https://api.github.com/users/dandavison/following{/other_user}","gists_url":"https://api.github.com/users/dandavison/gists{/gist_id}","starred_url":"https://api.github.com/users/dandavison/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/dandavison/subscriptions","organizations_url":"https://api.github.com/users/dandavison/orgs","repos_url":"https://api.github.com/users/dandavison/repos","events_url":"https://api.github.com/users/dandavison/events{/privacy}","received_events_url":"https://api.github.com/users/dandavison/received_events","type":"User","user_view_type":"public","site_admin":false},"body":"In the design that @bergundy and I have settled on, the caller sets the tail room. See `PollActivityExecution` in `chasm/lib/activity/handler.go`.","created_at":"2025-12-05T01:16:04Z","updated_at":"2025-12-05T01:19:17Z","html_url":"https://github.com/temporalio/temporal/pull/8563#discussion_r2591088354","pull_request_url":"https://api.github.com/repos/temporalio/temporal/pulls/8563","_links":{"self":{"href":"https://api.github.com/repos/temporalio/temporal/pulls/comments/2591088354"},"html":{"href":"https://github.com/temporalio/temporal/pull/8563#discussion_r2591088354"},"pull_request":{"href":"https://api.github.com/repos/temporalio/temporal/pulls/8563"}},"reactions":{"url":"https://api.github.com/repos/temporalio/temporal/pulls/comments/2591088354/reactions","total_count":0,"+1":0,"-1":0,"laugh":0,"hooray":0,"confused":0,"heart":0,"rocket":0,"eyes":0},"start_line":null,"original_start_line":null,"start_side":null,"line":324,"original_line":327,"side":"RIGHT","in_reply_to_id":2591067529,"author_association":"MEMBER","original_position":143,"position":136,"subject_type":"line"},{"url":"https://api.github.com/repos/temporalio/temporal/pulls/comments/2591089230","pull_request_review_id":3542695108,"id":2591089230,"node_id":"PRRC_kwDODNqesM6acOJO","diff_hunk":"@@ -241,14 +256,122 @@ func (e *ChasmEngine) ReadComponent(\n \treturn readFn(chasmContext, component)\n }\n \n+// PollComponent waits until the supplied predicate is satisfied when evaluated against the\n+// component identified by the supplied component reference. If there is no error, it returns (ref,\n+// nil) where ref is a component reference identifying the state at which the predicate was\n+// satisfied. It's possible that multiple state transitions (multiple notifications) occur between\n+// predicate checks, therefore the predicate must be monotonic: if it returns true at execution\n+// state transition s it must return true at all transitions t > s. It is an error if execution\n+// transition history is (after reloading from persistence) behind the requested ref, or if the ref\n+// is inconsistent with execution transition history. Thus when the predicate function is evaluated,\n+// it is guaranteed that the execution VT >= requestRef VT. opts are currently ignored.\n+// PollComponent subscribes to execution-level notifications. Suppose that an execution consists of\n+// one component A, and A has subcomponent B. Subscribers interested only in component B may be\n+// woken up unnecessarily (and thus evaluate the predicate unnecessarily) due to changes in parts of\n+// A that do not also belong to B.\n func (e *ChasmEngine) PollComponent(\n \tctx context.Context,\n-\tentityRef chasm.ComponentRef,\n-\tpredicateFn func(chasm.Context, chasm.Component) (any, bool, error),\n-\toperationFn func(chasm.MutableContext, chasm.Component, any) error,\n+\trequestRef chasm.ComponentRef,\n+\tmonotonicPredicate func(chasm.Context, chasm.Component) (bool, error),\n \topts ...chasm.TransitionOption,\n-) (newEntityRef []byte, retError error) {\n-\treturn nil, serviceerror.NewUnimplemented(\"PollComponent is not yet supported\")\n+) (retRef []byte, retError error) {\n+\n+\tvar ch <-chan struct{}\n+\tvar unsubscribe func()\n+\tdefer func() {\n+\t\tif unsubscribe != nil {\n+\t\t\tunsubscribe()\n+\t\t}\n+\t}()\n+\n+\tcheckPredicateOrSubscribe := func() ([]byte, error) {\n+\t\t_, executionLease, err := e.getExecutionLease(ctx, requestRef)\n+\t\tif err != nil {\n+\t\t\treturn nil, err\n+\t\t}\n+\t\tdefer executionLease.GetReleaseFn()(nil)\n+\n+\t\tref, err := e.predicateSatisfied(ctx, monotonicPredicate, requestRef, executionLease)\n+\t\tif err != nil {\n+\t\t\tif errors.Is(err, consts.ErrStaleState) {\n+\t\t\t\terr = serviceerror.NewUnavailable(\"please retry\")\n+\t\t\t}\n+\t\t\treturn nil, err\n+\t\t}\n+\t\tif ref != nil {\n+\t\t\treturn ref, nil\n+\t\t}\n+\t\t// Predicate not satisfied; subscribe before releasing the lock.\n+\t\tch, unsubscribe = e.notifier.Subscribe(requestRef.EntityKey)\n+\t\treturn nil, nil\n+\t}\n+\n+\tref, err := checkPredicateOrSubscribe()\n+\tif err != nil {\n+\t\treturn nil, err\n+\t}\n+\tif ref != nil {\n+\t\treturn ref, nil\n+\t}\n+\n+\tfor {\n+\t\tselect {\n+\t\tcase <-ch:\n+\t\t\tref, err := checkPredicateOrSubscribe()\n+\t\t\tif err != nil {\n+\t\t\t\treturn nil, err\n+\t\t\t}\n+\t\t\tif ref != nil {\n+\t\t\t\treturn ref, nil\n+\t\t\t}\n+\t\tcase <-ctx.Done():\n+\t\t\treturn nil, ctx.Err()\n+\t\t}\n+\t}\n+}\n+\n+// predicateSatisfied is a helper function for PollComponent. It returns (ref, err) where ref is non-nil\n+// iff there's no error and predicate evaluates to true.\n+func (e *ChasmEngine) predicateSatisfied(\n+\tctx context.Context,\n+\tpredicate func(chasm.Context, chasm.Component) (bool, error),\n+\tref chasm.ComponentRef,\n+\texecutionLease api.WorkflowLease,\n+) ([]byte, error) {\n+\tchasmTree, ok := executionLease.GetMutableState().ChasmTree().(*chasm.Node)\n+\tif !ok {\n+\t\treturn nil, serviceerror.NewInternalf(\n+\t\t\t\"CHASM tree implementation not properly wired up, encountered type: %T, expected type: %T\",\n+\t\t\texecutionLease.GetMutableState().ChasmTree(),\n+\t\t\t&chasm.Node{},\n+\t\t)\n+\t}\n+\n+\t// It is not acceptable to declare the predicate to be satisfied against execution state that is\n+\t// behind the requested reference. However, getExecutionLease does not currently guarantee that\n+\t// execution VT >= ref VT, therefore we call IsStale() again here and return any error (which at\n+\t// this point must be ErrStaleState; ErrStaleReference has already been eliminated).\n+\terr := chasmTree.IsStale(ref)","path":"service/history/chasm_engine.go","commit_id":"1d59e66d0ce5d91819f92c428ef5ab4c4efca1fb","original_commit_id":"101822827ec6f0ce5eb6c86421c7162b8ba21321","user":{"login":"dandavison","id":52205,"node_id":"MDQ6VXNlcjUyMjA1","avatar_url":"https://avatars.githubusercontent.com/u/52205?v=4","gravatar_id":"","url":"https://api.github.com/users/dandavison","html_url":"https://github.com/dandavison","followers_url":"https://api.github.com/users/dandavison/followers","following_url":"https://api.github.com/users/dandavison/following{/other_user}","gists_url":"https://api.github.com/users/dandavison/gists{/gist_id}","starred_url":"https://api.github.com/users/dandavison/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/dandavison/subscriptions","organizations_url":"https://api.github.com/users/dandavison/orgs","repos_url":"https://api.github.com/users/dandavison/repos","events_url":"https://api.github.com/users/dandavison/events{/privacy}","received_events_url":"https://api.github.com/users/dandavison/received_events","type":"User","user_view_type":"public","site_admin":false},"body":"Yes that's right. We can remove this when that bug is fixed.","created_at":"2025-12-05T01:16:45Z","updated_at":"2025-12-05T01:19:17Z","html_url":"https://github.com/temporalio/temporal/pull/8563#discussion_r2591089230","pull_request_url":"https://api.github.com/repos/temporalio/temporal/pulls/8563","_links":{"self":{"href":"https://api.github.com/repos/temporalio/temporal/pulls/comments/2591089230"},"html":{"href":"https://github.com/temporalio/temporal/pull/8563#discussion_r2591089230"},"pull_request":{"href":"https://api.github.com/repos/temporalio/temporal/pulls/8563"}},"reactions":{"url":"https://api.github.com/repos/temporalio/temporal/pulls/comments/2591089230/reactions","total_count":0,"+1":0,"-1":0,"laugh":0,"hooray":0,"confused":0,"heart":0,"rocket":0,"eyes":0},"start_line":null,"original_start_line":null,"start_side":null,"line":351,"original_line":354,"side":"RIGHT","in_reply_to_id":2591071579,"author_association":"MEMBER","original_position":170,"position":163,"subject_type":"line"},{"url":"https://api.github.com/repos/temporalio/temporal/pulls/comments/2591092303","pull_request_review_id":3542695108,"id":2591092303,"node_id":"PRRC_kwDODNqesM6acO5P","diff_hunk":"@@ -190,6 +191,27 @@ func (t *TransactionImpl) UpdateWorkflowExecution(\n \tif persistence.OperationPossiblySucceeded(err) {\n \t\tNotifyWorkflowMutationTasks(engine, currentWorkflowMutation)\n \t\tNotifyWorkflowSnapshotTasks(engine, newWorkflowSnapshot)\n+\n+\t\t// TODO(dan): there is no test coverage for on-delete or on-create CHASM notifications.\n+\n+\t\t// Notify for current workflow if it has CHASM updates\n+\t\tif len(currentWorkflowMutation.UpsertChasmNodes) > 0 ||\n+\t\t\tlen(currentWorkflowMutation.DeleteChasmNodes) > 0 {\n+\t\t\tengine.NotifyChasmExecution(chasm.EntityKey{","path":"service/history/workflow/transaction_impl.go","commit_id":"1d59e66d0ce5d91819f92c428ef5ab4c4efca1fb","original_commit_id":"101822827ec6f0ce5eb6c86421c7162b8ba21321","user":{"login":"dandavison","id":52205,"node_id":"MDQ6VXNlcjUyMjA1","avatar_url":"https://avatars.githubusercontent.com/u/52205?v=4","gravatar_id":"","url":"https://api.github.com/users/dandavison","html_url":"https://github.com/dandavison","followers_url":"https://api.github.com/users/dandavison/followers","following_url":"https://api.github.com/users/dandavison/following{/other_user}","gists_url":"https://api.github.com/users/dandavison/gists{/gist_id}","starred_url":"https://api.github.com/users/dandavison/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/dandavison/subscriptions","organizations_url":"https://api.github.com/users/dandavison/orgs","repos_url":"https://api.github.com/users/dandavison/repos","events_url":"https://api.github.com/users/dandavison/events{/privacy}","received_events_url":"https://api.github.com/users/dandavison/received_events","type":"User","user_view_type":"public","site_admin":false},"body":"Thanks, let's address this in one more PR to target `standalone-activity`. It will all arrive in  `main` at the same time.","created_at":"2025-12-05T01:18:14Z","updated_at":"2025-12-05T01:19:17Z","html_url":"https://github.com/temporalio/temporal/pull/8563#discussion_r2591092303","pull_request_url":"https://api.github.com/repos/temporalio/temporal/pulls/8563","_links":{"self":{"href":"https://api.github.com/repos/temporalio/temporal/pulls/comments/2591092303"},"html":{"href":"https://github.com/temporalio/temporal/pull/8563#discussion_r2591092303"},"pull_request":{"href":"https://api.github.com/repos/temporalio/temporal/pulls/8563"}},"reactions":{"url":"https://api.github.com/repos/temporalio/temporal/pulls/comments/2591092303/reactions","total_count":0,"+1":0,"-1":0,"laugh":0,"hooray":0,"confused":0,"heart":0,"rocket":0,"eyes":0},"start_line":null,"original_start_line":null,"start_side":null,"line":200,"original_line":200,"side":"RIGHT","in_reply_to_id":2591062791,"author_association":"MEMBER","original_position":18,"position":18,"subject_type":"line"},{"url":"https://api.github.com/repos/temporalio/temporal/pulls/comments/2591111208","pull_request_review_id":3542753172,"id":2591111208,"node_id":"PRRC_kwDODNqesM6acTgo","diff_hunk":"@@ -98,6 +99,8 @@ type (\n \n \t\tNotifyNewHistoryEvent(event *events.Notification)\n \t\tNotifyNewTasks(tasks map[tasks.Category][]tasks.Task)\n+\t\tChasmEngine() chasm.Engine","path":"service/history/interfaces/engine.go","commit_id":"34b3f8a7f60cc35efeeb40e6870798011c42c1ab","original_commit_id":"101822827ec6f0ce5eb6c86421c7162b8ba21321","user":{"login":"dandavison","id":52205,"node_id":"MDQ6VXNlcjUyMjA1","avatar_url":"https://avatars.githubusercontent.com/u/52205?v=4","gravatar_id":"","url":"https://api.github.com/users/dandavison","html_url":"https://github.com/dandavison","followers_url":"https://api.github.com/users/dandavison/followers","following_url":"https://api.github.com/users/dandavison/following{/other_user}","gists_url":"https://api.github.com/users/dandavison/gists{/gist_id}","starred_url":"https://api.github.com/users/dandavison/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/dandavison/subscriptions","organizations_url":"https://api.github.com/users/dandavison/orgs","repos_url":"https://api.github.com/users/dandavison/repos","events_url":"https://api.github.com/users/dandavison/events{/privacy}","received_events_url":"https://api.github.com/users/dandavison/received_events","type":"User","user_view_type":"public","site_admin":false},"body":"No, thanks!","created_at":"2025-12-05T01:31:38Z","updated_at":"2025-12-05T01:31:38Z","html_url":"https://github.com/temporalio/temporal/pull/8563#discussion_r2591111208","pull_request_url":"https://api.github.com/repos/temporalio/temporal/pulls/8563","_links":{"self":{"href":"https://api.github.com/repos/temporalio/temporal/pulls/comments/2591111208"},"html":{"href":"https://github.com/temporalio/temporal/pull/8563#discussion_r2591111208"},"pull_request":{"href":"https://api.github.com/repos/temporalio/temporal/pulls/8563"}},"reactions":{"url":"https://api.github.com/repos/temporalio/temporal/pulls/comments/2591111208/reactions","total_count":0,"+1":0,"-1":0,"laugh":0,"hooray":0,"confused":0,"heart":0,"rocket":0,"eyes":0},"start_line":null,"original_start_line":null,"start_side":null,"line":null,"original_line":102,"side":"RIGHT","in_reply_to_id":2591052769,"author_association":"MEMBER","original_position":12,"position":1,"subject_type":"line"},{"url":"https://api.github.com/repos/temporalio/temporal/pulls/comments/2591117481","pull_request_review_id":3542760269,"id":2591117481,"node_id":"PRRC_kwDODNqesM6acVCp","diff_hunk":"@@ -131,12 +136,19 @@ func (r *ComponentRef) Serialize(\n // DeserializeComponentRef deserializes a byte slice into a ComponentRef.\n // Provides caller the access to information including EntityKey, Archetype, and ShardingKey.\n func DeserializeComponentRef(data []byte) (ComponentRef, error) {\n+\tif len(data) == 0 {\n+\t\treturn ComponentRef{}, ErrInvalidComponentRef\n+\t}\n \tvar pRef persistencespb.ChasmComponentRef\n \tif err := pRef.Unmarshal(data); err != nil {\n \t\treturn ComponentRef{}, err","path":"chasm/ref.go","commit_id":"34b3f8a7f60cc35efeeb40e6870798011c42c1ab","original_commit_id":"101822827ec6f0ce5eb6c86421c7162b8ba21321","user":{"login":"dandavison","id":52205,"node_id":"MDQ6VXNlcjUyMjA1","avatar_url":"https://avatars.githubusercontent.com/u/52205?v=4","gravatar_id":"","url":"https://api.github.com/users/dandavison","html_url":"https://github.com/dandavison","followers_url":"https://api.github.com/users/dandavison/followers","following_url":"https://api.github.com/users/dandavison/following{/other_user}","gists_url":"https://api.github.com/users/dandavison/gists{/gist_id}","starred_url":"https://api.github.com/users/dandavison/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/dandavison/subscriptions","organizations_url":"https://api.github.com/users/dandavison/orgs","repos_url":"https://api.github.com/users/dandavison/repos","events_url":"https://api.github.com/users/dandavison/events{/privacy}","received_events_url":"https://api.github.com/users/dandavison/received_events","type":"User","user_view_type":"public","site_admin":false},"body":"Thanks, done ","created_at":"2025-12-05T01:36:05Z","updated_at":"2025-12-05T01:36:06Z","html_url":"https://github.com/temporalio/temporal/pull/8563#discussion_r2591117481","pull_request_url":"https://api.github.com/repos/temporalio/temporal/pulls/8563","_links":{"self":{"href":"https://api.github.com/repos/temporalio/temporal/pulls/comments/2591117481"},"html":{"href":"https://github.com/temporalio/temporal/pull/8563#discussion_r2591117481"},"pull_request":{"href":"https://api.github.com/repos/temporalio/temporal/pulls/8563"}},"reactions":{"url":"https://api.github.com/repos/temporalio/temporal/pulls/comments/2591117481/reactions","total_count":0,"+1":0,"-1":0,"laugh":0,"hooray":0,"confused":0,"heart":0,"rocket":0,"eyes":0},"start_line":null,"original_start_line":null,"start_side":null,"line":null,"original_line":144,"side":"RIGHT","in_reply_to_id":2591050640,"author_association":"MEMBER","original_position":33,"position":1,"subject_type":"line"},{"url":"https://api.github.com/repos/temporalio/temporal/pulls/comments/2591117662","pull_request_review_id":3542760460,"id":2591117662,"node_id":"PRRC_kwDODNqesM6acVFe","diff_hunk":"@@ -1,15 +1,20 @@\n package chasm\n \n import (\n+\t\"errors\"\n \t\"reflect\"\n \n \t\"go.temporal.io/api/serviceerror\"\n \tpersistencespb \"go.temporal.io/server/api/persistence/v1\"\n )\n \n-var (\n-\tdefaultShardingFn = func(key EntityKey) string { return key.NamespaceID + \"_\" + key.BusinessID }\n-)\n+// ErrMalformedComponentRef is returned when component ref bytes cannot be deserialized.\n+var ErrMalformedComponentRef = errors.New(\"malformed component ref\")\n+\n+// ErrInvalidComponentRef is returned when component ref bytes deserialize to an invalid component ref.\n+var ErrInvalidComponentRef = errors.New(\"invalid component ref\")","path":"chasm/ref.go","commit_id":"34b3f8a7f60cc35efeeb40e6870798011c42c1ab","original_commit_id":"101822827ec6f0ce5eb6c86421c7162b8ba21321","user":{"login":"dandavison","id":52205,"node_id":"MDQ6VXNlcjUyMjA1","avatar_url":"https://avatars.githubusercontent.com/u/52205?v=4","gravatar_id":"","url":"https://api.github.com/users/dandavison","html_url":"https://github.com/dandavison","followers_url":"https://api.github.com/users/dandavison/followers","following_url":"https://api.github.com/users/dandavison/following{/other_user}","gists_url":"https://api.github.com/users/dandavison/gists{/gist_id}","starred_url":"https://api.github.com/users/dandavison/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/dandavison/subscriptions","organizations_url":"https://api.github.com/users/dandavison/orgs","repos_url":"https://api.github.com/users/dandavison/repos","events_url":"https://api.github.com/users/dandavison/events{/privacy}","received_events_url":"https://api.github.com/users/dandavison/received_events","type":"User","user_view_type":"public","site_admin":false},"body":"Right, done.","created_at":"2025-12-05T01:36:13Z","updated_at":"2025-12-05T01:36:14Z","html_url":"https://github.com/temporalio/temporal/pull/8563#discussion_r2591117662","pull_request_url":"https://api.github.com/repos/temporalio/temporal/pulls/8563","_links":{"self":{"href":"https://api.github.com/repos/temporalio/temporal/pulls/comments/2591117662"},"html":{"href":"https://github.com/temporalio/temporal/pull/8563#discussion_r2591117662"},"pull_request":{"href":"https://api.github.com/repos/temporalio/temporal/pulls/8563"}},"reactions":{"url":"https://api.github.com/repos/temporalio/temporal/pulls/comments/2591117662/reactions","total_count":0,"+1":0,"-1":0,"laugh":0,"hooray":0,"confused":0,"heart":0,"rocket":0,"eyes":0},"start_line":null,"original_start_line":11,"start_side":"RIGHT","line":null,"original_line":15,"side":"RIGHT","in_reply_to_id":2591051822,"author_association":"MEMBER","original_position":18,"position":1,"subject_type":"line"},{"url":"https://api.github.com/repos/temporalio/temporal/pulls/comments/2591156724","pull_request_review_id":3542820823,"id":2591156724,"node_id":"PRRC_kwDODNqesM6acen0","diff_hunk":"@@ -53,3 +59,113 @@ func (h *handler) StartActivityExecution(ctx context.Context, req *activitypb.St\n \t\tFrontendResponse: response,\n \t}, nil\n }\n+\n+// PollActivityExecution handles PollActivityExecutionRequest from frontend. This method supports\n+// querying current activity state, optionally as a long-poll that waits for certain state changes.\n+// It is used by clients to poll for activity state and/or result. When used to long-poll, it\n+// returns an empty non-error response on context deadline expiry, to indicate that the state being\n+// waited for was not reached. Callers should interpret this as an invitation to resubmit their\n+// long-poll request. This response is sent before the caller's deadline (see\n+// chasm.activity.longPollBuffer) so that it is likely that the caller does indeed receive the\n+// non-error response.\n+func (h *handler) PollActivityExecution(\n+\tctx context.Context,\n+\treq *activitypb.PollActivityExecutionRequest,\n+) (response *activitypb.PollActivityExecutionResponse, err error) {\n+\tref := chasm.NewComponentRef[*Activity](chasm.EntityKey{\n+\t\tNamespaceID: req.GetNamespaceId(),\n+\t\tBusinessID:  req.GetFrontendRequest().GetActivityId(),\n+\t\tEntityID:    req.GetFrontendRequest().GetRunId(),\n+\t})\n+\tdefer func() {\n+\t\tvar notFound *serviceerror.NotFound\n+\t\tif errors.As(err, &notFound) {\n+\t\t\terr = serviceerror.NewNotFound(\"activity execution not found\")\n+\t\t}\n+\t}()\n+\n+\twaitPolicy := req.GetFrontendRequest().GetWaitPolicy()\n+\n+\tif waitPolicy == nil {\n+\t\treturn chasm.ReadComponent(ctx, ref, (*Activity).buildPollActivityExecutionResponse, req, nil)\n+\t}\n+\n+\t// Below, we send an empty non-error response on context deadline expiry. Here we compute a\n+\t// deadline that causes us to send that response before the caller's own deadline (see\n+\t// chasm.activity.longPollBuffer). We also cap the caller's deadline at\n+\t// chasm.activity.longPollTimeout.\n+\tnamespace := req.GetFrontendRequest().GetNamespace()\n+\tctx, cancel := contextutil.WithDeadlineBuffer(\n+\t\tctx,\n+\t\th.config.LongPollTimeout(namespace),\n+\t\th.config.LongPollBuffer(namespace),\n+\t)\n+\tdefer cancel()\n+\n+\tswitch waitPolicyType := waitPolicy.(type) {\n+\tcase *workflowservice.PollActivityExecutionRequest_WaitAnyStateChange:\n+\t\ttoken := waitPolicyType.WaitAnyStateChange.GetLongPollToken()\n+\t\tif len(token) == 0 {\n+\t\t\treturn chasm.ReadComponent(ctx, ref, (*Activity).buildPollActivityExecutionResponse, req, nil)\n+\t\t}\n+\t\tresponse, _, err = chasm.PollComponent(ctx, ref, func(\n+\t\t\ta *Activity,\n+\t\t\tctx chasm.Context,\n+\t\t\treq *activitypb.PollActivityExecutionRequest,\n+\t\t) (*activitypb.PollActivityExecutionResponse, bool, error) {\n+\t\t\tchanged, err := chasm.ExecutionStateChanged(a, ctx, token)\n+\t\t\tif err != nil {\n+\t\t\t\tif errors.Is(err, chasm.ErrMalformedComponentRef) {\n+\t\t\t\t\treturn nil, false, serviceerror.NewInvalidArgument(\"invalid long poll token\")\n+\t\t\t\t}\n+\t\t\t\tif errors.Is(err, chasm.ErrInvalidComponentRef) {\n+\t\t\t\t\treturn nil, false, serviceerror.NewInvalidArgument(\"long poll token does not match execution\")\n+\t\t\t\t}\n+\t\t\t\treturn nil, false, err\n+\t\t\t}\n+\t\t\tif changed {\n+\t\t\t\tresponse, err := a.buildPollActivityExecutionResponse(ctx, req)\n+\t\t\t\treturn response, true, err\n+\t\t\t} else {\n+\t\t\t\treturn nil, false, nil\n+\t\t\t}\n+\t\t}, req)\n+\tcase *workflowservice.PollActivityExecutionRequest_WaitCompletion:\n+\t\t// TODO(dan): add functional test when RecordActivityTaskCompleted is implemented\n+\t\tresponse, _, err = chasm.PollComponent(ctx, ref, func(\n+\t\t\ta *Activity,\n+\t\t\tctx chasm.Context,\n+\t\t\treq *activitypb.PollActivityExecutionRequest,\n+\t\t) (*activitypb.PollActivityExecutionResponse, bool, error) {\n+\t\t\t// TODO(dan): check for terminal activity states\n+\t\t\tpanic(\"pollActivityExecutionWaitCompletion is not implemented\")","path":"chasm/lib/activity/handler.go","commit_id":"2c24dfc62cddd82948e0ed0765afaeb9f38b6775","original_commit_id":"ba38880058f288839d9fd74d46b7ac8dbc549f5c","user":{"login":"cursor[bot]","id":206951365,"node_id":"BOT_kgDODFXTxQ","avatar_url":"https://avatars.githubusercontent.com/in/1210556?v=4","gravatar_id":"","url":"https://api.github.com/users/cursor%5Bbot%5D","html_url":"https://github.com/apps/cursor","followers_url":"https://api.github.com/users/cursor%5Bbot%5D/followers","following_url":"https://api.github.com/users/cursor%5Bbot%5D/following{/other_user}","gists_url":"https://api.github.com/users/cursor%5Bbot%5D/gists{/gist_id}","starred_url":"https://api.github.com/users/cursor%5Bbot%5D/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/cursor%5Bbot%5D/subscriptions","organizations_url":"https://api.github.com/users/cursor%5Bbot%5D/orgs","repos_url":"https://api.github.com/users/cursor%5Bbot%5D/repos","events_url":"https://api.github.com/users/cursor%5Bbot%5D/events{/privacy}","received_events_url":"https://api.github.com/users/cursor%5Bbot%5D/received_events","type":"Bot","user_view_type":"public","site_admin":false},"body":"### Bug: Panic in WaitCompletion handler crashes server\n\n<!-- **High Severity** -->\n\n<!-- DESCRIPTION START -->\nThe `PollActivityExecution` handler contains a `panic(\"pollActivityExecutionWaitCompletion is not implemented\")` statement in the `WaitCompletion` case branch. If a user sends a `PollActivityExecutionRequest` with a `WaitCompletion` wait policy, this will crash the server. This panic should be replaced with returning a proper error like `serviceerror.NewUnimplemented(\"WaitCompletion is not yet implemented\")` to avoid server crashes.\n<!-- DESCRIPTION END -->\n\n<!-- LOCATIONS START\nchasm/lib/activity/handler.go#L140-L141\nLOCATIONS END -->\n<a href=\"https://cursor.com/open?data=eyJhbGciOiJSUzI1NiIsInR5cCI6IkpXVCIsImtpZCI6ImJ1Z2JvdC12MSJ9.eyJ2ZXJzaW9uIjoxLCJ0eXBlIjoiQlVHQk9UX0ZJWF9JTl9DVVJTT1IiLCJkYXRhIjp7InJlZGlzS2V5IjoiYnVnYm90Ojc1Yjk3YWMxLWMxNjYtNGQ2MS05YWQ0LWRmNGY0MzY3ZTE2MiIsImVuY3J5cHRpb25LZXkiOiJuX29ibkh1Z3BDWnloMjFuTmlKTmJOVEdlMmFucEJfTnJUTlZ0U0VFVEV3IiwiYnJhbmNoIjoicG9sbC1jb21wb25lbnQifSwiaWF0IjoxNzY0ODk5NzcxLCJleHAiOjE3NjU1MDQ1NzF9.Toi6IGQA6FyRZYhBC8lByUOWoBHtQpniHNfSW63tvi6JoTNf5r8LT9b-JYxpzV79Bw-j3gT2yJpqSeMFeS7fJoWB4RF_-wmk1wX3jjneNkubwlpF0IM_l422114wp8Urpsk0K-VPPkNUKM3jSIwhAPB5XtMbvl9nhZQj3ptfU-vXttfj0pgf6WI_r_DcM2p04WrH_5S-HzCAtGQfXjrsGT1TpOMY1xrXCcyPW433QVEVPVe7LoK3aso5icV2aHD-IC6modTEa9S1CKusOdift5ve0AQ_mOOTnS-YLxYjjrvKj31Ymqj7q89TOxfvE3mQpw1IJOAtLm4SwL1lH3FFHA\"><picture><source media=\"(prefers-color-scheme: dark)\" srcset=\"https://cursor.com/fix-in-cursor-dark.svg\"><source media=\"(prefers-color-scheme: light)\" srcset=\"https://cursor.com/fix-in-cursor-light.svg\"><img alt=\"Fix in Cursor\" src=\"https://cursor.com/fix-in-cursor.svg\"></picture></a>&nbsp;<a href=\"https://cursor.com/agents?data=eyJhbGciOiJSUzI1NiIsInR5cCI6IkpXVCIsImtpZCI6ImJ1Z2JvdC12MSJ9.eyJ2ZXJzaW9uIjoxLCJ0eXBlIjoiQlVHQk9UX0ZJWF9JTl9XRUIiLCJkYXRhIjp7InJlZGlzS2V5IjoiYnVnYm90Ojc1Yjk3YWMxLWMxNjYtNGQ2MS05YWQ0LWRmNGY0MzY3ZTE2MiIsImVuY3J5cHRpb25LZXkiOiJuX29ibkh1Z3BDWnloMjFuTmlKTmJOVEdlMmFucEJfTnJUTlZ0U0VFVEV3IiwiYnJhbmNoIjoicG9sbC1jb21wb25lbnQiLCJyZXBvT3duZXIiOiJ0ZW1wb3JhbGlvIiwicmVwb05hbWUiOiJ0ZW1wb3JhbCIsInByTnVtYmVyIjo4NTYzLCJjb21taXRTaGEiOiJiYTM4ODgwMDU4ZjI4ODgzOWQ5ZmQ3NGQ0NmI3YWM4ZGJjNTQ5ZjVjIiwicHJvdmlkZXIiOiJnaXRodWIifSwiaWF0IjoxNzY0ODk5NzcxLCJleHAiOjE3NjU1MDQ1NzF9.J5foqCVLH8nHPYcXGKKrelIDwCsWHO6VMJ3xybw85MNlVGiTOcw7xN1j35fuUnkaf8tfAGRNDjUfPnBIl7o8yP-cns81eZ374hlDzslek0wzNLLtK3Sw_7Mw1jWiTFD1AA49F1GYn50l9CJpaD8J171ITq4ruFV3eUbGuvTtxMuosC33QvcTEdU1Nv3-0Pm9DJLRYRkNr7DujjF6AjwkeZ6K_mXtIYprTsU4U_IUsBdpFCJ9gXQxjMKRkWNTwp4OCH5xSCPiFuU3-28z_-pPwLsZV5gYXfkZmdCbC3W0XIPPK_9NuweOeD-5CzMplyaAlZdL4xspnxqoAcPZ_dM_gw\"><picture><source media=\"(prefers-color-scheme: dark)\" srcset=\"https://cursor.com/fix-in-web-dark.svg\"><source media=\"(prefers-color-scheme: light)\" srcset=\"https://cursor.com/fix-in-web-light.svg\"><img alt=\"Fix in Web\" src=\"https://cursor.com/fix-in-web.svg\"></picture></a>\n\n","created_at":"2025-12-05T01:56:11Z","updated_at":"2025-12-05T01:56:11Z","html_url":"https://github.com/temporalio/temporal/pull/8563#discussion_r2591156724","pull_request_url":"https://api.github.com/repos/temporalio/temporal/pulls/8563","_links":{"self":{"href":"https://api.github.com/repos/temporalio/temporal/pulls/comments/2591156724"},"html":{"href":"https://github.com/temporalio/temporal/pull/8563#discussion_r2591156724"},"pull_request":{"href":"https://api.github.com/repos/temporalio/temporal/pulls/8563"}},"reactions":{"url":"https://api.github.com/repos/temporalio/temporal/pulls/comments/2591156724/reactions","total_count":0,"+1":0,"-1":0,"laugh":0,"hooray":0,"confused":0,"heart":0,"rocket":0,"eyes":0},"start_line":null,"original_start_line":null,"start_side":null,"line":null,"original_line":141,"side":"RIGHT","author_association":"NONE","original_position":110,"position":1,"subject_type":"line"},{"url":"https://api.github.com/repos/temporalio/temporal/pulls/comments/2591160255","pull_request_review_id":3542784257,"id":2591160255,"node_id":"PRRC_kwDODNqesM6acfe_","diff_hunk":"@@ -5,45 +5,66 @@ import (\n \t\"testing\"\n \t\"time\"\n \n-\t\"github.com/google/uuid\"\n \t\"github.com/stretchr/testify/require\"\n \t\"github.com/stretchr/testify/suite\"\n \tactivitypb \"go.temporal.io/api/activity/v1\"\n \tcommonpb \"go.temporal.io/api/common/v1\"\n \tenumspb \"go.temporal.io/api/enums/v1\"\n+\t\"go.temporal.io/api/serviceerror\"\n \ttaskqueuepb \"go.temporal.io/api/taskqueue/v1\"\n \t\"go.temporal.io/api/workflowservice/v1\"\n+\t\"go.temporal.io/server/chasm/lib/activity\"\n \t\"go.temporal.io/server/common/dynamicconfig\"\n+\t\"go.temporal.io/server/common/testing/protorequire\"\n+\t\"go.temporal.io/server/common/testing/testvars\"\n \t\"go.temporal.io/server/tests/testcore\"\n \t\"google.golang.org/protobuf/proto\"\n \t\"google.golang.org/protobuf/types/known/durationpb\"\n )\n \n+var (\n+\tdefaultInput = &commonpb.Payloads{\n+\t\tPayloads: []*commonpb.Payload{\n+\t\t\t{\n+\t\t\t\tMetadata: map[string][]byte{\n+\t\t\t\t\t\"encoding\": []byte(\"json/plain\"),\n+\t\t\t\t},\n+\t\t\t\tData: []byte(\"test-activity-input\"),\n+\t\t\t},\n+\t\t},\n+\t}\n+)\n+\n type standaloneActivityTestSuite struct {\n \ttestcore.FunctionalTestBase\n+\ttv *testvars.TestVars\n }\n \n func TestStandaloneActivityTestSuite(t *testing.T) {\n \tt.Parallel()\n \tsuite.Run(t, new(standaloneActivityTestSuite))\n }\n \n-func (s *standaloneActivityTestSuite) TestStartActivityExecution() {\n-\tt := s.T()\n-\tctx, cancel := context.WithTimeout(t.Context(), 10*time.Second)\n-\tdefer cancel()\n-\n+func (s *standaloneActivityTestSuite) SetupSuite() {\n+\ts.FunctionalTestBase.SetupSuite()\n+\ts.tv = testvars.New(s.T())\n \ts.OverrideDynamicConfig(\n \t\tdynamicconfig.EnableChasm,\n \t\ttrue,\n \t)\n+}\n+\n+func (s *standaloneActivityTestSuite) TestStartActivityExecution() {\n+\tt := s.T()\n+\tctx, cancel := context.WithTimeout(t.Context(), 10*time.Second)\n+\tdefer cancel()\n \n \tactivityID := testcore.RandomizeStr(t.Name())\n \tactivityType := &commonpb.ActivityType{\n \t\tName: \"test-activity-type\",\n \t}\n \tinput := createDefaultInput()\n-\ttaskQueue := uuid.New().String()\n+\ttaskQueue := testcore.RandomizeStr(t.Name())","path":"tests/standalone_activity_test.go","commit_id":"1d59e66d0ce5d91819f92c428ef5ab4c4efca1fb","original_commit_id":"8aa718931afd6a83e7694ad3b97cec208dcf61e1","user":{"login":"dandavison","id":52205,"node_id":"MDQ6VXNlcjUyMjA1","avatar_url":"https://avatars.githubusercontent.com/u/52205?v=4","gravatar_id":"","url":"https://api.github.com/users/dandavison","html_url":"https://github.com/dandavison","followers_url":"https://api.github.com/users/dandavison/followers","following_url":"https://api.github.com/users/dandavison/following{/other_user}","gists_url":"https://api.github.com/users/dandavison/gists{/gist_id}","starred_url":"https://api.github.com/users/dandavison/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/dandavison/subscriptions","organizations_url":"https://api.github.com/users/dandavison/orgs","repos_url":"https://api.github.com/users/dandavison/repos","events_url":"https://api.github.com/users/dandavison/events{/privacy}","received_events_url":"https://api.github.com/users/dandavison/received_events","type":"User","user_view_type":"public","site_admin":false},"body":"I've switched them over","created_at":"2025-12-05T01:58:04Z","updated_at":"2025-12-05T03:07:13Z","html_url":"https://github.com/temporalio/temporal/pull/8563#discussion_r2591160255","pull_request_url":"https://api.github.com/repos/temporalio/temporal/pulls/8563","_links":{"self":{"href":"https://api.github.com/repos/temporalio/temporal/pulls/comments/2591160255"},"html":{"href":"https://github.com/temporalio/temporal/pull/8563#discussion_r2591160255"},"pull_request":{"href":"https://api.github.com/repos/temporalio/temporal/pulls/8563"}},"reactions":{"url":"https://api.github.com/repos/temporalio/temporal/pulls/comments/2591160255/reactions","total_count":0,"+1":0,"-1":0,"laugh":0,"hooray":0,"confused":0,"heart":0,"rocket":0,"eyes":0},"start_line":null,"original_start_line":null,"start_side":null,"line":58,"original_line":67,"side":"RIGHT","in_reply_to_id":2591040058,"author_association":"MEMBER","original_position":70,"position":62,"subject_type":"line"},{"url":"https://api.github.com/repos/temporalio/temporal/pulls/comments/2591160396","pull_request_review_id":3542784257,"id":2591160396,"node_id":"PRRC_kwDODNqesM6acfhM","diff_hunk":"@@ -5,45 +5,66 @@ import (\n \t\"testing\"\n \t\"time\"\n \n-\t\"github.com/google/uuid\"\n \t\"github.com/stretchr/testify/require\"\n \t\"github.com/stretchr/testify/suite\"\n \tactivitypb \"go.temporal.io/api/activity/v1\"\n \tcommonpb \"go.temporal.io/api/common/v1\"\n \tenumspb \"go.temporal.io/api/enums/v1\"\n+\t\"go.temporal.io/api/serviceerror\"\n \ttaskqueuepb \"go.temporal.io/api/taskqueue/v1\"\n \t\"go.temporal.io/api/workflowservice/v1\"\n+\t\"go.temporal.io/server/chasm/lib/activity\"\n \t\"go.temporal.io/server/common/dynamicconfig\"\n+\t\"go.temporal.io/server/common/testing/protorequire\"\n+\t\"go.temporal.io/server/common/testing/testvars\"\n \t\"go.temporal.io/server/tests/testcore\"\n \t\"google.golang.org/protobuf/proto\"\n \t\"google.golang.org/protobuf/types/known/durationpb\"\n )\n \n+var (\n+\tdefaultInput = &commonpb.Payloads{\n+\t\tPayloads: []*commonpb.Payload{\n+\t\t\t{\n+\t\t\t\tMetadata: map[string][]byte{\n+\t\t\t\t\t\"encoding\": []byte(\"json/plain\"),\n+\t\t\t\t},\n+\t\t\t\tData: []byte(\"test-activity-input\"),\n+\t\t\t},\n+\t\t},\n+\t}\n+)\n+\n type standaloneActivityTestSuite struct {\n \ttestcore.FunctionalTestBase\n+\ttv *testvars.TestVars\n }\n \n func TestStandaloneActivityTestSuite(t *testing.T) {\n \tt.Parallel()\n \tsuite.Run(t, new(standaloneActivityTestSuite))\n }\n \n-func (s *standaloneActivityTestSuite) TestStartActivityExecution() {\n-\tt := s.T()\n-\tctx, cancel := context.WithTimeout(t.Context(), 10*time.Second)\n-\tdefer cancel()\n-\n+func (s *standaloneActivityTestSuite) SetupSuite() {\n+\ts.FunctionalTestBase.SetupSuite()\n+\ts.tv = testvars.New(s.T())","path":"tests/standalone_activity_test.go","commit_id":"ba38880058f288839d9fd74d46b7ac8dbc549f5c","original_commit_id":"8aa718931afd6a83e7694ad3b97cec208dcf61e1","user":{"login":"dandavison","id":52205,"node_id":"MDQ6VXNlcjUyMjA1","avatar_url":"https://avatars.githubusercontent.com/u/52205?v=4","gravatar_id":"","url":"https://api.github.com/users/dandavison","html_url":"https://github.com/dandavison","followers_url":"https://api.github.com/users/dandavison/followers","following_url":"https://api.github.com/users/dandavison/following{/other_user}","gists_url":"https://api.github.com/users/dandavison/gists{/gist_id}","starred_url":"https://api.github.com/users/dandavison/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/dandavison/subscriptions","organizations_url":"https://api.github.com/users/dandavison/orgs","repos_url":"https://api.github.com/users/dandavison/repos","events_url":"https://api.github.com/users/dandavison/events{/privacy}","received_events_url":"https://api.github.com/users/dandavison/received_events","type":"User","user_view_type":"public","site_admin":false},"body":"Done","created_at":"2025-12-05T01:58:08Z","updated_at":"2025-12-05T03:07:13Z","html_url":"https://github.com/temporalio/temporal/pull/8563#discussion_r2591160396","pull_request_url":"https://api.github.com/repos/temporalio/temporal/pulls/8563","_links":{"self":{"href":"https://api.github.com/repos/temporalio/temporal/pulls/comments/2591160396"},"html":{"href":"https://github.com/temporalio/temporal/pull/8563#discussion_r2591160396"},"pull_request":{"href":"https://api.github.com/repos/temporalio/temporal/pulls/8563"}},"reactions":{"url":"https://api.github.com/repos/temporalio/temporal/pulls/comments/2591160396/reactions","total_count":0,"+1":0,"-1":0,"laugh":0,"hooray":0,"confused":0,"heart":0,"rocket":0,"eyes":0},"start_line":null,"original_start_line":null,"start_side":null,"line":null,"original_line":50,"side":"RIGHT","in_reply_to_id":2591039373,"author_association":"MEMBER","original_position":52,"position":1,"subject_type":"line"},{"url":"https://api.github.com/repos/temporalio/temporal/pulls/comments/2591192577","pull_request_review_id":3542784257,"id":2591192577,"node_id":"PRRC_kwDODNqesM6acnYB","diff_hunk":"@@ -5,45 +5,66 @@ import (\n \t\"testing\"\n \t\"time\"\n \n-\t\"github.com/google/uuid\"\n \t\"github.com/stretchr/testify/require\"\n \t\"github.com/stretchr/testify/suite\"\n \tactivitypb \"go.temporal.io/api/activity/v1\"\n \tcommonpb \"go.temporal.io/api/common/v1\"\n \tenumspb \"go.temporal.io/api/enums/v1\"\n+\t\"go.temporal.io/api/serviceerror\"\n \ttaskqueuepb \"go.temporal.io/api/taskqueue/v1\"\n \t\"go.temporal.io/api/workflowservice/v1\"\n+\t\"go.temporal.io/server/chasm/lib/activity\"\n \t\"go.temporal.io/server/common/dynamicconfig\"\n+\t\"go.temporal.io/server/common/testing/protorequire\"\n+\t\"go.temporal.io/server/common/testing/testvars\"\n \t\"go.temporal.io/server/tests/testcore\"\n \t\"google.golang.org/protobuf/proto\"\n \t\"google.golang.org/protobuf/types/known/durationpb\"\n )\n \n+var (\n+\tdefaultInput = &commonpb.Payloads{","path":"tests/standalone_activity_test.go","commit_id":"ba38880058f288839d9fd74d46b7ac8dbc549f5c","original_commit_id":"8aa718931afd6a83e7694ad3b97cec208dcf61e1","user":{"login":"dandavison","id":52205,"node_id":"MDQ6VXNlcjUyMjA1","avatar_url":"https://avatars.githubusercontent.com/u/52205?v=4","gravatar_id":"","url":"https://api.github.com/users/dandavison","html_url":"https://github.com/dandavison","followers_url":"https://api.github.com/users/dandavison/followers","following_url":"https://api.github.com/users/dandavison/following{/other_user}","gists_url":"https://api.github.com/users/dandavison/gists{/gist_id}","starred_url":"https://api.github.com/users/dandavison/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/dandavison/subscriptions","organizations_url":"https://api.github.com/users/dandavison/orgs","repos_url":"https://api.github.com/users/dandavison/repos","events_url":"https://api.github.com/users/dandavison/events{/privacy}","received_events_url":"https://api.github.com/users/dandavison/received_events","type":"User","user_view_type":"public","site_admin":false},"body":"Done (not specifically related to this PR so it may conflict, but good to do now in case we forget)","created_at":"2025-12-05T02:19:20Z","updated_at":"2025-12-05T03:07:13Z","html_url":"https://github.com/temporalio/temporal/pull/8563#discussion_r2591192577","pull_request_url":"https://api.github.com/repos/temporalio/temporal/pulls/8563","_links":{"self":{"href":"https://api.github.com/repos/temporalio/temporal/pulls/comments/2591192577"},"html":{"href":"https://github.com/temporalio/temporal/pull/8563#discussion_r2591192577"},"pull_request":{"href":"https://api.github.com/repos/temporalio/temporal/pulls/8563"}},"reactions":{"url":"https://api.github.com/repos/temporalio/temporal/pulls/comments/2591192577/reactions","total_count":0,"+1":0,"-1":0,"laugh":0,"hooray":0,"confused":0,"heart":0,"rocket":0,"eyes":0},"start_line":null,"original_start_line":null,"start_side":null,"line":null,"original_line":26,"side":"RIGHT","in_reply_to_id":2591038529,"author_association":"MEMBER","original_position":23,"position":1,"subject_type":"line"},{"url":"https://api.github.com/repos/temporalio/temporal/pulls/comments/2591192768","pull_request_review_id":3542784257,"id":2591192768,"node_id":"PRRC_kwDODNqesM6acnbA","diff_hunk":"@@ -838,6 +842,16 @@ func (e *historyEngineImpl) NotifyNewHistoryEvent(\n \te.eventNotifier.NotifyNewHistoryEvent(notification)\n }\n \n+func (e *historyEngineImpl) ChasmEngine() chasm.Engine {","path":"service/history/history_engine.go","commit_id":"083e3b013b3cad2ae65aefee701f4837a0cffd71","original_commit_id":"8aa718931afd6a83e7694ad3b97cec208dcf61e1","user":{"login":"dandavison","id":52205,"node_id":"MDQ6VXNlcjUyMjA1","avatar_url":"https://avatars.githubusercontent.com/u/52205?v=4","gravatar_id":"","url":"https://api.github.com/users/dandavison","html_url":"https://github.com/dandavison","followers_url":"https://api.github.com/users/dandavison/followers","following_url":"https://api.github.com/users/dandavison/following{/other_user}","gists_url":"https://api.github.com/users/dandavison/gists{/gist_id}","starred_url":"https://api.github.com/users/dandavison/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/dandavison/subscriptions","organizations_url":"https://api.github.com/users/dandavison/orgs","repos_url":"https://api.github.com/users/dandavison/repos","events_url":"https://api.github.com/users/dandavison/events{/privacy}","received_events_url":"https://api.github.com/users/dandavison/received_events","type":"User","user_view_type":"public","site_admin":false},"body":"Thanks, removed","created_at":"2025-12-05T02:19:30Z","updated_at":"2025-12-05T03:07:13Z","html_url":"https://github.com/temporalio/temporal/pull/8563#discussion_r2591192768","pull_request_url":"https://api.github.com/repos/temporalio/temporal/pulls/8563","_links":{"self":{"href":"https://api.github.com/repos/temporalio/temporal/pulls/comments/2591192768"},"html":{"href":"https://github.com/temporalio/temporal/pull/8563#discussion_r2591192768"},"pull_request":{"href":"https://api.github.com/repos/temporalio/temporal/pulls/8563"}},"reactions":{"url":"https://api.github.com/repos/temporalio/temporal/pulls/comments/2591192768/reactions","total_count":0,"+1":0,"-1":0,"laugh":0,"hooray":0,"confused":0,"heart":0,"rocket":0,"eyes":0},"start_line":null,"original_start_line":null,"start_side":null,"line":null,"original_line":845,"side":"RIGHT","in_reply_to_id":2591037212,"author_association":"MEMBER","original_position":36,"position":1,"subject_type":"line"},{"url":"https://api.github.com/repos/temporalio/temporal/pulls/comments/2591202645","pull_request_review_id":3542784257,"id":2591202645,"node_id":"PRRC_kwDODNqesM6acp1V","diff_hunk":"@@ -0,0 +1,65 @@\n+package history\n+\n+import (\n+\t\"sync\"\n+\n+\t\"go.temporal.io/server/chasm\"\n+)\n+\n+type (\n+\t// ChasmNotifier allows subscribers to receive notifications relating to a CHASM execution.\n+\tChasmNotifier struct {\n+\t\texecutions map[chasm.EntityKey]*subscriptionTracker","path":"service/history/chasm_notifier.go","commit_id":"ba38880058f288839d9fd74d46b7ac8dbc549f5c","original_commit_id":"8aa718931afd6a83e7694ad3b97cec208dcf61e1","user":{"login":"dandavison","id":52205,"node_id":"MDQ6VXNlcjUyMjA1","avatar_url":"https://avatars.githubusercontent.com/u/52205?v=4","gravatar_id":"","url":"https://api.github.com/users/dandavison","html_url":"https://github.com/dandavison","followers_url":"https://api.github.com/users/dandavison/followers","following_url":"https://api.github.com/users/dandavison/following{/other_user}","gists_url":"https://api.github.com/users/dandavison/gists{/gist_id}","starred_url":"https://api.github.com/users/dandavison/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/dandavison/subscriptions","organizations_url":"https://api.github.com/users/dandavison/orgs","repos_url":"https://api.github.com/users/dandavison/repos","events_url":"https://api.github.com/users/dandavison/events{/privacy}","received_events_url":"https://api.github.com/users/dandavison/received_events","type":"User","user_view_type":"public","site_admin":false},"body":"Done, and internally tracking need for an audit of TODOs in code","created_at":"2025-12-05T02:26:48Z","updated_at":"2025-12-05T03:07:13Z","html_url":"https://github.com/temporalio/temporal/pull/8563#discussion_r2591202645","pull_request_url":"https://api.github.com/repos/temporalio/temporal/pulls/8563","_links":{"self":{"href":"https://api.github.com/repos/temporalio/temporal/pulls/comments/2591202645"},"html":{"href":"https://github.com/temporalio/temporal/pull/8563#discussion_r2591202645"},"pull_request":{"href":"https://api.github.com/repos/temporalio/temporal/pulls/8563"}},"reactions":{"url":"https://api.github.com/repos/temporalio/temporal/pulls/comments/2591202645/reactions","total_count":0,"+1":0,"-1":0,"laugh":0,"hooray":0,"confused":0,"heart":0,"rocket":0,"eyes":0},"start_line":null,"original_start_line":null,"start_side":null,"line":null,"original_line":12,"side":"RIGHT","in_reply_to_id":2591034875,"author_association":"MEMBER","original_position":12,"position":1,"subject_type":"line"},{"url":"https://api.github.com/repos/temporalio/temporal/pulls/comments/2591206387","pull_request_review_id":3542784257,"id":2591206387,"node_id":"PRRC_kwDODNqesM6acqvz","diff_hunk":"@@ -0,0 +1,65 @@\n+package history\n+\n+import (\n+\t\"sync\"\n+\n+\t\"go.temporal.io/server/chasm\"\n+)\n+\n+type (\n+\t// ChasmNotifier allows subscribers to receive notifications relating to a CHASM execution.\n+\tChasmNotifier struct {\n+\t\texecutions map[chasm.EntityKey]*subscriptionTracker\n+\t\tlock       sync.Mutex\n+\t}\n+\n+\tsubscriptionTracker struct {\n+\t\tch             chan struct{}\n+\t\tnumSubscribers int\n+\t}\n+)","path":"service/history/chasm_notifier.go","commit_id":"ba38880058f288839d9fd74d46b7ac8dbc549f5c","original_commit_id":"8aa718931afd6a83e7694ad3b97cec208dcf61e1","user":{"login":"dandavison","id":52205,"node_id":"MDQ6VXNlcjUyMjA1","avatar_url":"https://avatars.githubusercontent.com/u/52205?v=4","gravatar_id":"","url":"https://api.github.com/users/dandavison","html_url":"https://github.com/dandavison","followers_url":"https://api.github.com/users/dandavison/followers","following_url":"https://api.github.com/users/dandavison/following{/other_user}","gists_url":"https://api.github.com/users/dandavison/gists{/gist_id}","starred_url":"https://api.github.com/users/dandavison/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/dandavison/subscriptions","organizations_url":"https://api.github.com/users/dandavison/orgs","repos_url":"https://api.github.com/users/dandavison/repos","events_url":"https://api.github.com/users/dandavison/events{/privacy}","received_events_url":"https://api.github.com/users/dandavison/received_events","type":"User","user_view_type":"public","site_admin":false},"body":"Done. And yes I'll start doing that; I realize it's this codebase being eccentric.","created_at":"2025-12-05T02:29:34Z","updated_at":"2025-12-05T03:07:13Z","html_url":"https://github.com/temporalio/temporal/pull/8563#discussion_r2591206387","pull_request_url":"https://api.github.com/repos/temporalio/temporal/pulls/8563","_links":{"self":{"href":"https://api.github.com/repos/temporalio/temporal/pulls/comments/2591206387"},"html":{"href":"https://github.com/temporalio/temporal/pull/8563#discussion_r2591206387"},"pull_request":{"href":"https://api.github.com/repos/temporalio/temporal/pulls/8563"}},"reactions":{"url":"https://api.github.com/repos/temporalio/temporal/pulls/comments/2591206387/reactions","total_count":0,"+1":0,"-1":0,"laugh":0,"hooray":0,"confused":0,"heart":0,"rocket":0,"eyes":0},"start_line":null,"original_start_line":9,"start_side":"RIGHT","line":null,"original_line":20,"side":"RIGHT","in_reply_to_id":2591028863,"author_association":"MEMBER","original_position":20,"position":1,"subject_type":"line"},{"url":"https://api.github.com/repos/temporalio/temporal/pulls/comments/2591207347","pull_request_review_id":3542784257,"id":2591207347,"node_id":"PRRC_kwDODNqesM6acq-z","diff_hunk":"@@ -0,0 +1,65 @@\n+package history\n+\n+import (\n+\t\"sync\"\n+\n+\t\"go.temporal.io/server/chasm\"\n+)\n+\n+type (\n+\t// ChasmNotifier allows subscribers to receive notifications relating to a CHASM execution.\n+\tChasmNotifier struct {\n+\t\texecutions map[chasm.EntityKey]*subscriptionTracker\n+\t\tlock       sync.Mutex\n+\t}\n+\n+\tsubscriptionTracker struct {\n+\t\tch             chan struct{}\n+\t\tnumSubscribers int\n+\t}\n+)\n+\n+// NewChasmNotifier creates a new instance of ChasmNotifier.\n+func NewChasmNotifier() *ChasmNotifier {\n+\treturn &ChasmNotifier{\n+\t\texecutions: make(map[chasm.EntityKey]*subscriptionTracker),\n+\t}\n+}\n+\n+// Subscribe returns a channel that will be closed when there is a notification relating to the\n+// execution, along with an unsubscribe function. No data will be written to the channel: on\n+// notification, the caller should determine whether the execution state they are waiting for has\n+// been reached and resubscribe if necessary, while holding a lock on the execution. The caller must\n+// arrange for the unsubscribe function to be called when they have finished monitoring the channel\n+// for notifications. It is safe to call the unsubscribe function multiple times and concurrently.\n+func (n *ChasmNotifier) Subscribe(key chasm.EntityKey) (<-chan struct{}, func()) {\n+\tn.lock.Lock()\n+\tdefer n.lock.Unlock()\n+\ts, ok := n.executions[key]\n+\tif !ok {\n+\t\ts = &subscriptionTracker{ch: make(chan struct{})}\n+\t}\n+\tn.executions[key] = s","path":"service/history/chasm_notifier.go","commit_id":"ba38880058f288839d9fd74d46b7ac8dbc549f5c","original_commit_id":"8aa718931afd6a83e7694ad3b97cec208dcf61e1","user":{"login":"dandavison","id":52205,"node_id":"MDQ6VXNlcjUyMjA1","avatar_url":"https://avatars.githubusercontent.com/u/52205?v=4","gravatar_id":"","url":"https://api.github.com/users/dandavison","html_url":"https://github.com/dandavison","followers_url":"https://api.github.com/users/dandavison/followers","following_url":"https://api.github.com/users/dandavison/following{/other_user}","gists_url":"https://api.github.com/users/dandavison/gists{/gist_id}","starred_url":"https://api.github.com/users/dandavison/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/dandavison/subscriptions","organizations_url":"https://api.github.com/users/dandavison/orgs","repos_url":"https://api.github.com/users/dandavison/repos","events_url":"https://api.github.com/users/dandavison/events{/privacy}","received_events_url":"https://api.github.com/users/dandavison/received_events","type":"User","user_view_type":"public","site_admin":false},"body":"Good spot","created_at":"2025-12-05T02:30:06Z","updated_at":"2025-12-05T03:07:13Z","html_url":"https://github.com/temporalio/temporal/pull/8563#discussion_r2591207347","pull_request_url":"https://api.github.com/repos/temporalio/temporal/pulls/8563","_links":{"self":{"href":"https://api.github.com/repos/temporalio/temporal/pulls/comments/2591207347"},"html":{"href":"https://github.com/temporalio/temporal/pull/8563#discussion_r2591207347"},"pull_request":{"href":"https://api.github.com/repos/temporalio/temporal/pulls/8563"}},"reactions":{"url":"https://api.github.com/repos/temporalio/temporal/pulls/comments/2591207347/reactions","total_count":0,"+1":0,"-1":0,"laugh":0,"hooray":0,"confused":0,"heart":0,"rocket":0,"eyes":0},"start_line":null,"original_start_line":39,"start_side":"RIGHT","line":null,"original_line":42,"side":"RIGHT","in_reply_to_id":2591030815,"author_association":"MEMBER","original_position":42,"position":1,"subject_type":"line"},{"url":"https://api.github.com/repos/temporalio/temporal/pulls/comments/2591210958","pull_request_review_id":3542784257,"id":2591210958,"node_id":"PRRC_kwDODNqesM6acr3O","diff_hunk":"@@ -0,0 +1,65 @@\n+package history\n+\n+import (\n+\t\"sync\"\n+\n+\t\"go.temporal.io/server/chasm\"\n+)\n+\n+type (\n+\t// ChasmNotifier allows subscribers to receive notifications relating to a CHASM execution.\n+\tChasmNotifier struct {\n+\t\texecutions map[chasm.EntityKey]*subscriptionTracker\n+\t\tlock       sync.Mutex\n+\t}\n+\n+\tsubscriptionTracker struct {\n+\t\tch             chan struct{}\n+\t\tnumSubscribers int\n+\t}\n+)\n+\n+// NewChasmNotifier creates a new instance of ChasmNotifier.\n+func NewChasmNotifier() *ChasmNotifier {\n+\treturn &ChasmNotifier{\n+\t\texecutions: make(map[chasm.EntityKey]*subscriptionTracker),\n+\t}\n+}\n+\n+// Subscribe returns a channel that will be closed when there is a notification relating to the\n+// execution, along with an unsubscribe function. No data will be written to the channel: on\n+// notification, the caller should determine whether the execution state they are waiting for has\n+// been reached and resubscribe if necessary, while holding a lock on the execution. The caller must\n+// arrange for the unsubscribe function to be called when they have finished monitoring the channel\n+// for notifications. It is safe to call the unsubscribe function multiple times and concurrently.\n+func (n *ChasmNotifier) Subscribe(key chasm.EntityKey) (<-chan struct{}, func()) {\n+\tn.lock.Lock()\n+\tdefer n.lock.Unlock()\n+\ts, ok := n.executions[key]\n+\tif !ok {\n+\t\ts = &subscriptionTracker{ch: make(chan struct{})}\n+\t}\n+\tn.executions[key] = s\n+\ts.numSubscribers++\n+\treturn s.ch, sync.OnceFunc(func() {\n+\t\tn.lock.Lock()\n+\t\tdefer n.lock.Unlock()\n+\t\tif n.executions[key] == s {\n+\t\t\ts.numSubscribers--\n+\t\t\tif s.numSubscribers == 0 {\n+\t\t\t\tclose(s.ch)","path":"service/history/chasm_notifier.go","commit_id":"ba38880058f288839d9fd74d46b7ac8dbc549f5c","original_commit_id":"8aa718931afd6a83e7694ad3b97cec208dcf61e1","user":{"login":"dandavison","id":52205,"node_id":"MDQ6VXNlcjUyMjA1","avatar_url":"https://avatars.githubusercontent.com/u/52205?v=4","gravatar_id":"","url":"https://api.github.com/users/dandavison","html_url":"https://github.com/dandavison","followers_url":"https://api.github.com/users/dandavison/followers","following_url":"https://api.github.com/users/dandavison/following{/other_user}","gists_url":"https://api.github.com/users/dandavison/gists{/gist_id}","starred_url":"https://api.github.com/users/dandavison/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/dandavison/subscriptions","organizations_url":"https://api.github.com/users/dandavison/orgs","repos_url":"https://api.github.com/users/dandavison/repos","events_url":"https://api.github.com/users/dandavison/events{/privacy}","received_events_url":"https://api.github.com/users/dandavison/received_events","type":"User","user_view_type":"public","site_admin":false},"body":"Removed, makes more sense not to have it.","created_at":"2025-12-05T02:32:52Z","updated_at":"2025-12-05T03:07:13Z","html_url":"https://github.com/temporalio/temporal/pull/8563#discussion_r2591210958","pull_request_url":"https://api.github.com/repos/temporalio/temporal/pulls/8563","_links":{"self":{"href":"https://api.github.com/repos/temporalio/temporal/pulls/comments/2591210958"},"html":{"href":"https://github.com/temporalio/temporal/pull/8563#discussion_r2591210958"},"pull_request":{"href":"https://api.github.com/repos/temporalio/temporal/pulls/8563"}},"reactions":{"url":"https://api.github.com/repos/temporalio/temporal/pulls/comments/2591210958/reactions","total_count":0,"+1":0,"-1":0,"laugh":0,"hooray":0,"confused":0,"heart":0,"rocket":0,"eyes":0},"start_line":null,"original_start_line":null,"start_side":null,"line":null,"original_line":50,"side":"RIGHT","in_reply_to_id":2591033572,"author_association":"MEMBER","original_position":50,"position":1,"subject_type":"line"},{"url":"https://api.github.com/repos/temporalio/temporal/pulls/comments/2591214525","pull_request_review_id":3542784257,"id":2591214525,"node_id":"PRRC_kwDODNqesM6acsu9","diff_hunk":"@@ -56,9 +57,10 @@ var defaultTransitionOptions = chasm.TransitionOptions{\n }\n \n var ChasmEngineModule = fx.Options(\n+\tfx.Provide(NewChasmNotifier),\n \tfx.Provide(newChasmEngine),\n \tfx.Provide(func(impl *ChasmEngine) chasm.Engine { return impl }),\n-\tfx.Invoke(func(impl *ChasmEngine, shardController shard.Controller) {\n+\tfx.Invoke(func(lc fx.Lifecycle, impl *ChasmEngine, shardController shard.Controller) {","path":"service/history/chasm_engine.go","commit_id":"ba38880058f288839d9fd74d46b7ac8dbc549f5c","original_commit_id":"8aa718931afd6a83e7694ad3b97cec208dcf61e1","user":{"login":"dandavison","id":52205,"node_id":"MDQ6VXNlcjUyMjA1","avatar_url":"https://avatars.githubusercontent.com/u/52205?v=4","gravatar_id":"","url":"https://api.github.com/users/dandavison","html_url":"https://github.com/dandavison","followers_url":"https://api.github.com/users/dandavison/followers","following_url":"https://api.github.com/users/dandavison/following{/other_user}","gists_url":"https://api.github.com/users/dandavison/gists{/gist_id}","starred_url":"https://api.github.com/users/dandavison/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/dandavison/subscriptions","organizations_url":"https://api.github.com/users/dandavison/orgs","repos_url":"https://api.github.com/users/dandavison/repos","events_url":"https://api.github.com/users/dandavison/events{/privacy}","received_events_url":"https://api.github.com/users/dandavison/received_events","type":"User","user_view_type":"public","site_admin":false},"body":"Good catch","created_at":"2025-12-05T02:35:37Z","updated_at":"2025-12-05T03:07:13Z","html_url":"https://github.com/temporalio/temporal/pull/8563#discussion_r2591214525","pull_request_url":"https://api.github.com/repos/temporalio/temporal/pulls/8563","_links":{"self":{"href":"https://api.github.com/repos/temporalio/temporal/pulls/comments/2591214525"},"html":{"href":"https://github.com/temporalio/temporal/pull/8563#discussion_r2591214525"},"pull_request":{"href":"https://api.github.com/repos/temporalio/temporal/pulls/8563"}},"reactions":{"url":"https://api.github.com/repos/temporalio/temporal/pulls/comments/2591214525/reactions","total_count":0,"+1":0,"-1":0,"laugh":0,"hooray":0,"confused":0,"heart":0,"rocket":0,"eyes":0},"start_line":null,"original_start_line":null,"start_side":null,"line":null,"original_line":63,"side":"RIGHT","in_reply_to_id":2591022326,"author_association":"MEMBER","original_position":16,"position":1,"subject_type":"line"},{"url":"https://api.github.com/repos/temporalio/temporal/pulls/comments/2591214792","pull_request_review_id":3542784257,"id":2591214792,"node_id":"PRRC_kwDODNqesM6acszI","diff_hunk":"@@ -53,3 +59,118 @@ func (h *handler) StartActivityExecution(ctx context.Context, req *activitypb.St\n \t\tFrontendResponse: response,\n \t}, nil\n }\n+\n+// PollActivityExecution handles PollActivityExecutionRequest from frontend. This method supports\n+// querying current activity state, optionally as a long-poll that waits for certain state changes.\n+// It is used by clients to poll for activity state and/or result. When used to long-poll, it\n+// returns an empty non-error response on context deadline expiry, to indicate that the state being\n+// waited for was not reached. Callers should interpret this as an invitation to resubmit their\n+// long-poll request. This response is sent before the caller's deadline (see\n+// chasm.activity.longPollBuffer) so that it is likely that the caller does indeed receive the\n+// non-error response.\n+func (h *handler) PollActivityExecution(\n+\tctx context.Context,\n+\treq *activitypb.PollActivityExecutionRequest,\n+) (response *activitypb.PollActivityExecutionResponse, err error) {\n+\tref := chasm.NewComponentRef[*Activity](chasm.EntityKey{\n+\t\tNamespaceID: req.GetNamespaceId(),\n+\t\tBusinessID:  req.GetFrontendRequest().GetActivityId(),\n+\t\tEntityID:    req.GetFrontendRequest().GetRunId(),\n+\t})\n+\tdefer func() {\n+\t\tvar notFound *serviceerror.NotFound\n+\t\tif errors.As(err, &notFound) {\n+\t\t\t// TODO(dan): include execution key in error message; we may do this at the CHASM\n+\t\t\t// framework level.","path":"chasm/lib/activity/handler.go","commit_id":"34b3f8a7f60cc35efeeb40e6870798011c42c1ab","original_commit_id":"8aa718931afd6a83e7694ad3b97cec208dcf61e1","user":{"login":"dandavison","id":52205,"node_id":"MDQ6VXNlcjUyMjA1","avatar_url":"https://avatars.githubusercontent.com/u/52205?v=4","gravatar_id":"","url":"https://api.github.com/users/dandavison","html_url":"https://github.com/dandavison","followers_url":"https://api.github.com/users/dandavison/followers","following_url":"https://api.github.com/users/dandavison/following{/other_user}","gists_url":"https://api.github.com/users/dandavison/gists{/gist_id}","starred_url":"https://api.github.com/users/dandavison/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/dandavison/subscriptions","organizations_url":"https://api.github.com/users/dandavison/orgs","repos_url":"https://api.github.com/users/dandavison/repos","events_url":"https://api.github.com/users/dandavison/events{/privacy}","received_events_url":"https://api.github.com/users/dandavison/received_events","type":"User","user_view_type":"public","site_admin":false},"body":"I've removed the comment","created_at":"2025-12-05T02:35:52Z","updated_at":"2025-12-05T03:07:13Z","html_url":"https://github.com/temporalio/temporal/pull/8563#discussion_r2591214792","pull_request_url":"https://api.github.com/repos/temporalio/temporal/pulls/8563","_links":{"self":{"href":"https://api.github.com/repos/temporalio/temporal/pulls/comments/2591214792"},"html":{"href":"https://github.com/temporalio/temporal/pull/8563#discussion_r2591214792"},"pull_request":{"href":"https://api.github.com/repos/temporalio/temporal/pulls/8563"}},"reactions":{"url":"https://api.github.com/repos/temporalio/temporal/pulls/comments/2591214792/reactions","total_count":0,"+1":0,"-1":0,"laugh":0,"hooray":0,"confused":0,"heart":0,"rocket":0,"eyes":0},"start_line":null,"original_start_line":83,"start_side":"RIGHT","line":null,"original_line":84,"side":"RIGHT","in_reply_to_id":2591007095,"author_association":"MEMBER","original_position":53,"position":1,"subject_type":"line"},{"url":"https://api.github.com/repos/temporalio/temporal/pulls/comments/2591221694","pull_request_review_id":3542784257,"id":2591221694,"node_id":"PRRC_kwDODNqesM6acue-","diff_hunk":"@@ -838,6 +842,21 @@ func (e *historyEngineImpl) NotifyNewHistoryEvent(\n \te.eventNotifier.NotifyNewHistoryEvent(notification)\n }\n \n+func (e *historyEngineImpl) GetChasmEngine() chasm.Engine {\n+\treturn e.chasmEngine\n+}\n+\n+func (e *historyEngineImpl) NotifyChasmExecution(executionKey chasm.EntityKey, componentRef []byte) {\n+\tif e.chasmEngine == nil {\n+\t\treturn\n+\t}\n+\tif chasmEngine, ok := e.chasmEngine.(*ChasmEngine); ok && chasmEngine != nil {","path":"service/history/history_engine.go","commit_id":"7bf19dc271aec2f2f649077fac915077fc6028fe","original_commit_id":"59d749626d6a00c5fff76abe79a85eb627366521","user":{"login":"dandavison","id":52205,"node_id":"MDQ6VXNlcjUyMjA1","avatar_url":"https://avatars.githubusercontent.com/u/52205?v=4","gravatar_id":"","url":"https://api.github.com/users/dandavison","html_url":"https://github.com/dandavison","followers_url":"https://api.github.com/users/dandavison/followers","following_url":"https://api.github.com/users/dandavison/following{/other_user}","gists_url":"https://api.github.com/users/dandavison/gists{/gist_id}","starred_url":"https://api.github.com/users/dandavison/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/dandavison/subscriptions","organizations_url":"https://api.github.com/users/dandavison/orgs","repos_url":"https://api.github.com/users/dandavison/repos","events_url":"https://api.github.com/users/dandavison/events{/privacy}","received_events_url":"https://api.github.com/users/dandavison/received_events","type":"User","user_view_type":"public","site_admin":false},"body":"Thanks, this is fixed","created_at":"2025-12-05T02:41:03Z","updated_at":"2025-12-05T03:07:13Z","html_url":"https://github.com/temporalio/temporal/pull/8563#discussion_r2591221694","pull_request_url":"https://api.github.com/repos/temporalio/temporal/pulls/8563","_links":{"self":{"href":"https://api.github.com/repos/temporalio/temporal/pulls/comments/2591221694"},"html":{"href":"https://github.com/temporalio/temporal/pull/8563#discussion_r2591221694"},"pull_request":{"href":"https://api.github.com/repos/temporalio/temporal/pulls/8563"}},"reactions":{"url":"https://api.github.com/repos/temporalio/temporal/pulls/comments/2591221694/reactions","total_count":0,"+1":0,"-1":0,"laugh":0,"hooray":0,"confused":0,"heart":0,"rocket":0,"eyes":0},"start_line":null,"original_start_line":null,"start_side":null,"line":null,"original_line":853,"side":"RIGHT","in_reply_to_id":2579143853,"author_association":"MEMBER","original_position":44,"position":1,"subject_type":"line"},{"url":"https://api.github.com/repos/temporalio/temporal/pulls/comments/2591223217","pull_request_review_id":3542784257,"id":2591223217,"node_id":"PRRC_kwDODNqesM6acu2x","diff_hunk":"@@ -241,14 +256,137 @@ func (e *ChasmEngine) ReadComponent(\n \treturn readFn(chasmContext, component)\n }\n \n+// PollComponent waits until the supplied predicate is satisfied when evaluated against the\n+// component identified by the supplied component reference. If there is no error, it returns (ref,\n+// nil) where ref is a component reference identifying the state at which the predicate was\n+// satisfied. The predicate must be monotonic: if it returns true at execution state transition s it\n+// must return true at all transitions t > s. It is an error if execution transition history is\n+// (after reloading from persistence) behind the requested ref, or if the ref is inconsistent with\n+// execution transition history. Thus when the predicate function is evaluated, it is guaranteed\n+// that the execution VT >= requestRef VT. opts are currently ignored.\n func (e *ChasmEngine) PollComponent(\n \tctx context.Context,\n-\tentityRef chasm.ComponentRef,\n-\tpredicateFn func(chasm.Context, chasm.Component) (any, bool, error),\n-\toperationFn func(chasm.MutableContext, chasm.Component, any) error,\n+\trequestRef chasm.ComponentRef,\n+\tmonotonicPredicate func(chasm.Context, chasm.Component) (bool, error),\n \topts ...chasm.TransitionOption,\n-) (newEntityRef []byte, retError error) {\n-\treturn nil, serviceerror.NewUnimplemented(\"PollComponent is not yet supported\")\n+) (retRef []byte, retError error) {\n+\tdefer func() {\n+\t\tif errors.Is(retError, consts.ErrStaleState) {\n+\t\t\tretError = serviceerror.NewUnavailable(\"please retry\")\n+\t\t}\n+\t}()\n+\n+\tshardContext, executionLease, err := e.getExecutionLease(ctx, requestRef)\n+\tif err != nil {\n+\t\t// E.g. requestRef VT inconsistent with execution VT ('stale reference')\n+\t\treturn nil, err\n+\t}\n+\tdefer executionLease.GetReleaseFn()(nil)\n+\n+\t// At this point it's possible that execution VT < requestRef VT (getExecutionLease does not\n+\t// guarantee that returned execution state is non-stale w.r.t. requestRef).\n+\tsatisfiedRef, err := e.predicateSatisfied(ctx, monotonicPredicate, requestRef, executionLease)\n+\tif err != nil {\n+\t\treturn nil, err\n+\t}\n+\t// execution VT >= requestRef VT (enforced by predicateSatisfied)\n+\n+\tif satisfiedRef != nil {\n+\t\t// wait condition was satisfied\n+\t\treturn satisfiedRef, nil\n+\t}\n+\n+\t// Wait condition not satisfied; long-poll\n+\n+\tnamespaceRegistry, err := shardContext.GetNamespaceRegistry().GetNamespaceByID(","path":"service/history/chasm_engine.go","commit_id":"59d749626d6a00c5fff76abe79a85eb627366521","original_commit_id":"59d749626d6a00c5fff76abe79a85eb627366521","user":{"login":"dandavison","id":52205,"node_id":"MDQ6VXNlcjUyMjA1","avatar_url":"https://avatars.githubusercontent.com/u/52205?v=4","gravatar_id":"","url":"https://api.github.com/users/dandavison","html_url":"https://github.com/dandavison","followers_url":"https://api.github.com/users/dandavison/followers","following_url":"https://api.github.com/users/dandavison/following{/other_user}","gists_url":"https://api.github.com/users/dandavison/gists{/gist_id}","starred_url":"https://api.github.com/users/dandavison/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/dandavison/subscriptions","organizations_url":"https://api.github.com/users/dandavison/orgs","repos_url":"https://api.github.com/users/dandavison/repos","events_url":"https://api.github.com/users/dandavison/events{/privacy}","received_events_url":"https://api.github.com/users/dandavison/received_events","type":"User","user_view_type":"public","site_admin":false},"body":"Thanks, we got rid of use of the  `shardContext.GetNamespaceRegistry()`","created_at":"2025-12-05T02:42:18Z","updated_at":"2025-12-05T03:07:13Z","html_url":"https://github.com/temporalio/temporal/pull/8563#discussion_r2591223217","pull_request_url":"https://api.github.com/repos/temporalio/temporal/pulls/8563","_links":{"self":{"href":"https://api.github.com/repos/temporalio/temporal/pulls/comments/2591223217"},"html":{"href":"https://github.com/temporalio/temporal/pull/8563#discussion_r2591223217"},"pull_request":{"href":"https://api.github.com/repos/temporalio/temporal/pulls/8563"}},"reactions":{"url":"https://api.github.com/repos/temporalio/temporal/pulls/comments/2591223217/reactions","total_count":0,"+1":0,"-1":0,"laugh":0,"hooray":0,"confused":0,"heart":0,"rocket":0,"eyes":0},"start_line":null,"original_start_line":null,"start_side":null,"line":null,"original_line":301,"side":"RIGHT","in_reply_to_id":2578349210,"author_association":"MEMBER","original_position":117,"position":1,"subject_type":"line"},{"url":"https://api.github.com/repos/temporalio/temporal/pulls/comments/2591223878","pull_request_review_id":3542784257,"id":2591223878,"node_id":"PRRC_kwDODNqesM6acvBG","diff_hunk":"@@ -241,14 +256,137 @@ func (e *ChasmEngine) ReadComponent(\n \treturn readFn(chasmContext, component)\n }\n \n+// PollComponent waits until the supplied predicate is satisfied when evaluated against the\n+// component identified by the supplied component reference. If there is no error, it returns (ref,\n+// nil) where ref is a component reference identifying the state at which the predicate was\n+// satisfied. The predicate must be monotonic: if it returns true at execution state transition s it\n+// must return true at all transitions t > s. It is an error if execution transition history is\n+// (after reloading from persistence) behind the requested ref, or if the ref is inconsistent with\n+// execution transition history. Thus when the predicate function is evaluated, it is guaranteed\n+// that the execution VT >= requestRef VT. opts are currently ignored.\n func (e *ChasmEngine) PollComponent(\n \tctx context.Context,\n-\tentityRef chasm.ComponentRef,\n-\tpredicateFn func(chasm.Context, chasm.Component) (any, bool, error),\n-\toperationFn func(chasm.MutableContext, chasm.Component, any) error,\n+\trequestRef chasm.ComponentRef,\n+\tmonotonicPredicate func(chasm.Context, chasm.Component) (bool, error),\n \topts ...chasm.TransitionOption,\n-) (newEntityRef []byte, retError error) {\n-\treturn nil, serviceerror.NewUnimplemented(\"PollComponent is not yet supported\")\n+) (retRef []byte, retError error) {\n+\tdefer func() {\n+\t\tif errors.Is(retError, consts.ErrStaleState) {\n+\t\t\tretError = serviceerror.NewUnavailable(\"please retry\")\n+\t\t}\n+\t}()\n+\n+\tshardContext, executionLease, err := e.getExecutionLease(ctx, requestRef)\n+\tif err != nil {\n+\t\t// E.g. requestRef VT inconsistent with execution VT ('stale reference')\n+\t\treturn nil, err\n+\t}\n+\tdefer executionLease.GetReleaseFn()(nil)\n+\n+\t// At this point it's possible that execution VT < requestRef VT (getExecutionLease does not\n+\t// guarantee that returned execution state is non-stale w.r.t. requestRef).\n+\tsatisfiedRef, err := e.predicateSatisfied(ctx, monotonicPredicate, requestRef, executionLease)\n+\tif err != nil {\n+\t\treturn nil, err\n+\t}\n+\t// execution VT >= requestRef VT (enforced by predicateSatisfied)\n+\n+\tif satisfiedRef != nil {\n+\t\t// wait condition was satisfied\n+\t\treturn satisfiedRef, nil\n+\t}\n+\n+\t// Wait condition not satisfied; long-poll\n+\n+\tnamespaceRegistry, err := shardContext.GetNamespaceRegistry().GetNamespaceByID(\n+\t\tnamespace.ID(requestRef.EntityKey.NamespaceID),\n+\t)\n+\tif err != nil {\n+\t\treturn nil, err\n+\t}\n+\n+\tinternalLongPollTimeout := shardContext.GetConfig().LongPollExpirationInterval(namespaceRegistry.Name().String())\n+\tctx, cancel := context.WithTimeout(ctx, internalLongPollTimeout)\n+\tdefer cancel()","path":"service/history/chasm_engine.go","commit_id":"59d749626d6a00c5fff76abe79a85eb627366521","original_commit_id":"59d749626d6a00c5fff76abe79a85eb627366521","user":{"login":"dandavison","id":52205,"node_id":"MDQ6VXNlcjUyMjA1","avatar_url":"https://avatars.githubusercontent.com/u/52205?v=4","gravatar_id":"","url":"https://api.github.com/users/dandavison","html_url":"https://github.com/dandavison","followers_url":"https://api.github.com/users/dandavison/followers","following_url":"https://api.github.com/users/dandavison/following{/other_user}","gists_url":"https://api.github.com/users/dandavison/gists{/gist_id}","starred_url":"https://api.github.com/users/dandavison/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/dandavison/subscriptions","organizations_url":"https://api.github.com/users/dandavison/orgs","repos_url":"https://api.github.com/users/dandavison/repos","events_url":"https://api.github.com/users/dandavison/events{/privacy}","received_events_url":"https://api.github.com/users/dandavison/received_events","type":"User","user_view_type":"public","site_admin":false},"body":"Thanks, this deadline logic is fixed now.","created_at":"2025-12-05T02:42:45Z","updated_at":"2025-12-05T03:07:13Z","html_url":"https://github.com/temporalio/temporal/pull/8563#discussion_r2591223878","pull_request_url":"https://api.github.com/repos/temporalio/temporal/pulls/8563","_links":{"self":{"href":"https://api.github.com/repos/temporalio/temporal/pulls/comments/2591223878"},"html":{"href":"https://github.com/temporalio/temporal/pull/8563#discussion_r2591223878"},"pull_request":{"href":"https://api.github.com/repos/temporalio/temporal/pulls/8563"}},"reactions":{"url":"https://api.github.com/repos/temporalio/temporal/pulls/comments/2591223878/reactions","total_count":0,"+1":0,"-1":0,"laugh":0,"hooray":0,"confused":0,"heart":0,"rocket":0,"eyes":0},"start_line":null,"original_start_line":null,"start_side":null,"line":null,"original_line":310,"side":"RIGHT","in_reply_to_id":2578360812,"author_association":"MEMBER","original_position":126,"position":1,"subject_type":"line"},{"url":"https://api.github.com/repos/temporalio/temporal/pulls/comments/2591224436","pull_request_review_id":3542784257,"id":2591224436,"node_id":"PRRC_kwDODNqesM6acvJ0","diff_hunk":"@@ -241,14 +256,137 @@ func (e *ChasmEngine) ReadComponent(\n \treturn readFn(chasmContext, component)\n }\n \n+// PollComponent waits until the supplied predicate is satisfied when evaluated against the\n+// component identified by the supplied component reference. If there is no error, it returns (ref,\n+// nil) where ref is a component reference identifying the state at which the predicate was\n+// satisfied. The predicate must be monotonic: if it returns true at execution state transition s it\n+// must return true at all transitions t > s. It is an error if execution transition history is\n+// (after reloading from persistence) behind the requested ref, or if the ref is inconsistent with\n+// execution transition history. Thus when the predicate function is evaluated, it is guaranteed\n+// that the execution VT >= requestRef VT. opts are currently ignored.\n func (e *ChasmEngine) PollComponent(\n \tctx context.Context,\n-\tentityRef chasm.ComponentRef,\n-\tpredicateFn func(chasm.Context, chasm.Component) (any, bool, error),\n-\toperationFn func(chasm.MutableContext, chasm.Component, any) error,\n+\trequestRef chasm.ComponentRef,\n+\tmonotonicPredicate func(chasm.Context, chasm.Component) (bool, error),\n \topts ...chasm.TransitionOption,\n-) (newEntityRef []byte, retError error) {\n-\treturn nil, serviceerror.NewUnimplemented(\"PollComponent is not yet supported\")\n+) (retRef []byte, retError error) {\n+\tdefer func() {\n+\t\tif errors.Is(retError, consts.ErrStaleState) {\n+\t\t\tretError = serviceerror.NewUnavailable(\"please retry\")\n+\t\t}\n+\t}()\n+\n+\tshardContext, executionLease, err := e.getExecutionLease(ctx, requestRef)\n+\tif err != nil {\n+\t\t// E.g. requestRef VT inconsistent with execution VT ('stale reference')\n+\t\treturn nil, err\n+\t}\n+\tdefer executionLease.GetReleaseFn()(nil)\n+\n+\t// At this point it's possible that execution VT < requestRef VT (getExecutionLease does not\n+\t// guarantee that returned execution state is non-stale w.r.t. requestRef).\n+\tsatisfiedRef, err := e.predicateSatisfied(ctx, monotonicPredicate, requestRef, executionLease)\n+\tif err != nil {\n+\t\treturn nil, err\n+\t}\n+\t// execution VT >= requestRef VT (enforced by predicateSatisfied)\n+\n+\tif satisfiedRef != nil {\n+\t\t// wait condition was satisfied\n+\t\treturn satisfiedRef, nil\n+\t}\n+\n+\t// Wait condition not satisfied; long-poll\n+\n+\tnamespaceRegistry, err := shardContext.GetNamespaceRegistry().GetNamespaceByID(\n+\t\tnamespace.ID(requestRef.EntityKey.NamespaceID),\n+\t)\n+\tif err != nil {\n+\t\treturn nil, err\n+\t}\n+\n+\tinternalLongPollTimeout := shardContext.GetConfig().LongPollExpirationInterval(namespaceRegistry.Name().String())\n+\tctx, cancel := context.WithTimeout(ctx, internalLongPollTimeout)\n+\tdefer cancel()\n+\n+\t// PollComponent subscribes to execution-level notifications. Suppose that an execution consists\n+\t// of one component A, and A has subcomponent B. Subscribers interested only in component B may\n+\t// be woken up unnecessarily (and thus evaluate the predicate unnecessarily) due to changes in\n+\t// parts of A that do not also belong to B.\n+\tch := e.notifier.Subscribe(requestRef.EntityKey)\n+\texecutionLease.GetReleaseFn()(nil)\n+\n+\tfor {\n+\t\tselect {\n+\t\t// It is possible that multiple state transitions (multiple notifications) occur between\n+\t\t// predicate checks, therefore the predicate must be monotonic: if it returns true at\n+\t\t// execution state transition s then it must return true at all transitions t > s.\n+\t\tcase <-ch:\n+\t\t\t_, executionLease, err := e.getExecutionLease(ctx, requestRef)\n+\t\t\tif err != nil {\n+\t\t\t\treturn nil, err\n+\t\t\t}\n+\t\t\tfunc() {","path":"service/history/chasm_engine.go","commit_id":"372cc0a17931bd461ec03349b8509b57820e36c2","original_commit_id":"59d749626d6a00c5fff76abe79a85eb627366521","user":{"login":"dandavison","id":52205,"node_id":"MDQ6VXNlcjUyMjA1","avatar_url":"https://avatars.githubusercontent.com/u/52205?v=4","gravatar_id":"","url":"https://api.github.com/users/dandavison","html_url":"https://github.com/dandavison","followers_url":"https://api.github.com/users/dandavison/followers","following_url":"https://api.github.com/users/dandavison/following{/other_user}","gists_url":"https://api.github.com/users/dandavison/gists{/gist_id}","starred_url":"https://api.github.com/users/dandavison/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/dandavison/subscriptions","organizations_url":"https://api.github.com/users/dandavison/orgs","repos_url":"https://api.github.com/users/dandavison/repos","events_url":"https://api.github.com/users/dandavison/events{/privacy}","received_events_url":"https://api.github.com/users/dandavison/received_events","type":"User","user_view_type":"public","site_admin":false},"body":"Did end up cleaning up this function significantly, thanks for the suggestion.","created_at":"2025-12-05T02:43:15Z","updated_at":"2025-12-05T03:07:13Z","html_url":"https://github.com/temporalio/temporal/pull/8563#discussion_r2591224436","pull_request_url":"https://api.github.com/repos/temporalio/temporal/pulls/8563","_links":{"self":{"href":"https://api.github.com/repos/temporalio/temporal/pulls/comments/2591224436"},"html":{"href":"https://github.com/temporalio/temporal/pull/8563#discussion_r2591224436"},"pull_request":{"href":"https://api.github.com/repos/temporalio/temporal/pulls/8563"}},"reactions":{"url":"https://api.github.com/repos/temporalio/temporal/pulls/comments/2591224436/reactions","total_count":0,"+1":0,"-1":0,"laugh":0,"hooray":0,"confused":0,"heart":0,"rocket":0,"eyes":0},"start_line":null,"original_start_line":null,"start_side":null,"line":null,"original_line":329,"side":"RIGHT","in_reply_to_id":2579110212,"author_association":"MEMBER","original_position":145,"position":1,"subject_type":"line"},{"url":"https://api.github.com/repos/temporalio/temporal/pulls/comments/2591226784","pull_request_review_id":3542784257,"id":2591226784,"node_id":"PRRC_kwDODNqesM6acvug","diff_hunk":"@@ -0,0 +1,46 @@\n+package history\n+\n+import (\n+\t\"sync\"\n+\n+\t\"go.temporal.io/server/chasm\"\n+\t\"go.temporal.io/server/common/metrics\"\n+)\n+\n+type (\n+\t// ChasmNotifier allows subscribers to receive notifications relating to a CHASM execution.\n+\tChasmNotifier struct {\n+\t\texecutions map[chasm.EntityKey]chan struct{}\n+\t\tlock       sync.Mutex","path":"service/history/chasm_notifier.go","commit_id":"ba38880058f288839d9fd74d46b7ac8dbc549f5c","original_commit_id":"59d749626d6a00c5fff76abe79a85eb627366521","user":{"login":"dandavison","id":52205,"node_id":"MDQ6VXNlcjUyMjA1","avatar_url":"https://avatars.githubusercontent.com/u/52205?v=4","gravatar_id":"","url":"https://api.github.com/users/dandavison","html_url":"https://github.com/dandavison","followers_url":"https://api.github.com/users/dandavison/followers","following_url":"https://api.github.com/users/dandavison/following{/other_user}","gists_url":"https://api.github.com/users/dandavison/gists{/gist_id}","starred_url":"https://api.github.com/users/dandavison/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/dandavison/subscriptions","organizations_url":"https://api.github.com/users/dandavison/orgs","repos_url":"https://api.github.com/users/dandavison/repos","events_url":"https://api.github.com/users/dandavison/events{/privacy}","received_events_url":"https://api.github.com/users/dandavison/received_events","type":"User","user_view_type":"public","site_admin":false},"body":"Tracked","created_at":"2025-12-05T02:45:06Z","updated_at":"2025-12-05T03:07:13Z","html_url":"https://github.com/temporalio/temporal/pull/8563#discussion_r2591226784","pull_request_url":"https://api.github.com/repos/temporalio/temporal/pulls/8563","_links":{"self":{"href":"https://api.github.com/repos/temporalio/temporal/pulls/comments/2591226784"},"html":{"href":"https://github.com/temporalio/temporal/pull/8563#discussion_r2591226784"},"pull_request":{"href":"https://api.github.com/repos/temporalio/temporal/pulls/8563"}},"reactions":{"url":"https://api.github.com/repos/temporalio/temporal/pulls/comments/2591226784/reactions","total_count":0,"+1":0,"-1":0,"laugh":0,"hooray":0,"confused":0,"heart":0,"rocket":0,"eyes":0},"start_line":null,"original_start_line":null,"start_side":null,"line":null,"original_line":14,"side":"RIGHT","in_reply_to_id":2579139461,"author_association":"MEMBER","original_position":14,"position":1,"subject_type":"line"},{"url":"https://api.github.com/repos/temporalio/temporal/pulls/comments/2591227018","pull_request_review_id":3542784257,"id":2591227018,"node_id":"PRRC_kwDODNqesM6acvyK","diff_hunk":"@@ -0,0 +1,46 @@\n+package history\n+\n+import (\n+\t\"sync\"\n+\n+\t\"go.temporal.io/server/chasm\"\n+\t\"go.temporal.io/server/common/metrics\"\n+)\n+\n+type (\n+\t// ChasmNotifier allows subscribers to receive notifications relating to a CHASM execution.\n+\tChasmNotifier struct {\n+\t\texecutions map[chasm.EntityKey]chan struct{}\n+\t\tlock       sync.Mutex\n+\t}\n+)\n+\n+// NewChasmNotifier creates a new instance of ChasmNotifier.\n+func NewChasmNotifier(metricsHandler metrics.Handler) *ChasmNotifier {\n+\treturn &ChasmNotifier{\n+\t\texecutions: make(map[chasm.EntityKey]chan struct{}),\n+\t}\n+}\n+\n+// Subscribe returns a channel that will be closed when there is a notification relating to the\n+// execution. No data will be written to the channel.\n+func (n *ChasmNotifier) Subscribe(key chasm.EntityKey) <-chan struct{} {","path":"service/history/chasm_notifier.go","commit_id":"372cc0a17931bd461ec03349b8509b57820e36c2","original_commit_id":"59d749626d6a00c5fff76abe79a85eb627366521","user":{"login":"dandavison","id":52205,"node_id":"MDQ6VXNlcjUyMjA1","avatar_url":"https://avatars.githubusercontent.com/u/52205?v=4","gravatar_id":"","url":"https://api.github.com/users/dandavison","html_url":"https://github.com/dandavison","followers_url":"https://api.github.com/users/dandavison/followers","following_url":"https://api.github.com/users/dandavison/following{/other_user}","gists_url":"https://api.github.com/users/dandavison/gists{/gist_id}","starred_url":"https://api.github.com/users/dandavison/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/dandavison/subscriptions","organizations_url":"https://api.github.com/users/dandavison/orgs","repos_url":"https://api.github.com/users/dandavison/repos","events_url":"https://api.github.com/users/dandavison/events{/privacy}","received_events_url":"https://api.github.com/users/dandavison/received_events","type":"User","user_view_type":"public","site_admin":false},"body":"Unsubscribe was added","created_at":"2025-12-05T02:45:19Z","updated_at":"2025-12-05T03:07:13Z","html_url":"https://github.com/temporalio/temporal/pull/8563#discussion_r2591227018","pull_request_url":"https://api.github.com/repos/temporalio/temporal/pulls/8563","_links":{"self":{"href":"https://api.github.com/repos/temporalio/temporal/pulls/comments/2591227018"},"html":{"href":"https://github.com/temporalio/temporal/pull/8563#discussion_r2591227018"},"pull_request":{"href":"https://api.github.com/repos/temporalio/temporal/pulls/8563"}},"reactions":{"url":"https://api.github.com/repos/temporalio/temporal/pulls/comments/2591227018/reactions","total_count":0,"+1":0,"-1":0,"laugh":0,"hooray":0,"confused":0,"heart":0,"rocket":0,"eyes":0},"start_line":null,"original_start_line":null,"start_side":null,"line":null,"original_line":27,"side":"RIGHT","in_reply_to_id":2579141090,"author_association":"MEMBER","original_position":27,"position":1,"subject_type":"line"},{"url":"https://api.github.com/repos/temporalio/temporal/pulls/comments/2591227190","pull_request_review_id":3542784257,"id":2591227190,"node_id":"PRRC_kwDODNqesM6acv02","diff_hunk":"@@ -5,45 +5,66 @@ import (\n \t\"testing\"\n \t\"time\"\n \n-\t\"github.com/google/uuid\"\n \t\"github.com/stretchr/testify/require\"\n \t\"github.com/stretchr/testify/suite\"\n \tactivitypb \"go.temporal.io/api/activity/v1\"\n \tcommonpb \"go.temporal.io/api/common/v1\"\n \tenumspb \"go.temporal.io/api/enums/v1\"\n+\t\"go.temporal.io/api/serviceerror\"\n \ttaskqueuepb \"go.temporal.io/api/taskqueue/v1\"\n \t\"go.temporal.io/api/workflowservice/v1\"\n \t\"go.temporal.io/server/common/dynamicconfig\"\n+\t\"go.temporal.io/server/common/testing/protorequire\"\n+\t\"go.temporal.io/server/common/testing/testvars\"\n \t\"go.temporal.io/server/tests/testcore\"\n+\t\"google.golang.org/grpc/codes\"\n \t\"google.golang.org/protobuf/proto\"\n \t\"google.golang.org/protobuf/types/known/durationpb\"\n )\n \n+var (\n+\tdefaultInput = &commonpb.Payloads{","path":"tests/standalone_activity_test.go","commit_id":"ba38880058f288839d9fd74d46b7ac8dbc549f5c","original_commit_id":"59d749626d6a00c5fff76abe79a85eb627366521","user":{"login":"dandavison","id":52205,"node_id":"MDQ6VXNlcjUyMjA1","avatar_url":"https://avatars.githubusercontent.com/u/52205?v=4","gravatar_id":"","url":"https://api.github.com/users/dandavison","html_url":"https://github.com/dandavison","followers_url":"https://api.github.com/users/dandavison/followers","following_url":"https://api.github.com/users/dandavison/following{/other_user}","gists_url":"https://api.github.com/users/dandavison/gists{/gist_id}","starred_url":"https://api.github.com/users/dandavison/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/dandavison/subscriptions","organizations_url":"https://api.github.com/users/dandavison/orgs","repos_url":"https://api.github.com/users/dandavison/repos","events_url":"https://api.github.com/users/dandavison/events{/privacy}","received_events_url":"https://api.github.com/users/dandavison/received_events","type":"User","user_view_type":"public","site_admin":false},"body":"Done","created_at":"2025-12-05T02:45:27Z","updated_at":"2025-12-05T03:07:13Z","html_url":"https://github.com/temporalio/temporal/pull/8563#discussion_r2591227190","pull_request_url":"https://api.github.com/repos/temporalio/temporal/pulls/8563","_links":{"self":{"href":"https://api.github.com/repos/temporalio/temporal/pulls/comments/2591227190"},"html":{"href":"https://github.com/temporalio/temporal/pull/8563#discussion_r2591227190"},"pull_request":{"href":"https://api.github.com/repos/temporalio/temporal/pulls/8563"}},"reactions":{"url":"https://api.github.com/repos/temporalio/temporal/pulls/comments/2591227190/reactions","total_count":0,"+1":0,"-1":0,"laugh":0,"hooray":0,"confused":0,"heart":0,"rocket":0,"eyes":0},"start_line":null,"original_start_line":null,"start_side":null,"line":null,"original_line":26,"side":"RIGHT","in_reply_to_id":2579160362,"author_association":"MEMBER","original_position":23,"position":1,"subject_type":"line"},{"url":"https://api.github.com/repos/temporalio/temporal/pulls/comments/2591251755","pull_request_review_id":3542784257,"id":2591251755,"node_id":"PRRC_kwDODNqesM6ac10r","diff_hunk":"@@ -105,3 +221,553 @@ func createDefaultInput() *commonpb.Payloads {\n \t\t},\n \t}\n }\n+\n+func (s *standaloneActivityTestSuite) TestPollActivityExecution_NoWait() {\n+\tt := s.T()\n+\tctx, cancel := context.WithTimeout(t.Context(), 10*time.Second)\n+\tdefer cancel()\n+\tactivityID := testcore.RandomizeStr(t.Name())\n+\ttaskQueue := testcore.RandomizeStr(t.Name())\n+\n+\tstartResp, err := s.startActivity(ctx, activityID, taskQueue)\n+\trequire.NoError(t, err)\n+\n+\tt.Run(\"MinimalResponse\", func(t *testing.T) {\n+\t\tpollResp, err := s.FrontendClient().PollActivityExecution(ctx, &workflowservice.PollActivityExecutionRequest{\n+\t\t\tNamespace:  s.Namespace().String(),\n+\t\t\tActivityId: activityID,\n+\t\t\t// Omit RunID to verify that latest run will be used\n+\t\t\tIncludeInfo:    false,\n+\t\t\tIncludeInput:   false,\n+\t\t\tIncludeOutcome: false,\n+\t\t})\n+\t\trequire.NoError(t, err)\n+\t\trequire.NotNil(t, pollResp.StateChangeLongPollToken)\n+\t\trequire.Equal(t, startResp.RunId, pollResp.RunId)\n+\t\trequire.Nil(t, pollResp.Info)\n+\t\trequire.Nil(t, pollResp.Input)\n+\t\trequire.Nil(t, pollResp.GetResult())\n+\t\trequire.Nil(t, pollResp.GetFailure())\n+\t})\n+\n+\tt.Run(\"FullResponse\", func(t *testing.T) {\n+\t\tpollResp, err := s.FrontendClient().PollActivityExecution(ctx, &workflowservice.PollActivityExecutionRequest{\n+\t\t\tNamespace:      s.Namespace().String(),\n+\t\t\tActivityId:     activityID,\n+\t\t\tRunId:          startResp.RunId,\n+\t\t\tIncludeInfo:    true,\n+\t\t\tIncludeInput:   true,\n+\t\t\tIncludeOutcome: true,\n+\t\t})\n+\t\trequire.NoError(t, err)\n+\t\trequire.NotNil(t, pollResp.StateChangeLongPollToken)\n+\t\trequire.NotNil(t, pollResp.Info)\n+\t\ts.assertActivityExecutionInfo(\n+\t\t\tt,\n+\t\t\tpollResp.Info,\n+\t\t\tactivityID,\n+\t\t\tstartResp.RunId,\n+\t\t\tenumspb.PENDING_ACTIVITY_STATE_SCHEDULED,\n+\t\t)\n+\t\trequire.NotNil(t, pollResp.Input)\n+\t\trequire.Equal(t, \"test-activity-input\", string(pollResp.Input.Payloads[0].Data))\n+\n+\t\t// Activity is scheduled but not completed, so no outcome yet\n+\t\trequire.Nil(t, pollResp.GetResult())\n+\t\trequire.Nil(t, pollResp.GetFailure())\n+\t})\n+}\n+\n+func (s *standaloneActivityTestSuite) TestPollActivityExecution_WaitAnyStateChange() {\n+\t// Long poll for any state change. PollActivityTaskQueue is used to cause a state change.\n+\tt := s.T()\n+\tctx, cancel := context.WithTimeout(t.Context(), 10*time.Second)\n+\tdefer cancel()\n+\tactivityID := testcore.RandomizeStr(t.Name())\n+\ttaskQueue := testcore.RandomizeStr(t.Name())\n+\n+\tstartResp, err := s.startActivity(ctx, activityID, taskQueue)\n+\trequire.NoError(t, err)\n+\n+\t// First poll lacks token and therefore responds immediately, returning a token\n+\tfirstPollResp, err := s.FrontendClient().PollActivityExecution(ctx, &workflowservice.PollActivityExecutionRequest{\n+\t\tNamespace:  s.Namespace().String(),\n+\t\tActivityId: activityID,\n+\t\tRunId:      startResp.RunId, // RunID is now required by validation\n+\t\tWaitPolicy: &workflowservice.PollActivityExecutionRequest_WaitAnyStateChange{\n+\t\t\tWaitAnyStateChange: &workflowservice.PollActivityExecutionRequest_StateChangeWaitOptions{},\n+\t\t},\n+\t\tIncludeInfo:  true,\n+\t\tIncludeInput: true,\n+\t})\n+\trequire.NoError(t, err)\n+\trequire.NotNil(t, firstPollResp.StateChangeLongPollToken)\n+\trequire.NotNil(t, firstPollResp.Info)\n+\trequire.Equal(t, firstPollResp.RunId, startResp.RunId)\n+\ts.assertActivityExecutionInfo(\n+\t\tt,\n+\t\tfirstPollResp.Info,\n+\t\tactivityID,\n+\t\tstartResp.RunId,\n+\t\tenumspb.PENDING_ACTIVITY_STATE_SCHEDULED,\n+\t)\n+\n+\ttaskQueuePollErr := make(chan error, 1)\n+\tactivityPollDone := make(chan struct{})\n+\tvar activityPollResp *workflowservice.PollActivityExecutionResponse\n+\tvar activityPollErr error\n+\n+\tgo func() {\n+\t\tdefer close(activityPollDone)\n+\t\t// Second poll uses token and therefore waits for a state transition\n+\t\tactivityPollResp, activityPollErr = s.FrontendClient().PollActivityExecution(ctx, &workflowservice.PollActivityExecutionRequest{\n+\t\t\tNamespace:    s.Namespace().String(),\n+\t\t\tActivityId:   activityID,\n+\t\t\tRunId:        startResp.RunId,\n+\t\t\tIncludeInfo:  true,\n+\t\t\tIncludeInput: true,\n+\t\t\tWaitPolicy: &workflowservice.PollActivityExecutionRequest_WaitAnyStateChange{\n+\t\t\t\tWaitAnyStateChange: &workflowservice.PollActivityExecutionRequest_StateChangeWaitOptions{\n+\t\t\t\t\tLongPollToken: firstPollResp.StateChangeLongPollToken,\n+\t\t\t\t},\n+\t\t\t},\n+\t\t})\n+\t}()\n+\n+\t// TODO(dan): race here: subscription might not be established yet\n+\n+\t// Worker picks up activity task, triggering transition (via RecordActivityTaskStarted)\n+\tgo func() {\n+\t\t_, err := s.pollActivityTaskQueue(ctx, taskQueue)\n+\t\ttaskQueuePollErr <- err\n+\t}()","path":"tests/standalone_activity_test.go","commit_id":"1d59e66d0ce5d91819f92c428ef5ab4c4efca1fb","original_commit_id":"59d749626d6a00c5fff76abe79a85eb627366521","user":{"login":"dandavison","id":52205,"node_id":"MDQ6VXNlcjUyMjA1","avatar_url":"https://avatars.githubusercontent.com/u/52205?v=4","gravatar_id":"","url":"https://api.github.com/users/dandavison","html_url":"https://github.com/dandavison","followers_url":"https://api.github.com/users/dandavison/followers","following_url":"https://api.github.com/users/dandavison/following{/other_user}","gists_url":"https://api.github.com/users/dandavison/gists{/gist_id}","starred_url":"https://api.github.com/users/dandavison/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/dandavison/subscriptions","organizations_url":"https://api.github.com/users/dandavison/orgs","repos_url":"https://api.github.com/users/dandavison/repos","events_url":"https://api.github.com/users/dandavison/events{/privacy}","received_events_url":"https://api.github.com/users/dandavison/received_events","type":"User","user_view_type":"public","site_admin":false},"body":"That's not true: the test is like this in order to test the case where the predicate is not satisfied initially, but becomes satisfied while the long-poll request is open.","created_at":"2025-12-05T03:03:52Z","updated_at":"2025-12-05T03:07:13Z","html_url":"https://github.com/temporalio/temporal/pull/8563#discussion_r2591251755","pull_request_url":"https://api.github.com/repos/temporalio/temporal/pulls/8563","_links":{"self":{"href":"https://api.github.com/repos/temporalio/temporal/pulls/comments/2591251755"},"html":{"href":"https://github.com/temporalio/temporal/pull/8563#discussion_r2591251755"},"pull_request":{"href":"https://api.github.com/repos/temporalio/temporal/pulls/8563"}},"reactions":{"url":"https://api.github.com/repos/temporalio/temporal/pulls/comments/2591251755/reactions","total_count":0,"+1":0,"-1":0,"laugh":0,"hooray":0,"confused":0,"heart":0,"rocket":0,"eyes":0},"start_line":298,"original_start_line":320,"start_side":"RIGHT","line":321,"original_line":343,"side":"RIGHT","in_reply_to_id":2579164008,"author_association":"MEMBER","original_position":318,"position":305,"subject_type":"line"},{"url":"https://api.github.com/repos/temporalio/temporal/pulls/comments/2591273871","pull_request_review_id":3542955727,"id":2591273871,"node_id":"PRRC_kwDODNqesM6ac7OP","diff_hunk":"@@ -53,3 +59,113 @@ func (h *handler) StartActivityExecution(ctx context.Context, req *activitypb.St\n \t\tFrontendResponse: response,\n \t}, nil\n }\n+\n+// PollActivityExecution handles PollActivityExecutionRequest from frontend. This method supports\n+// querying current activity state, optionally as a long-poll that waits for certain state changes.\n+// It is used by clients to poll for activity state and/or result. When used to long-poll, it\n+// returns an empty non-error response on context deadline expiry, to indicate that the state being\n+// waited for was not reached. Callers should interpret this as an invitation to resubmit their\n+// long-poll request. This response is sent before the caller's deadline (see\n+// chasm.activity.longPollBuffer) so that it is likely that the caller does indeed receive the\n+// non-error response.\n+func (h *handler) PollActivityExecution(\n+\tctx context.Context,\n+\treq *activitypb.PollActivityExecutionRequest,\n+) (response *activitypb.PollActivityExecutionResponse, err error) {\n+\tref := chasm.NewComponentRef[*Activity](chasm.EntityKey{\n+\t\tNamespaceID: req.GetNamespaceId(),\n+\t\tBusinessID:  req.GetFrontendRequest().GetActivityId(),\n+\t\tEntityID:    req.GetFrontendRequest().GetRunId(),\n+\t})\n+\tdefer func() {\n+\t\tvar notFound *serviceerror.NotFound\n+\t\tif errors.As(err, &notFound) {\n+\t\t\terr = serviceerror.NewNotFound(\"activity execution not found\")\n+\t\t}\n+\t}()\n+\n+\twaitPolicy := req.GetFrontendRequest().GetWaitPolicy()\n+\n+\tif waitPolicy == nil {\n+\t\treturn chasm.ReadComponent(ctx, ref, (*Activity).buildPollActivityExecutionResponse, req, nil)","path":"chasm/lib/activity/handler.go","commit_id":"1d59e66d0ce5d91819f92c428ef5ab4c4efca1fb","original_commit_id":"2c24dfc62cddd82948e0ed0765afaeb9f38b6775","user":{"login":"cursor[bot]","id":206951365,"node_id":"BOT_kgDODFXTxQ","avatar_url":"https://avatars.githubusercontent.com/in/1210556?v=4","gravatar_id":"","url":"https://api.github.com/users/cursor%5Bbot%5D","html_url":"https://github.com/apps/cursor","followers_url":"https://api.github.com/users/cursor%5Bbot%5D/followers","following_url":"https://api.github.com/users/cursor%5Bbot%5D/following{/other_user}","gists_url":"https://api.github.com/users/cursor%5Bbot%5D/gists{/gist_id}","starred_url":"https://api.github.com/users/cursor%5Bbot%5D/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/cursor%5Bbot%5D/subscriptions","organizations_url":"https://api.github.com/users/cursor%5Bbot%5D/orgs","repos_url":"https://api.github.com/users/cursor%5Bbot%5D/repos","events_url":"https://api.github.com/users/cursor%5Bbot%5D/events{/privacy}","received_events_url":"https://api.github.com/users/cursor%5Bbot%5D/received_events","type":"Bot","user_view_type":"public","site_admin":false},"body":"### Bug: Deferred error transformation bypassed on early returns\n\n<!-- **Medium Severity** -->\n\n<!-- DESCRIPTION START -->\nThe deferred function at lines 80-85 transforms `NotFound` errors into a user-friendly message by modifying the named return variable `err`. However, the direct `return chasm.ReadComponent(...)` statements on lines 90 and 109 bypass the named return variable entirely. In Go, when using `return expr1, expr2` with named returns, the expressions go directly to the caller without updating the named variables. This means `NotFound` errors from the `waitPolicy == nil` and `len(token) == 0` code paths won't be transformed to \"activity execution not found\".\n<!-- DESCRIPTION END -->\n\n<!-- LOCATIONS START\nchasm/lib/activity/handler.go#L89-L90\nchasm/lib/activity/handler.go#L108-L109\nLOCATIONS END -->\n<details>\n<summary>Additional Locations (1)</summary>\n\n- [`chasm/lib/activity/handler.go#L108-L109`](https://github.com/temporalio/temporal/blob/2c24dfc62cddd82948e0ed0765afaeb9f38b6775/chasm/lib/activity/handler.go#L108-L109)\n\n</details>\n\n<a href=\"https://cursor.com/open?data=eyJhbGciOiJSUzI1NiIsInR5cCI6IkpXVCIsImtpZCI6ImJ1Z2JvdC12MSJ9.eyJ2ZXJzaW9uIjoxLCJ0eXBlIjoiQlVHQk9UX0ZJWF9JTl9DVVJTT1IiLCJkYXRhIjp7InJlZGlzS2V5IjoiYnVnYm90OmRiZDA5N2U1LTg1NTctNGNlYy1iNTE1LTRiMjZkNjQ2N2Q0OCIsImVuY3J5cHRpb25LZXkiOiJ0enBpN3FDQ2Rmbjk2TjFXZ3M0NEFGNDZUZXp4R0JUdWRGSUJlZkt1Ym5NIiwiYnJhbmNoIjoicG9sbC1jb21wb25lbnQifSwiaWF0IjoxNzY0OTA0OTMwLCJleHAiOjE3NjU1MDk3MzB9.HRglw_gN019awCmBoj4tJRarExKnR6L-N4VT2WwOe3_wthiwd97BrQwH_9dkrXSHhwBuWXVWX_i6cok0tQ8otSWrblaoqQTdDh2vSxwAQnCa2r-DRTck_A05mlzPWBCj_dmHq_rW6uLOyFOCr7wA3T_5QQDBz2ebvFIfIE4izvywMQbCHInt645nfDxR5eTXzSok3sGzGyszekM-7b7Qmg-zF1U8snEfVRl7ZJ2BFP7R87UBrfHBPPrnDBMBGVL4ygTXrHW2o81epfaSE3o3_l5bv9W_VZja78wA-mBJIDWqKEgjAkSLLEZrFV8ccutVxOTMqfKbm58Egj8FzPqUoQ\"><picture><source media=\"(prefers-color-scheme: dark)\" srcset=\"https://cursor.com/fix-in-cursor-dark.svg\"><source media=\"(prefers-color-scheme: light)\" srcset=\"https://cursor.com/fix-in-cursor-light.svg\"><img alt=\"Fix in Cursor\" src=\"https://cursor.com/fix-in-cursor.svg\"></picture></a>&nbsp;<a href=\"https://cursor.com/agents?data=eyJhbGciOiJSUzI1NiIsInR5cCI6IkpXVCIsImtpZCI6ImJ1Z2JvdC12MSJ9.eyJ2ZXJzaW9uIjoxLCJ0eXBlIjoiQlVHQk9UX0ZJWF9JTl9XRUIiLCJkYXRhIjp7InJlZGlzS2V5IjoiYnVnYm90OmRiZDA5N2U1LTg1NTctNGNlYy1iNTE1LTRiMjZkNjQ2N2Q0OCIsImVuY3J5cHRpb25LZXkiOiJ0enBpN3FDQ2Rmbjk2TjFXZ3M0NEFGNDZUZXp4R0JUdWRGSUJlZkt1Ym5NIiwiYnJhbmNoIjoicG9sbC1jb21wb25lbnQiLCJyZXBvT3duZXIiOiJ0ZW1wb3JhbGlvIiwicmVwb05hbWUiOiJ0ZW1wb3JhbCIsInByTnVtYmVyIjo4NTYzLCJjb21taXRTaGEiOiIyYzI0ZGZjNjJjZGRkODI5NDhlMGVkMDc2NWFmYWViOWYzOGI2Nzc1IiwicHJvdmlkZXIiOiJnaXRodWIifSwiaWF0IjoxNzY0OTA0OTMwLCJleHAiOjE3NjU1MDk3MzB9.bb8NfL4oP9Vg3c9wBvPPl-a4DXTBnNnFSfn5tQwYYq3QN4qis-8fwm08FLh9rURXL1--AfHL-CWtwJLJnLNLfvLmMkrrfR0tHmVPpmsQk3N67RJlp1JcUTU8u3tfN0FDoeUqn-blx-e_gsVj5tu5BM3v_3c5uSBjBvLKFwcsqx1COkq-SXC8xlRa-oitQ9poTvBjCSplq5lJvGP1sug2kKffEsjYRU7IjasDBb-WWNoFXg0IBdpfLf2n50g5VUZWX4Qp51RMz5rIvgcMpeaaM7tykC_JYgDLE60j0qhbOOBWP4aZvHs-jiU0DSriZar4b9PQlYgu-xnqLjL242pm6g\"><picture><source media=\"(prefers-color-scheme: dark)\" srcset=\"https://cursor.com/fix-in-web-dark.svg\"><source media=\"(prefers-color-scheme: light)\" srcset=\"https://cursor.com/fix-in-web-light.svg\"><img alt=\"Fix in Web\" src=\"https://cursor.com/fix-in-web.svg\"></picture></a>\n\n","created_at":"2025-12-05T03:22:10Z","updated_at":"2025-12-05T03:22:10Z","html_url":"https://github.com/temporalio/temporal/pull/8563#discussion_r2591273871","pull_request_url":"https://api.github.com/repos/temporalio/temporal/pulls/8563","_links":{"self":{"href":"https://api.github.com/repos/temporalio/temporal/pulls/comments/2591273871"},"html":{"href":"https://github.com/temporalio/temporal/pull/8563#discussion_r2591273871"},"pull_request":{"href":"https://api.github.com/repos/temporalio/temporal/pulls/8563"}},"reactions":{"url":"https://api.github.com/repos/temporalio/temporal/pulls/comments/2591273871/reactions","total_count":0,"+1":0,"-1":0,"laugh":0,"hooray":0,"confused":0,"heart":0,"rocket":0,"eyes":0},"start_line":null,"original_start_line":null,"start_side":null,"line":92,"original_line":90,"side":"RIGHT","author_association":"NONE","original_position":59,"position":61,"subject_type":"line"},{"url":"https://api.github.com/repos/temporalio/temporal/pulls/comments/2591321991","pull_request_review_id":3543008337,"id":2591321991,"node_id":"PRRC_kwDODNqesM6adG-H","diff_hunk":"@@ -0,0 +1,35 @@\n+package chasm\n+\n+import (\n+\t\"go.temporal.io/server/common/persistence/transitionhistory\"\n+\t\"go.temporal.io/server/service/history/consts\"\n+)\n+\n+// ExecutionStateChanged returns true if execution state has advanced beyond the state encoded in\n+// refBytes. It may return ErrInvalidComponentRef or ErrMalformedComponentRef. Callers should\n+// consider converting these to serviceerror.NewInvalidArgument.\n+func ExecutionStateChanged(c Component, ctx Context, refBytes []byte) (bool, error) {\n+\tref, err := DeserializeComponentRef(refBytes)\n+\tif err != nil {\n+\t\treturn false, ErrMalformedComponentRef\n+\t}","path":"chasm/transition_history.go","commit_id":"1d59e66d0ce5d91819f92c428ef5ab4c4efca1fb","original_commit_id":"1d59e66d0ce5d91819f92c428ef5ab4c4efca1fb","user":{"login":"cursor[bot]","id":206951365,"node_id":"BOT_kgDODFXTxQ","avatar_url":"https://avatars.githubusercontent.com/in/1210556?v=4","gravatar_id":"","url":"https://api.github.com/users/cursor%5Bbot%5D","html_url":"https://github.com/apps/cursor","followers_url":"https://api.github.com/users/cursor%5Bbot%5D/followers","following_url":"https://api.github.com/users/cursor%5Bbot%5D/following{/other_user}","gists_url":"https://api.github.com/users/cursor%5Bbot%5D/gists{/gist_id}","starred_url":"https://api.github.com/users/cursor%5Bbot%5D/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/cursor%5Bbot%5D/subscriptions","organizations_url":"https://api.github.com/users/cursor%5Bbot%5D/orgs","repos_url":"https://api.github.com/users/cursor%5Bbot%5D/repos","events_url":"https://api.github.com/users/cursor%5Bbot%5D/events{/privacy}","received_events_url":"https://api.github.com/users/cursor%5Bbot%5D/received_events","type":"Bot","user_view_type":"public","site_admin":false},"body":"### Bug: `ExecutionStateChanged` always returns `ErrMalformedComponentRef` discarding original error type\n\n<!-- **Medium Severity** -->\n\n<!-- DESCRIPTION START -->\nThe function `ExecutionStateChanged` unconditionally returns `ErrMalformedComponentRef` when `DeserializeComponentRef` fails, but `DeserializeComponentRef` can return either `ErrMalformedComponentRef` or `ErrInvalidComponentRef` (for empty data or missing fields). The function's doc comment claims it \"may return ErrInvalidComponentRef or ErrMalformedComponentRef\" but the implementation always substitutes `ErrMalformedComponentRef` on deserialization error. The original error should be returned directly (`return false, err`) instead of always returning `ErrMalformedComponentRef`.\n<!-- DESCRIPTION END -->\n\n<!-- LOCATIONS START\nchasm/transition_history.go#L11-L15\nLOCATIONS END -->\n<a href=\"https://cursor.com/open?data=eyJhbGciOiJSUzI1NiIsInR5cCI6IkpXVCIsImtpZCI6ImJ1Z2JvdC12MSJ9.eyJ2ZXJzaW9uIjoxLCJ0eXBlIjoiQlVHQk9UX0ZJWF9JTl9DVVJTT1IiLCJkYXRhIjp7InJlZGlzS2V5IjoiYnVnYm90OmRmM2FjNTM4LTMwOTItNGVhYS1iYmVjLTk3NjMwYjc0ODA0OSIsImVuY3J5cHRpb25LZXkiOiJ6cnp4MHdvWkVLNFBjMkVyUmVUMm1CVlJPclk4YzExZXZ2NUxvQzd0ZVhBIiwiYnJhbmNoIjoicG9sbC1jb21wb25lbnQifSwiaWF0IjoxNzY0OTA3MDU2LCJleHAiOjE3NjU1MTE4NTZ9.MiTi_xJ0WohvnWmlukYwLyTTIKS50wrEE11xkYQqghJaBcIKh1MPrGRV3RxtZH4H4TPnytVjcrvpAqLG1BtQ9JtwwFvCNL669x1FBWvsq6SwTiIIJLghA_Ffp5Qv-MsaEeArifImt49eTgMG9QjjMIGGZ0ZHwK6tK3stoJpbaMoC7n53g5x1cfpOqXTQAPQX1juwsUQGQK1vpfMh6tl0Om7QMvF7I75IuPruTMqO9ko4oY1l1yYohIZOK4HxmapTRHHioBR91RhzfJ-swaHV8jDR71ureY6eMYOTHO8_uxKCe2K4xSio-Ep91AKuvSGCqz005Ad2A7PKMvOHjUKrVg\"><picture><source media=\"(prefers-color-scheme: dark)\" srcset=\"https://cursor.com/fix-in-cursor-dark.svg\"><source media=\"(prefers-color-scheme: light)\" srcset=\"https://cursor.com/fix-in-cursor-light.svg\"><img alt=\"Fix in Cursor\" src=\"https://cursor.com/fix-in-cursor.svg\"></picture></a>&nbsp;<a href=\"https://cursor.com/agents?data=eyJhbGciOiJSUzI1NiIsInR5cCI6IkpXVCIsImtpZCI6ImJ1Z2JvdC12MSJ9.eyJ2ZXJzaW9uIjoxLCJ0eXBlIjoiQlVHQk9UX0ZJWF9JTl9XRUIiLCJkYXRhIjp7InJlZGlzS2V5IjoiYnVnYm90OmRmM2FjNTM4LTMwOTItNGVhYS1iYmVjLTk3NjMwYjc0ODA0OSIsImVuY3J5cHRpb25LZXkiOiJ6cnp4MHdvWkVLNFBjMkVyUmVUMm1CVlJPclk4YzExZXZ2NUxvQzd0ZVhBIiwiYnJhbmNoIjoicG9sbC1jb21wb25lbnQiLCJyZXBvT3duZXIiOiJ0ZW1wb3JhbGlvIiwicmVwb05hbWUiOiJ0ZW1wb3JhbCIsInByTnVtYmVyIjo4NTYzLCJjb21taXRTaGEiOiIxZDU5ZTY2ZDBjZTVkOTE4MTlmOTJjNDI4ZWY1YWI0YzRlZmNhMWZiIiwicHJvdmlkZXIiOiJnaXRodWIifSwiaWF0IjoxNzY0OTA3MDU2LCJleHAiOjE3NjU1MTE4NTZ9.iihmfw7kkKfsoIXQ7XpPe-R9Bqq5jvHcqlpl3ihKfRvTyMpmWP4_ku9-bN9OZSTMENhkb9aDFnFxdBBS18C9mNeD3Mc0IvOgT0C0qjmjdWdUOWKmZSxzASe0kajtq8raL7cnp8R1KvmUqFL9fCJ4ITE8FZJJkTeW2EMn3FN6Df_xitGxsCF4fkXH50OHeaKMVXETAN_a-vgc3hT3Wh9zM7rggLSRTBckx1fUB0lYJbqZU0MhKuecRZMSSKjzh5yZGuzhrf5VmmTNKL581sO3o1hZraMVmYCYDU1jJ0jm6504IRks8cayOEVHhYdrD2Y9O6rgTb2SI4PTEozggF-drA\"><picture><source media=\"(prefers-color-scheme: dark)\" srcset=\"https://cursor.com/fix-in-web-dark.svg\"><source media=\"(prefers-color-scheme: light)\" srcset=\"https://cursor.com/fix-in-web-light.svg\"><img alt=\"Fix in Web\" src=\"https://cursor.com/fix-in-web.svg\"></picture></a>\n\n","created_at":"2025-12-05T03:57:36Z","updated_at":"2025-12-05T03:57:36Z","html_url":"https://github.com/temporalio/temporal/pull/8563#discussion_r2591321991","pull_request_url":"https://api.github.com/repos/temporalio/temporal/pulls/8563","_links":{"self":{"href":"https://api.github.com/repos/temporalio/temporal/pulls/comments/2591321991"},"html":{"href":"https://github.com/temporalio/temporal/pull/8563#discussion_r2591321991"},"pull_request":{"href":"https://api.github.com/repos/temporalio/temporal/pulls/8563"}},"reactions":{"url":"https://api.github.com/repos/temporalio/temporal/pulls/comments/2591321991/reactions","total_count":0,"+1":0,"-1":0,"laugh":0,"hooray":0,"confused":0,"heart":0,"rocket":0,"eyes":0},"start_line":null,"original_start_line":null,"start_side":null,"line":15,"original_line":15,"side":"RIGHT","author_association":"NONE","original_position":15,"position":15,"subject_type":"line"}]