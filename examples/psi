#!/usr/bin/env -S uv run --script
# /// script
# requires-python = ">=3.10"
# dependencies = ["fzfui"]
# [tool.uv.sources]
# fzfui = { path = "/Users/dan/src/fzfui", editable = true }
# ///

from __future__ import annotations

import os
import subprocess
import sys

import fzfui

app = fzfui.App(__file__)


@app.main(
    command="ps -U $USER -o pid,%cpu,%mem,stat,time,command | cut -c1-200",
    header_lines=1,
    with_nth="2..",
)
def psi():
    pass


@app.action("enter", field=1)
def detail(pid: str):
    pid = pid.strip()
    if not pid.isdigit():
        return

    result = subprocess.run(
        ["ps", "-p", pid, "-o", "pid=,user=,%cpu=,%mem=,stat=,start=,time=,command="],
        capture_output=True,
        text=True,
    )

    if result.returncode != 0:
        print(f"Process {pid} not found")
        input("Press any key...")
        return

    os.system("clear")
    print()
    print("═" * 67)
    print(f"  PROCESS DETAILS (PID: {pid})")
    print("═" * 67)
    print()

    parts = result.stdout.strip().split(None, 7)
    if len(parts) >= 7:
        labels = ["PID", "User", "CPU", "Memory", "State", "Started", "Time"]
        for label, val in zip(labels, parts[:7]):
            print(f"  {label:8} {val}")
        if len(parts) > 7:
            print()
            print("  Command:")
            print(f"    {parts[7][:70]}")

    print()
    print("─" * 67)
    print("  Open files/ports (first 20):")

    lsof_result = subprocess.run(
        ["lsof", "-p", pid],
        capture_output=True,
        text=True,
    )
    if lsof_result.returncode == 0:
        lines = lsof_result.stdout.strip().split("\n")[1:21]
        if lines:
            for line in lines:
                parts = line.split()
                if len(parts) >= 9:
                    print(f"    {parts[4]:10} {parts[8]}")
        else:
            print("    (none)")
    else:
        print("    (permission denied)")

    print()
    print("═" * 67)
    print()
    input("Press any key...")


@app.action("ctrl-k", reload=True, silent=True, field=1)
def kill_proc(pid: str):
    pid = pid.strip()
    if pid.isdigit():
        try:
            os.kill(int(pid), 9)
        except ProcessLookupError:
            pass


@app.action("ctrl-r", reload=True, silent=True)
def reload(_: str):
    pass


@app.preview
def help_panel(_: str) -> str:
    return """
╭──────────────────────────────────────────────────────────────╮
│                        Keybindings                           │
╰──────────────────────────────────────────────────────────────╯

  enter       Show process details
  ctrl-k      Kill process (SIGKILL)
  ctrl-r      Reload process list
  ctrl-h      Toggle this help
  ctrl-\\      Toggle query/command mode
  esc         Exit

╭──────────────────────────────────────────────────────────────╮
│                         Columns                              │
╰──────────────────────────────────────────────────────────────╯

  %CPU    CPU usage percentage
  %MEM    Memory usage percentage
  STAT    Process state (S=sleeping, R=running, etc.)
  TIME    Cumulative CPU time
  COMMAND Process command (truncated)

  PID is hidden but used for kill/details.
"""


if __name__ == "__main__":
    app()

