#!/usr/bin/env -S uv run --script
# /// script
# requires-python = ">=3.10"
# dependencies = ["fzfui"]
# ///

from __future__ import annotations

import atexit
import os
import subprocess
import sys
from pathlib import Path
from textwrap import dedent

import fzfui

app = fzfui.App(__file__)
script = os.path.abspath(__file__)

# State file to track listening filter - use parent PID for subprocess invocations
_pid = os.environ.get("PSI_PID", str(os.getpid()))
if "PSI_PID" not in os.environ:
    os.environ["PSI_PID"] = _pid
    atexit.register(lambda: Path(f"/tmp/psi-listening-{_pid}.state").unlink(missing_ok=True))
LISTENING_STATE = Path(f"/tmp/psi-listening-{_pid}.state")


# The ps query - this is what we show in the footer
PS_QUERY = "ps -U $USER -o pid,%cpu,%mem,stat,time,command"

# Annotate ps output with listening ports and cwd (left join with lsof)
# Output tab-separated, then use column -t for alignment
# PID is field 1 (hidden via with_nth), PORTS is field 2
PS_WITH_PORTS = r"""
ps -U $USER -o pid,%cpu,%mem,stat,time,command | awk '
BEGIN {
    OFS = "\t"
    cmd = "lsof -iTCP -sTCP:LISTEN -P -n 2>/dev/null"
    while ((cmd | getline line) > 0) {
        n = split(line, arr)
        if (n >= 9 && arr[1] != "COMMAND") {
            pid = arr[2]; port = arr[9]
            gsub(/.*:/, "", port); gsub(/\(LISTEN\)/, "", port)
            if (pid in ports) ports[pid] = ports[pid] "," port
            else ports[pid] = port
        }
    }
    close(cmd)
    cmd = "lsof -d cwd -a -u $USER 2>/dev/null"
    while ((cmd | getline line) > 0) {
        n = split(line, arr)
        if (n >= 9 && arr[1] != "COMMAND") {
            pid = arr[2]; cwd[pid] = arr[n]
        }
    }
    close(cmd)
}
NR == 1 {
    print $1, "PORTS", $2, $3, $4, $5, "CWD", "COMMAND"
    next
}
{
    p = ($1 in ports) ? ports[$1] : "-"
    if (length(p) > 12) p = substr(p, 1, 9) "..."
    c = ($1 in cwd) ? cwd[$1] : "-"
    if (length(c) > 25) c = "..." substr(c, length(c)-21)
    cmd = ""
    for (i = 6; i <= NF; i++) cmd = cmd (i > 6 ? " " : "") $i
    if (length(cmd) > 80) cmd = substr(cmd, 1, 77) "..."
    print $1, p, $2, $3, $4, $5, c, cmd
}
' | column -t -s $'\t'
"""

# Filter to only processes with listening ports (exclude "-" placeholder)
LISTENING_ONLY = PS_WITH_PORTS.rstrip() + " | awk 'NR==1 || $2!=\"-\"'"


TOGGLE_LISTENING = f"transform({script} _toggle-listening)"


@app.main(
    command=PS_WITH_PORTS,
    header_lines=1,
    with_nth="2..",
    fzf_options=["--footer", PS_QUERY],  # Show clean ps command, not the awk script
    bindings={"ctrl-l": TOGGLE_LISTENING},
)
def psi():
    pass


@app.cli.command("_toggle-listening", hidden=True)
def toggle_listening():
    """Toggle between all processes and listening-only."""
    if LISTENING_STATE.exists():
        LISTENING_STATE.unlink()
        print(f"reload({PS_WITH_PORTS})+change-footer({PS_QUERY})")
    else:
        LISTENING_STATE.touch()
        print(f"reload({LISTENING_ONLY})+change-footer({PS_QUERY} [listening])")


@app.action("enter", description="Show process details", field=1)
def detail(pid: str):
    pid = pid.strip()
    if not pid.isdigit():
        return

    result = subprocess.run(
        ["ps", "-p", pid, "-o", "pid=,user=,%cpu=,%mem=,stat=,start=,time=,command="],
        capture_output=True,
        text=True,
    )

    if result.returncode != 0:
        print(f"Process {pid} not found")
        input("Press any key...")
        return

    parts = result.stdout.strip().split(None, 7)
    info = dict(
        zip(
            ["pid", "user", "cpu", "mem", "stat", "start", "time", "cmd"],
            parts + [""] * (8 - len(parts)),
        )
    )
    info["cmd"] = info["cmd"][:70]

    lsof_result = subprocess.run(["lsof", "-p", pid], capture_output=True, text=True)
    if lsof_result.returncode == 0:
        lines = lsof_result.stdout.strip().split("\n")[1:21]
        files = (
            "\n".join(
                f"        {p[4]:10} {p[8]}"
                for line in lines
                if len(p := line.split()) >= 9
            )
            or "        (none)"
        )
    else:
        files = "        (permission denied)"

    os.system("clear")
    print(
        dedent(f"""
        ═══════════════════════════════════════════════════════════════════
          PROCESS DETAILS (PID: {pid})
        ═══════════════════════════════════════════════════════════════════

          PID      {info["pid"]}
          User     {info["user"]}
          CPU      {info["cpu"]}
          Memory   {info["mem"]}
          State    {info["stat"]}
          Started  {info["start"]}
          Time     {info["time"]}

          Command:
            {info["cmd"]}

        ───────────────────────────────────────────────────────────────────
          Open files/ports (first 20):
        {files}

        ═══════════════════════════════════════════════════════════════════
    """)
    )
    input("Press any key...")


@app.action(
    "ctrl-k", description="Kill process (SIGKILL)", reload=True, silent=True, field=1
)
def kill_proc(pid: str):
    pid = pid.strip()
    if pid.isdigit():
        try:
            os.kill(int(pid), 9)
        except ProcessLookupError:
            pass


@app.action("ctrl-r", description="Reload process list", reload=True, silent=True)
def reload(_: str):
    pass


@app.preview
def help_panel(_: str) -> str:
    extra_bindings = {"ctrl-l": "Toggle listening-only filter"}
    return app.help_text(extra_bindings=extra_bindings)


if __name__ == "__main__":
    app()
