#!/usr/bin/env -S uv run --script
# /// script
# requires-python = ">=3.10"
# dependencies = ["fzfui"]
# [tool.uv.sources]
# fzfui = { path = "/Users/dan/src/fzfui", editable = true }
# ///

"""
jqi - Interactive jq expression explorer

Usage: cat data.json | jqi
       curl api.example.com | jqi '.items[]'

Type jq expressions and see results in real-time.
Start with "." (identity) to see the full JSON.

Keys:
    enter       Output jq result and exit
    alt-up/down Navigate history
    ctrl-k      Kill to end of line
    ctrl-y      Yank (paste)
    esc/ctrl-c  Exit without output
"""

from __future__ import annotations

import atexit
import os
import subprocess
import sys
import tempfile
from pathlib import Path

import fzfui

HISTORY_FILE = Path.home() / ".jqi_history"

# Read stdin and save to temp file (jq needs to re-read on each query)
# Do this before fzfui takes over, but only for main invocation
if len(sys.argv) == 1 or (len(sys.argv) >= 2 and not sys.argv[1].startswith("_")):
    if not sys.stdin.isatty():
        fd, tmpfile = tempfile.mkstemp(prefix="jqi-", suffix=".json")
        os.write(fd, sys.stdin.buffer.read())
        os.close(fd)
        os.environ["FZFUI_ARG_file"] = tmpfile
        atexit.register(lambda: os.unlink(tmpfile))
        # Reopen stdin from tty for fzf
        sys.stdin = open("/dev/tty")

app = fzfui.App(__file__)


@app.main(
    disabled=True,
    initial_query=".",
    bindings={
        "ctrl-k": "kill-line",
        "ctrl-p": "up",
        "ctrl-n": "down",
        "alt-up": "prev-history",
        "alt-down": "next-history",
    },
    fzf_options=["--history", str(HISTORY_FILE)],
)
def jqi():
    pass


@app.query_preview
def preview(query: str) -> str:
    file = app.arg("file")
    if not file:
        return "Pipe JSON to stdin: cat data.json | jqi"

    if not os.path.exists(file):
        return f"File not found: {file}"

    try:
        result = subprocess.run(
            ["jq", "-C", query, file],
            capture_output=True,
            text=True,
            timeout=5,
        )
        if result.returncode == 0:
            return result.stdout
        else:
            return f"jq error:\n{result.stderr}"
    except subprocess.TimeoutExpired:
        return "Query timed out"
    except FileNotFoundError:
        return "jq not found. Install with: brew install jq"


def save_history(query: str):
    """Append query to history if it's not the same as the last entry."""
    try:
        last = HISTORY_FILE.read_text().splitlines()[-1] if HISTORY_FILE.exists() else ""
    except (IndexError, OSError):
        last = ""
    if query and query != last:
        with open(HISTORY_FILE, "a") as f:
            f.write(query + "\n")


@app.action("enter", exit=True)
def output_result(query: str):
    """Output the jq result and exit."""
    save_history(query)

    file = app.arg("file")
    if not file:
        return

    result = subprocess.run(
        ["jq", query, file],
        capture_output=True,
        text=True,
    )
    if result.returncode == 0:
        print(result.stdout, end="")


if __name__ == "__main__":
    if sys.stdin.isatty() and not os.environ.get("FZFUI_ARG_file"):
        print(__doc__.strip(), file=sys.stderr)
        sys.exit(1)
    app()
