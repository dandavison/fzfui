#!/usr/bin/env -S uv run --script
# /// script
# requires-python = ">=3.10"
# dependencies = ["fzfui", "typer"]
# [tool.uv.sources]
# fzfui = { path = "/Users/dan/src/fzfui", editable = true }
# ///

"""
jqi - Interactive jq expression explorer

Usage: cat data.json | jqi
       curl api.example.com | jqi '.items[]'

Type jq expressions and see results in real-time.
Start with "." (identity) to see the full JSON.

Keys:
    enter       Output jq result and exit
    ctrl-c      Print jq command (to stderr) and exit
    ctrl-\\      LLM assist - describe what you want in natural language
    alt-up/down Navigate history
    ctrl-k      Kill to end of line
    ctrl-y      Yank (paste)
    esc         Exit without output
"""

from __future__ import annotations

import atexit
import os
import shlex
import subprocess
import sys
import tempfile
from pathlib import Path

import typer

import fzfui

PROMPT = "jq> "
LLM_PROMPT = "llm> "

HISTORY_FILE = Path.home() / ".jqi_history"

# LLM state file - shared across all subprocesses via env var
# Main process creates the path and exports it; subprocesses read from env
if "JQI_LLM_STATE" in os.environ:
    LLM_STATE_FILE = Path(os.environ["JQI_LLM_STATE"])
else:
    LLM_STATE_FILE = Path(f"/tmp/jqi-llm-{os.getpid()}.state")
    os.environ["JQI_LLM_STATE"] = str(LLM_STATE_FILE)

# Read stdin and save to temp file (jq needs to re-read on each query)
# Do this before fzfui takes over, but only for main invocation
if len(sys.argv) == 1 or (len(sys.argv) >= 2 and not sys.argv[1].startswith("_")):
    if not sys.stdin.isatty():
        fd, tmpfile = tempfile.mkstemp(prefix="jqi-", suffix=".json")
        os.write(fd, sys.stdin.buffer.read())
        os.close(fd)
        os.environ["FZFUI_ARG_file"] = tmpfile
        atexit.register(lambda: os.unlink(tmpfile))
        # Reopen stdin from tty for fzf
        sys.stdin = open("/dev/tty")
    # Clean up LLM state on exit
    atexit.register(lambda: LLM_STATE_FILE.unlink(missing_ok=True))

app = fzfui.App(__file__)
script = os.path.abspath(__file__)

# Enter uses transform to check LLM mode and decide what to do
ENTER_BINDING = f"transform({script} _enter {{q}})"
LLM_BINDING = f"transform({script} _llm-toggle {{q}})"


@app.main(
    disabled=True,
    initial_query=".",
    prompt=PROMPT,
    bindings={
        "ctrl-k": "kill-line",
        "alt-up": "prev-history",
        "alt-down": "next-history",
        "ctrl-\\": LLM_BINDING,  # LLM assist mode
        "enter": ENTER_BINDING,  # Override default enter
    },
    fzf_options=["--history", str(HISTORY_FILE)],
)
def jqi():
    pass


# Register commands with typer (these use transform, not execute)
@app.cli.command("_enter", hidden=True)
def enter_handler(query: str = typer.Argument("")):
    """Handle enter - check LLM mode or output result."""
    if LLM_STATE_FILE.exists():
        # In LLM mode - call LLM and update query
        original = LLM_STATE_FILE.read_text()
        LLM_STATE_FILE.unlink()

        llm_cmd = os.environ.get("LLM")
        if not llm_cmd:
            # No LLM configured - restore original
            # Use [] delimiters so parentheses in query are preserved
            print(f"change-prompt({PROMPT})+change-query[{original}]")
            return

        json_file = app.arg("file")
        llm_prompt = build_llm_prompt(original, query, json_file)
        try:
            result = subprocess.run(
                f"{llm_cmd} {shlex.quote(llm_prompt)}",
                shell=True,
                capture_output=True,
                text=True,
                timeout=30,
            )
            new_expr = clean_llm_response(result.stdout.strip())
        except Exception:
            new_expr = original  # Error - restore original

        # Use [] delimiters so parentheses in query are preserved
        print(f"change-prompt({PROMPT})+change-query[{new_expr}]")
    else:
        # Normal mode - output result and exit
        # Use execute+abort to run the action handler
        print(f"execute({script} _action enter {{q}})+abort")


@app.cli.command("_llm-toggle", hidden=True)
def llm_toggle(query: str = typer.Argument("")):
    """Toggle LLM assist mode."""
    if LLM_STATE_FILE.exists():
        # Already in LLM mode -> cancel, restore original
        original = LLM_STATE_FILE.read_text()
        LLM_STATE_FILE.unlink()
        # Restore normal mode (use [] so parentheses in query are preserved)
        print(f"change-prompt({PROMPT})+change-query[{original}]")
    else:
        # Enter LLM mode - save current expression
        LLM_STATE_FILE.write_text(query)
        print(f"change-prompt({LLM_PROMPT})+change-query[]")


def build_llm_prompt(current_expr: str, request: str, json_file: str | None) -> str:
    """Build the prompt for the LLM, including a sample of the JSON data."""
    # Get a sample of the JSON for context (truncate if large)
    json_sample = ""
    if json_file and os.path.exists(json_file):
        try:
            with open(json_file) as f:
                content = f.read(4000)  # First 4KB
                if len(content) == 4000:
                    content = content.rsplit("\n", 1)[0] + "\n... (truncated)"
                json_sample = f"\nJSON data sample:\n```json\n{content}\n```\n"
        except Exception:
            pass

    return f"""Convert this natural language request into a valid jq expression.
{json_sample}
Current jq expression: {current_expr}
Request: {request}

Respond with ONLY the jq expression, no explanation or markdown."""


def clean_llm_response(response: str) -> str:
    """Clean up common LLM response artifacts."""
    # Remove markdown code blocks
    if response.startswith("```"):
        lines = response.split("\n")
        # Find content between ``` markers
        start = 1 if lines[0].startswith("```") else 0
        end = len(lines)
        for i in range(len(lines) - 1, 0, -1):
            if lines[i].strip() == "```":
                end = i
                break
        response = "\n".join(lines[start:end])
    # Remove leading/trailing quotes if present
    response = response.strip()
    if response.startswith('"') and response.endswith('"'):
        response = response[1:-1]
    if response.startswith("'") and response.endswith("'"):
        response = response[1:-1]
    return response.strip()


@app.query_preview
def preview(query: str) -> str:
    # In LLM mode, keep showing preview with the original expression
    # (stored in state file) while user types their request
    if LLM_STATE_FILE.exists():
        query = LLM_STATE_FILE.read_text()

    file = app.arg("file")
    if not file:
        return "Pipe JSON to stdin: cat data.json | jqi"

    if not os.path.exists(file):
        return f"File not found: {file}"

    try:
        result = subprocess.run(
            ["jq", "-C", query, file],
            capture_output=True,
            text=True,
            timeout=5,
        )
        if result.returncode == 0:
            return result.stdout
        else:
            return f"jq error:\n{result.stderr}"
    except subprocess.TimeoutExpired:
        return "Query timed out"
    except FileNotFoundError:
        return "jq not found. Install with: brew install jq"


def save_history(query: str):
    """Append query to history if it's not the same as the last entry."""
    try:
        last = (
            HISTORY_FILE.read_text().splitlines()[-1] if HISTORY_FILE.exists() else ""
        )
    except (IndexError, OSError):
        last = ""
    if query and query != last:
        with open(HISTORY_FILE, "a") as f:
            f.write(query + "\n")


@app.action("enter", exit=True)
def output_result(query: str):
    """Output the jq result and exit."""
    save_history(query)

    file = app.arg("file")
    if not file:
        return

    result = subprocess.run(
        ["jq", query, file],
        capture_output=True,
        text=True,
    )
    if result.returncode == 0:
        print(result.stdout, end="")


@app.action("ctrl-c", exit=True)
def print_command(query: str):
    """Print the jq command and exit."""
    save_history(query)
    print(f"jq '{query}'", file=sys.stderr)


if __name__ == "__main__":
    if sys.stdin.isatty() and not os.environ.get("FZFUI_ARG_file"):
        if __doc__:
            print(__doc__.strip(), file=sys.stderr)
        sys.exit(1)
    app()
